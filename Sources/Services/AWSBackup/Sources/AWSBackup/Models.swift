//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct DeleteBackupSelectionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteBackupVaultAccessPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteBackupVaultLockConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteBackupVaultNotificationsOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteBackupVaultOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFrameworkOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRecoveryPointOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteReportPlanOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRestoreTestingPlanOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRestoreTestingSelectionOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateRecoveryPointFromParentOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateRecoveryPointOutput: Swift.Sendable {

    public init() { }
}

public struct GetSupportedResourceTypesInput: Swift.Sendable {

    public init() { }
}

public struct PutBackupVaultAccessPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct PutBackupVaultLockConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct PutBackupVaultNotificationsOutput: Swift.Sendable {

    public init() { }
}

public struct PutRestoreValidationResultOutput: Swift.Sendable {

    public init() { }
}

public struct StopBackupJobOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateGlobalSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateRegionSettingsOutput: Swift.Sendable {

    public init() { }
}

extension BackupClientTypes {

    /// The backup options for each resource type.
    public struct AdvancedBackupSetting: Swift.Sendable {
        /// Specifies the backup option for a selected resource. This option is only available for Windows VSS backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS":"disabled" to create a regular backup. The WindowsVSS option is not enabled by default. If you specify an invalid option, you get an InvalidParameterValueException exception. For more information about Windows VSS backups, see [Creating a VSS-Enabled Windows Backup](https://docs.aws.amazon.com/aws-backup/latest/devguide/windows-backups.html).
        public var backupOptions: [Swift.String: Swift.String]?
        /// Specifies an object containing resource type and backup options. The only supported resource type is Amazon EC2 instances with Windows Volume Shadow Copy Service (VSS). For a CloudFormation example, see the [sample CloudFormation template to enable Windows VSS](https://docs.aws.amazon.com/aws-backup/latest/devguide/integrate-cloudformation-with-aws-backup.html) in the Backup User Guide. Valid values: EC2.
        public var resourceType: Swift.String?

        public init(
            backupOptions: [Swift.String: Swift.String]? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.backupOptions = backupOptions
            self.resourceType = resourceType
        }
    }
}

extension BackupClientTypes {

    public enum AggregationPeriod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fourteenDays
        case oneDay
        case sevenDays
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationPeriod] {
            return [
                .fourteenDays,
                .oneDay,
                .sevenDays
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fourteenDays: return "FOURTEEN_DAYS"
            case .oneDay: return "ONE_DAY"
            case .sevenDays: return "SEVEN_DAYS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The required resource already exists.
public struct AlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var arn: Swift.String? = nil
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        ///
        public internal(set) var creatorRequestId: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        arn: Swift.String? = nil,
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        creatorRequestId: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.arn = arn
        self.properties.code = code
        self.properties.context = context
        self.properties.creatorRequestId = creatorRequestId
        self.properties.message = message
        self.properties.type = type
    }
}

extension BackupClientTypes {

    /// Contains information about the backup plan and rule that Backup used to initiate the recovery point backup.
    public struct RecoveryPointCreator: Swift.Sendable {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public var backupPlanArn: Swift.String?
        /// Uniquely identifies a backup plan.
        public var backupPlanId: Swift.String?
        /// Version IDs are unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. They cannot be edited.
        public var backupPlanVersion: Swift.String?
        /// Uniquely identifies a rule used to schedule the backup of a selection of resources.
        public var backupRuleId: Swift.String?

        public init(
            backupPlanArn: Swift.String? = nil,
            backupPlanId: Swift.String? = nil,
            backupPlanVersion: Swift.String? = nil,
            backupRuleId: Swift.String? = nil
        )
        {
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanVersion = backupPlanVersion
            self.backupRuleId = backupRuleId
        }
    }
}

extension BackupClientTypes {

    public enum BackupJobState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aborted
        case aborting
        case completed
        case created
        case expired
        case failed
        case partial
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupJobState] {
            return [
                .aborted,
                .aborting,
                .completed,
                .created,
                .expired,
                .failed,
                .partial,
                .pending,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .aborting: return "ABORTING"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .expired: return "EXPIRED"
            case .failed: return "FAILED"
            case .partial: return "PARTIAL"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupClientTypes {

    /// Contains detailed information about a backup job.
    public struct BackupJob: Swift.Sendable {
        /// The account ID that owns the backup job.
        public var accountId: Swift.String?
        /// Uniquely identifies a request to Backup to back up a resource.
        public var backupJobId: Swift.String?
        /// Specifies the backup option for a selected resource. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS":"disabled" to create a regular backup. If you specify an invalid option, you get an InvalidParameterValueException exception.
        public var backupOptions: [Swift.String: Swift.String]?
        /// The size, in bytes, of a backup.
        public var backupSizeInBytes: Swift.Int?
        /// Represents the type of backup for a backup job.
        public var backupType: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public var backupVaultName: Swift.String?
        /// The size in bytes transferred to a backup vault at the time that the job status was queried.
        public var bytesTransferred: Swift.Int?
        /// The date and time a job to create a backup job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: Foundation.Date?
        /// Contains identifying information about the creation of a backup job, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan used to create it.
        public var createdBy: BackupClientTypes.RecoveryPointCreator?
        /// The date and time a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: Foundation.Date?
        /// The date and time a job to back up resources is expected to be completed, in Unix format and Coordinated Universal Time (UTC). The value of ExpectedCompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var expectedCompletionDate: Foundation.Date?
        /// Specifies the IAM role ARN used to create the target recovery point. IAM roles other than the default role must include either AWSBackup or AwsBackup in the role name. For example, arn:aws:iam::123456789012:role/AWSBackupRDSAccess. Role names without those strings lack permissions to perform backup jobs.
        public var iamRoleArn: Swift.String?
        /// The date on which the backup job was initiated.
        public var initiationDate: Foundation.Date?
        /// This is a boolean value indicating this is a parent (composite) backup job.
        public var isParent: Swift.Bool
        /// This parameter is the job count for the specified message category. Example strings may include AccessDenied, SUCCESS, AGGREGATE_ALL, and INVALIDPARAMETERS. See [Monitoring](https://docs.aws.amazon.com/aws-backup/latest/devguide/monitoring.html) for a list of MessageCategory strings. The the value ANY returns count of all message categories. AGGREGATE_ALL aggregates job counts for all message categories and returns the sum.
        public var messageCategory: Swift.String?
        /// This uniquely identifies a request to Backup to back up a resource. The return will be the parent (composite) job ID.
        public var parentJobId: Swift.String?
        /// Contains an estimated percentage complete of a job at the time the job status was queried.
        public var percentDone: Swift.String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var resourceArn: Swift.String?
        /// The non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?
        /// Specifies the time in Unix format and Coordinated Universal Time (UTC) when a backup job must be started before it is canceled. The value is calculated by adding the start window to the scheduled time. So if the scheduled time were 6:00 PM and the start window is 2 hours, the StartBy time would be 8:00 PM on the date specified. The value of StartBy is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var startBy: Foundation.Date?
        /// The current state of a backup job.
        public var state: BackupClientTypes.BackupJobState?
        /// A detailed message explaining the status of the job to back up a resource.
        public var statusMessage: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            backupJobId: Swift.String? = nil,
            backupOptions: [Swift.String: Swift.String]? = nil,
            backupSizeInBytes: Swift.Int? = nil,
            backupType: Swift.String? = nil,
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            bytesTransferred: Swift.Int? = nil,
            completionDate: Foundation.Date? = nil,
            createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
            creationDate: Foundation.Date? = nil,
            expectedCompletionDate: Foundation.Date? = nil,
            iamRoleArn: Swift.String? = nil,
            initiationDate: Foundation.Date? = nil,
            isParent: Swift.Bool = false,
            messageCategory: Swift.String? = nil,
            parentJobId: Swift.String? = nil,
            percentDone: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            startBy: Foundation.Date? = nil,
            state: BackupClientTypes.BackupJobState? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.backupJobId = backupJobId
            self.backupOptions = backupOptions
            self.backupSizeInBytes = backupSizeInBytes
            self.backupType = backupType
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.bytesTransferred = bytesTransferred
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.expectedCompletionDate = expectedCompletionDate
            self.iamRoleArn = iamRoleArn
            self.initiationDate = initiationDate
            self.isParent = isParent
            self.messageCategory = messageCategory
            self.parentJobId = parentJobId
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.startBy = startBy
            self.state = state
            self.statusMessage = statusMessage
        }
    }
}

extension BackupClientTypes {

    public enum BackupJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aborted
        case aborting
        case aggregateAll
        case any
        case completed
        case created
        case expired
        case failed
        case partial
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupJobStatus] {
            return [
                .aborted,
                .aborting,
                .aggregateAll,
                .any,
                .completed,
                .created,
                .expired,
                .failed,
                .partial,
                .pending,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .aborting: return "ABORTING"
            case .aggregateAll: return "AGGREGATE_ALL"
            case .any: return "ANY"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .expired: return "EXPIRED"
            case .failed: return "FAILED"
            case .partial: return "PARTIAL"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupClientTypes {

    /// This is a summary of jobs created or running within the most recent 30 days. The returned summary may contain the following: Region, Account, State, RestourceType, MessageCategory, StartTime, EndTime, and Count of included jobs.
    public struct BackupJobSummary: Swift.Sendable {
        /// The account ID that owns the jobs within the summary.
        public var accountId: Swift.String?
        /// The value as a number of jobs in a job summary.
        public var count: Swift.Int
        /// The value of time in number format of a job end time. This value is the time in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var endTime: Foundation.Date?
        /// This parameter is the job count for the specified message category. Example strings include AccessDenied, Success, and InvalidParameters. See [Monitoring](https://docs.aws.amazon.com/aws-backup/latest/devguide/monitoring.html) for a list of MessageCategory strings. The the value ANY returns count of all message categories. AGGREGATE_ALL aggregates job counts for all message categories and returns the sum.
        public var messageCategory: Swift.String?
        /// The Amazon Web Services Regions within the job summary.
        public var region: Swift.String?
        /// This value is the job count for the specified resource type. The request GetSupportedResourceTypes returns strings for supported resource types.
        public var resourceType: Swift.String?
        /// The value of time in number format of a job start time. This value is the time in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var startTime: Foundation.Date?
        /// This value is job count for jobs with the specified state.
        public var state: BackupClientTypes.BackupJobStatus?

        public init(
            accountId: Swift.String? = nil,
            count: Swift.Int = 0,
            endTime: Foundation.Date? = nil,
            messageCategory: Swift.String? = nil,
            region: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: BackupClientTypes.BackupJobStatus? = nil
        )
        {
            self.accountId = accountId
            self.count = count
            self.endTime = endTime
            self.messageCategory = messageCategory
            self.region = region
            self.resourceType = resourceType
            self.startTime = startTime
            self.state = state
        }
    }
}

extension BackupClientTypes {

    /// Specifies the time period, in days, before a recovery point transitions to cold storage or is deleted. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the retention setting must be 90 days greater than the transition to cold after days setting. The transition to cold after days setting can't be changed after a backup has been transitioned to cold. Resource types that can transition to cold storage are listed in the [Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/backup-feature-availability.html#features-by-resource) table. Backup ignores this expression for other resource types. To remove the existing lifecycle and retention periods and keep your recovery points indefinitely, specify -1 for MoveToColdStorageAfterDays and DeleteAfterDays.
    public struct Lifecycle: Swift.Sendable {
        /// The number of days after creation that a recovery point is deleted. This value must be at least 90 days after the number of days specified in MoveToColdStorageAfterDays.
        public var deleteAfterDays: Swift.Int?
        /// The number of days after creation that a recovery point is moved to cold storage.
        public var moveToColdStorageAfterDays: Swift.Int?
        /// If the value is true, your backup plan transitions supported resources to archive (cold) storage tier in accordance with your lifecycle settings.
        public var optInToArchiveForSupportedResources: Swift.Bool?

        public init(
            deleteAfterDays: Swift.Int? = nil,
            moveToColdStorageAfterDays: Swift.Int? = nil,
            optInToArchiveForSupportedResources: Swift.Bool? = nil
        )
        {
            self.deleteAfterDays = deleteAfterDays
            self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
            self.optInToArchiveForSupportedResources = optInToArchiveForSupportedResources
        }
    }
}

extension BackupClientTypes {

    /// The details of the copy operation.
    public struct CopyAction: Swift.Sendable {
        /// An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup. For example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        /// This member is required.
        public var destinationBackupVaultArn: Swift.String?
        /// Specifies the time period, in days, before a recovery point transitions to cold storage or is deleted. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the retention setting must be 90 days greater than the transition to cold after days setting. The transition to cold after days setting can't be changed after a backup has been transitioned to cold. Resource types that can transition to cold storage are listed in the [Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/backup-feature-availability.html#features-by-resource) table. Backup ignores this expression for other resource types. To remove the existing lifecycle and retention periods and keep your recovery points indefinitely, specify -1 for MoveToColdStorageAfterDays and DeleteAfterDays.
        public var lifecycle: BackupClientTypes.Lifecycle?

        public init(
            destinationBackupVaultArn: Swift.String? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil
        )
        {
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.lifecycle = lifecycle
        }
    }
}

extension BackupClientTypes {

    /// Specifies a scheduled task used to back up a selection of resources.
    public struct BackupRule: Swift.Sendable {
        /// A value in minutes after a backup job is successfully started before it must be completed or it will be canceled by Backup. This value is optional.
        public var completionWindowMinutes: Swift.Int?
        /// An array of CopyAction objects, which contains the details of the copy operation.
        public var copyActions: [BackupClientTypes.CopyAction]?
        /// Specifies whether Backup creates continuous backups. True causes Backup to create continuous backups capable of point-in-time restore (PITR). False (or not specified) causes Backup to create snapshot backups.
        public var enableContinuousBackup: Swift.Bool?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that can transition to cold storage are listed in the [Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/backup-feature-availability.html#features-by-resource) table. Backup ignores this expression for other resource types.
        public var lifecycle: BackupClientTypes.Lifecycle?
        /// The tags that are assigned to resources that are associated with this rule when restored from backup.
        public var recoveryPointTags: [Swift.String: Swift.String]?
        /// Uniquely identifies a rule that is used to schedule the backup of a selection of resources.
        public var ruleId: Swift.String?
        /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var ruleName: Swift.String?
        /// A cron expression in UTC specifying when Backup initiates a backup job. For more information about Amazon Web Services cron expressions, see [Schedule Expressions for Rules](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html) in the Amazon CloudWatch Events User Guide.. Two examples of Amazon Web Services cron expressions are  15 * ? * * * (take a backup every hour at 15 minutes past the hour) and 0 12 * * ? * (take a backup every day at 12 noon UTC). For a table of examples, click the preceding link and scroll down the page.
        public var scheduleExpression: Swift.String?
        /// The timezone in which the schedule expression is set. By default, ScheduleExpressions are in UTC. You can modify this to a specified timezone.
        public var scheduleExpressionTimezone: Swift.String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional. If this value is included, it must be at least 60 minutes to avoid errors. During the start window, the backup job status remains in CREATED status until it has successfully begun or until the start window time has run out. If within the start window time Backup receives an error that allows the job to be retried, Backup will automatically retry to begin the job at least every 10 minutes until the backup successfully begins (the job status changes to RUNNING) or until the job status changes to EXPIRED (which is expected to occur when the start window time is over).
        public var startWindowMinutes: Swift.Int?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        /// This member is required.
        public var targetBackupVaultName: Swift.String?

        public init(
            completionWindowMinutes: Swift.Int? = nil,
            copyActions: [BackupClientTypes.CopyAction]? = nil,
            enableContinuousBackup: Swift.Bool? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil,
            recoveryPointTags: [Swift.String: Swift.String]? = nil,
            ruleId: Swift.String? = nil,
            ruleName: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleExpressionTimezone: Swift.String? = nil,
            startWindowMinutes: Swift.Int? = nil,
            targetBackupVaultName: Swift.String? = nil
        )
        {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.lifecycle = lifecycle
            self.recoveryPointTags = recoveryPointTags
            self.ruleId = ruleId
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVaultName = targetBackupVaultName
        }
    }
}

extension BackupClientTypes.BackupRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupRule(completionWindowMinutes: \(Swift.String(describing: completionWindowMinutes)), copyActions: \(Swift.String(describing: copyActions)), enableContinuousBackup: \(Swift.String(describing: enableContinuousBackup)), lifecycle: \(Swift.String(describing: lifecycle)), ruleId: \(Swift.String(describing: ruleId)), ruleName: \(Swift.String(describing: ruleName)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), scheduleExpressionTimezone: \(Swift.String(describing: scheduleExpressionTimezone)), startWindowMinutes: \(Swift.String(describing: startWindowMinutes)), targetBackupVaultName: \(Swift.String(describing: targetBackupVaultName)), recoveryPointTags: \"CONTENT_REDACTED\")"}
}

extension BackupClientTypes {

    /// Contains an optional backup plan display name and an array of BackupRule objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task and can back up a different selection of Amazon Web Services resources.
    public struct BackupPlan: Swift.Sendable {
        /// Contains a list of BackupOptions for each resource type.
        public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
        /// The display name of a backup plan. Must contain only alphanumeric or '-_.' special characters. If this is set in the console, it can contain 1 to 50 characters; if this is set through CLI or API, it can contain 1 to 200 characters.
        /// This member is required.
        public var backupPlanName: Swift.String?
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        /// This member is required.
        public var rules: [BackupClientTypes.BackupRule]?

        public init(
            advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
            backupPlanName: Swift.String? = nil,
            rules: [BackupClientTypes.BackupRule]? = nil
        )
        {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.rules = rules
        }
    }
}

extension BackupClientTypes {

    /// Specifies a scheduled task used to back up a selection of resources.
    public struct BackupRuleInput: Swift.Sendable {
        /// A value in minutes after a backup job is successfully started before it must be completed or it will be canceled by Backup. This value is optional.
        public var completionWindowMinutes: Swift.Int?
        /// An array of CopyAction objects, which contains the details of the copy operation.
        public var copyActions: [BackupClientTypes.CopyAction]?
        /// Specifies whether Backup creates continuous backups. True causes Backup to create continuous backups capable of point-in-time restore (PITR). False (or not specified) causes Backup to create snapshot backups.
        public var enableContinuousBackup: Swift.Bool?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup will transition and expire backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold storage. Resource types that can transition to cold storage are listed in the [Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/backup-feature-availability.html#features-by-resource) table. Backup ignores this expression for other resource types. This parameter has a maximum value of 100 years (36,500 days).
        public var lifecycle: BackupClientTypes.Lifecycle?
        /// The tags to assign to the resources.
        public var recoveryPointTags: [Swift.String: Swift.String]?
        /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var ruleName: Swift.String?
        /// A CRON expression in UTC specifying when Backup initiates a backup job.
        public var scheduleExpression: Swift.String?
        /// The timezone in which the schedule expression is set. By default, ScheduleExpressions are in UTC. You can modify this to a specified timezone.
        public var scheduleExpressionTimezone: Swift.String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional. If this value is included, it must be at least 60 minutes to avoid errors. This parameter has a maximum value of 100 years (52,560,000 minutes). During the start window, the backup job status remains in CREATED status until it has successfully begun or until the start window time has run out. If within the start window time Backup receives an error that allows the job to be retried, Backup will automatically retry to begin the job at least every 10 minutes until the backup successfully begins (the job status changes to RUNNING) or until the job status changes to EXPIRED (which is expected to occur when the start window time is over).
        public var startWindowMinutes: Swift.Int?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        /// This member is required.
        public var targetBackupVaultName: Swift.String?

        public init(
            completionWindowMinutes: Swift.Int? = nil,
            copyActions: [BackupClientTypes.CopyAction]? = nil,
            enableContinuousBackup: Swift.Bool? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil,
            recoveryPointTags: [Swift.String: Swift.String]? = nil,
            ruleName: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleExpressionTimezone: Swift.String? = nil,
            startWindowMinutes: Swift.Int? = nil,
            targetBackupVaultName: Swift.String? = nil
        )
        {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.lifecycle = lifecycle
            self.recoveryPointTags = recoveryPointTags
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVaultName = targetBackupVaultName
        }
    }
}

extension BackupClientTypes.BackupRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupRuleInput(completionWindowMinutes: \(Swift.String(describing: completionWindowMinutes)), copyActions: \(Swift.String(describing: copyActions)), enableContinuousBackup: \(Swift.String(describing: enableContinuousBackup)), lifecycle: \(Swift.String(describing: lifecycle)), ruleName: \(Swift.String(describing: ruleName)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), scheduleExpressionTimezone: \(Swift.String(describing: scheduleExpressionTimezone)), startWindowMinutes: \(Swift.String(describing: startWindowMinutes)), targetBackupVaultName: \(Swift.String(describing: targetBackupVaultName)), recoveryPointTags: \"CONTENT_REDACTED\")"}
}

extension BackupClientTypes {

    /// Contains an optional backup plan display name and an array of BackupRule objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task.
    public struct BackupPlanInput: Swift.Sendable {
        /// Specifies a list of BackupOptions for each resource type. These settings are only available for Windows Volume Shadow Copy Service (VSS) backup jobs.
        public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
        /// The display name of a backup plan. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var backupPlanName: Swift.String?
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        /// This member is required.
        public var rules: [BackupClientTypes.BackupRuleInput]?

        public init(
            advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
            backupPlanName: Swift.String? = nil,
            rules: [BackupClientTypes.BackupRuleInput]? = nil
        )
        {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.rules = rules
        }
    }
}

extension BackupClientTypes {

    /// Contains metadata about a backup plan.
    public struct BackupPlansListMember: Swift.Sendable {
        /// Contains a list of BackupOptions for a resource type.
        public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public var backupPlanArn: Swift.String?
        /// Uniquely identifies a backup plan.
        public var backupPlanId: Swift.String?
        /// The display name of a saved backup plan.
        public var backupPlanName: Swift.String?
        /// The date and time a resource backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: Foundation.Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public var creatorRequestId: Swift.String?
        /// The date and time a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var deletionDate: Foundation.Date?
        /// The last time this backup plan was run. A date and time, in Unix format and Coordinated Universal Time (UTC). The value of LastExecutionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastExecutionDate: Foundation.Date?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
        public var versionId: Swift.String?

        public init(
            advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
            backupPlanArn: Swift.String? = nil,
            backupPlanId: Swift.String? = nil,
            backupPlanName: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            deletionDate: Foundation.Date? = nil,
            lastExecutionDate: Foundation.Date? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanName = backupPlanName
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.deletionDate = deletionDate
            self.lastExecutionDate = lastExecutionDate
            self.versionId = versionId
        }
    }
}

extension BackupClientTypes {

    /// An object specifying metadata associated with a backup plan template.
    public struct BackupPlanTemplatesListMember: Swift.Sendable {
        /// Uniquely identifies a stored backup plan template.
        public var backupPlanTemplateId: Swift.String?
        /// The optional display name of a backup plan template.
        public var backupPlanTemplateName: Swift.String?

        public init(
            backupPlanTemplateId: Swift.String? = nil,
            backupPlanTemplateName: Swift.String? = nil
        )
        {
            self.backupPlanTemplateId = backupPlanTemplateId
            self.backupPlanTemplateName = backupPlanTemplateName
        }
    }
}

extension BackupClientTypes {

    /// Includes information about tags you define to assign tagged resources to a backup plan. Include the prefix aws:ResourceTag in your tags. For example, "aws:ResourceTag/TagKey1": "Value1".
    public struct ConditionParameter: Swift.Sendable {
        /// The key in a key-value pair. For example, in the tag Department: Accounting, Department is the key.
        public var conditionKey: Swift.String?
        /// The value in a key-value pair. For example, in the tag Department: Accounting, Accounting is the value.
        public var conditionValue: Swift.String?

        public init(
            conditionKey: Swift.String? = nil,
            conditionValue: Swift.String? = nil
        )
        {
            self.conditionKey = conditionKey
            self.conditionValue = conditionValue
        }
    }
}

extension BackupClientTypes {

    /// Contains information about which resources to include or exclude from a backup plan using their tags. Conditions are case sensitive.
    public struct Conditions: Swift.Sendable {
        /// Filters the values of your tagged resources for only those resources that you tagged with the same value. Also called "exact matching."
        public var stringEquals: [BackupClientTypes.ConditionParameter]?
        /// Filters the values of your tagged resources for matching tag values with the use of a wildcard character (*) anywhere in the string. For example, "prod*" or "*rod*" matches the tag value "production".
        public var stringLike: [BackupClientTypes.ConditionParameter]?
        /// Filters the values of your tagged resources for only those resources that you tagged that do not have the same value. Also called "negated matching."
        public var stringNotEquals: [BackupClientTypes.ConditionParameter]?
        /// Filters the values of your tagged resources for non-matching tag values with the use of a wildcard character (*) anywhere in the string.
        public var stringNotLike: [BackupClientTypes.ConditionParameter]?

        public init(
            stringEquals: [BackupClientTypes.ConditionParameter]? = nil,
            stringLike: [BackupClientTypes.ConditionParameter]? = nil,
            stringNotEquals: [BackupClientTypes.ConditionParameter]? = nil,
            stringNotLike: [BackupClientTypes.ConditionParameter]? = nil
        )
        {
            self.stringEquals = stringEquals
            self.stringLike = stringLike
            self.stringNotEquals = stringNotEquals
            self.stringNotLike = stringNotLike
        }
    }
}

extension BackupClientTypes {

    public enum ConditionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case stringequals
        case sdkUnknown(Swift.String)

        public static var allCases: [ConditionType] {
            return [
                .stringequals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .stringequals: return "STRINGEQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupClientTypes {

    /// Contains an array of triplets made up of a condition type (such as StringEquals), a key, and a value. Used to filter resources using their tags and assign them to a backup plan. Case sensitive.
    public struct Condition: Swift.Sendable {
        /// The key in a key-value pair. For example, in the tag Department: Accounting, Department is the key.
        /// This member is required.
        public var conditionKey: Swift.String?
        /// An operation applied to a key-value pair used to assign resources to your backup plan. Condition only supports StringEquals. For more flexible assignment options, including StringLike and the ability to exclude resources from your backup plan, use Conditions (with an "s" on the end) for your [BackupSelection](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BackupSelection.html).
        /// This member is required.
        public var conditionType: BackupClientTypes.ConditionType?
        /// The value in a key-value pair. For example, in the tag Department: Accounting, Accounting is the value.
        /// This member is required.
        public var conditionValue: Swift.String?

        public init(
            conditionKey: Swift.String? = nil,
            conditionType: BackupClientTypes.ConditionType? = nil,
            conditionValue: Swift.String? = nil
        )
        {
            self.conditionKey = conditionKey
            self.conditionType = conditionType
            self.conditionValue = conditionValue
        }
    }
}

extension BackupClientTypes {

    /// Used to specify a set of resources to a backup plan. We recommend that you specify conditions, tags, or resources to include or exclude. Otherwise, Backup attempts to select all supported and opted-in storage resources, which could have unintended cost implications. For more information, see [Assigning resources programmatically](https://docs.aws.amazon.com/aws-backup/latest/devguide/assigning-resources.html#assigning-resources-json).
    public struct BackupSelection: Swift.Sendable {
        /// The conditions that you define to assign resources to your backup plans using tags. For example, "StringEquals": { "ConditionKey": "aws:ResourceTag/backup", "ConditionValue": "daily" }. Conditions supports StringEquals, StringLike, StringNotEquals, and StringNotLike. Condition operators are case sensitive. If you specify multiple conditions, the resources much match all conditions (AND logic).
        public var conditions: BackupClientTypes.Conditions?
        /// The ARN of the IAM role that Backup uses to authenticate when backing up the target resource; for example, arn:aws:iam::123456789012:role/S3Access.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// The conditions that you define to assign resources to your backup plans using tags. For example, "StringEquals": { "ConditionKey": "backup", "ConditionValue": "daily"}. ListOfTags supports only StringEquals. Condition operators are case sensitive. If you specify multiple conditions, the resources much match any of the conditions (OR logic).
        public var listOfTags: [BackupClientTypes.Condition]?
        /// The Amazon Resource Names (ARNs) of the resources to exclude from a backup plan. The maximum number of ARNs is 500 without wildcards, or 30 ARNs with wildcards. If you need to exclude many resources from a backup plan, consider a different resource selection strategy, such as assigning only one or a few resource types or refining your resource selection using tags.
        public var notResources: [Swift.String]?
        /// The Amazon Resource Names (ARNs) of the resources to assign to a backup plan. The maximum number of ARNs is 500 without wildcards, or 30 ARNs with wildcards. If you need to assign many resources to a backup plan, consider a different resource selection strategy, such as assigning all resources of a resource type or refining your resource selection using tags. If you specify multiple ARNs, the resources much match any of the ARNs (OR logic).
        public var resources: [Swift.String]?
        /// The display name of a resource selection document. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var selectionName: Swift.String?

        public init(
            conditions: BackupClientTypes.Conditions? = nil,
            iamRoleArn: Swift.String? = nil,
            listOfTags: [BackupClientTypes.Condition]? = nil,
            notResources: [Swift.String]? = nil,
            resources: [Swift.String]? = nil,
            selectionName: Swift.String? = nil
        )
        {
            self.conditions = conditions
            self.iamRoleArn = iamRoleArn
            self.listOfTags = listOfTags
            self.notResources = notResources
            self.resources = resources
            self.selectionName = selectionName
        }
    }
}

extension BackupClientTypes {

    /// Contains metadata about a BackupSelection object.
    public struct BackupSelectionsListMember: Swift.Sendable {
        /// Uniquely identifies a backup plan.
        public var backupPlanId: Swift.String?
        /// The date and time a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: Foundation.Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public var creatorRequestId: Swift.String?
        /// Specifies the IAM role Amazon Resource Name (ARN) to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// Uniquely identifies a request to assign a set of resources to a backup plan.
        public var selectionId: Swift.String?
        /// The display name of a resource selection document.
        public var selectionName: Swift.String?

        public init(
            backupPlanId: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            selectionId: Swift.String? = nil,
            selectionName: Swift.String? = nil
        )
        {
            self.backupPlanId = backupPlanId
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.iamRoleArn = iamRoleArn
            self.selectionId = selectionId
            self.selectionName = selectionName
        }
    }
}

extension BackupClientTypes {

    public enum BackupVaultEvent: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case backupJobCompleted
        case backupJobExpired
        case backupJobFailed
        case backupJobStarted
        case backupJobSuccessful
        case backupPlanCreated
        case backupPlanModified
        case copyJobFailed
        case copyJobStarted
        case copyJobSuccessful
        case recoveryPointModified
        case restoreJobCompleted
        case restoreJobFailed
        case restoreJobStarted
        case restoreJobSuccessful
        case s3BackupObjectFailed
        case s3RestoreObjectFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupVaultEvent] {
            return [
                .backupJobCompleted,
                .backupJobExpired,
                .backupJobFailed,
                .backupJobStarted,
                .backupJobSuccessful,
                .backupPlanCreated,
                .backupPlanModified,
                .copyJobFailed,
                .copyJobStarted,
                .copyJobSuccessful,
                .recoveryPointModified,
                .restoreJobCompleted,
                .restoreJobFailed,
                .restoreJobStarted,
                .restoreJobSuccessful,
                .s3BackupObjectFailed,
                .s3RestoreObjectFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .backupJobCompleted: return "BACKUP_JOB_COMPLETED"
            case .backupJobExpired: return "BACKUP_JOB_EXPIRED"
            case .backupJobFailed: return "BACKUP_JOB_FAILED"
            case .backupJobStarted: return "BACKUP_JOB_STARTED"
            case .backupJobSuccessful: return "BACKUP_JOB_SUCCESSFUL"
            case .backupPlanCreated: return "BACKUP_PLAN_CREATED"
            case .backupPlanModified: return "BACKUP_PLAN_MODIFIED"
            case .copyJobFailed: return "COPY_JOB_FAILED"
            case .copyJobStarted: return "COPY_JOB_STARTED"
            case .copyJobSuccessful: return "COPY_JOB_SUCCESSFUL"
            case .recoveryPointModified: return "RECOVERY_POINT_MODIFIED"
            case .restoreJobCompleted: return "RESTORE_JOB_COMPLETED"
            case .restoreJobFailed: return "RESTORE_JOB_FAILED"
            case .restoreJobStarted: return "RESTORE_JOB_STARTED"
            case .restoreJobSuccessful: return "RESTORE_JOB_SUCCESSFUL"
            case .s3BackupObjectFailed: return "S3_BACKUP_OBJECT_FAILED"
            case .s3RestoreObjectFailed: return "S3_RESTORE_OBJECT_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupClientTypes {

    public enum VaultState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [VaultState] {
            return [
                .available,
                .creating,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupClientTypes {

    public enum VaultType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case backupVault
        case logicallyAirGappedBackupVault
        case sdkUnknown(Swift.String)

        public static var allCases: [VaultType] {
            return [
                .backupVault,
                .logicallyAirGappedBackupVault
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .backupVault: return "BACKUP_VAULT"
            case .logicallyAirGappedBackupVault: return "LOGICALLY_AIR_GAPPED_BACKUP_VAULT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupClientTypes {

    /// Contains metadata about a backup vault.
    public struct BackupVaultListMember: Swift.Sendable {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public var backupVaultName: Swift.String?
        /// The date and time a resource backup is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: Foundation.Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public var creatorRequestId: Swift.String?
        /// A server-side encryption key you can specify to encrypt your backups from services that support full Backup management; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab. If you specify a key, you must specify its ARN, not its alias. If you do not specify a key, Backup creates a KMS key for you by default. To learn which Backup services support full Backup management and how Backup handles encryption for backups from services that do not yet support full Backup, see [ Encryption for backups in Backup](https://docs.aws.amazon.com/aws-backup/latest/devguide/encryption.html)
        public var encryptionKeyArn: Swift.String?
        /// The date and time when Backup Vault Lock configuration becomes immutable, meaning it cannot be changed or deleted. If you applied Vault Lock to your vault without specifying a lock date, you can change your Vault Lock settings, or delete Vault Lock from the vault entirely, at any time. This value is in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lockDate: Foundation.Date?
        /// A Boolean value that indicates whether Backup Vault Lock applies to the selected backup vault. If true, Vault Lock prevents delete and update operations on the recovery points in the selected vault.
        public var locked: Swift.Bool?
        /// The Backup Vault Lock setting that specifies the maximum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a maximum retention period on the recovery points in the vault (allowing indefinite storage). If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
        public var maxRetentionDays: Swift.Int?
        /// The Backup Vault Lock setting that specifies the minimum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a minimum retention period. If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
        public var minRetentionDays: Swift.Int?
        /// The number of recovery points that are stored in a backup vault.
        public var numberOfRecoveryPoints: Swift.Int
        /// The current state of the vault.
        public var vaultState: BackupClientTypes.VaultState?
        /// The type of vault in which the described recovery point is stored.
        public var vaultType: BackupClientTypes.VaultType?

        public init(
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            encryptionKeyArn: Swift.String? = nil,
            lockDate: Foundation.Date? = nil,
            locked: Swift.Bool? = nil,
            maxRetentionDays: Swift.Int? = nil,
            minRetentionDays: Swift.Int? = nil,
            numberOfRecoveryPoints: Swift.Int = 0,
            vaultState: BackupClientTypes.VaultState? = nil,
            vaultType: BackupClientTypes.VaultType? = nil
        )
        {
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.encryptionKeyArn = encryptionKeyArn
            self.lockDate = lockDate
            self.locked = locked
            self.maxRetentionDays = maxRetentionDays
            self.minRetentionDays = minRetentionDays
            self.numberOfRecoveryPoints = numberOfRecoveryPoints
            self.vaultState = vaultState
            self.vaultType = vaultType
        }
    }
}

extension BackupClientTypes {

    /// Contains DeleteAt and MoveToColdStorageAt timestamps, which are used to specify a lifecycle for a recovery point. The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that can transition to cold storage are listed in the [Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/backup-feature-availability.html#features-by-resource) table. Backup ignores this expression for other resource types.
    public struct CalculatedLifecycle: Swift.Sendable {
        /// A timestamp that specifies when to delete a recovery point.
        public var deleteAt: Foundation.Date?
        /// A timestamp that specifies when to transition a recovery point to cold storage.
        public var moveToColdStorageAt: Foundation.Date?

        public init(
            deleteAt: Foundation.Date? = nil,
            moveToColdStorageAt: Foundation.Date? = nil
        )
        {
            self.deleteAt = deleteAt
            self.moveToColdStorageAt = moveToColdStorageAt
        }
    }
}

/// Indicates that something is wrong with a parameter's value. For example, the value is out of range.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValueException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

/// Backup is already performing an action on this recovery point. It can't perform the action you requested until the first action finishes. Try again later.
public struct InvalidResourceStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

/// Indicates that a required parameter is missing.
public struct MissingParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MissingParameterValueException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

/// A resource that is required for the action doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

/// The request failed due to a temporary failure of the server.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

public struct CancelLegalHoldInput: Swift.Sendable {
    /// A string the describes the reason for removing the legal hold.
    /// This member is required.
    public var cancelDescription: Swift.String?
    /// The ID of the legal hold.
    /// This member is required.
    public var legalHoldId: Swift.String?
    /// The integer amount, in days, after which to remove legal hold.
    public var retainRecordInDays: Swift.Int?

    public init(
        cancelDescription: Swift.String? = nil,
        legalHoldId: Swift.String? = nil,
        retainRecordInDays: Swift.Int? = nil
    )
    {
        self.cancelDescription = cancelDescription
        self.legalHoldId = legalHoldId
        self.retainRecordInDays = retainRecordInDays
    }
}

public struct CancelLegalHoldOutput: Swift.Sendable {

    public init() { }
}

/// Backup can't perform the action that you requested until it finishes performing a previous action. Try again later.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

extension BackupClientTypes {

    /// The parameters for a control. A control can have zero, one, or more than one parameter. An example of a control with two parameters is: "backup plan frequency is at least daily and the retention period is at least 1 year". The first parameter is daily. The second parameter is 1 year.
    public struct ControlInputParameter: Swift.Sendable {
        /// The name of a parameter, for example, BackupPlanFrequency.
        public var parameterName: Swift.String?
        /// The value of parameter, for example, hourly.
        public var parameterValue: Swift.String?

        public init(
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }
    }
}

extension BackupClientTypes {

    /// A framework consists of one or more controls. Each control has its own control scope. The control scope can include one or more resource types, a combination of a tag key and value, or a combination of one resource type and one resource ID. If no scope is specified, evaluations for the rule are triggered when any resource in your recording group changes in configuration. To set a control scope that includes all of a particular resource, leave the ControlScope empty or do not pass it when calling CreateFramework.
    public struct ControlScope: Swift.Sendable {
        /// The ID of the only Amazon Web Services resource that you want your control scope to contain.
        public var complianceResourceIds: [Swift.String]?
        /// Describes whether the control scope includes one or more types of resources, such as EFS or RDS.
        public var complianceResourceTypes: [Swift.String]?
        /// The tag key-value pair applied to those Amazon Web Services resources that you want to trigger an evaluation for a rule. A maximum of one key-value pair can be provided. The tag value is optional, but it cannot be an empty string if you are creating or editing a framework from the console (though the value can be an empty string when included in a CloudFormation template). The structure to assign a tag is: [{"Key":"string","Value":"string"}].
        public var tags: [Swift.String: Swift.String]?

        public init(
            complianceResourceIds: [Swift.String]? = nil,
            complianceResourceTypes: [Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.complianceResourceIds = complianceResourceIds
            self.complianceResourceTypes = complianceResourceTypes
            self.tags = tags
        }
    }
}

extension BackupClientTypes {

    public enum CopyJobState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case created
        case failed
        case partial
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [CopyJobState] {
            return [
                .completed,
                .created,
                .failed,
                .partial,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .partial: return "PARTIAL"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupClientTypes {

    /// Contains detailed information about a copy job.
    public struct CopyJob: Swift.Sendable {
        /// The account ID that owns the copy job.
        public var accountId: Swift.String?
        /// The size, in bytes, of a copy job.
        public var backupSizeInBytes: Swift.Int?
        /// This returns the statistics of the included child (nested) copy jobs.
        public var childJobsInState: [Swift.String: Swift.Int]?
        /// The date and time a copy job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: Foundation.Date?
        /// The identifier of a resource within a composite group, such as nested (child) recovery point belonging to a composite (parent) stack. The ID is transferred from the [ logical ID](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html#resources-section-structure-syntax) within a stack.
        public var compositeMemberIdentifier: Swift.String?
        /// Uniquely identifies a copy job.
        public var copyJobId: Swift.String?
        /// Contains information about the backup plan and rule that Backup used to initiate the recovery point backup.
        public var createdBy: BackupClientTypes.RecoveryPointCreator?
        /// The date and time a copy job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: Foundation.Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a destination copy vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public var destinationBackupVaultArn: Swift.String?
        /// An ARN that uniquely identifies a destination recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var destinationRecoveryPointArn: Swift.String?
        /// Specifies the IAM role ARN used to copy the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// This is a boolean value indicating this is a parent (composite) copy job.
        public var isParent: Swift.Bool
        /// This parameter is the job count for the specified message category. Example strings may include AccessDenied, SUCCESS, AGGREGATE_ALL, and InvalidParameters. See [Monitoring](https://docs.aws.amazon.com/aws-backup/latest/devguide/monitoring.html) for a list of MessageCategory strings. The the value ANY returns count of all message categories. AGGREGATE_ALL aggregates job counts for all message categories and returns the sum
        public var messageCategory: Swift.String?
        /// The number of child (nested) copy jobs.
        public var numberOfChildJobs: Swift.Int?
        /// This uniquely identifies a request to Backup to copy a resource. The return will be the parent (composite) job ID.
        public var parentJobId: Swift.String?
        /// The Amazon Web Services resource to be copied; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public var resourceArn: Swift.String?
        /// The non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource to be copied; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public var resourceType: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a source copy vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public var sourceBackupVaultArn: Swift.String?
        /// An ARN that uniquely identifies a source recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var sourceRecoveryPointArn: Swift.String?
        /// The current state of a copy job.
        public var state: BackupClientTypes.CopyJobState?
        /// A detailed message explaining the status of the job to copy a resource.
        public var statusMessage: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            backupSizeInBytes: Swift.Int? = nil,
            childJobsInState: [Swift.String: Swift.Int]? = nil,
            completionDate: Foundation.Date? = nil,
            compositeMemberIdentifier: Swift.String? = nil,
            copyJobId: Swift.String? = nil,
            createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
            creationDate: Foundation.Date? = nil,
            destinationBackupVaultArn: Swift.String? = nil,
            destinationRecoveryPointArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            isParent: Swift.Bool = false,
            messageCategory: Swift.String? = nil,
            numberOfChildJobs: Swift.Int? = nil,
            parentJobId: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            sourceBackupVaultArn: Swift.String? = nil,
            sourceRecoveryPointArn: Swift.String? = nil,
            state: BackupClientTypes.CopyJobState? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.backupSizeInBytes = backupSizeInBytes
            self.childJobsInState = childJobsInState
            self.completionDate = completionDate
            self.compositeMemberIdentifier = compositeMemberIdentifier
            self.copyJobId = copyJobId
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.destinationRecoveryPointArn = destinationRecoveryPointArn
            self.iamRoleArn = iamRoleArn
            self.isParent = isParent
            self.messageCategory = messageCategory
            self.numberOfChildJobs = numberOfChildJobs
            self.parentJobId = parentJobId
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.sourceRecoveryPointArn = sourceRecoveryPointArn
            self.state = state
            self.statusMessage = statusMessage
        }
    }
}

extension BackupClientTypes {

    public enum CopyJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aborted
        case aborting
        case aggregateAll
        case any
        case completed
        case completing
        case created
        case failed
        case failing
        case partial
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [CopyJobStatus] {
            return [
                .aborted,
                .aborting,
                .aggregateAll,
                .any,
                .completed,
                .completing,
                .created,
                .failed,
                .failing,
                .partial,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .aborting: return "ABORTING"
            case .aggregateAll: return "AGGREGATE_ALL"
            case .any: return "ANY"
            case .completed: return "COMPLETED"
            case .completing: return "COMPLETING"
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .failing: return "FAILING"
            case .partial: return "PARTIAL"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupClientTypes {

    /// This is a summary of copy jobs created or running within the most recent 30 days. The returned summary may contain the following: Region, Account, State, RestourceType, MessageCategory, StartTime, EndTime, and Count of included jobs.
    public struct CopyJobSummary: Swift.Sendable {
        /// The account ID that owns the jobs within the summary.
        public var accountId: Swift.String?
        /// The value as a number of jobs in a job summary.
        public var count: Swift.Int
        /// The value of time in number format of a job end time. This value is the time in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var endTime: Foundation.Date?
        /// This parameter is the job count for the specified message category. Example strings include AccessDenied, Success, and InvalidParameters. See [Monitoring](https://docs.aws.amazon.com/aws-backup/latest/devguide/monitoring.html) for a list of MessageCategory strings. The the value ANY returns count of all message categories. AGGREGATE_ALL aggregates job counts for all message categories and returns the sum.
        public var messageCategory: Swift.String?
        /// The Amazon Web Services Regions within the job summary.
        public var region: Swift.String?
        /// This value is the job count for the specified resource type. The request GetSupportedResourceTypes returns strings for supported resource types
        public var resourceType: Swift.String?
        /// The value of time in number format of a job start time. This value is the time in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var startTime: Foundation.Date?
        /// This value is job count for jobs with the specified state.
        public var state: BackupClientTypes.CopyJobStatus?

        public init(
            accountId: Swift.String? = nil,
            count: Swift.Int = 0,
            endTime: Foundation.Date? = nil,
            messageCategory: Swift.String? = nil,
            region: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: BackupClientTypes.CopyJobStatus? = nil
        )
        {
            self.accountId = accountId
            self.count = count
            self.endTime = endTime
            self.messageCategory = messageCategory
            self.region = region
            self.resourceType = resourceType
            self.startTime = startTime
            self.state = state
        }
    }
}

/// A limit in the request has been exceeded; for example, a maximum number of items allowed in a request.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

public struct CreateBackupPlanInput: Swift.Sendable {
    /// The body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    /// This member is required.
    public var backupPlan: BackupClientTypes.BackupPlanInput?
    /// The tags to assign to the backup plan.
    public var backupPlanTags: [Swift.String: Swift.String]?
    /// Identifies the request and allows failed requests to be retried without the risk of running the operation twice. If the request includes a CreatorRequestId that matches an existing backup plan, that plan is returned. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?

    public init(
        backupPlan: BackupClientTypes.BackupPlanInput? = nil,
        backupPlanTags: [Swift.String: Swift.String]? = nil,
        creatorRequestId: Swift.String? = nil
    )
    {
        self.backupPlan = backupPlan
        self.backupPlanTags = backupPlanTags
        self.creatorRequestId = creatorRequestId
    }
}

extension CreateBackupPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupPlanInput(backupPlan: \(Swift.String(describing: backupPlan)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), backupPlanTags: \"CONTENT_REDACTED\")"}
}

public struct CreateBackupPlanOutput: Swift.Sendable {
    /// The settings for a resource type. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs.
    public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// The ID of the backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time that a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: Foundation.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. They cannot be edited.
    public var versionId: Swift.String?

    public init(
        advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        creationDate: Foundation.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.versionId = versionId
    }
}

public struct CreateBackupSelectionInput: Swift.Sendable {
    /// The ID of the backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// The body of a request to assign a set of resources to a backup plan.
    /// This member is required.
    public var backupSelection: BackupClientTypes.BackupSelection?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        backupSelection: BackupClientTypes.BackupSelection? = nil,
        creatorRequestId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.backupSelection = backupSelection
        self.creatorRequestId = creatorRequestId
    }
}

public struct CreateBackupSelectionOutput: Swift.Sendable {
    /// The ID of the backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time a backup selection is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: Foundation.Date?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    public var selectionId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        creationDate: Foundation.Date? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.selectionId = selectionId
    }
}

public struct CreateBackupVaultInput: Swift.Sendable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The tags to assign to the backup vault.
    public var backupVaultTags: [Swift.String: Swift.String]?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?
    /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    public var encryptionKeyArn: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil,
        backupVaultTags: [Swift.String: Swift.String]? = nil,
        creatorRequestId: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.backupVaultTags = backupVaultTags
        self.creatorRequestId = creatorRequestId
        self.encryptionKeyArn = encryptionKeyArn
    }
}

extension CreateBackupVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupVaultInput(backupVaultName: \(Swift.String(describing: backupVaultName)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), encryptionKeyArn: \(Swift.String(describing: encryptionKeyArn)), backupVaultTags: \"CONTENT_REDACTED\")"}
}

public struct CreateBackupVaultOutput: Swift.Sendable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// The date and time a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: Foundation.Date?

    public init(
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        creationDate: Foundation.Date? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.creationDate = creationDate
    }
}

extension BackupClientTypes {

    /// Contains detailed information about all of the controls of a framework. Each framework must contain at least one control.
    public struct FrameworkControl: Swift.Sendable {
        /// The name/value pairs.
        public var controlInputParameters: [BackupClientTypes.ControlInputParameter]?
        /// The name of a control. This name is between 1 and 256 characters.
        /// This member is required.
        public var controlName: Swift.String?
        /// The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans. For more information, see [ControlScope].(https://docs.aws.amazon.com/aws-backup/latest/devguide/API_ControlScope.html)
        public var controlScope: BackupClientTypes.ControlScope?

        public init(
            controlInputParameters: [BackupClientTypes.ControlInputParameter]? = nil,
            controlName: Swift.String? = nil,
            controlScope: BackupClientTypes.ControlScope? = nil
        )
        {
            self.controlInputParameters = controlInputParameters
            self.controlName = controlName
            self.controlScope = controlScope
        }
    }
}

public struct CreateFrameworkInput: Swift.Sendable {
    /// The controls that make up the framework. Each control in the list has a name, input parameters, and scope.
    /// This member is required.
    public var frameworkControls: [BackupClientTypes.FrameworkControl]?
    /// An optional description of the framework with a maximum of 1,024 characters.
    public var frameworkDescription: Swift.String?
    /// The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var frameworkName: Swift.String?
    /// The tags to assign to the framework.
    public var frameworkTags: [Swift.String: Swift.String]?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to CreateFrameworkInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?

    public init(
        frameworkControls: [BackupClientTypes.FrameworkControl]? = nil,
        frameworkDescription: Swift.String? = nil,
        frameworkName: Swift.String? = nil,
        frameworkTags: [Swift.String: Swift.String]? = nil,
        idempotencyToken: Swift.String? = nil
    )
    {
        self.frameworkControls = frameworkControls
        self.frameworkDescription = frameworkDescription
        self.frameworkName = frameworkName
        self.frameworkTags = frameworkTags
        self.idempotencyToken = idempotencyToken
    }
}

public struct CreateFrameworkOutput: Swift.Sendable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var frameworkArn: Swift.String?
    /// The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    public var frameworkName: Swift.String?

    public init(
        frameworkArn: Swift.String? = nil,
        frameworkName: Swift.String? = nil
    )
    {
        self.frameworkArn = frameworkArn
        self.frameworkName = frameworkName
    }
}

extension BackupClientTypes {

    /// This is a resource filter containing FromDate: DateTime and ToDate: DateTime. Both values are required. Future DateTime values are not permitted. The date and time are in Unix format and Coordinated Universal Time (UTC), and it is accurate to milliseconds ((milliseconds are optional). For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public struct DateRange: Swift.Sendable {
        /// This value is the beginning date, inclusive. The date and time are in Unix format and Coordinated Universal Time (UTC), and it is accurate to milliseconds (milliseconds are optional).
        /// This member is required.
        public var fromDate: Foundation.Date?
        /// This value is the end date, inclusive. The date and time are in Unix format and Coordinated Universal Time (UTC), and it is accurate to milliseconds (milliseconds are optional).
        /// This member is required.
        public var toDate: Foundation.Date?

        public init(
            fromDate: Foundation.Date? = nil,
            toDate: Foundation.Date? = nil
        )
        {
            self.fromDate = fromDate
            self.toDate = toDate
        }
    }
}

extension BackupClientTypes {

    /// This specifies criteria to assign a set of resources, such as resource types or backup vaults.
    public struct RecoveryPointSelection: Swift.Sendable {
        /// This is a resource filter containing FromDate: DateTime and ToDate: DateTime. Both values are required. Future DateTime values are not permitted. The date and time are in Unix format and Coordinated Universal Time (UTC), and it is accurate to milliseconds ((milliseconds are optional). For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var dateRange: BackupClientTypes.DateRange?
        /// These are the resources included in the resource selection (including type of resources and vaults).
        public var resourceIdentifiers: [Swift.String]?
        /// These are the names of the vaults in which the selected recovery points are contained.
        public var vaultNames: [Swift.String]?

        public init(
            dateRange: BackupClientTypes.DateRange? = nil,
            resourceIdentifiers: [Swift.String]? = nil,
            vaultNames: [Swift.String]? = nil
        )
        {
            self.dateRange = dateRange
            self.resourceIdentifiers = resourceIdentifiers
            self.vaultNames = vaultNames
        }
    }
}

public struct CreateLegalHoldInput: Swift.Sendable {
    /// The description of the legal hold.
    /// This member is required.
    public var description: Swift.String?
    /// This is a user-chosen string used to distinguish between otherwise identical calls. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// The criteria to assign a set of resources, such as resource types or backup vaults.
    public var recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
    /// Optional tags to include. A tag is a key-value pair you can use to manage, filter, and search for your resources. Allowed characters include UTF-8 letters, numbers, spaces, and the following characters: + - = . _ : /.
    public var tags: [Swift.String: Swift.String]?
    /// The title of the legal hold.
    /// This member is required.
    public var title: Swift.String?

    public init(
        description: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        recoveryPointSelection: BackupClientTypes.RecoveryPointSelection? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        title: Swift.String? = nil
    )
    {
        self.description = description
        self.idempotencyToken = idempotencyToken
        self.recoveryPointSelection = recoveryPointSelection
        self.tags = tags
        self.title = title
    }
}

extension CreateLegalHoldInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLegalHoldInput(description: \(Swift.String(describing: description)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), recoveryPointSelection: \(Swift.String(describing: recoveryPointSelection)), title: \(Swift.String(describing: title)), tags: \"CONTENT_REDACTED\")"}
}

extension BackupClientTypes {

    public enum LegalHoldStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case canceled
        case canceling
        case creating
        case sdkUnknown(Swift.String)

        public static var allCases: [LegalHoldStatus] {
            return [
                .active,
                .canceled,
                .canceling,
                .creating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .canceling: return "CANCELING"
            case .creating: return "CREATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateLegalHoldOutput: Swift.Sendable {
    /// The time when the legal hold was created.
    public var creationDate: Foundation.Date?
    /// The description of the legal hold.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the legal hold.
    public var legalHoldArn: Swift.String?
    /// The ID of the legal hold.
    public var legalHoldId: Swift.String?
    /// The criteria to assign to a set of resources, such as resource types or backup vaults.
    public var recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
    /// The status of the legal hold.
    public var status: BackupClientTypes.LegalHoldStatus?
    /// The title of the legal hold.
    public var title: Swift.String?

    public init(
        creationDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        legalHoldArn: Swift.String? = nil,
        legalHoldId: Swift.String? = nil,
        recoveryPointSelection: BackupClientTypes.RecoveryPointSelection? = nil,
        status: BackupClientTypes.LegalHoldStatus? = nil,
        title: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.description = description
        self.legalHoldArn = legalHoldArn
        self.legalHoldId = legalHoldId
        self.recoveryPointSelection = recoveryPointSelection
        self.status = status
        self.title = title
    }
}

/// Indicates that something is wrong with the input to the request. For example, a parameter is of the wrong type.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

public struct CreateLogicallyAirGappedBackupVaultInput: Swift.Sendable {
    /// The name of a logical container where backups are stored. Logically air-gapped backup vaults are identified by names that are unique to the account used to create them and the Region where they are created.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The tags to assign to the vault.
    public var backupVaultTags: [Swift.String: Swift.String]?
    /// The ID of the creation request. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?
    /// The maximum retention period that the vault retains its recovery points.
    /// This member is required.
    public var maxRetentionDays: Swift.Int?
    /// This setting specifies the minimum retention period that the vault retains its recovery points. The minimum value accepted is 7 days.
    /// This member is required.
    public var minRetentionDays: Swift.Int?

    public init(
        backupVaultName: Swift.String? = nil,
        backupVaultTags: [Swift.String: Swift.String]? = nil,
        creatorRequestId: Swift.String? = nil,
        maxRetentionDays: Swift.Int? = nil,
        minRetentionDays: Swift.Int? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.backupVaultTags = backupVaultTags
        self.creatorRequestId = creatorRequestId
        self.maxRetentionDays = maxRetentionDays
        self.minRetentionDays = minRetentionDays
    }
}

extension CreateLogicallyAirGappedBackupVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLogicallyAirGappedBackupVaultInput(backupVaultName: \(Swift.String(describing: backupVaultName)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), maxRetentionDays: \(Swift.String(describing: maxRetentionDays)), minRetentionDays: \(Swift.String(describing: minRetentionDays)), backupVaultTags: \"CONTENT_REDACTED\")"}
}

public struct CreateLogicallyAirGappedBackupVaultOutput: Swift.Sendable {
    /// The ARN (Amazon Resource Name) of the vault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Logically air-gapped backup vaults are identified by names that are unique to the account used to create them and the Region where they are created.
    public var backupVaultName: Swift.String?
    /// The date and time when the vault was created. This value is in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: Foundation.Date?
    /// The current state of the vault.
    public var vaultState: BackupClientTypes.VaultState?

    public init(
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        creationDate: Foundation.Date? = nil,
        vaultState: BackupClientTypes.VaultState? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.creationDate = creationDate
        self.vaultState = vaultState
    }
}

extension BackupClientTypes {

    /// Contains information from your report plan about where to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
    public struct ReportDeliveryChannel: Swift.Sendable {
        /// The format of your reports: CSV, JSON, or both. If not specified, the default format is CSV.
        public var formats: [Swift.String]?
        /// The unique name of the S3 bucket that receives your reports.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// The prefix for where Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name. If not specified, there is no prefix.
        public var s3KeyPrefix: Swift.String?

        public init(
            formats: [Swift.String]? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil
        )
        {
            self.formats = formats
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }
    }
}

extension BackupClientTypes {

    /// Contains detailed information about a report setting.
    public struct ReportSetting: Swift.Sendable {
        /// These are the accounts to be included in the report. Use string value of ROOT to include all organizational units.
        public var accounts: [Swift.String]?
        /// The Amazon Resource Names (ARNs) of the frameworks a report covers.
        public var frameworkArns: [Swift.String]?
        /// The number of frameworks a report covers.
        public var numberOfFrameworks: Swift.Int
        /// These are the Organizational Units to be included in the report.
        public var organizationUnits: [Swift.String]?
        /// These are the Regions to be included in the report. Use the wildcard as the string value to include all Regions.
        public var regions: [Swift.String]?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        /// This member is required.
        public var reportTemplate: Swift.String?

        public init(
            accounts: [Swift.String]? = nil,
            frameworkArns: [Swift.String]? = nil,
            numberOfFrameworks: Swift.Int = 0,
            organizationUnits: [Swift.String]? = nil,
            regions: [Swift.String]? = nil,
            reportTemplate: Swift.String? = nil
        )
        {
            self.accounts = accounts
            self.frameworkArns = frameworkArns
            self.numberOfFrameworks = numberOfFrameworks
            self.organizationUnits = organizationUnits
            self.regions = regions
            self.reportTemplate = reportTemplate
        }
    }
}

public struct CreateReportPlanInput: Swift.Sendable {
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to CreateReportPlanInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// A structure that contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
    /// This member is required.
    public var reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
    /// An optional description of the report plan with a maximum of 1,024 characters.
    public var reportPlanDescription: Swift.String?
    /// The unique name of the report plan. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var reportPlanName: Swift.String?
    /// The tags to assign to the report plan.
    public var reportPlanTags: [Swift.String: Swift.String]?
    /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
    /// This member is required.
    public var reportSetting: BackupClientTypes.ReportSetting?

    public init(
        idempotencyToken: Swift.String? = nil,
        reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel? = nil,
        reportPlanDescription: Swift.String? = nil,
        reportPlanName: Swift.String? = nil,
        reportPlanTags: [Swift.String: Swift.String]? = nil,
        reportSetting: BackupClientTypes.ReportSetting? = nil
    )
    {
        self.idempotencyToken = idempotencyToken
        self.reportDeliveryChannel = reportDeliveryChannel
        self.reportPlanDescription = reportPlanDescription
        self.reportPlanName = reportPlanName
        self.reportPlanTags = reportPlanTags
        self.reportSetting = reportSetting
    }
}

public struct CreateReportPlanOutput: Swift.Sendable {
    /// The date and time a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationTime: Foundation.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var reportPlanArn: Swift.String?
    /// The unique name of the report plan.
    public var reportPlanName: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        reportPlanArn: Swift.String? = nil,
        reportPlanName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.reportPlanArn = reportPlanArn
        self.reportPlanName = reportPlanName
    }
}

extension BackupClientTypes {

    public enum RestoreTestingRecoveryPointSelectionAlgorithm: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case latestWithinWindow
        case randomWithinWindow
        case sdkUnknown(Swift.String)

        public static var allCases: [RestoreTestingRecoveryPointSelectionAlgorithm] {
            return [
                .latestWithinWindow,
                .randomWithinWindow
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .latestWithinWindow: return "LATEST_WITHIN_WINDOW"
            case .randomWithinWindow: return "RANDOM_WITHIN_WINDOW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupClientTypes {

    public enum RestoreTestingRecoveryPointType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuous
        case snapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [RestoreTestingRecoveryPointType] {
            return [
                .continuous,
                .snapshot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuous: return "CONTINUOUS"
            case .snapshot: return "SNAPSHOT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupClientTypes {

    /// RecoveryPointSelection has five parameters (three required and two optional). The values you specify determine which recovery point is included in the restore test. You must indicate with Algorithm if you want the latest recovery point within your SelectionWindowDays or if you want a random recovery point, and you must indicate through IncludeVaults from which vaults the recovery points can be chosen. Algorithm (required) Valid values: "LATEST_WITHIN_WINDOW" or "RANDOM_WITHIN_WINDOW". Recovery point types (required) Valid values: "SNAPSHOT" and/or "CONTINUOUS". Include SNAPSHOT to restore only snapshot recovery points; include CONTINUOUS to restore continuous recovery points (point in time restore / PITR); use both to restore either a snapshot or a continuous recovery point. The recovery point will be determined by the value for Algorithm. IncludeVaults (required). You must include one or more backup vaults. Use the wildcard ["*"] or specific ARNs. SelectionWindowDays (optional) Value must be an integer (in days) from 1 to 365. If not included, the value defaults to 30. ExcludeVaults (optional). You can choose to input one or more specific backup vault ARNs to exclude those vaults' contents from restore eligibility. Or, you can include a list of selectors. If this parameter and its value are not included, it defaults to empty list.
    public struct RestoreTestingRecoveryPointSelection: Swift.Sendable {
        /// Acceptable values include "LATEST_WITHIN_WINDOW" or "RANDOM_WITHIN_WINDOW"
        public var algorithm: BackupClientTypes.RestoreTestingRecoveryPointSelectionAlgorithm?
        /// Accepted values include specific ARNs or list of selectors. Defaults to empty list if not listed.
        public var excludeVaults: [Swift.String]?
        /// Accepted values include wildcard ["*"] or by specific ARNs or ARN wilcard replacement ["arn:aws:backup:us-west-2:123456789012:backup-vault:asdf", ...] ["arn:aws:backup:*:*:backup-vault:asdf-*", ...]
        public var includeVaults: [Swift.String]?
        /// These are the types of recovery points. Include SNAPSHOT to restore only snapshot recovery points; include CONTINUOUS to restore continuous recovery points (point in time restore / PITR); use both to restore either a snapshot or a continuous recovery point. The recovery point will be determined by the value for Algorithm.
        public var recoveryPointTypes: [BackupClientTypes.RestoreTestingRecoveryPointType]?
        /// Accepted values are integers from 1 to 365.
        public var selectionWindowDays: Swift.Int

        public init(
            algorithm: BackupClientTypes.RestoreTestingRecoveryPointSelectionAlgorithm? = nil,
            excludeVaults: [Swift.String]? = nil,
            includeVaults: [Swift.String]? = nil,
            recoveryPointTypes: [BackupClientTypes.RestoreTestingRecoveryPointType]? = nil,
            selectionWindowDays: Swift.Int = 0
        )
        {
            self.algorithm = algorithm
            self.excludeVaults = excludeVaults
            self.includeVaults = includeVaults
            self.recoveryPointTypes = recoveryPointTypes
            self.selectionWindowDays = selectionWindowDays
        }
    }
}

extension BackupClientTypes {

    /// This contains metadata about a restore testing plan.
    public struct RestoreTestingPlanForCreate: Swift.Sendable {
        /// RecoveryPointSelection has five parameters (three required and two optional). The values you specify determine which recovery point is included in the restore test. You must indicate with Algorithm if you want the latest recovery point within your SelectionWindowDays or if you want a random recovery point, and you must indicate through IncludeVaults from which vaults the recovery points can be chosen. Algorithm (required) Valid values: "LATEST_WITHIN_WINDOW" or "RANDOM_WITHIN_WINDOW". Recovery point types (required) Valid values: "SNAPSHOT" and/or "CONTINUOUS". Include SNAPSHOT to restore only snapshot recovery points; include CONTINUOUS to restore continuous recovery points (point in time restore / PITR); use both to restore either a snapshot or a continuous recovery point. The recovery point will be determined by the value for Algorithm. IncludeVaults (required). You must include one or more backup vaults. Use the wildcard ["*"] or specific ARNs. SelectionWindowDays (optional) Value must be an integer (in days) from 1 to 365. If not included, the value defaults to 30. ExcludeVaults (optional). You can choose to input one or more specific backup vault ARNs to exclude those vaults' contents from restore eligibility. Or, you can include a list of selectors. If this parameter and its value are not included, it defaults to empty list.
        /// This member is required.
        public var recoveryPointSelection: BackupClientTypes.RestoreTestingRecoveryPointSelection?
        /// The RestoreTestingPlanName is a unique string that is the name of the restore testing plan. This cannot be changed after creation, and it must consist of only alphanumeric characters and underscores.
        /// This member is required.
        public var restoreTestingPlanName: Swift.String?
        /// A CRON expression in specified timezone when a restore testing plan is executed.
        /// This member is required.
        public var scheduleExpression: Swift.String?
        /// Optional. This is the timezone in which the schedule expression is set. By default, ScheduleExpressions are in UTC. You can modify this to a specified timezone.
        public var scheduleExpressionTimezone: Swift.String?
        /// Defaults to 24 hours. A value in hours after a restore test is scheduled before a job will be canceled if it doesn't start successfully. This value is optional. If this value is included, this parameter has a maximum value of 168 hours (one week).
        public var startWindowHours: Swift.Int

        public init(
            recoveryPointSelection: BackupClientTypes.RestoreTestingRecoveryPointSelection? = nil,
            restoreTestingPlanName: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleExpressionTimezone: Swift.String? = nil,
            startWindowHours: Swift.Int = 0
        )
        {
            self.recoveryPointSelection = recoveryPointSelection
            self.restoreTestingPlanName = restoreTestingPlanName
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startWindowHours = startWindowHours
        }
    }
}

public struct CreateRestoreTestingPlanInput: Swift.Sendable {
    /// This is a unique string that identifies the request and allows failed requests to be retriedwithout the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?
    /// A restore testing plan must contain a unique RestoreTestingPlanName string you create and must contain a ScheduleExpression cron. You may optionally include a StartWindowHours integer and a CreatorRequestId string. The RestoreTestingPlanName is a unique string that is the name of the restore testing plan. This cannot be changed after creation, and it must consist of only alphanumeric characters and underscores.
    /// This member is required.
    public var restoreTestingPlan: BackupClientTypes.RestoreTestingPlanForCreate?
    /// The tags to assign to the restore testing plan.
    public var tags: [Swift.String: Swift.String]?

    public init(
        creatorRequestId: Swift.String? = nil,
        restoreTestingPlan: BackupClientTypes.RestoreTestingPlanForCreate? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.restoreTestingPlan = restoreTestingPlan
        self.tags = tags
    }
}

extension CreateRestoreTestingPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRestoreTestingPlanInput(creatorRequestId: \(Swift.String(describing: creatorRequestId)), restoreTestingPlan: \(Swift.String(describing: restoreTestingPlan)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateRestoreTestingPlanOutput: Swift.Sendable {
    /// The date and time a restore testing plan was created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087AM.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies the created restore testing plan.
    /// This member is required.
    public var restoreTestingPlanArn: Swift.String?
    /// This unique string is the name of the restore testing plan. The name cannot be changed after creation. The name consists of only alphanumeric characters and underscores. Maximum length is 50.
    /// This member is required.
    public var restoreTestingPlanName: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        restoreTestingPlanArn: Swift.String? = nil,
        restoreTestingPlanName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.restoreTestingPlanArn = restoreTestingPlanArn
        self.restoreTestingPlanName = restoreTestingPlanName
    }
}

extension BackupClientTypes {

    /// Pair of two related strings. Allowed characters are letters, white space, and numbers that can be represented in UTF-8 and the following characters:  + - = . _ : /
    public struct KeyValue: Swift.Sendable {
        /// The tag key (String). The key can't start with aws:. Length Constraints: Minimum length of 1. Maximum length of 128. Pattern: ^(?![aA]{1}[wW]{1}[sS]{1}:)([\p{L}\p{Z}\p{N}_.:/=+\-@]+)$
        /// This member is required.
        public var key: Swift.String?
        /// The value of the key. Length Constraints: Maximum length of 256. Pattern: ^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension BackupClientTypes {

    /// The conditions that you define for resources in your restore testing plan using tags.
    public struct ProtectedResourceConditions: Swift.Sendable {
        /// Filters the values of your tagged resources for only those resources that you tagged with the same value. Also called "exact matching."
        public var stringEquals: [BackupClientTypes.KeyValue]?
        /// Filters the values of your tagged resources for only those resources that you tagged that do not have the same value. Also called "negated matching."
        public var stringNotEquals: [BackupClientTypes.KeyValue]?

        public init(
            stringEquals: [BackupClientTypes.KeyValue]? = nil,
            stringNotEquals: [BackupClientTypes.KeyValue]? = nil
        )
        {
            self.stringEquals = stringEquals
            self.stringNotEquals = stringNotEquals
        }
    }
}

extension BackupClientTypes {

    /// This contains metadata about a specific restore testing selection. ProtectedResourceType is required, such as Amazon EBS or Amazon EC2. This consists of RestoreTestingSelectionName, ProtectedResourceType, and one of the following:
    ///
    /// * ProtectedResourceArns
    ///
    /// * ProtectedResourceConditions
    ///
    ///
    /// Each protected resource type can have one single value. A restore testing selection can include a wildcard value ("*") for ProtectedResourceArns along with ProtectedResourceConditions. Alternatively, you can include up to 30 specific protected resource ARNs in ProtectedResourceArns. ProtectedResourceConditions examples include as StringEquals and StringNotEquals.
    public struct RestoreTestingSelectionForCreate: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the IAM role that Backup uses to create the target resource; for example: arn:aws:iam::123456789012:role/S3Access.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// Each protected resource can be filtered by its specific ARNs, such as ProtectedResourceArns: ["arn:aws:...", "arn:aws:..."] or by a wildcard: ProtectedResourceArns: ["*"], but not both.
        public var protectedResourceArns: [Swift.String]?
        /// If you have included the wildcard in ProtectedResourceArns, you can include resource conditions, such as ProtectedResourceConditions: { StringEquals: [{ key: "XXXX", value: "YYYY" }].
        public var protectedResourceConditions: BackupClientTypes.ProtectedResourceConditions?
        /// The type of Amazon Web Services resource included in a restore testing selection; for example, an Amazon EBS volume or an Amazon RDS database. Supported resource types accepted include:
        ///
        /// * Aurora for Amazon Aurora
        ///
        /// * DocumentDB for Amazon DocumentDB (with MongoDB compatibility)
        ///
        /// * DynamoDB for Amazon DynamoDB
        ///
        /// * EBS for Amazon Elastic Block Store
        ///
        /// * EC2 for Amazon Elastic Compute Cloud
        ///
        /// * EFS for Amazon Elastic File System
        ///
        /// * FSx for Amazon FSx
        ///
        /// * Neptune for Amazon Neptune
        ///
        /// * RDS for Amazon Relational Database Service
        ///
        /// * S3 for Amazon S3
        /// This member is required.
        public var protectedResourceType: Swift.String?
        /// You can override certain restore metadata keys by including the parameter RestoreMetadataOverrides in the body of RestoreTestingSelection. Key values are not case sensitive. See the complete list of [restore testing inferred metadata](https://docs.aws.amazon.com/aws-backup/latest/devguide/restore-testing-inferred-metadata.html).
        public var restoreMetadataOverrides: [Swift.String: Swift.String]?
        /// The unique name of the restore testing selection that belongs to the related restore testing plan.
        /// This member is required.
        public var restoreTestingSelectionName: Swift.String?
        /// This is amount of hours (1 to 168) available to run a validation script on the data. The data will be deleted upon the completion of the validation script or the end of the specified retention period, whichever comes first.
        public var validationWindowHours: Swift.Int

        public init(
            iamRoleArn: Swift.String? = nil,
            protectedResourceArns: [Swift.String]? = nil,
            protectedResourceConditions: BackupClientTypes.ProtectedResourceConditions? = nil,
            protectedResourceType: Swift.String? = nil,
            restoreMetadataOverrides: [Swift.String: Swift.String]? = nil,
            restoreTestingSelectionName: Swift.String? = nil,
            validationWindowHours: Swift.Int = 0
        )
        {
            self.iamRoleArn = iamRoleArn
            self.protectedResourceArns = protectedResourceArns
            self.protectedResourceConditions = protectedResourceConditions
            self.protectedResourceType = protectedResourceType
            self.restoreMetadataOverrides = restoreMetadataOverrides
            self.restoreTestingSelectionName = restoreTestingSelectionName
            self.validationWindowHours = validationWindowHours
        }
    }
}

extension BackupClientTypes.RestoreTestingSelectionForCreate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreTestingSelectionForCreate(iamRoleArn: \(Swift.String(describing: iamRoleArn)), protectedResourceArns: \(Swift.String(describing: protectedResourceArns)), protectedResourceConditions: \(Swift.String(describing: protectedResourceConditions)), protectedResourceType: \(Swift.String(describing: protectedResourceType)), restoreTestingSelectionName: \(Swift.String(describing: restoreTestingSelectionName)), validationWindowHours: \(Swift.String(describing: validationWindowHours)), restoreMetadataOverrides: \"CONTENT_REDACTED\")"}
}

public struct CreateRestoreTestingSelectionInput: Swift.Sendable {
    /// This is an optional unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?
    /// Input the restore testing plan name that was returned from the related CreateRestoreTestingPlan request.
    /// This member is required.
    public var restoreTestingPlanName: Swift.String?
    /// This consists of RestoreTestingSelectionName, ProtectedResourceType, and one of the following:
    ///
    /// * ProtectedResourceArns
    ///
    /// * ProtectedResourceConditions
    ///
    ///
    /// Each protected resource type can have one single value. A restore testing selection can include a wildcard value ("*") for ProtectedResourceArns along with ProtectedResourceConditions. Alternatively, you can include up to 30 specific protected resource ARNs in ProtectedResourceArns.
    /// This member is required.
    public var restoreTestingSelection: BackupClientTypes.RestoreTestingSelectionForCreate?

    public init(
        creatorRequestId: Swift.String? = nil,
        restoreTestingPlanName: Swift.String? = nil,
        restoreTestingSelection: BackupClientTypes.RestoreTestingSelectionForCreate? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.restoreTestingPlanName = restoreTestingPlanName
        self.restoreTestingSelection = restoreTestingSelection
    }
}

public struct CreateRestoreTestingSelectionOutput: Swift.Sendable {
    /// The time that the resource testing selection was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The ARN of the restore testing plan with which the restore testing selection is associated.
    /// This member is required.
    public var restoreTestingPlanArn: Swift.String?
    /// The name of the restore testing plan. The name cannot be changed after creation. The name consists of only alphanumeric characters and underscores. Maximum length is 50.
    /// This member is required.
    public var restoreTestingPlanName: Swift.String?
    /// The name of the restore testing selection for the related restore testing plan.
    /// This member is required.
    public var restoreTestingSelectionName: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        restoreTestingPlanArn: Swift.String? = nil,
        restoreTestingPlanName: Swift.String? = nil,
        restoreTestingSelectionName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.restoreTestingPlanArn = restoreTestingPlanArn
        self.restoreTestingPlanName = restoreTestingPlanName
        self.restoreTestingSelectionName = restoreTestingSelectionName
    }
}

public struct DeleteBackupPlanInput: Swift.Sendable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
    }
}

public struct DeleteBackupPlanOutput: Swift.Sendable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var deletionDate: Foundation.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
    public var versionId: Swift.String?

    public init(
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        deletionDate: Foundation.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.deletionDate = deletionDate
        self.versionId = versionId
    }
}

public struct DeleteBackupSelectionInput: Swift.Sendable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    /// This member is required.
    public var selectionId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.selectionId = selectionId
    }
}

public struct DeleteBackupVaultInput: Swift.Sendable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

public struct DeleteBackupVaultAccessPolicyInput: Swift.Sendable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

public struct DeleteBackupVaultLockConfigurationInput: Swift.Sendable {
    /// The name of the backup vault from which to delete Backup Vault Lock.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

public struct DeleteBackupVaultNotificationsInput: Swift.Sendable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

public struct DeleteFrameworkInput: Swift.Sendable {
    /// The unique name of a framework.
    /// This member is required.
    public var frameworkName: Swift.String?

    public init(
        frameworkName: Swift.String? = nil
    )
    {
        self.frameworkName = frameworkName
    }
}

public struct DeleteRecoveryPointInput: Swift.Sendable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

public struct DeleteReportPlanInput: Swift.Sendable {
    /// The unique name of a report plan.
    /// This member is required.
    public var reportPlanName: Swift.String?

    public init(
        reportPlanName: Swift.String? = nil
    )
    {
        self.reportPlanName = reportPlanName
    }
}

public struct DeleteRestoreTestingPlanInput: Swift.Sendable {
    /// Required unique name of the restore testing plan you wish to delete.
    /// This member is required.
    public var restoreTestingPlanName: Swift.String?

    public init(
        restoreTestingPlanName: Swift.String? = nil
    )
    {
        self.restoreTestingPlanName = restoreTestingPlanName
    }
}

public struct DeleteRestoreTestingSelectionInput: Swift.Sendable {
    /// Required unique name of the restore testing plan that contains the restore testing selection you wish to delete.
    /// This member is required.
    public var restoreTestingPlanName: Swift.String?
    /// Required unique name of the restore testing selection you wish to delete.
    /// This member is required.
    public var restoreTestingSelectionName: Swift.String?

    public init(
        restoreTestingPlanName: Swift.String? = nil,
        restoreTestingSelectionName: Swift.String? = nil
    )
    {
        self.restoreTestingPlanName = restoreTestingPlanName
        self.restoreTestingSelectionName = restoreTestingSelectionName
    }
}

/// A dependent Amazon Web Services service or resource returned an error to the Backup service, and the action cannot be completed.
public struct DependencyFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

public struct DescribeBackupJobInput: Swift.Sendable {
    /// Uniquely identifies a request to Backup to back up a resource.
    /// This member is required.
    public var backupJobId: Swift.String?

    public init(
        backupJobId: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
    }
}

public struct DescribeBackupJobOutput: Swift.Sendable {
    /// Returns the account ID that owns the backup job.
    public var accountId: Swift.String?
    /// Uniquely identifies a request to Backup to back up a resource.
    public var backupJobId: Swift.String?
    /// Represents the options specified as part of backup plan or on-demand backup job.
    public var backupOptions: [Swift.String: Swift.String]?
    /// The size, in bytes, of a backup.
    public var backupSizeInBytes: Swift.Int?
    /// Represents the actual backup type selected for a backup job. For example, if a successful Windows Volume Shadow Copy Service (VSS) backup was taken, BackupType returns "WindowsVSS". If BackupType is empty, then the backup type was a regular backup.
    public var backupType: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    public var backupVaultName: Swift.String?
    /// The size in bytes transferred to a backup vault at the time that the job status was queried.
    public var bytesTransferred: Swift.Int?
    /// This returns the statistics of the included child (nested) backup jobs.
    public var childJobsInState: [Swift.String: Swift.Int]?
    /// The date and time that a job to create a backup job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var completionDate: Foundation.Date?
    /// Contains identifying information about the creation of a backup job, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan that is used to create it.
    public var createdBy: BackupClientTypes.RecoveryPointCreator?
    /// The date and time that a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: Foundation.Date?
    /// The date and time that a job to back up resources is expected to be completed, in Unix format and Coordinated Universal Time (UTC). The value of ExpectedCompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var expectedCompletionDate: Foundation.Date?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// The date a backup job was initiated.
    public var initiationDate: Foundation.Date?
    /// This returns the boolean value that a backup job is a parent (composite) job.
    public var isParent: Swift.Bool
    /// The job count for the specified message category. Example strings may include AccessDenied, SUCCESS, AGGREGATE_ALL, and INVALIDPARAMETERS. View [Monitoring](https://docs.aws.amazon.com/aws-backup/latest/devguide/monitoring.html) for a list of accepted MessageCategory strings.
    public var messageCategory: Swift.String?
    /// This returns the number of child (nested) backup jobs.
    public var numberOfChildJobs: Swift.Int?
    /// This returns the parent (composite) resource backup job ID.
    public var parentJobId: Swift.String?
    /// Contains an estimated percentage that is complete of a job at the time the job status was queried.
    public var percentDone: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// An ARN that uniquely identifies a saved resource. The format of the ARN depends on the resource type.
    public var resourceArn: Swift.String?
    /// The non-unique name of the resource that belongs to the specified backup.
    public var resourceName: Swift.String?
    /// The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
    public var resourceType: Swift.String?
    /// Specifies the time in Unix format and Coordinated Universal Time (UTC) when a backup job must be started before it is canceled. The value is calculated by adding the start window to the scheduled time. So if the scheduled time were 6:00 PM and the start window is 2 hours, the StartBy time would be 8:00 PM on the date specified. The value of StartBy is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var startBy: Foundation.Date?
    /// The current state of a backup job.
    public var state: BackupClientTypes.BackupJobState?
    /// A detailed message explaining the status of the job to back up a resource.
    public var statusMessage: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        backupJobId: Swift.String? = nil,
        backupOptions: [Swift.String: Swift.String]? = nil,
        backupSizeInBytes: Swift.Int? = nil,
        backupType: Swift.String? = nil,
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        bytesTransferred: Swift.Int? = nil,
        childJobsInState: [Swift.String: Swift.Int]? = nil,
        completionDate: Foundation.Date? = nil,
        createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
        creationDate: Foundation.Date? = nil,
        expectedCompletionDate: Foundation.Date? = nil,
        iamRoleArn: Swift.String? = nil,
        initiationDate: Foundation.Date? = nil,
        isParent: Swift.Bool = false,
        messageCategory: Swift.String? = nil,
        numberOfChildJobs: Swift.Int? = nil,
        parentJobId: Swift.String? = nil,
        percentDone: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        startBy: Foundation.Date? = nil,
        state: BackupClientTypes.BackupJobState? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.backupJobId = backupJobId
        self.backupOptions = backupOptions
        self.backupSizeInBytes = backupSizeInBytes
        self.backupType = backupType
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.bytesTransferred = bytesTransferred
        self.childJobsInState = childJobsInState
        self.completionDate = completionDate
        self.createdBy = createdBy
        self.creationDate = creationDate
        self.expectedCompletionDate = expectedCompletionDate
        self.iamRoleArn = iamRoleArn
        self.initiationDate = initiationDate
        self.isParent = isParent
        self.messageCategory = messageCategory
        self.numberOfChildJobs = numberOfChildJobs
        self.parentJobId = parentJobId
        self.percentDone = percentDone
        self.recoveryPointArn = recoveryPointArn
        self.resourceArn = resourceArn
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.startBy = startBy
        self.state = state
        self.statusMessage = statusMessage
    }
}

public struct DescribeBackupVaultInput: Swift.Sendable {
    /// The account ID of the specified backup vault.
    public var backupVaultAccountId: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init(
        backupVaultAccountId: Swift.String? = nil,
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultAccountId = backupVaultAccountId
        self.backupVaultName = backupVaultName
    }
}

public struct DescribeBackupVaultOutput: Swift.Sendable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created.
    public var backupVaultName: Swift.String?
    /// The date and time that a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: Foundation.Date?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?
    /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    public var encryptionKeyArn: Swift.String?
    /// The date and time when Backup Vault Lock configuration cannot be changed or deleted. If you applied Vault Lock to your vault without specifying a lock date, you can change any of your Vault Lock settings, or delete Vault Lock from the vault entirely, at any time. This value is in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lockDate: Foundation.Date?
    /// A Boolean that indicates whether Backup Vault Lock is currently protecting the backup vault. True means that Vault Lock causes delete or update operations on the recovery points stored in the vault to fail.
    public var locked: Swift.Bool?
    /// The Backup Vault Lock setting that specifies the maximum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a maximum retention period on the recovery points in the vault (allowing indefinite storage). If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
    public var maxRetentionDays: Swift.Int?
    /// The Backup Vault Lock setting that specifies the minimum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock will not enforce a minimum retention period. If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
    public var minRetentionDays: Swift.Int?
    /// The number of recovery points that are stored in a backup vault.
    public var numberOfRecoveryPoints: Swift.Int
    /// The current state of the vault.->
    public var vaultState: BackupClientTypes.VaultState?
    /// The type of vault described.
    public var vaultType: BackupClientTypes.VaultType?

    public init(
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        creationDate: Foundation.Date? = nil,
        creatorRequestId: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil,
        lockDate: Foundation.Date? = nil,
        locked: Swift.Bool? = nil,
        maxRetentionDays: Swift.Int? = nil,
        minRetentionDays: Swift.Int? = nil,
        numberOfRecoveryPoints: Swift.Int = 0,
        vaultState: BackupClientTypes.VaultState? = nil,
        vaultType: BackupClientTypes.VaultType? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.encryptionKeyArn = encryptionKeyArn
        self.lockDate = lockDate
        self.locked = locked
        self.maxRetentionDays = maxRetentionDays
        self.minRetentionDays = minRetentionDays
        self.numberOfRecoveryPoints = numberOfRecoveryPoints
        self.vaultState = vaultState
        self.vaultType = vaultType
    }
}

public struct DescribeCopyJobInput: Swift.Sendable {
    /// Uniquely identifies a copy job.
    /// This member is required.
    public var copyJobId: Swift.String?

    public init(
        copyJobId: Swift.String? = nil
    )
    {
        self.copyJobId = copyJobId
    }
}

public struct DescribeCopyJobOutput: Swift.Sendable {
    /// Contains detailed information about a copy job.
    public var copyJob: BackupClientTypes.CopyJob?

    public init(
        copyJob: BackupClientTypes.CopyJob? = nil
    )
    {
        self.copyJob = copyJob
    }
}

public struct DescribeFrameworkInput: Swift.Sendable {
    /// The unique name of a framework.
    /// This member is required.
    public var frameworkName: Swift.String?

    public init(
        frameworkName: Swift.String? = nil
    )
    {
        self.frameworkName = frameworkName
    }
}

public struct DescribeFrameworkOutput: Swift.Sendable {
    /// The date and time that a framework is created, in ISO 8601 representation. The value of CreationTime is accurate to milliseconds. For example, 2020-07-10T15:00:00.000-08:00 represents the 10th of July 2020 at 3:00 PM 8 hours behind UTC.
    public var creationTime: Foundation.Date?
    /// The deployment status of a framework. The statuses are: CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED | FAILED
    public var deploymentStatus: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var frameworkArn: Swift.String?
    /// The controls that make up the framework. Each control in the list has a name, input parameters, and scope.
    public var frameworkControls: [BackupClientTypes.FrameworkControl]?
    /// An optional description of the framework.
    public var frameworkDescription: Swift.String?
    /// The unique name of a framework.
    public var frameworkName: Swift.String?
    /// A framework consists of one or more controls. Each control governs a resource, such as backup plans, backup selections, backup vaults, or recovery points. You can also turn Config recording on or off for each resource. The statuses are:
    ///
    /// * ACTIVE when recording is turned on for all resources governed by the framework.
    ///
    /// * PARTIALLY_ACTIVE when recording is turned off for at least one resource governed by the framework.
    ///
    /// * INACTIVE when recording is turned off for all resources governed by the framework.
    ///
    /// * UNAVAILABLE when Backup is unable to validate recording status at this time.
    public var frameworkStatus: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to DescribeFrameworkOutput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        deploymentStatus: Swift.String? = nil,
        frameworkArn: Swift.String? = nil,
        frameworkControls: [BackupClientTypes.FrameworkControl]? = nil,
        frameworkDescription: Swift.String? = nil,
        frameworkName: Swift.String? = nil,
        frameworkStatus: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.deploymentStatus = deploymentStatus
        self.frameworkArn = frameworkArn
        self.frameworkControls = frameworkControls
        self.frameworkDescription = frameworkDescription
        self.frameworkName = frameworkName
        self.frameworkStatus = frameworkStatus
        self.idempotencyToken = idempotencyToken
    }
}

public struct DescribeGlobalSettingsInput: Swift.Sendable {

    public init() { }
}

public struct DescribeGlobalSettingsOutput: Swift.Sendable {
    /// The status of the flag isCrossAccountBackupEnabled.
    public var globalSettings: [Swift.String: Swift.String]?
    /// The date and time that the flag isCrossAccountBackupEnabled was last updated. This update is in Unix format and Coordinated Universal Time (UTC). The value of LastUpdateTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastUpdateTime: Foundation.Date?

    public init(
        globalSettings: [Swift.String: Swift.String]? = nil,
        lastUpdateTime: Foundation.Date? = nil
    )
    {
        self.globalSettings = globalSettings
        self.lastUpdateTime = lastUpdateTime
    }
}

public struct DescribeProtectedResourceInput: Swift.Sendable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct DescribeProtectedResourceOutput: Swift.Sendable {
    /// The date and time that a resource was last backed up, in Unix format and Coordinated Universal Time (UTC). The value of LastBackupTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastBackupTime: Foundation.Date?
    /// The ARN (Amazon Resource Name) of the backup vault that contains the most recent backup recovery point.
    public var lastBackupVaultArn: Swift.String?
    /// The ARN (Amazon Resource Name) of the most recent recovery point.
    public var lastRecoveryPointArn: Swift.String?
    /// The time, in minutes, that the most recent restore job took to complete.
    public var latestRestoreExecutionTimeMinutes: Swift.Int?
    /// The creation date of the most recent restore job.
    public var latestRestoreJobCreationDate: Foundation.Date?
    /// The date the most recent recovery point was created.
    public var latestRestoreRecoveryPointCreationDate: Foundation.Date?
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var resourceArn: Swift.String?
    /// The name of the resource that belongs to the specified backup.
    public var resourceName: Swift.String?
    /// The type of Amazon Web Services resource saved as a recovery point; for example, an Amazon EBS volume or an Amazon RDS database.
    public var resourceType: Swift.String?

    public init(
        lastBackupTime: Foundation.Date? = nil,
        lastBackupVaultArn: Swift.String? = nil,
        lastRecoveryPointArn: Swift.String? = nil,
        latestRestoreExecutionTimeMinutes: Swift.Int? = nil,
        latestRestoreJobCreationDate: Foundation.Date? = nil,
        latestRestoreRecoveryPointCreationDate: Foundation.Date? = nil,
        resourceArn: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.lastBackupTime = lastBackupTime
        self.lastBackupVaultArn = lastBackupVaultArn
        self.lastRecoveryPointArn = lastRecoveryPointArn
        self.latestRestoreExecutionTimeMinutes = latestRestoreExecutionTimeMinutes
        self.latestRestoreJobCreationDate = latestRestoreJobCreationDate
        self.latestRestoreRecoveryPointCreationDate = latestRestoreRecoveryPointCreationDate
        self.resourceArn = resourceArn
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

public struct DescribeRecoveryPointInput: Swift.Sendable {
    /// The account ID of the specified backup vault.
    public var backupVaultAccountId: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultAccountId: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultAccountId = backupVaultAccountId
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

extension BackupClientTypes {

    public enum RecoveryPointStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case deleting
        case expired
        case partial
        case sdkUnknown(Swift.String)

        public static var allCases: [RecoveryPointStatus] {
            return [
                .completed,
                .deleting,
                .expired,
                .partial
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .deleting: return "DELETING"
            case .expired: return "EXPIRED"
            case .partial: return "PARTIAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupClientTypes {

    public enum StorageClass: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cold
        case deleted
        case warm
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageClass] {
            return [
                .cold,
                .deleted,
                .warm
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cold: return "COLD"
            case .deleted: return "DELETED"
            case .warm: return "WARM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeRecoveryPointOutput: Swift.Sendable {
    /// The size, in bytes, of a backup.
    public var backupSizeInBytes: Swift.Int?
    /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created.
    public var backupVaultName: Swift.String?
    /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
    public var calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
    /// The date and time that a job to create a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var completionDate: Foundation.Date?
    /// The identifier of a resource within a composite group, such as nested (child) recovery point belonging to a composite (parent) stack. The ID is transferred from the [ logical ID](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html#resources-section-structure-syntax) within a stack.
    public var compositeMemberIdentifier: Swift.String?
    /// Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan used to create it.
    public var createdBy: BackupClientTypes.RecoveryPointCreator?
    /// The date and time that a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: Foundation.Date?
    /// The server-side encryption key used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    public var encryptionKeyArn: Swift.String?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.
    public var isEncrypted: Swift.Bool
    /// This returns the boolean value that a recovery point is a parent (composite) job.
    public var isParent: Swift.Bool
    /// The date and time that a recovery point was last restored, in Unix format and Coordinated Universal Time (UTC). The value of LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastRestoreTime: Foundation.Date?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups that are transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that can transition to cold storage are listed in the [Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/backup-feature-availability.html#features-by-resource) table. Backup ignores this expression for other resource types.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// This is an ARN that uniquely identifies a parent (composite) recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var parentRecoveryPointArn: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// An ARN that uniquely identifies a saved resource. The format of the ARN depends on the resource type.
    public var resourceArn: Swift.String?
    /// The name of the resource that belongs to the specified backup.
    public var resourceName: Swift.String?
    /// The type of Amazon Web Services resource to save as a recovery point; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
    public var resourceType: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies the source vault where the resource was originally backed up in; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault. If the recovery is restored to the same Amazon Web Services account or Region, this value will be null.
    public var sourceBackupVaultArn: Swift.String?
    /// A status code specifying the state of the recovery point. PARTIAL status indicates Backup could not create the recovery point before the backup window closed. To increase your backup plan window using the API, see [UpdateBackupPlan](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_UpdateBackupPlan.html). You can also increase your backup plan window using the Console by choosing and editing your backup plan. EXPIRED status indicates that the recovery point has exceeded its retention period, but Backup lacks permission or is otherwise unable to delete it. To manually delete these recovery points, see [ Step 3: Delete the recovery points](https://docs.aws.amazon.com/aws-backup/latest/devguide/gs-cleanup-resources.html#cleanup-backups) in the Clean up resources section of Getting started. STOPPED status occurs on a continuous backup where a user has taken some action that causes the continuous backup to be disabled. This can be caused by the removal of permissions, turning off versioning, turning off events being sent to EventBridge, or disabling the EventBridge rules that are put in place by Backup. For recovery points of Amazon S3, Amazon RDS, and Amazon Aurora resources, this status occurs when the retention period of a continuous backup rule is changed. To resolve STOPPED status, ensure that all requested permissions are in place and that versioning is enabled on the S3 bucket. Once these conditions are met, the next instance of a backup rule running will result in a new continuous recovery point being created. The recovery points with STOPPED status do not need to be deleted. For SAP HANA on Amazon EC2 STOPPED status occurs due to user action, application misconfiguration, or backup failure. To ensure that future continuous backups succeed, refer to the recovery point status and check SAP HANA for details.
    public var status: BackupClientTypes.RecoveryPointStatus?
    /// A status message explaining the status of the recovery point.
    public var statusMessage: Swift.String?
    /// Specifies the storage class of the recovery point. Valid values are WARM or COLD.
    public var storageClass: BackupClientTypes.StorageClass?
    /// The type of vault in which the described recovery point is stored.
    public var vaultType: BackupClientTypes.VaultType?

    public init(
        backupSizeInBytes: Swift.Int? = nil,
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        calculatedLifecycle: BackupClientTypes.CalculatedLifecycle? = nil,
        completionDate: Foundation.Date? = nil,
        compositeMemberIdentifier: Swift.String? = nil,
        createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
        creationDate: Foundation.Date? = nil,
        encryptionKeyArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        isEncrypted: Swift.Bool = false,
        isParent: Swift.Bool = false,
        lastRestoreTime: Foundation.Date? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        parentRecoveryPointArn: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        sourceBackupVaultArn: Swift.String? = nil,
        status: BackupClientTypes.RecoveryPointStatus? = nil,
        statusMessage: Swift.String? = nil,
        storageClass: BackupClientTypes.StorageClass? = nil,
        vaultType: BackupClientTypes.VaultType? = nil
    )
    {
        self.backupSizeInBytes = backupSizeInBytes
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.calculatedLifecycle = calculatedLifecycle
        self.completionDate = completionDate
        self.compositeMemberIdentifier = compositeMemberIdentifier
        self.createdBy = createdBy
        self.creationDate = creationDate
        self.encryptionKeyArn = encryptionKeyArn
        self.iamRoleArn = iamRoleArn
        self.isEncrypted = isEncrypted
        self.isParent = isParent
        self.lastRestoreTime = lastRestoreTime
        self.lifecycle = lifecycle
        self.parentRecoveryPointArn = parentRecoveryPointArn
        self.recoveryPointArn = recoveryPointArn
        self.resourceArn = resourceArn
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.sourceBackupVaultArn = sourceBackupVaultArn
        self.status = status
        self.statusMessage = statusMessage
        self.storageClass = storageClass
        self.vaultType = vaultType
    }
}

public struct DescribeRegionSettingsInput: Swift.Sendable {

    public init() { }
}

public struct DescribeRegionSettingsOutput: Swift.Sendable {
    /// Returns whether Backup fully manages the backups for a resource type. For the benefits of full Backup management, see [Full Backup management](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#full-management). For a list of resource types and whether each supports full Backup management, see the [Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/backup-feature-availability.html#features-by-resource) table. If "DynamoDB":false, you can enable full Backup management for DynamoDB backup by enabling [ Backup's advanced DynamoDB backup features](https://docs.aws.amazon.com/aws-backup/latest/devguide/advanced-ddb-backup.html#advanced-ddb-backup-enable-cli).
    public var resourceTypeManagementPreference: [Swift.String: Swift.Bool]?
    /// The services along with the opt-in preferences in the Region.
    public var resourceTypeOptInPreference: [Swift.String: Swift.Bool]?

    public init(
        resourceTypeManagementPreference: [Swift.String: Swift.Bool]? = nil,
        resourceTypeOptInPreference: [Swift.String: Swift.Bool]? = nil
    )
    {
        self.resourceTypeManagementPreference = resourceTypeManagementPreference
        self.resourceTypeOptInPreference = resourceTypeOptInPreference
    }
}

public struct DescribeReportJobInput: Swift.Sendable {
    /// The identifier of the report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. The report job ID cannot be edited.
    /// This member is required.
    public var reportJobId: Swift.String?

    public init(
        reportJobId: Swift.String? = nil
    )
    {
        self.reportJobId = reportJobId
    }
}

extension BackupClientTypes {

    /// Contains information from your report job about your report destination.
    public struct ReportDestination: Swift.Sendable {
        /// The unique name of the Amazon S3 bucket that receives your reports.
        public var s3BucketName: Swift.String?
        /// The object key that uniquely identifies your reports in your S3 bucket.
        public var s3Keys: [Swift.String]?

        public init(
            s3BucketName: Swift.String? = nil,
            s3Keys: [Swift.String]? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3Keys = s3Keys
        }
    }
}

extension BackupClientTypes {

    /// Contains detailed information about a report job. A report job compiles a report based on a report plan and publishes it to Amazon S3.
    public struct ReportJob: Swift.Sendable {
        /// The date and time that a report job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionTime: Foundation.Date?
        /// The date and time that a report job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationTime: Foundation.Date?
        /// The S3 bucket name and S3 keys for the destination where the report job publishes the report.
        public var reportDestination: BackupClientTypes.ReportDestination?
        /// The identifier for a report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. Report job IDs cannot be edited.
        public var reportJobId: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var reportPlanArn: Swift.String?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        public var reportTemplate: Swift.String?
        /// The status of a report job. The statuses are: CREATED | RUNNING | COMPLETED | FAILEDCOMPLETED means that the report is available for your review at your designated destination. If the status is FAILED, review the StatusMessage for the reason.
        public var status: Swift.String?
        /// A message explaining the status of the report job.
        public var statusMessage: Swift.String?

        public init(
            completionTime: Foundation.Date? = nil,
            creationTime: Foundation.Date? = nil,
            reportDestination: BackupClientTypes.ReportDestination? = nil,
            reportJobId: Swift.String? = nil,
            reportPlanArn: Swift.String? = nil,
            reportTemplate: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.reportDestination = reportDestination
            self.reportJobId = reportJobId
            self.reportPlanArn = reportPlanArn
            self.reportTemplate = reportTemplate
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct DescribeReportJobOutput: Swift.Sendable {
    /// The information about a report job, including its completion and creation times, report destination, unique report job ID, Amazon Resource Name (ARN), report template, status, and status message.
    public var reportJob: BackupClientTypes.ReportJob?

    public init(
        reportJob: BackupClientTypes.ReportJob? = nil
    )
    {
        self.reportJob = reportJob
    }
}

public struct DescribeReportPlanInput: Swift.Sendable {
    /// The unique name of a report plan.
    /// This member is required.
    public var reportPlanName: Swift.String?

    public init(
        reportPlanName: Swift.String? = nil
    )
    {
        self.reportPlanName = reportPlanName
    }
}

extension BackupClientTypes {

    /// Contains detailed information about a report plan.
    public struct ReportPlan: Swift.Sendable {
        /// The date and time that a report plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationTime: Foundation.Date?
        /// The deployment status of a report plan. The statuses are: CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED
        public var deploymentStatus: Swift.String?
        /// The date and time that a report job associated with this report plan last attempted to run, in Unix format and Coordinated Universal Time (UTC). The value of LastAttemptedExecutionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastAttemptedExecutionTime: Foundation.Date?
        /// The date and time that a report job associated with this report plan last successfully ran, in Unix format and Coordinated Universal Time (UTC). The value of LastSuccessfulExecutionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastSuccessfulExecutionTime: Foundation.Date?
        /// Contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
        public var reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var reportPlanArn: Swift.String?
        /// An optional description of the report plan with a maximum 1,024 characters.
        public var reportPlanDescription: Swift.String?
        /// The unique name of the report plan. This name is between 1 and 256 characters starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public var reportPlanName: Swift.String?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
        public var reportSetting: BackupClientTypes.ReportSetting?

        public init(
            creationTime: Foundation.Date? = nil,
            deploymentStatus: Swift.String? = nil,
            lastAttemptedExecutionTime: Foundation.Date? = nil,
            lastSuccessfulExecutionTime: Foundation.Date? = nil,
            reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel? = nil,
            reportPlanArn: Swift.String? = nil,
            reportPlanDescription: Swift.String? = nil,
            reportPlanName: Swift.String? = nil,
            reportSetting: BackupClientTypes.ReportSetting? = nil
        )
        {
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.lastAttemptedExecutionTime = lastAttemptedExecutionTime
            self.lastSuccessfulExecutionTime = lastSuccessfulExecutionTime
            self.reportDeliveryChannel = reportDeliveryChannel
            self.reportPlanArn = reportPlanArn
            self.reportPlanDescription = reportPlanDescription
            self.reportPlanName = reportPlanName
            self.reportSetting = reportSetting
        }
    }
}

public struct DescribeReportPlanOutput: Swift.Sendable {
    /// Returns details about the report plan that is specified by its name. These details include the report plan's Amazon Resource Name (ARN), description, settings, delivery channel, deployment status, creation time, and last attempted and successful run times.
    public var reportPlan: BackupClientTypes.ReportPlan?

    public init(
        reportPlan: BackupClientTypes.ReportPlan? = nil
    )
    {
        self.reportPlan = reportPlan
    }
}

public struct DescribeRestoreJobInput: Swift.Sendable {
    /// Uniquely identifies the job that restores a recovery point.
    /// This member is required.
    public var restoreJobId: Swift.String?

    public init(
        restoreJobId: Swift.String? = nil
    )
    {
        self.restoreJobId = restoreJobId
    }
}

extension BackupClientTypes {

    /// Contains information about the restore testing plan that Backup used to initiate the restore job.
    public struct RestoreJobCreator: Swift.Sendable {
        /// An Amazon Resource Name (ARN) that uniquely identifies a restore testing plan.
        public var restoreTestingPlanArn: Swift.String?

        public init(
            restoreTestingPlanArn: Swift.String? = nil
        )
        {
            self.restoreTestingPlanArn = restoreTestingPlanArn
        }
    }
}

extension BackupClientTypes {

    public enum RestoreDeletionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleting
        case failed
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [RestoreDeletionStatus] {
            return [
                .deleting,
                .failed,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .successful: return "SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupClientTypes {

    public enum RestoreJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aborted
        case completed
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [RestoreJobStatus] {
            return [
                .aborted,
                .completed,
                .failed,
                .pending,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupClientTypes {

    public enum RestoreValidationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case successful
        case timedOut
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [RestoreValidationStatus] {
            return [
                .failed,
                .successful,
                .timedOut,
                .validating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .successful: return "SUCCESSFUL"
            case .timedOut: return "TIMED_OUT"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeRestoreJobOutput: Swift.Sendable {
    /// Returns the account ID that owns the restore job.
    public var accountId: Swift.String?
    /// The size, in bytes, of the restored resource.
    public var backupSizeInBytes: Swift.Int?
    /// The date and time that a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var completionDate: Foundation.Date?
    /// Contains identifying information about the creation of a restore job.
    public var createdBy: BackupClientTypes.RestoreJobCreator?
    /// The Amazon Resource Name (ARN) of the resource that was created by the restore job. The format of the ARN depends on the resource type of the backed-up resource.
    public var createdResourceArn: Swift.String?
    /// The date and time that a restore job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: Foundation.Date?
    /// The status of the data generated by the restore test.
    public var deletionStatus: BackupClientTypes.RestoreDeletionStatus?
    /// This describes the restore job deletion status.
    public var deletionStatusMessage: Swift.String?
    /// The amount of time in minutes that a job restoring a recovery point is expected to take.
    public var expectedCompletionTimeMinutes: Swift.Int?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// Contains an estimated percentage that is complete of a job at the time the job status was queried.
    public var percentDone: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// The creation date of the recovery point made by the specifed restore job.
    public var recoveryPointCreationDate: Foundation.Date?
    /// Returns metadata associated with a restore job listed by resource type.
    public var resourceType: Swift.String?
    /// Uniquely identifies the job that restores a recovery point.
    public var restoreJobId: Swift.String?
    /// Status code specifying the state of the job that is initiated by Backup to restore a recovery point.
    public var status: BackupClientTypes.RestoreJobStatus?
    /// A message showing the status of a job to restore a recovery point.
    public var statusMessage: Swift.String?
    /// The status of validation run on the indicated restore job.
    public var validationStatus: BackupClientTypes.RestoreValidationStatus?
    /// The status message.
    public var validationStatusMessage: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        backupSizeInBytes: Swift.Int? = nil,
        completionDate: Foundation.Date? = nil,
        createdBy: BackupClientTypes.RestoreJobCreator? = nil,
        createdResourceArn: Swift.String? = nil,
        creationDate: Foundation.Date? = nil,
        deletionStatus: BackupClientTypes.RestoreDeletionStatus? = nil,
        deletionStatusMessage: Swift.String? = nil,
        expectedCompletionTimeMinutes: Swift.Int? = nil,
        iamRoleArn: Swift.String? = nil,
        percentDone: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        recoveryPointCreationDate: Foundation.Date? = nil,
        resourceType: Swift.String? = nil,
        restoreJobId: Swift.String? = nil,
        status: BackupClientTypes.RestoreJobStatus? = nil,
        statusMessage: Swift.String? = nil,
        validationStatus: BackupClientTypes.RestoreValidationStatus? = nil,
        validationStatusMessage: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.backupSizeInBytes = backupSizeInBytes
        self.completionDate = completionDate
        self.createdBy = createdBy
        self.createdResourceArn = createdResourceArn
        self.creationDate = creationDate
        self.deletionStatus = deletionStatus
        self.deletionStatusMessage = deletionStatusMessage
        self.expectedCompletionTimeMinutes = expectedCompletionTimeMinutes
        self.iamRoleArn = iamRoleArn
        self.percentDone = percentDone
        self.recoveryPointArn = recoveryPointArn
        self.recoveryPointCreationDate = recoveryPointCreationDate
        self.resourceType = resourceType
        self.restoreJobId = restoreJobId
        self.status = status
        self.statusMessage = statusMessage
        self.validationStatus = validationStatus
        self.validationStatusMessage = validationStatusMessage
    }
}

public struct DisassociateRecoveryPointInput: Swift.Sendable {
    /// The unique name of an Backup vault.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies an Backup recovery point.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

public struct DisassociateRecoveryPointFromParentInput: Swift.Sendable {
    /// The name of a logical container where the child (nested) recovery point is stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The Amazon Resource Name (ARN) that uniquely identifies the child (nested) recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

public struct ExportBackupPlanTemplateInput: Swift.Sendable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
    }
}

public struct ExportBackupPlanTemplateOutput: Swift.Sendable {
    /// The body of a backup plan template in JSON format. This is a signed JSON document that cannot be modified before being passed to GetBackupPlanFromJSON.
    public var backupPlanTemplateJson: Swift.String?

    public init(
        backupPlanTemplateJson: Swift.String? = nil
    )
    {
        self.backupPlanTemplateJson = backupPlanTemplateJson
    }
}

public struct GetBackupPlanInput: Swift.Sendable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
    public var versionId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.versionId = versionId
    }
}

public struct GetBackupPlanOutput: Swift.Sendable {
    /// Contains a list of BackupOptions for each resource type. The list is populated only if the advanced option is set for the backup plan.
    public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
    /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    public var backupPlan: BackupClientTypes.BackupPlan?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time that a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: Foundation.Date?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
    public var creatorRequestId: Swift.String?
    /// The date and time that a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var deletionDate: Foundation.Date?
    /// The last time this backup plan was run. A date and time, in Unix format and Coordinated Universal Time (UTC). The value of LastExecutionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastExecutionDate: Foundation.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
    public var versionId: Swift.String?

    public init(
        advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
        backupPlan: BackupClientTypes.BackupPlan? = nil,
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        creationDate: Foundation.Date? = nil,
        creatorRequestId: Swift.String? = nil,
        deletionDate: Foundation.Date? = nil,
        lastExecutionDate: Foundation.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlan = backupPlan
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.deletionDate = deletionDate
        self.lastExecutionDate = lastExecutionDate
        self.versionId = versionId
    }
}

public struct GetBackupPlanFromJSONInput: Swift.Sendable {
    /// A customer-supplied backup plan document in JSON format.
    /// This member is required.
    public var backupPlanTemplateJson: Swift.String?

    public init(
        backupPlanTemplateJson: Swift.String? = nil
    )
    {
        self.backupPlanTemplateJson = backupPlanTemplateJson
    }
}

public struct GetBackupPlanFromJSONOutput: Swift.Sendable {
    /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    public var backupPlan: BackupClientTypes.BackupPlan?

    public init(
        backupPlan: BackupClientTypes.BackupPlan? = nil
    )
    {
        self.backupPlan = backupPlan
    }
}

public struct GetBackupPlanFromTemplateInput: Swift.Sendable {
    /// Uniquely identifies a stored backup plan template.
    /// This member is required.
    public var backupPlanTemplateId: Swift.String?

    public init(
        backupPlanTemplateId: Swift.String? = nil
    )
    {
        self.backupPlanTemplateId = backupPlanTemplateId
    }
}

public struct GetBackupPlanFromTemplateOutput: Swift.Sendable {
    /// Returns the body of a backup plan based on the target template, including the name, rules, and backup vault of the plan.
    public var backupPlanDocument: BackupClientTypes.BackupPlan?

    public init(
        backupPlanDocument: BackupClientTypes.BackupPlan? = nil
    )
    {
        self.backupPlanDocument = backupPlanDocument
    }
}

public struct GetBackupSelectionInput: Swift.Sendable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    /// This member is required.
    public var selectionId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.selectionId = selectionId
    }
}

public struct GetBackupSelectionOutput: Swift.Sendable {
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// Specifies the body of a request to assign a set of resources to a backup plan.
    public var backupSelection: BackupClientTypes.BackupSelection?
    /// The date and time a backup selection is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: Foundation.Date?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
    public var creatorRequestId: Swift.String?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    public var selectionId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        backupSelection: BackupClientTypes.BackupSelection? = nil,
        creationDate: Foundation.Date? = nil,
        creatorRequestId: Swift.String? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.backupSelection = backupSelection
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.selectionId = selectionId
    }
}

public struct GetBackupVaultAccessPolicyInput: Swift.Sendable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

public struct GetBackupVaultAccessPolicyOutput: Swift.Sendable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created.
    public var backupVaultName: Swift.String?
    /// The backup vault access policy document in JSON format.
    public var policy: Swift.String?

    public init(
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.policy = policy
    }
}

public struct GetBackupVaultNotificationsInput: Swift.Sendable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

public struct GetBackupVaultNotificationsOutput: Swift.Sendable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// An array of events that indicate the status of jobs to back up resources to the backup vault.
    public var backupVaultEvents: [BackupClientTypes.BackupVaultEvent]?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created.
    public var backupVaultName: Swift.String?
    /// An ARN that uniquely identifies an Amazon Simple Notification Service (Amazon SNS) topic; for example, arn:aws:sns:us-west-2:111122223333:MyTopic.
    public var snsTopicArn: Swift.String?

    public init(
        backupVaultArn: Swift.String? = nil,
        backupVaultEvents: [BackupClientTypes.BackupVaultEvent]? = nil,
        backupVaultName: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultEvents = backupVaultEvents
        self.backupVaultName = backupVaultName
        self.snsTopicArn = snsTopicArn
    }
}

public struct GetLegalHoldInput: Swift.Sendable {
    /// The ID of the legal hold.
    /// This member is required.
    public var legalHoldId: Swift.String?

    public init(
        legalHoldId: Swift.String? = nil
    )
    {
        self.legalHoldId = legalHoldId
    }
}

public struct GetLegalHoldOutput: Swift.Sendable {
    /// The reason for removing the legal hold.
    public var cancelDescription: Swift.String?
    /// The time when the legal hold was cancelled.
    public var cancellationDate: Foundation.Date?
    /// The time when the legal hold was created.
    public var creationDate: Foundation.Date?
    /// The description of the legal hold.
    public var description: Swift.String?
    /// The framework ARN for the specified legal hold. The format of the ARN depends on the resource type.
    public var legalHoldArn: Swift.String?
    /// The ID of the legal hold.
    public var legalHoldId: Swift.String?
    /// The criteria to assign a set of resources, such as resource types or backup vaults.
    public var recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
    /// The date and time until which the legal hold record is retained.
    public var retainRecordUntil: Foundation.Date?
    /// The status of the legal hold.
    public var status: BackupClientTypes.LegalHoldStatus?
    /// The title of the legal hold.
    public var title: Swift.String?

    public init(
        cancelDescription: Swift.String? = nil,
        cancellationDate: Foundation.Date? = nil,
        creationDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        legalHoldArn: Swift.String? = nil,
        legalHoldId: Swift.String? = nil,
        recoveryPointSelection: BackupClientTypes.RecoveryPointSelection? = nil,
        retainRecordUntil: Foundation.Date? = nil,
        status: BackupClientTypes.LegalHoldStatus? = nil,
        title: Swift.String? = nil
    )
    {
        self.cancelDescription = cancelDescription
        self.cancellationDate = cancellationDate
        self.creationDate = creationDate
        self.description = description
        self.legalHoldArn = legalHoldArn
        self.legalHoldId = legalHoldId
        self.recoveryPointSelection = recoveryPointSelection
        self.retainRecordUntil = retainRecordUntil
        self.status = status
        self.title = title
    }
}

public struct GetRecoveryPointRestoreMetadataInput: Swift.Sendable {
    /// The account ID of the specified backup vault.
    public var backupVaultAccountId: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultAccountId: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultAccountId = backupVaultAccountId
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

public struct GetRecoveryPointRestoreMetadataOutput: Swift.Sendable {
    /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// The resource type of the recovery point.
    public var resourceType: Swift.String?
    /// The set of metadata key-value pairs that describe the original configuration of the backed-up resource. These values vary depending on the service that is being restored.
    public var restoreMetadata: [Swift.String: Swift.String]?

    public init(
        backupVaultArn: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        restoreMetadata: [Swift.String: Swift.String]? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.recoveryPointArn = recoveryPointArn
        self.resourceType = resourceType
        self.restoreMetadata = restoreMetadata
    }
}

extension GetRecoveryPointRestoreMetadataOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecoveryPointRestoreMetadataOutput(backupVaultArn: \(Swift.String(describing: backupVaultArn)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), resourceType: \(Swift.String(describing: resourceType)), restoreMetadata: \"CONTENT_REDACTED\")"}
}

public struct GetRestoreJobMetadataInput: Swift.Sendable {
    /// This is a unique identifier of a restore job within Backup.
    /// This member is required.
    public var restoreJobId: Swift.String?

    public init(
        restoreJobId: Swift.String? = nil
    )
    {
        self.restoreJobId = restoreJobId
    }
}

public struct GetRestoreJobMetadataOutput: Swift.Sendable {
    /// This contains the metadata of the specified backup job.
    public var metadata: [Swift.String: Swift.String]?
    /// This is a unique identifier of a restore job within Backup.
    public var restoreJobId: Swift.String?

    public init(
        metadata: [Swift.String: Swift.String]? = nil,
        restoreJobId: Swift.String? = nil
    )
    {
        self.metadata = metadata
        self.restoreJobId = restoreJobId
    }
}

extension GetRestoreJobMetadataOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRestoreJobMetadataOutput(restoreJobId: \(Swift.String(describing: restoreJobId)), metadata: \"CONTENT_REDACTED\")"}
}

public struct GetRestoreTestingInferredMetadataInput: Swift.Sendable {
    /// The account ID of the specified backup vault.
    public var backupVaultAccountId: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web ServicesRegion where they are created. They consist of letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultAccountId: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultAccountId = backupVaultAccountId
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

public struct GetRestoreTestingInferredMetadataOutput: Swift.Sendable {
    /// This is a string map of the metadata inferred from the request.
    /// This member is required.
    public var inferredMetadata: [Swift.String: Swift.String]?

    public init(
        inferredMetadata: [Swift.String: Swift.String]? = nil
    )
    {
        self.inferredMetadata = inferredMetadata
    }
}

public struct GetRestoreTestingPlanInput: Swift.Sendable {
    /// Required unique name of the restore testing plan.
    /// This member is required.
    public var restoreTestingPlanName: Swift.String?

    public init(
        restoreTestingPlanName: Swift.String? = nil
    )
    {
        self.restoreTestingPlanName = restoreTestingPlanName
    }
}

extension BackupClientTypes {

    /// This contains metadata about a restore testing plan.
    public struct RestoreTestingPlanForGet: Swift.Sendable {
        /// The date and time that a restore testing plan was created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// This identifies the request and allows failed requests to be retried without the risk of running the operation twice. If the request includes a CreatorRequestId that matches an existing backup plan, that plan is returned. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public var creatorRequestId: Swift.String?
        /// The last time a restore test was run with the specified restore testing plan. A date and time, in Unix format and Coordinated Universal Time (UTC). The value of LastExecutionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastExecutionTime: Foundation.Date?
        /// The date and time that the restore testing plan was updated. This update is in Unix format and Coordinated Universal Time (UTC). The value of LastUpdateTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastUpdateTime: Foundation.Date?
        /// The specified criteria to assign a set of resources, such as recovery point types or backup vaults.
        /// This member is required.
        public var recoveryPointSelection: BackupClientTypes.RestoreTestingRecoveryPointSelection?
        /// An Amazon Resource Name (ARN) that uniquely identifies a restore testing plan.
        /// This member is required.
        public var restoreTestingPlanArn: Swift.String?
        /// The restore testing plan name.
        /// This member is required.
        public var restoreTestingPlanName: Swift.String?
        /// A CRON expression in specified timezone when a restore testing plan is executed.
        /// This member is required.
        public var scheduleExpression: Swift.String?
        /// Optional. This is the timezone in which the schedule expression is set. By default, ScheduleExpressions are in UTC. You can modify this to a specified timezone.
        public var scheduleExpressionTimezone: Swift.String?
        /// Defaults to 24 hours. A value in hours after a restore test is scheduled before a job will be canceled if it doesn't start successfully. This value is optional. If this value is included, this parameter has a maximum value of 168 hours (one week).
        public var startWindowHours: Swift.Int

        public init(
            creationTime: Foundation.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            lastExecutionTime: Foundation.Date? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            recoveryPointSelection: BackupClientTypes.RestoreTestingRecoveryPointSelection? = nil,
            restoreTestingPlanArn: Swift.String? = nil,
            restoreTestingPlanName: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleExpressionTimezone: Swift.String? = nil,
            startWindowHours: Swift.Int = 0
        )
        {
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.lastExecutionTime = lastExecutionTime
            self.lastUpdateTime = lastUpdateTime
            self.recoveryPointSelection = recoveryPointSelection
            self.restoreTestingPlanArn = restoreTestingPlanArn
            self.restoreTestingPlanName = restoreTestingPlanName
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startWindowHours = startWindowHours
        }
    }
}

public struct GetRestoreTestingPlanOutput: Swift.Sendable {
    /// Specifies the body of a restore testing plan. Includes RestoreTestingPlanName.
    /// This member is required.
    public var restoreTestingPlan: BackupClientTypes.RestoreTestingPlanForGet?

    public init(
        restoreTestingPlan: BackupClientTypes.RestoreTestingPlanForGet? = nil
    )
    {
        self.restoreTestingPlan = restoreTestingPlan
    }
}

public struct GetRestoreTestingSelectionInput: Swift.Sendable {
    /// Required unique name of the restore testing plan.
    /// This member is required.
    public var restoreTestingPlanName: Swift.String?
    /// Required unique name of the restore testing selection.
    /// This member is required.
    public var restoreTestingSelectionName: Swift.String?

    public init(
        restoreTestingPlanName: Swift.String? = nil,
        restoreTestingSelectionName: Swift.String? = nil
    )
    {
        self.restoreTestingPlanName = restoreTestingPlanName
        self.restoreTestingSelectionName = restoreTestingSelectionName
    }
}

extension BackupClientTypes {

    /// This contains metadata about a restore testing selection.
    public struct RestoreTestingSelectionForGet: Swift.Sendable {
        /// The date and time that a restore testing selection was created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 201812:11:30.087 AM.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// This identifies the request and allows failed requests to be retried without the risk of running the operation twice. If the request includes a CreatorRequestId that matches an existing backup plan, that plan is returned. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public var creatorRequestId: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role that Backup uses to create the target resource; for example:arn:aws:iam::123456789012:role/S3Access.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// You can include specific ARNs, such as ProtectedResourceArns: ["arn:aws:...", "arn:aws:..."] or you can include a wildcard: ProtectedResourceArns: ["*"], but not both.
        public var protectedResourceArns: [Swift.String]?
        /// In a resource testing selection, this parameter filters by specific conditions such as StringEquals or StringNotEquals.
        public var protectedResourceConditions: BackupClientTypes.ProtectedResourceConditions?
        /// The type of Amazon Web Services resource included in a resource testing selection; for example, an Amazon EBS volume or an Amazon RDS database.
        /// This member is required.
        public var protectedResourceType: Swift.String?
        /// You can override certain restore metadata keys by including the parameter RestoreMetadataOverrides in the body of RestoreTestingSelection. Key values are not case sensitive. See the complete list of [restore testing inferred metadata](https://docs.aws.amazon.com/aws-backup/latest/devguide/restore-testing-inferred-metadata.html).
        public var restoreMetadataOverrides: [Swift.String: Swift.String]?
        /// The RestoreTestingPlanName is a unique string that is the name of the restore testing plan.
        /// This member is required.
        public var restoreTestingPlanName: Swift.String?
        /// The unique name of the restore testing selection that belongs to the related restore testing plan.
        /// This member is required.
        public var restoreTestingSelectionName: Swift.String?
        /// This is amount of hours (1 to 168) available to run a validation script on the data. The data will be deleted upon the completion of the validation script or the end of the specified retention period, whichever comes first.
        public var validationWindowHours: Swift.Int

        public init(
            creationTime: Foundation.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            protectedResourceArns: [Swift.String]? = nil,
            protectedResourceConditions: BackupClientTypes.ProtectedResourceConditions? = nil,
            protectedResourceType: Swift.String? = nil,
            restoreMetadataOverrides: [Swift.String: Swift.String]? = nil,
            restoreTestingPlanName: Swift.String? = nil,
            restoreTestingSelectionName: Swift.String? = nil,
            validationWindowHours: Swift.Int = 0
        )
        {
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.iamRoleArn = iamRoleArn
            self.protectedResourceArns = protectedResourceArns
            self.protectedResourceConditions = protectedResourceConditions
            self.protectedResourceType = protectedResourceType
            self.restoreMetadataOverrides = restoreMetadataOverrides
            self.restoreTestingPlanName = restoreTestingPlanName
            self.restoreTestingSelectionName = restoreTestingSelectionName
            self.validationWindowHours = validationWindowHours
        }
    }
}

extension BackupClientTypes.RestoreTestingSelectionForGet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreTestingSelectionForGet(creationTime: \(Swift.String(describing: creationTime)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), protectedResourceArns: \(Swift.String(describing: protectedResourceArns)), protectedResourceConditions: \(Swift.String(describing: protectedResourceConditions)), protectedResourceType: \(Swift.String(describing: protectedResourceType)), restoreTestingPlanName: \(Swift.String(describing: restoreTestingPlanName)), restoreTestingSelectionName: \(Swift.String(describing: restoreTestingSelectionName)), validationWindowHours: \(Swift.String(describing: validationWindowHours)), restoreMetadataOverrides: \"CONTENT_REDACTED\")"}
}

public struct GetRestoreTestingSelectionOutput: Swift.Sendable {
    /// Unique name of the restore testing selection.
    /// This member is required.
    public var restoreTestingSelection: BackupClientTypes.RestoreTestingSelectionForGet?

    public init(
        restoreTestingSelection: BackupClientTypes.RestoreTestingSelectionForGet? = nil
    )
    {
        self.restoreTestingSelection = restoreTestingSelection
    }
}

public struct GetSupportedResourceTypesOutput: Swift.Sendable {
    /// Contains a string with the supported Amazon Web Services resource types:
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * CloudFormation for CloudFormation
    ///
    /// * DocumentDB for Amazon DocumentDB (with MongoDB compatibility)
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * FSx for Amazon FSx
    ///
    /// * Neptune for Amazon Neptune
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Redshift for Amazon Redshift
    ///
    /// * S3 for Amazon Simple Storage Service (Amazon S3)
    ///
    /// * SAP HANA on Amazon EC2 for SAP HANA databases on Amazon Elastic Compute Cloud instances
    ///
    /// * Storage Gateway for Storage Gateway
    ///
    /// * Timestream for Amazon Timestream
    ///
    /// * VirtualMachine for VMware virtual machines
    public var resourceTypes: [Swift.String]?

    public init(
        resourceTypes: [Swift.String]? = nil
    )
    {
        self.resourceTypes = resourceTypes
    }
}

public struct ListBackupJobsInput: Swift.Sendable {
    /// The account ID to list the jobs from. Returns only backup jobs associated with the specified account ID. If used from an Organizations management account, passing * returns all jobs across the organization.
    public var byAccountId: Swift.String?
    /// Returns only backup jobs that will be stored in the specified backup vault. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    public var byBackupVaultName: Swift.String?
    /// Returns only backup jobs completed after a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteAfter: Foundation.Date?
    /// Returns only backup jobs completed before a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteBefore: Foundation.Date?
    /// Returns only backup jobs that were created after the specified date.
    public var byCreatedAfter: Foundation.Date?
    /// Returns only backup jobs that were created before the specified date.
    public var byCreatedBefore: Foundation.Date?
    /// This is an optional parameter that can be used to filter out jobs with a MessageCategory which matches the value you input. Example strings may include AccessDenied, SUCCESS, AGGREGATE_ALL, and InvalidParameters. View [Monitoring](https://docs.aws.amazon.com/aws-backup/latest/devguide/monitoring.html) The wildcard () returns count of all message categories. AGGREGATE_ALL aggregates job counts for all message categories and returns the sum.
    public var byMessageCategory: Swift.String?
    /// This is a filter to list child (nested) jobs based on parent job ID.
    public var byParentJobId: Swift.String?
    /// Returns only backup jobs that match the specified resource Amazon Resource Name (ARN).
    public var byResourceArn: Swift.String?
    /// Returns only backup jobs for the specified resources:
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * CloudFormation for CloudFormation
    ///
    /// * DocumentDB for Amazon DocumentDB (with MongoDB compatibility)
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * FSx for Amazon FSx
    ///
    /// * Neptune for Amazon Neptune
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Redshift for Amazon Redshift
    ///
    /// * S3 for Amazon Simple Storage Service (Amazon S3)
    ///
    /// * SAP HANA on Amazon EC2 for SAP HANA databases on Amazon Elastic Compute Cloud instances
    ///
    /// * Storage Gateway for Storage Gateway
    ///
    /// * Timestream for Amazon Timestream
    ///
    /// * VirtualMachine for VMware virtual machines
    public var byResourceType: Swift.String?
    /// Returns only backup jobs that are in the specified state. Completed with issues is a status found only in the Backup console. For API, this status refers to jobs with a state of COMPLETED and a MessageCategory with a value other than SUCCESS; that is, the status is completed but comes with a status message. To obtain the job count for Completed with issues, run two GET requests, and subtract the second, smaller number: GET /backup-jobs/?state=COMPLETED GET /backup-jobs/?messageCategory=SUCCESS&state=COMPLETED
    public var byState: BackupClientTypes.BackupJobState?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        byAccountId: Swift.String? = nil,
        byBackupVaultName: Swift.String? = nil,
        byCompleteAfter: Foundation.Date? = nil,
        byCompleteBefore: Foundation.Date? = nil,
        byCreatedAfter: Foundation.Date? = nil,
        byCreatedBefore: Foundation.Date? = nil,
        byMessageCategory: Swift.String? = nil,
        byParentJobId: Swift.String? = nil,
        byResourceArn: Swift.String? = nil,
        byResourceType: Swift.String? = nil,
        byState: BackupClientTypes.BackupJobState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byBackupVaultName = byBackupVaultName
        self.byCompleteAfter = byCompleteAfter
        self.byCompleteBefore = byCompleteBefore
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byMessageCategory = byMessageCategory
        self.byParentJobId = byParentJobId
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.byState = byState
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListBackupJobsOutput: Swift.Sendable {
    /// An array of structures containing metadata about your backup jobs returned in JSON format.
    public var backupJobs: [BackupClientTypes.BackupJob]?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupJobs: [BackupClientTypes.BackupJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupJobs = backupJobs
        self.nextToken = nextToken
    }
}

public struct ListBackupJobSummariesInput: Swift.Sendable {
    /// Returns the job count for the specified account. If the request is sent from a member account or an account not part of Amazon Web Services Organizations, jobs within requestor's account will be returned. Root, admin, and delegated administrator accounts can use the value ANY to return job counts from every account in the organization. AGGREGATE_ALL aggregates job counts from all accounts within the authenticated organization, then returns the sum.
    public var accountId: Swift.String?
    /// The period for the returned results.
    ///
    /// * ONE_DAY - The daily job count for the prior 14 days.
    ///
    /// * SEVEN_DAYS - The aggregated job count for the prior 7 days.
    ///
    /// * FOURTEEN_DAYS - The aggregated job count for prior 14 days.
    public var aggregationPeriod: BackupClientTypes.AggregationPeriod?
    /// The maximum number of items to be returned. The value is an integer. Range of accepted values is from 1 to 500.
    public var maxResults: Swift.Int?
    /// This parameter returns the job count for the specified message category. Example accepted strings include AccessDenied, Success, and InvalidParameters. See [Monitoring](https://docs.aws.amazon.com/aws-backup/latest/devguide/monitoring.html) for a list of accepted MessageCategory strings. The the value ANY returns count of all message categories. AGGREGATE_ALL aggregates job counts for all message categories and returns the sum.
    public var messageCategory: Swift.String?
    /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// Returns the job count for the specified resource type. Use request GetSupportedResourceTypes to obtain strings for supported resource types. The the value ANY returns count of all resource types. AGGREGATE_ALL aggregates job counts for all resource types and returns the sum. The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
    public var resourceType: Swift.String?
    /// This parameter returns the job count for jobs with the specified state. The the value ANY returns count of all states. AGGREGATE_ALL aggregates job counts for all states and returns the sum. Completed with issues is a status found only in the Backup console. For API, this status refers to jobs with a state of COMPLETED and a MessageCategory with a value other than SUCCESS; that is, the status is completed but comes with a status message. To obtain the job count for Completed with issues, run two GET requests, and subtract the second, smaller number: GET /audit/backup-job-summaries?AggregationPeriod=FOURTEEN_DAYS&State=COMPLETED GET /audit/backup-job-summaries?AggregationPeriod=FOURTEEN_DAYS&MessageCategory=SUCCESS&State=COMPLETED
    public var state: BackupClientTypes.BackupJobStatus?

    public init(
        accountId: Swift.String? = nil,
        aggregationPeriod: BackupClientTypes.AggregationPeriod? = nil,
        maxResults: Swift.Int? = nil,
        messageCategory: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        state: BackupClientTypes.BackupJobStatus? = nil
    )
    {
        self.accountId = accountId
        self.aggregationPeriod = aggregationPeriod
        self.maxResults = maxResults
        self.messageCategory = messageCategory
        self.nextToken = nextToken
        self.resourceType = resourceType
        self.state = state
    }
}

public struct ListBackupJobSummariesOutput: Swift.Sendable {
    /// The period for the returned results.
    ///
    /// * ONE_DAY - The daily job count for the prior 14 days.
    ///
    /// * SEVEN_DAYS - The aggregated job count for the prior 7 days.
    ///
    /// * FOURTEEN_DAYS - The aggregated job count for prior 14 days.
    public var aggregationPeriod: Swift.String?
    /// The summary information.
    public var backupJobSummaries: [BackupClientTypes.BackupJobSummary]?
    /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        aggregationPeriod: Swift.String? = nil,
        backupJobSummaries: [BackupClientTypes.BackupJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregationPeriod = aggregationPeriod
        self.backupJobSummaries = backupJobSummaries
        self.nextToken = nextToken
    }
}

public struct ListBackupPlansInput: Swift.Sendable {
    /// A Boolean value with a default value of FALSE that returns deleted backup plans when set to TRUE.
    public var includeDeleted: Swift.Bool?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        includeDeleted: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.includeDeleted = includeDeleted
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListBackupPlansOutput: Swift.Sendable {
    /// Information about the backup plans.
    public var backupPlansList: [BackupClientTypes.BackupPlansListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupPlansList: [BackupClientTypes.BackupPlansListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlansList = backupPlansList
        self.nextToken = nextToken
    }
}

public struct ListBackupPlanTemplatesInput: Swift.Sendable {
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListBackupPlanTemplatesOutput: Swift.Sendable {
    /// An array of template list items containing metadata about your saved templates.
    public var backupPlanTemplatesList: [BackupClientTypes.BackupPlanTemplatesListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupPlanTemplatesList: [BackupClientTypes.BackupPlanTemplatesListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanTemplatesList = backupPlanTemplatesList
        self.nextToken = nextToken
    }
}

public struct ListBackupPlanVersionsInput: Swift.Sendable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListBackupPlanVersionsOutput: Swift.Sendable {
    /// An array of version list items containing metadata about your backup plans.
    public var backupPlanVersionsList: [BackupClientTypes.BackupPlansListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupPlanVersionsList: [BackupClientTypes.BackupPlansListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanVersionsList = backupPlanVersionsList
        self.nextToken = nextToken
    }
}

public struct ListBackupSelectionsInput: Swift.Sendable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListBackupSelectionsOutput: Swift.Sendable {
    /// An array of backup selection list items containing metadata about each resource in the list.
    public var backupSelectionsList: [BackupClientTypes.BackupSelectionsListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupSelectionsList: [BackupClientTypes.BackupSelectionsListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupSelectionsList = backupSelectionsList
        self.nextToken = nextToken
    }
}

public struct ListBackupVaultsInput: Swift.Sendable {
    /// This parameter will sort the list of vaults by shared vaults.
    public var byShared: Swift.Bool?
    /// This parameter will sort the list of vaults by vault type.
    public var byVaultType: BackupClientTypes.VaultType?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        byShared: Swift.Bool? = false,
        byVaultType: BackupClientTypes.VaultType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byShared = byShared
        self.byVaultType = byVaultType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListBackupVaultsOutput: Swift.Sendable {
    /// An array of backup vault list members containing vault metadata, including Amazon Resource Name (ARN), display name, creation date, number of saved recovery points, and encryption information if the resources saved in the backup vault are encrypted.
    public var backupVaultList: [BackupClientTypes.BackupVaultListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupVaultList: [BackupClientTypes.BackupVaultListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupVaultList = backupVaultList
        self.nextToken = nextToken
    }
}

public struct ListCopyJobsInput: Swift.Sendable {
    /// The account ID to list the jobs from. Returns only copy jobs associated with the specified account ID.
    public var byAccountId: Swift.String?
    /// Returns only copy jobs completed after a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteAfter: Foundation.Date?
    /// Returns only copy jobs completed before a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteBefore: Foundation.Date?
    /// Returns only copy jobs that were created after the specified date.
    public var byCreatedAfter: Foundation.Date?
    /// Returns only copy jobs that were created before the specified date.
    public var byCreatedBefore: Foundation.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a source backup vault to copy from; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
    public var byDestinationVaultArn: Swift.String?
    /// This is an optional parameter that can be used to filter out jobs with a MessageCategory which matches the value you input. Example strings may include AccessDenied, SUCCESS, AGGREGATE_ALL, and INVALIDPARAMETERS. View [Monitoring](https://docs.aws.amazon.com/aws-backup/latest/devguide/monitoring.html) for a list of accepted strings. The the value ANY returns count of all message categories. AGGREGATE_ALL aggregates job counts for all message categories and returns the sum.
    public var byMessageCategory: Swift.String?
    /// This is a filter to list child (nested) jobs based on parent job ID.
    public var byParentJobId: Swift.String?
    /// Returns only copy jobs that match the specified resource Amazon Resource Name (ARN).
    public var byResourceArn: Swift.String?
    /// Returns only backup jobs for the specified resources:
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * CloudFormation for CloudFormation
    ///
    /// * DocumentDB for Amazon DocumentDB (with MongoDB compatibility)
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * FSx for Amazon FSx
    ///
    /// * Neptune for Amazon Neptune
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Redshift for Amazon Redshift
    ///
    /// * S3 for Amazon Simple Storage Service (Amazon S3)
    ///
    /// * SAP HANA on Amazon EC2 for SAP HANA databases on Amazon Elastic Compute Cloud instances
    ///
    /// * Storage Gateway for Storage Gateway
    ///
    /// * Timestream for Amazon Timestream
    ///
    /// * VirtualMachine for VMware virtual machines
    public var byResourceType: Swift.String?
    /// Returns only copy jobs that are in the specified state.
    public var byState: BackupClientTypes.CopyJobState?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        byAccountId: Swift.String? = nil,
        byCompleteAfter: Foundation.Date? = nil,
        byCompleteBefore: Foundation.Date? = nil,
        byCreatedAfter: Foundation.Date? = nil,
        byCreatedBefore: Foundation.Date? = nil,
        byDestinationVaultArn: Swift.String? = nil,
        byMessageCategory: Swift.String? = nil,
        byParentJobId: Swift.String? = nil,
        byResourceArn: Swift.String? = nil,
        byResourceType: Swift.String? = nil,
        byState: BackupClientTypes.CopyJobState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byCompleteAfter = byCompleteAfter
        self.byCompleteBefore = byCompleteBefore
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byDestinationVaultArn = byDestinationVaultArn
        self.byMessageCategory = byMessageCategory
        self.byParentJobId = byParentJobId
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.byState = byState
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCopyJobsOutput: Swift.Sendable {
    /// An array of structures containing metadata about your copy jobs returned in JSON format.
    public var copyJobs: [BackupClientTypes.CopyJob]?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        copyJobs: [BackupClientTypes.CopyJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.copyJobs = copyJobs
        self.nextToken = nextToken
    }
}

public struct ListCopyJobSummariesInput: Swift.Sendable {
    /// Returns the job count for the specified account. If the request is sent from a member account or an account not part of Amazon Web Services Organizations, jobs within requestor's account will be returned. Root, admin, and delegated administrator accounts can use the value ANY to return job counts from every account in the organization. AGGREGATE_ALL aggregates job counts from all accounts within the authenticated organization, then returns the sum.
    public var accountId: Swift.String?
    /// The period for the returned results.
    ///
    /// * ONE_DAY - The daily job count for the prior 14 days.
    ///
    /// * SEVEN_DAYS - The aggregated job count for the prior 7 days.
    ///
    /// * FOURTEEN_DAYS - The aggregated job count for prior 14 days.
    public var aggregationPeriod: BackupClientTypes.AggregationPeriod?
    /// This parameter sets the maximum number of items to be returned. The value is an integer. Range of accepted values is from 1 to 500.
    public var maxResults: Swift.Int?
    /// This parameter returns the job count for the specified message category. Example accepted strings include AccessDenied, Success, and InvalidParameters. See [Monitoring](https://docs.aws.amazon.com/aws-backup/latest/devguide/monitoring.html) for a list of accepted MessageCategory strings. The the value ANY returns count of all message categories. AGGREGATE_ALL aggregates job counts for all message categories and returns the sum.
    public var messageCategory: Swift.String?
    /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// Returns the job count for the specified resource type. Use request GetSupportedResourceTypes to obtain strings for supported resource types. The the value ANY returns count of all resource types. AGGREGATE_ALL aggregates job counts for all resource types and returns the sum. The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
    public var resourceType: Swift.String?
    /// This parameter returns the job count for jobs with the specified state. The the value ANY returns count of all states. AGGREGATE_ALL aggregates job counts for all states and returns the sum.
    public var state: BackupClientTypes.CopyJobStatus?

    public init(
        accountId: Swift.String? = nil,
        aggregationPeriod: BackupClientTypes.AggregationPeriod? = nil,
        maxResults: Swift.Int? = nil,
        messageCategory: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        state: BackupClientTypes.CopyJobStatus? = nil
    )
    {
        self.accountId = accountId
        self.aggregationPeriod = aggregationPeriod
        self.maxResults = maxResults
        self.messageCategory = messageCategory
        self.nextToken = nextToken
        self.resourceType = resourceType
        self.state = state
    }
}

public struct ListCopyJobSummariesOutput: Swift.Sendable {
    /// The period for the returned results.
    ///
    /// * ONE_DAY - The daily job count for the prior 14 days.
    ///
    /// * SEVEN_DAYS - The aggregated job count for the prior 7 days.
    ///
    /// * FOURTEEN_DAYS - The aggregated job count for prior 14 days.
    public var aggregationPeriod: Swift.String?
    /// This return shows a summary that contains Region, Account, State, ResourceType, MessageCategory, StartTime, EndTime, and Count of included jobs.
    public var copyJobSummaries: [BackupClientTypes.CopyJobSummary]?
    /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        aggregationPeriod: Swift.String? = nil,
        copyJobSummaries: [BackupClientTypes.CopyJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregationPeriod = aggregationPeriod
        self.copyJobSummaries = copyJobSummaries
        self.nextToken = nextToken
    }
}

public struct ListFrameworksInput: Swift.Sendable {
    /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BackupClientTypes {

    /// Contains detailed information about a framework. Frameworks contain controls, which evaluate and report on your backup events and resources. Frameworks generate daily compliance results.
    public struct Framework: Swift.Sendable {
        /// The date and time that a framework is created, in ISO 8601 representation. The value of CreationTime is accurate to milliseconds. For example, 2020-07-10T15:00:00.000-08:00 represents the 10th of July 2020 at 3:00 PM 8 hours behind UTC.
        public var creationTime: Foundation.Date?
        /// The deployment status of a framework. The statuses are: CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED | FAILED
        public var deploymentStatus: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var frameworkArn: Swift.String?
        /// An optional description of the framework with a maximum 1,024 characters.
        public var frameworkDescription: Swift.String?
        /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public var frameworkName: Swift.String?
        /// The number of controls contained by the framework.
        public var numberOfControls: Swift.Int

        public init(
            creationTime: Foundation.Date? = nil,
            deploymentStatus: Swift.String? = nil,
            frameworkArn: Swift.String? = nil,
            frameworkDescription: Swift.String? = nil,
            frameworkName: Swift.String? = nil,
            numberOfControls: Swift.Int = 0
        )
        {
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.frameworkArn = frameworkArn
            self.frameworkDescription = frameworkDescription
            self.frameworkName = frameworkName
            self.numberOfControls = numberOfControls
        }
    }
}

public struct ListFrameworksOutput: Swift.Sendable {
    /// The frameworks with details for each framework, including the framework name, Amazon Resource Name (ARN), description, number of controls, creation time, and deployment status.
    public var frameworks: [BackupClientTypes.Framework]?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        frameworks: [BackupClientTypes.Framework]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.frameworks = frameworks
        self.nextToken = nextToken
    }
}

public struct ListLegalHoldsInput: Swift.Sendable {
    /// The maximum number of resource list items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BackupClientTypes {

    /// A legal hold is an administrative tool that helps prevent backups from being deleted while under a hold. While the hold is in place, backups under a hold cannot be deleted and lifecycle policies that would alter the backup status (such as transition to cold storage) are delayed until the legal hold is removed. A backup can have more than one legal hold. Legal holds are applied to one or more backups (also known as recovery points). These backups can be filtered by resource types and by resource IDs.
    public struct LegalHold: Swift.Sendable {
        /// The time when the legal hold was cancelled.
        public var cancellationDate: Foundation.Date?
        /// The time when the legal hold was created.
        public var creationDate: Foundation.Date?
        /// The description of a legal hold.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the legal hold; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var legalHoldArn: Swift.String?
        /// The ID of the legal hold.
        public var legalHoldId: Swift.String?
        /// The status of the legal hold.
        public var status: BackupClientTypes.LegalHoldStatus?
        /// The title of a legal hold.
        public var title: Swift.String?

        public init(
            cancellationDate: Foundation.Date? = nil,
            creationDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            legalHoldArn: Swift.String? = nil,
            legalHoldId: Swift.String? = nil,
            status: BackupClientTypes.LegalHoldStatus? = nil,
            title: Swift.String? = nil
        )
        {
            self.cancellationDate = cancellationDate
            self.creationDate = creationDate
            self.description = description
            self.legalHoldArn = legalHoldArn
            self.legalHoldId = legalHoldId
            self.status = status
            self.title = title
        }
    }
}

public struct ListLegalHoldsOutput: Swift.Sendable {
    /// This is an array of returned legal holds, both active and previous.
    public var legalHolds: [BackupClientTypes.LegalHold]?
    /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        legalHolds: [BackupClientTypes.LegalHold]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.legalHolds = legalHolds
        self.nextToken = nextToken
    }
}

public struct ListProtectedResourcesInput: Swift.Sendable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BackupClientTypes {

    /// A structure that contains information about a backed-up resource.
    public struct ProtectedResource: Swift.Sendable {
        /// The date and time a resource was last backed up, in Unix format and Coordinated Universal Time (UTC). The value of LastBackupTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastBackupTime: Foundation.Date?
        /// The ARN (Amazon Resource Name) of the backup vault that contains the most recent backup recovery point.
        public var lastBackupVaultArn: Swift.String?
        /// The ARN (Amazon Resource Name) of the most recent recovery point.
        public var lastRecoveryPointArn: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var resourceArn: Swift.String?
        /// The non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?

        public init(
            lastBackupTime: Foundation.Date? = nil,
            lastBackupVaultArn: Swift.String? = nil,
            lastRecoveryPointArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.lastBackupTime = lastBackupTime
            self.lastBackupVaultArn = lastBackupVaultArn
            self.lastRecoveryPointArn = lastRecoveryPointArn
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
        }
    }
}

public struct ListProtectedResourcesOutput: Swift.Sendable {
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of resources successfully backed up by Backup including the time the resource was saved, an Amazon Resource Name (ARN) of the resource, and a resource type.
    public var results: [BackupClientTypes.ProtectedResource]?

    public init(
        nextToken: Swift.String? = nil,
        results: [BackupClientTypes.ProtectedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

public struct ListProtectedResourcesByBackupVaultInput: Swift.Sendable {
    /// The list of protected resources by backup vault within the vault(s) you specify by account ID.
    public var backupVaultAccountId: Swift.String?
    /// The list of protected resources by backup vault within the vault(s) you specify by name.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupVaultAccountId: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupVaultAccountId = backupVaultAccountId
        self.backupVaultName = backupVaultName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListProtectedResourcesByBackupVaultOutput: Swift.Sendable {
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// These are the results returned for the request ListProtectedResourcesByBackupVault.
    public var results: [BackupClientTypes.ProtectedResource]?

    public init(
        nextToken: Swift.String? = nil,
        results: [BackupClientTypes.ProtectedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

public struct ListRecoveryPointsByBackupVaultInput: Swift.Sendable {
    /// This parameter will sort the list of recovery points by account ID.
    public var backupVaultAccountId: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. Backup vault name might not be available when a supported service creates the backup.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// Returns only recovery points that match the specified backup plan ID.
    public var byBackupPlanId: Swift.String?
    /// Returns only recovery points that were created after the specified timestamp.
    public var byCreatedAfter: Foundation.Date?
    /// Returns only recovery points that were created before the specified timestamp.
    public var byCreatedBefore: Foundation.Date?
    /// This returns only recovery points that match the specified parent (composite) recovery point Amazon Resource Name (ARN).
    public var byParentRecoveryPointArn: Swift.String?
    /// Returns only recovery points that match the specified resource Amazon Resource Name (ARN).
    public var byResourceArn: Swift.String?
    /// Returns only recovery points that match the specified resource type(s):
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * CloudFormation for CloudFormation
    ///
    /// * DocumentDB for Amazon DocumentDB (with MongoDB compatibility)
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * FSx for Amazon FSx
    ///
    /// * Neptune for Amazon Neptune
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Redshift for Amazon Redshift
    ///
    /// * S3 for Amazon Simple Storage Service (Amazon S3)
    ///
    /// * SAP HANA on Amazon EC2 for SAP HANA databases on Amazon Elastic Compute Cloud instances
    ///
    /// * Storage Gateway for Storage Gateway
    ///
    /// * Timestream for Amazon Timestream
    ///
    /// * VirtualMachine for VMware virtual machines
    public var byResourceType: Swift.String?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupVaultAccountId: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        byBackupPlanId: Swift.String? = nil,
        byCreatedAfter: Foundation.Date? = nil,
        byCreatedBefore: Foundation.Date? = nil,
        byParentRecoveryPointArn: Swift.String? = nil,
        byResourceArn: Swift.String? = nil,
        byResourceType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupVaultAccountId = backupVaultAccountId
        self.backupVaultName = backupVaultName
        self.byBackupPlanId = byBackupPlanId
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byParentRecoveryPointArn = byParentRecoveryPointArn
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BackupClientTypes {

    /// Contains detailed information about the recovery points stored in a backup vault.
    public struct RecoveryPointByBackupVault: Swift.Sendable {
        /// The size, in bytes, of a backup.
        public var backupSizeInBytes: Swift.Int?
        /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public var backupVaultName: Swift.String?
        /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
        public var calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
        /// The date and time a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: Foundation.Date?
        /// The identifier of a resource within a composite group, such as nested (child) recovery point belonging to a composite (parent) stack. The ID is transferred from the [ logical ID](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html#resources-section-structure-syntax) within a stack.
        public var compositeMemberIdentifier: Swift.String?
        /// Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan that is used to create it.
        public var createdBy: BackupClientTypes.RecoveryPointCreator?
        /// The date and time a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: Foundation.Date?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public var encryptionKeyArn: Swift.String?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.
        public var isEncrypted: Swift.Bool
        /// This is a boolean value indicating this is a parent (composite) recovery point.
        public var isParent: Swift.Bool
        /// The date and time a recovery point was last restored, in Unix format and Coordinated Universal Time (UTC). The value of LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastRestoreTime: Foundation.Date?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that can transition to cold storage are listed in the [Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/backup-feature-availability.html#features-by-resource) table. Backup ignores this expression for other resource types.
        public var lifecycle: BackupClientTypes.Lifecycle?
        /// The Amazon Resource Name (ARN) of the parent (composite) recovery point.
        public var parentRecoveryPointArn: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var resourceArn: Swift.String?
        /// The non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource saved as a recovery point; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?
        /// The backup vault where the recovery point was originally copied from. If the recovery point is restored to the same account this value will be null.
        public var sourceBackupVaultArn: Swift.String?
        /// A status code specifying the state of the recovery point.
        public var status: BackupClientTypes.RecoveryPointStatus?
        /// A message explaining the current status of the recovery point.
        public var statusMessage: Swift.String?
        /// The type of vault in which the described recovery point is stored.
        public var vaultType: BackupClientTypes.VaultType?

        public init(
            backupSizeInBytes: Swift.Int? = nil,
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            calculatedLifecycle: BackupClientTypes.CalculatedLifecycle? = nil,
            completionDate: Foundation.Date? = nil,
            compositeMemberIdentifier: Swift.String? = nil,
            createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
            creationDate: Foundation.Date? = nil,
            encryptionKeyArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            isEncrypted: Swift.Bool = false,
            isParent: Swift.Bool = false,
            lastRestoreTime: Foundation.Date? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil,
            parentRecoveryPointArn: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            sourceBackupVaultArn: Swift.String? = nil,
            status: BackupClientTypes.RecoveryPointStatus? = nil,
            statusMessage: Swift.String? = nil,
            vaultType: BackupClientTypes.VaultType? = nil
        )
        {
            self.backupSizeInBytes = backupSizeInBytes
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.calculatedLifecycle = calculatedLifecycle
            self.completionDate = completionDate
            self.compositeMemberIdentifier = compositeMemberIdentifier
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.iamRoleArn = iamRoleArn
            self.isEncrypted = isEncrypted
            self.isParent = isParent
            self.lastRestoreTime = lastRestoreTime
            self.lifecycle = lifecycle
            self.parentRecoveryPointArn = parentRecoveryPointArn
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.status = status
            self.statusMessage = statusMessage
            self.vaultType = vaultType
        }
    }
}

public struct ListRecoveryPointsByBackupVaultOutput: Swift.Sendable {
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of objects that contain detailed information about recovery points saved in a backup vault.
    public var recoveryPoints: [BackupClientTypes.RecoveryPointByBackupVault]?

    public init(
        nextToken: Swift.String? = nil,
        recoveryPoints: [BackupClientTypes.RecoveryPointByBackupVault]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

public struct ListRecoveryPointsByLegalHoldInput: Swift.Sendable {
    /// The ID of the legal hold.
    /// This member is required.
    public var legalHoldId: Swift.String?
    /// The maximum number of resource list items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        legalHoldId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.legalHoldId = legalHoldId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BackupClientTypes {

    /// This is a recovery point which is a child (nested) recovery point of a parent (composite) recovery point. These recovery points can be disassociated from their parent (composite) recovery point, in which case they will no longer be a member.
    public struct RecoveryPointMember: Swift.Sendable {
        /// The name of the backup vault (the logical container in which backups are stored).
        public var backupVaultName: Swift.String?
        /// The Amazon Resource Name (ARN) of the parent (composite) recovery point.
        public var recoveryPointArn: Swift.String?
        /// The Amazon Resource Name (ARN) that uniquely identifies a saved resource.
        public var resourceArn: Swift.String?
        /// The Amazon Web Services resource type that is saved as a recovery point.
        public var resourceType: Swift.String?

        public init(
            backupVaultName: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.backupVaultName = backupVaultName
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }
    }
}

public struct ListRecoveryPointsByLegalHoldOutput: Swift.Sendable {
    /// The next item following a partial list of returned resources.
    public var nextToken: Swift.String?
    /// The recovery points.
    public var recoveryPoints: [BackupClientTypes.RecoveryPointMember]?

    public init(
        nextToken: Swift.String? = nil,
        recoveryPoints: [BackupClientTypes.RecoveryPointMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

public struct ListRecoveryPointsByResourceInput: Swift.Sendable {
    /// This attribute filters recovery points based on ownership. If this is set to TRUE, the response will contain recovery points associated with the selected resources that are managed by Backup. If this is set to FALSE, the response will contain all recovery points associated with the selected resource. Type: Boolean
    public var managedByAWSBackupOnly: Swift.Bool?
    /// The maximum number of items to be returned. Amazon RDS requires a value of at least 20.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        managedByAWSBackupOnly: Swift.Bool? = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.managedByAWSBackupOnly = managedByAWSBackupOnly
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

extension BackupClientTypes {

    /// Contains detailed information about a saved recovery point.
    public struct RecoveryPointByResource: Swift.Sendable {
        /// The size, in bytes, of a backup.
        public var backupSizeBytes: Swift.Int?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public var backupVaultName: Swift.String?
        /// The date and time a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: Foundation.Date?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public var encryptionKeyArn: Swift.String?
        /// This is a boolean value indicating this is a parent (composite) recovery point.
        public var isParent: Swift.Bool
        /// The Amazon Resource Name (ARN) of the parent (composite) recovery point.
        public var parentRecoveryPointArn: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// The non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// A status code specifying the state of the recovery point.
        public var status: BackupClientTypes.RecoveryPointStatus?
        /// A message explaining the current status of the recovery point.
        public var statusMessage: Swift.String?
        /// The type of vault in which the described recovery point is stored.
        public var vaultType: BackupClientTypes.VaultType?

        public init(
            backupSizeBytes: Swift.Int? = nil,
            backupVaultName: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            encryptionKeyArn: Swift.String? = nil,
            isParent: Swift.Bool = false,
            parentRecoveryPointArn: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            status: BackupClientTypes.RecoveryPointStatus? = nil,
            statusMessage: Swift.String? = nil,
            vaultType: BackupClientTypes.VaultType? = nil
        )
        {
            self.backupSizeBytes = backupSizeBytes
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.isParent = isParent
            self.parentRecoveryPointArn = parentRecoveryPointArn
            self.recoveryPointArn = recoveryPointArn
            self.resourceName = resourceName
            self.status = status
            self.statusMessage = statusMessage
            self.vaultType = vaultType
        }
    }
}

public struct ListRecoveryPointsByResourceOutput: Swift.Sendable {
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of objects that contain detailed information about recovery points of the specified resource type. Only Amazon EFS and Amazon EC2 recovery points return BackupVaultName.
    public var recoveryPoints: [BackupClientTypes.RecoveryPointByResource]?

    public init(
        nextToken: Swift.String? = nil,
        recoveryPoints: [BackupClientTypes.RecoveryPointByResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

public struct ListReportJobsInput: Swift.Sendable {
    /// Returns only report jobs that were created after the date and time specified in Unix format and Coordinated Universal Time (UTC). For example, the value 1516925490 represents Friday, January 26, 2018 12:11:30 AM.
    public var byCreationAfter: Foundation.Date?
    /// Returns only report jobs that were created before the date and time specified in Unix format and Coordinated Universal Time (UTC). For example, the value 1516925490 represents Friday, January 26, 2018 12:11:30 AM.
    public var byCreationBefore: Foundation.Date?
    /// Returns only report jobs with the specified report plan name.
    public var byReportPlanName: Swift.String?
    /// Returns only report jobs that are in the specified status. The statuses are: CREATED | RUNNING | COMPLETED | FAILED
    public var byStatus: Swift.String?
    /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        byCreationAfter: Foundation.Date? = nil,
        byCreationBefore: Foundation.Date? = nil,
        byReportPlanName: Swift.String? = nil,
        byStatus: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byCreationAfter = byCreationAfter
        self.byCreationBefore = byCreationBefore
        self.byReportPlanName = byReportPlanName
        self.byStatus = byStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListReportJobsOutput: Swift.Sendable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Details about your report jobs in JSON format.
    public var reportJobs: [BackupClientTypes.ReportJob]?

    public init(
        nextToken: Swift.String? = nil,
        reportJobs: [BackupClientTypes.ReportJob]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportJobs = reportJobs
    }
}

public struct ListReportPlansInput: Swift.Sendable {
    /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListReportPlansOutput: Swift.Sendable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The report plans with detailed information for each plan. This information includes the Amazon Resource Name (ARN), report plan name, description, settings, delivery channel, deployment status, creation time, and last times the report plan attempted to and successfully ran.
    public var reportPlans: [BackupClientTypes.ReportPlan]?

    public init(
        nextToken: Swift.String? = nil,
        reportPlans: [BackupClientTypes.ReportPlan]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportPlans = reportPlans
    }
}

public struct ListRestoreJobsInput: Swift.Sendable {
    /// The account ID to list the jobs from. Returns only restore jobs associated with the specified account ID.
    public var byAccountId: Swift.String?
    /// Returns only copy jobs completed after a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteAfter: Foundation.Date?
    /// Returns only copy jobs completed before a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteBefore: Foundation.Date?
    /// Returns only restore jobs that were created after the specified date.
    public var byCreatedAfter: Foundation.Date?
    /// Returns only restore jobs that were created before the specified date.
    public var byCreatedBefore: Foundation.Date?
    /// Include this parameter to return only restore jobs for the specified resources:
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * CloudFormation for CloudFormation
    ///
    /// * DocumentDB for Amazon DocumentDB (with MongoDB compatibility)
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * FSx for Amazon FSx
    ///
    /// * Neptune for Amazon Neptune
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Redshift for Amazon Redshift
    ///
    /// * S3 for Amazon Simple Storage Service (Amazon S3)
    ///
    /// * SAP HANA on Amazon EC2 for SAP HANA databases on Amazon Elastic Compute Cloud instances
    ///
    /// * Storage Gateway for Storage Gateway
    ///
    /// * Timestream for Amazon Timestream
    ///
    /// * VirtualMachine for VMware virtual machines
    public var byResourceType: Swift.String?
    /// This returns only restore testing jobs that match the specified resource Amazon Resource Name (ARN).
    public var byRestoreTestingPlanArn: Swift.String?
    /// Returns only restore jobs associated with the specified job status.
    public var byStatus: BackupClientTypes.RestoreJobStatus?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        byAccountId: Swift.String? = nil,
        byCompleteAfter: Foundation.Date? = nil,
        byCompleteBefore: Foundation.Date? = nil,
        byCreatedAfter: Foundation.Date? = nil,
        byCreatedBefore: Foundation.Date? = nil,
        byResourceType: Swift.String? = nil,
        byRestoreTestingPlanArn: Swift.String? = nil,
        byStatus: BackupClientTypes.RestoreJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byCompleteAfter = byCompleteAfter
        self.byCompleteBefore = byCompleteBefore
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byResourceType = byResourceType
        self.byRestoreTestingPlanArn = byRestoreTestingPlanArn
        self.byStatus = byStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BackupClientTypes {

    /// Contains metadata about a restore job.
    public struct RestoreJobsListMember: Swift.Sendable {
        /// The account ID that owns the restore job.
        public var accountId: Swift.String?
        /// The size, in bytes, of the restored resource.
        public var backupSizeInBytes: Swift.Int?
        /// The date and time a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: Foundation.Date?
        /// Contains identifying information about the creation of a restore job.
        public var createdBy: BackupClientTypes.RestoreJobCreator?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var createdResourceArn: Swift.String?
        /// The date and time a restore job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: Foundation.Date?
        /// This notes the status of the data generated by the restore test. The status may be Deleting, Failed, or Successful.
        public var deletionStatus: BackupClientTypes.RestoreDeletionStatus?
        /// This describes the restore job deletion status.
        public var deletionStatusMessage: Swift.String?
        /// The amount of time in minutes that a job restoring a recovery point is expected to take.
        public var expectedCompletionTimeMinutes: Swift.Int?
        /// The IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// Contains an estimated percentage complete of a job at the time the job status was queried.
        public var percentDone: Swift.String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// The date on which a recovery point was created.
        public var recoveryPointCreationDate: Foundation.Date?
        /// The resource type of the listed restore jobs; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?
        /// Uniquely identifies the job that restores a recovery point.
        public var restoreJobId: Swift.String?
        /// A status code specifying the state of the job initiated by Backup to restore a recovery point.
        public var status: BackupClientTypes.RestoreJobStatus?
        /// A detailed message explaining the status of the job to restore a recovery point.
        public var statusMessage: Swift.String?
        /// The status of validation run on the indicated restore job.
        public var validationStatus: BackupClientTypes.RestoreValidationStatus?
        /// This describes the status of validation run on the indicated restore job.
        public var validationStatusMessage: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            backupSizeInBytes: Swift.Int? = nil,
            completionDate: Foundation.Date? = nil,
            createdBy: BackupClientTypes.RestoreJobCreator? = nil,
            createdResourceArn: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            deletionStatus: BackupClientTypes.RestoreDeletionStatus? = nil,
            deletionStatusMessage: Swift.String? = nil,
            expectedCompletionTimeMinutes: Swift.Int? = nil,
            iamRoleArn: Swift.String? = nil,
            percentDone: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            recoveryPointCreationDate: Foundation.Date? = nil,
            resourceType: Swift.String? = nil,
            restoreJobId: Swift.String? = nil,
            status: BackupClientTypes.RestoreJobStatus? = nil,
            statusMessage: Swift.String? = nil,
            validationStatus: BackupClientTypes.RestoreValidationStatus? = nil,
            validationStatusMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.backupSizeInBytes = backupSizeInBytes
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.createdResourceArn = createdResourceArn
            self.creationDate = creationDate
            self.deletionStatus = deletionStatus
            self.deletionStatusMessage = deletionStatusMessage
            self.expectedCompletionTimeMinutes = expectedCompletionTimeMinutes
            self.iamRoleArn = iamRoleArn
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.recoveryPointCreationDate = recoveryPointCreationDate
            self.resourceType = resourceType
            self.restoreJobId = restoreJobId
            self.status = status
            self.statusMessage = statusMessage
            self.validationStatus = validationStatus
            self.validationStatusMessage = validationStatusMessage
        }
    }
}

public struct ListRestoreJobsOutput: Swift.Sendable {
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of objects that contain detailed information about jobs to restore saved resources.
    public var restoreJobs: [BackupClientTypes.RestoreJobsListMember]?

    public init(
        nextToken: Swift.String? = nil,
        restoreJobs: [BackupClientTypes.RestoreJobsListMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.restoreJobs = restoreJobs
    }
}

public struct ListRestoreJobsByProtectedResourceInput: Swift.Sendable {
    /// Returns only restore jobs of recovery points that were created after the specified date.
    public var byRecoveryPointCreationDateAfter: Foundation.Date?
    /// Returns only restore jobs of recovery points that were created before the specified date.
    public var byRecoveryPointCreationDateBefore: Foundation.Date?
    /// Returns only restore jobs associated with the specified job status.
    public var byStatus: BackupClientTypes.RestoreJobStatus?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request ismade to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// Returns only restore jobs that match the specified resource Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        byRecoveryPointCreationDateAfter: Foundation.Date? = nil,
        byRecoveryPointCreationDateBefore: Foundation.Date? = nil,
        byStatus: BackupClientTypes.RestoreJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.byRecoveryPointCreationDateAfter = byRecoveryPointCreationDateAfter
        self.byRecoveryPointCreationDateBefore = byRecoveryPointCreationDateBefore
        self.byStatus = byStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

public struct ListRestoreJobsByProtectedResourceOutput: Swift.Sendable {
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows youto return more items in your list starting at the location pointed to by the next token
    public var nextToken: Swift.String?
    /// An array of objects that contain detailed information about jobs to restore saved resources.>
    public var restoreJobs: [BackupClientTypes.RestoreJobsListMember]?

    public init(
        nextToken: Swift.String? = nil,
        restoreJobs: [BackupClientTypes.RestoreJobsListMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.restoreJobs = restoreJobs
    }
}

extension BackupClientTypes {

    public enum RestoreJobState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aborted
        case aggregateAll
        case any
        case completed
        case created
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [RestoreJobState] {
            return [
                .aborted,
                .aggregateAll,
                .any,
                .completed,
                .created,
                .failed,
                .pending,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .aggregateAll: return "AGGREGATE_ALL"
            case .any: return "ANY"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListRestoreJobSummariesInput: Swift.Sendable {
    /// Returns the job count for the specified account. If the request is sent from a member account or an account not part of Amazon Web Services Organizations, jobs within requestor's account will be returned. Root, admin, and delegated administrator accounts can use the value ANY to return job counts from every account in the organization. AGGREGATE_ALL aggregates job counts from all accounts within the authenticated organization, then returns the sum.
    public var accountId: Swift.String?
    /// The period for the returned results.
    ///
    /// * ONE_DAY - The daily job count for the prior 14 days.
    ///
    /// * SEVEN_DAYS - The aggregated job count for the prior 7 days.
    ///
    /// * FOURTEEN_DAYS - The aggregated job count for prior 14 days.
    public var aggregationPeriod: BackupClientTypes.AggregationPeriod?
    /// This parameter sets the maximum number of items to be returned. The value is an integer. Range of accepted values is from 1 to 500.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// Returns the job count for the specified resource type. Use request GetSupportedResourceTypes to obtain strings for supported resource types. The the value ANY returns count of all resource types. AGGREGATE_ALL aggregates job counts for all resource types and returns the sum. The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
    public var resourceType: Swift.String?
    /// This parameter returns the job count for jobs with the specified state. The the value ANY returns count of all states. AGGREGATE_ALL aggregates job counts for all states and returns the sum.
    public var state: BackupClientTypes.RestoreJobState?

    public init(
        accountId: Swift.String? = nil,
        aggregationPeriod: BackupClientTypes.AggregationPeriod? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        state: BackupClientTypes.RestoreJobState? = nil
    )
    {
        self.accountId = accountId
        self.aggregationPeriod = aggregationPeriod
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
        self.state = state
    }
}

extension BackupClientTypes {

    /// This is a summary of restore jobs created or running within the most recent 30 days. The returned summary may contain the following: Region, Account, State, ResourceType, MessageCategory, StartTime, EndTime, and Count of included jobs.
    public struct RestoreJobSummary: Swift.Sendable {
        /// The account ID that owns the jobs within the summary.
        public var accountId: Swift.String?
        /// The value as a number of jobs in a job summary.
        public var count: Swift.Int
        /// The value of time in number format of a job end time. This value is the time in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var endTime: Foundation.Date?
        /// The Amazon Web Services Regions within the job summary.
        public var region: Swift.String?
        /// This value is the job count for the specified resource type. The request GetSupportedResourceTypes returns strings for supported resource types.
        public var resourceType: Swift.String?
        /// The value of time in number format of a job start time. This value is the time in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var startTime: Foundation.Date?
        /// This value is job count for jobs with the specified state.
        public var state: BackupClientTypes.RestoreJobState?

        public init(
            accountId: Swift.String? = nil,
            count: Swift.Int = 0,
            endTime: Foundation.Date? = nil,
            region: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: BackupClientTypes.RestoreJobState? = nil
        )
        {
            self.accountId = accountId
            self.count = count
            self.endTime = endTime
            self.region = region
            self.resourceType = resourceType
            self.startTime = startTime
            self.state = state
        }
    }
}

public struct ListRestoreJobSummariesOutput: Swift.Sendable {
    /// The period for the returned results.
    ///
    /// * ONE_DAY - The daily job count for the prior 14 days.
    ///
    /// * SEVEN_DAYS - The aggregated job count for the prior 7 days.
    ///
    /// * FOURTEEN_DAYS - The aggregated job count for prior 14 days.
    public var aggregationPeriod: Swift.String?
    /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// This return contains a summary that contains Region, Account, State, ResourceType, MessageCategory, StartTime, EndTime, and Count of included jobs.
    public var restoreJobSummaries: [BackupClientTypes.RestoreJobSummary]?

    public init(
        aggregationPeriod: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        restoreJobSummaries: [BackupClientTypes.RestoreJobSummary]? = nil
    )
    {
        self.aggregationPeriod = aggregationPeriod
        self.nextToken = nextToken
        self.restoreJobSummaries = restoreJobSummaries
    }
}

public struct ListRestoreTestingPlansInput: Swift.Sendable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the nexttoken.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BackupClientTypes {

    /// This contains metadata about a restore testing plan.
    public struct RestoreTestingPlanForList: Swift.Sendable {
        /// The date and time that a restore testing plan was created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The last time a restore test was run with the specified restore testing plan. A date and time, in Unix format and Coordinated Universal Time (UTC). The value of LastExecutionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastExecutionTime: Foundation.Date?
        /// The date and time that the restore testing plan was updated. This update is in Unix format and Coordinated Universal Time (UTC). The value of LastUpdateTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastUpdateTime: Foundation.Date?
        /// An Amazon Resource Name (ARN) that uniquely identifiesa restore testing plan.
        /// This member is required.
        public var restoreTestingPlanArn: Swift.String?
        /// The restore testing plan name.
        /// This member is required.
        public var restoreTestingPlanName: Swift.String?
        /// A CRON expression in specified timezone when a restore testing plan is executed.
        /// This member is required.
        public var scheduleExpression: Swift.String?
        /// Optional. This is the timezone in which the schedule expression is set. By default, ScheduleExpressions are in UTC. You can modify this to a specified timezone.
        public var scheduleExpressionTimezone: Swift.String?
        /// Defaults to 24 hours. A value in hours after a restore test is scheduled before a job will be canceled if it doesn't start successfully. This value is optional. If this value is included, this parameter has a maximum value of 168 hours (one week).
        public var startWindowHours: Swift.Int

        public init(
            creationTime: Foundation.Date? = nil,
            lastExecutionTime: Foundation.Date? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            restoreTestingPlanArn: Swift.String? = nil,
            restoreTestingPlanName: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleExpressionTimezone: Swift.String? = nil,
            startWindowHours: Swift.Int = 0
        )
        {
            self.creationTime = creationTime
            self.lastExecutionTime = lastExecutionTime
            self.lastUpdateTime = lastUpdateTime
            self.restoreTestingPlanArn = restoreTestingPlanArn
            self.restoreTestingPlanName = restoreTestingPlanName
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startWindowHours = startWindowHours
        }
    }
}

public struct ListRestoreTestingPlansOutput: Swift.Sendable {
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the nexttoken.
    public var nextToken: Swift.String?
    /// This is a returned list of restore testing plans.
    /// This member is required.
    public var restoreTestingPlans: [BackupClientTypes.RestoreTestingPlanForList]?

    public init(
        nextToken: Swift.String? = nil,
        restoreTestingPlans: [BackupClientTypes.RestoreTestingPlanForList]? = nil
    )
    {
        self.nextToken = nextToken
        self.restoreTestingPlans = restoreTestingPlans
    }
}

public struct ListRestoreTestingSelectionsInput: Swift.Sendable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the nexttoken.
    public var nextToken: Swift.String?
    /// Returns restore testing selections by the specified restore testing plan name.
    /// This member is required.
    public var restoreTestingPlanName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        restoreTestingPlanName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.restoreTestingPlanName = restoreTestingPlanName
    }
}

extension BackupClientTypes {

    /// This contains metadata about a restore testing selection.
    public struct RestoreTestingSelectionForList: Swift.Sendable {
        /// The date and time that a restore testing selection was created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26,2018 12:11:30.087 AM.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the IAM role that Backup uses to create the target resource; for example: arn:aws:iam::123456789012:role/S3Access.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// The type of Amazon Web Services resource included in a restore testing selection; for example, an Amazon EBS volume or an Amazon RDS database.
        /// This member is required.
        public var protectedResourceType: Swift.String?
        /// Unique string that is the name of the restore testing plan. The name cannot be changed after creation. The name must consist of only alphanumeric characters and underscores. Maximum length is 50.
        /// This member is required.
        public var restoreTestingPlanName: Swift.String?
        /// Unique name of a restore testing selection.
        /// This member is required.
        public var restoreTestingSelectionName: Swift.String?
        /// This value represents the time, in hours, data is retained after a restore test so that optional validation can be completed. Accepted value is an integer between 0 and 168 (the hourly equivalent of seven days).
        public var validationWindowHours: Swift.Int

        public init(
            creationTime: Foundation.Date? = nil,
            iamRoleArn: Swift.String? = nil,
            protectedResourceType: Swift.String? = nil,
            restoreTestingPlanName: Swift.String? = nil,
            restoreTestingSelectionName: Swift.String? = nil,
            validationWindowHours: Swift.Int = 0
        )
        {
            self.creationTime = creationTime
            self.iamRoleArn = iamRoleArn
            self.protectedResourceType = protectedResourceType
            self.restoreTestingPlanName = restoreTestingPlanName
            self.restoreTestingSelectionName = restoreTestingSelectionName
            self.validationWindowHours = validationWindowHours
        }
    }
}

public struct ListRestoreTestingSelectionsOutput: Swift.Sendable {
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the nexttoken.
    public var nextToken: Swift.String?
    /// The returned restore testing selections associated with the restore testing plan.
    /// This member is required.
    public var restoreTestingSelections: [BackupClientTypes.RestoreTestingSelectionForList]?

    public init(
        nextToken: Swift.String? = nil,
        restoreTestingSelections: [BackupClientTypes.RestoreTestingSelectionForList]? = nil
    )
    {
        self.nextToken = nextToken
        self.restoreTestingSelections = restoreTestingSelections
    }
}

public struct ListTagsInput: Swift.Sendable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the type of resource. Valid targets for ListTags are recovery points, backup plans, and backup vaults.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

public struct ListTagsOutput: Swift.Sendable {
    /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// Information about the tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

extension ListTagsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsOutput(nextToken: \(Swift.String(describing: nextToken)), tags: \"CONTENT_REDACTED\")"}
}

public struct PutBackupVaultAccessPolicyInput: Swift.Sendable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The backup vault access policy document in JSON format.
    public var policy: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.policy = policy
    }
}

public struct PutBackupVaultLockConfigurationInput: Swift.Sendable {
    /// The Backup Vault Lock configuration that specifies the name of the backup vault it protects.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The Backup Vault Lock configuration that specifies the number of days before the lock date. For example, setting ChangeableForDays to 30 on Jan. 1, 2022 at 8pm UTC will set the lock date to Jan. 31, 2022 at 8pm UTC. Backup enforces a 72-hour cooling-off period before Vault Lock takes effect and becomes immutable. Therefore, you must set ChangeableForDays to 3 or greater. Before the lock date, you can delete Vault Lock from the vault using DeleteBackupVaultLockConfiguration or change the Vault Lock configuration using PutBackupVaultLockConfiguration. On and after the lock date, the Vault Lock becomes immutable and cannot be changed or deleted. If this parameter is not specified, you can delete Vault Lock from the vault using DeleteBackupVaultLockConfiguration or change the Vault Lock configuration using PutBackupVaultLockConfiguration at any time.
    public var changeableForDays: Swift.Int?
    /// The Backup Vault Lock configuration that specifies the maximum retention period that the vault retains its recovery points. This setting can be useful if, for example, your organization's policies require you to destroy certain data after retaining it for four years (1460 days). If this parameter is not included, Vault Lock does not enforce a maximum retention period on the recovery points in the vault. If this parameter is included without a value, Vault Lock will not enforce a maximum retention period. If this parameter is specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. The longest maximum retention period you can specify is 36500 days (approximately 100 years). Recovery points already saved in the vault prior to Vault Lock are not affected.
    public var maxRetentionDays: Swift.Int?
    /// The Backup Vault Lock configuration that specifies the minimum retention period that the vault retains its recovery points. This setting can be useful if, for example, your organization's policies require you to retain certain data for at least seven years (2555 days). This parameter is required when a vault lock is created through CloudFormation; otherwise, this parameter is optional. If this parameter is not specified, Vault Lock will not enforce a minimum retention period. If this parameter is specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails that backup or copy job, and you should either modify your lifecycle settings or use a different vault. The shortest minimum retention period you can specify is 1 day. Recovery points already saved in the vault prior to Vault Lock are not affected.
    public var minRetentionDays: Swift.Int?

    public init(
        backupVaultName: Swift.String? = nil,
        changeableForDays: Swift.Int? = nil,
        maxRetentionDays: Swift.Int? = nil,
        minRetentionDays: Swift.Int? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.changeableForDays = changeableForDays
        self.maxRetentionDays = maxRetentionDays
        self.minRetentionDays = minRetentionDays
    }
}

public struct PutBackupVaultNotificationsInput: Swift.Sendable {
    /// An array of events that indicate the status of jobs to back up resources to the backup vault. For common use cases and code samples, see [Using Amazon SNS to track Backup events](https://docs.aws.amazon.com/aws-backup/latest/devguide/sns-notifications.html). The following events are supported:
    ///
    /// * BACKUP_JOB_STARTED | BACKUP_JOB_COMPLETED
    ///
    /// * COPY_JOB_STARTED | COPY_JOB_SUCCESSFUL | COPY_JOB_FAILED
    ///
    /// * RESTORE_JOB_STARTED | RESTORE_JOB_COMPLETED | RECOVERY_POINT_MODIFIED
    ///
    /// * S3_BACKUP_OBJECT_FAILED | S3_RESTORE_OBJECT_FAILED
    ///
    ///
    /// The list below includes both supported events and deprecated events that are no longer in use (for reference). Deprecated events do not return statuses or notifications. Refer to the list above for the supported events.
    /// This member is required.
    public var backupVaultEvents: [BackupClientTypes.BackupVaultEvent]?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The Amazon Resource Name (ARN) that specifies the topic for a backup vault’s events; for example, arn:aws:sns:us-west-2:111122223333:MyVaultTopic.
    /// This member is required.
    public var snsTopicArn: Swift.String?

    public init(
        backupVaultEvents: [BackupClientTypes.BackupVaultEvent]? = nil,
        backupVaultName: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.backupVaultEvents = backupVaultEvents
        self.backupVaultName = backupVaultName
        self.snsTopicArn = snsTopicArn
    }
}

public struct PutRestoreValidationResultInput: Swift.Sendable {
    /// This is a unique identifier of a restore job within Backup.
    /// This member is required.
    public var restoreJobId: Swift.String?
    /// The status of your restore validation.
    /// This member is required.
    public var validationStatus: BackupClientTypes.RestoreValidationStatus?
    /// This is an optional message string you can input to describe the validation status for the restore test validation.
    public var validationStatusMessage: Swift.String?

    public init(
        restoreJobId: Swift.String? = nil,
        validationStatus: BackupClientTypes.RestoreValidationStatus? = nil,
        validationStatusMessage: Swift.String? = nil
    )
    {
        self.restoreJobId = restoreJobId
        self.validationStatus = validationStatus
        self.validationStatusMessage = validationStatusMessage
    }
}

public struct StartBackupJobInput: Swift.Sendable {
    /// The backup option for a selected resource. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS""disabled" to create a regular backup. The WindowsVSS option is not enabled by default.
    public var backupOptions: [Swift.String: Swift.String]?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// A value in minutes during which a successfully started backup must complete, or else Backup will cancel the job. This value is optional. This value begins counting down from when the backup was scheduled. It does not add additional time for StartWindowMinutes, or if the backup started later than scheduled. Like StartWindowMinutes, this parameter has a maximum value of 100 years (52,560,000 minutes).
    public var completeWindowMinutes: Swift.Int?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartBackupJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup will transition and expire backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that can transition to cold storage are listed in the [Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/backup-feature-availability.html#features-by-resource) table. Backup ignores this expression for other resource types. This parameter has a maximum value of 100 years (36,500 days).
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// The tags to assign to the resources.
    public var recoveryPointTags: [Swift.String: Swift.String]?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional, and the default is 8 hours. If this value is included, it must be at least 60 minutes to avoid errors. This parameter has a maximum value of 100 years (52,560,000 minutes). During the start window, the backup job status remains in CREATED status until it has successfully begun or until the start window time has run out. If within the start window time Backup receives an error that allows the job to be retried, Backup will automatically retry to begin the job at least every 10 minutes until the backup successfully begins (the job status changes to RUNNING) or until the job status changes to EXPIRED (which is expected to occur when the start window time is over).
    public var startWindowMinutes: Swift.Int?

    public init(
        backupOptions: [Swift.String: Swift.String]? = nil,
        backupVaultName: Swift.String? = nil,
        completeWindowMinutes: Swift.Int? = nil,
        iamRoleArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointTags: [Swift.String: Swift.String]? = nil,
        resourceArn: Swift.String? = nil,
        startWindowMinutes: Swift.Int? = nil
    )
    {
        self.backupOptions = backupOptions
        self.backupVaultName = backupVaultName
        self.completeWindowMinutes = completeWindowMinutes
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.lifecycle = lifecycle
        self.recoveryPointTags = recoveryPointTags
        self.resourceArn = resourceArn
        self.startWindowMinutes = startWindowMinutes
    }
}

extension StartBackupJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartBackupJobInput(backupOptions: \(Swift.String(describing: backupOptions)), backupVaultName: \(Swift.String(describing: backupVaultName)), completeWindowMinutes: \(Swift.String(describing: completeWindowMinutes)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), lifecycle: \(Swift.String(describing: lifecycle)), resourceArn: \(Swift.String(describing: resourceArn)), startWindowMinutes: \(Swift.String(describing: startWindowMinutes)), recoveryPointTags: \"CONTENT_REDACTED\")"}
}

public struct StartBackupJobOutput: Swift.Sendable {
    /// Uniquely identifies a request to Backup to back up a resource.
    public var backupJobId: Swift.String?
    /// The date and time that a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: Foundation.Date?
    /// This is a returned boolean value indicating this is a parent (composite) backup job.
    public var isParent: Swift.Bool
    /// Note: This field is only returned for Amazon EFS and Advanced DynamoDB resources. An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?

    public init(
        backupJobId: Swift.String? = nil,
        creationDate: Foundation.Date? = nil,
        isParent: Swift.Bool = false,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
        self.creationDate = creationDate
        self.isParent = isParent
        self.recoveryPointArn = recoveryPointArn
    }
}

public struct StartCopyJobInput: Swift.Sendable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a destination backup vault to copy to; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
    /// This member is required.
    public var destinationBackupVaultArn: Swift.String?
    /// Specifies the IAM role ARN used to copy the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartCopyJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// Specifies the time period, in days, before a recovery point transitions to cold storage or is deleted. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the retention setting must be 90 days greater than the transition to cold after days setting. The transition to cold after days setting can't be changed after a backup has been transitioned to cold. Resource types that can transition to cold storage are listed in the [Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/backup-feature-availability.html#features-by-resource) table. Backup ignores this expression for other resource types. To remove the existing lifecycle and retention periods and keep your recovery points indefinitely, specify -1 for MoveToColdStorageAfterDays and DeleteAfterDays.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// An ARN that uniquely identifies a recovery point to use for the copy job; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?
    /// The name of a logical source container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    /// This member is required.
    public var sourceBackupVaultName: Swift.String?

    public init(
        destinationBackupVaultArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointArn: Swift.String? = nil,
        sourceBackupVaultName: Swift.String? = nil
    )
    {
        self.destinationBackupVaultArn = destinationBackupVaultArn
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
        self.sourceBackupVaultName = sourceBackupVaultName
    }
}

public struct StartCopyJobOutput: Swift.Sendable {
    /// Uniquely identifies a copy job.
    public var copyJobId: Swift.String?
    /// The date and time that a copy job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: Foundation.Date?
    /// This is a returned boolean value indicating this is a parent (composite) copy job.
    public var isParent: Swift.Bool

    public init(
        copyJobId: Swift.String? = nil,
        creationDate: Foundation.Date? = nil,
        isParent: Swift.Bool = false
    )
    {
        self.copyJobId = copyJobId
        self.creationDate = creationDate
        self.isParent = isParent
    }
}

public struct StartReportJobInput: Swift.Sendable {
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartReportJobInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// The unique name of a report plan.
    /// This member is required.
    public var reportPlanName: Swift.String?

    public init(
        idempotencyToken: Swift.String? = nil,
        reportPlanName: Swift.String? = nil
    )
    {
        self.idempotencyToken = idempotencyToken
        self.reportPlanName = reportPlanName
    }
}

public struct StartReportJobOutput: Swift.Sendable {
    /// The identifier of the report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. The report job ID cannot be edited.
    public var reportJobId: Swift.String?

    public init(
        reportJobId: Swift.String? = nil
    )
    {
        self.reportJobId = reportJobId
    }
}

public struct StartRestoreJobInput: Swift.Sendable {
    /// This is an optional parameter. If this equals True, tags included in the backup will be copied to the restored resource. This can only be applied to backups created through Backup.
    public var copySourceTagsToRestoredResource: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role that Backup uses to create the target resource; for example: arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartRestoreJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// A set of metadata key-value pairs. You can get configuration metadata about a resource at the time it was backed up by calling GetRecoveryPointRestoreMetadata. However, values in addition to those provided by GetRecoveryPointRestoreMetadata might be required to restore a resource. For example, you might need to provide a new resource name if the original already exists. For more information about the metadata for each resource, see the following:
    ///
    /// * [Metadata for Amazon Aurora](https://docs.aws.amazon.com/aws-backup/latest/devguide/restoring-aur.html#aur-restore-cli)
    ///
    /// * [Metadata for Amazon DocumentDB](https://docs.aws.amazon.com/aws-backup/latest/devguide/restoring-docdb.html#docdb-restore-cli)
    ///
    /// * [Metadata for CloudFormation](https://docs.aws.amazon.com/aws-backup/latest/devguide/restore-application-stacks.html#restoring-cfn-cli)
    ///
    /// * [Metadata for Amazon DynamoDB](https://docs.aws.amazon.com/aws-backup/latest/devguide/restoring-dynamodb.html#ddb-restore-cli)
    ///
    /// * [ Metadata for Amazon EBS](https://docs.aws.amazon.com/aws-backup/latest/devguide/restoring-ebs.html#ebs-restore-cli)
    ///
    /// * [Metadata for Amazon EC2](https://docs.aws.amazon.com/aws-backup/latest/devguide/restoring-ec2.html#restoring-ec2-cli)
    ///
    /// * [Metadata for Amazon EFS](https://docs.aws.amazon.com/aws-backup/latest/devguide/restoring-efs.html#efs-restore-cli)
    ///
    /// * [Metadata for Amazon FSx](https://docs.aws.amazon.com/aws-backup/latest/devguide/restoring-fsx.html#fsx-restore-cli)
    ///
    /// * [Metadata for Amazon Neptune](https://docs.aws.amazon.com/aws-backup/latest/devguide/restoring-nep.html#nep-restore-cli)
    ///
    /// * [Metadata for Amazon RDS](https://docs.aws.amazon.com/aws-backup/latest/devguide/restoring-rds.html#rds-restore-cli)
    ///
    /// * [Metadata for Amazon Redshift](https://docs.aws.amazon.com/aws-backup/latest/devguide/redshift-restores.html#redshift-restore-api)
    ///
    /// * [Metadata for Storage Gateway](https://docs.aws.amazon.com/aws-backup/latest/devguide/restoring-storage-gateway.html#restoring-sgw-cli)
    ///
    /// * [Metadata for Amazon S3](https://docs.aws.amazon.com/aws-backup/latest/devguide/restoring-s3.html#s3-restore-cli)
    ///
    /// * [Metadata for Amazon Timestream](https://docs.aws.amazon.com/aws-backup/latest/devguide/timestream-restore.html#timestream-restore-api)
    ///
    /// * [Metadata for virtual machines](https://docs.aws.amazon.com/aws-backup/latest/devguide/restoring-vm.html#vm-restore-cli)
    /// This member is required.
    public var metadata: [Swift.String: Swift.String]?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?
    /// Starts a job to restore a recovery point for one of the following resources:
    ///
    /// * Aurora - Amazon Aurora
    ///
    /// * DocumentDB - Amazon DocumentDB
    ///
    /// * CloudFormation - CloudFormation
    ///
    /// * DynamoDB - Amazon DynamoDB
    ///
    /// * EBS - Amazon Elastic Block Store
    ///
    /// * EC2 - Amazon Elastic Compute Cloud
    ///
    /// * EFS - Amazon Elastic File System
    ///
    /// * FSx - Amazon FSx
    ///
    /// * Neptune - Amazon Neptune
    ///
    /// * RDS - Amazon Relational Database Service
    ///
    /// * Redshift - Amazon Redshift
    ///
    /// * Storage Gateway - Storage Gateway
    ///
    /// * S3 - Amazon Simple Storage Service
    ///
    /// * Timestream - Amazon Timestream
    ///
    /// * VirtualMachine - Virtual machines
    public var resourceType: Swift.String?

    public init(
        copySourceTagsToRestoredResource: Swift.Bool? = false,
        iamRoleArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        metadata: [Swift.String: Swift.String]? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.copySourceTagsToRestoredResource = copySourceTagsToRestoredResource
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.metadata = metadata
        self.recoveryPointArn = recoveryPointArn
        self.resourceType = resourceType
    }
}

extension StartRestoreJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartRestoreJobInput(copySourceTagsToRestoredResource: \(Swift.String(describing: copySourceTagsToRestoredResource)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), resourceType: \(Swift.String(describing: resourceType)), metadata: \"CONTENT_REDACTED\")"}
}

public struct StartRestoreJobOutput: Swift.Sendable {
    /// Uniquely identifies the job that restores a recovery point.
    public var restoreJobId: Swift.String?

    public init(
        restoreJobId: Swift.String? = nil
    )
    {
        self.restoreJobId = restoreJobId
    }
}

public struct StopBackupJobInput: Swift.Sendable {
    /// Uniquely identifies a request to Backup to back up a resource.
    /// This member is required.
    public var backupJobId: Swift.String?

    public init(
        backupJobId: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the type of the tagged resource. ARNs that do not include backup are incompatible with tagging. TagResource and UntagResource with invalid ARNs will result in an error. Acceptable ARN content can include arn:aws:backup:us-east. Invalid ARN content may look like arn:aws:ec2:us-east.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Key-value pairs that are used to help organize your resources. You can assign your own metadata to the resources you create. For clarity, this is the structure to assign tags: [{"Key":"string","Value":"string"}].
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceInput: Swift.Sendable {
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the type of the tagged resource. ARNs that do not include backup are incompatible with tagging. TagResource and UntagResource with invalid ARNs will result in an error. Acceptable ARN content can include arn:aws:backup:us-east. Invalid ARN content may look like arn:aws:ec2:us-east.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys to identify which key-value tags to remove from a resource.
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeyList = tagKeyList
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeyList: \"CONTENT_REDACTED\")"}
}

public struct UpdateBackupPlanInput: Swift.Sendable {
    /// The body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    /// This member is required.
    public var backupPlan: BackupClientTypes.BackupPlanInput?
    /// The ID of the backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?

    public init(
        backupPlan: BackupClientTypes.BackupPlanInput? = nil,
        backupPlanId: Swift.String? = nil
    )
    {
        self.backupPlan = backupPlan
        self.backupPlanId = backupPlanId
    }
}

public struct UpdateBackupPlanOutput: Swift.Sendable {
    /// Contains a list of BackupOptions for each resource type.
    public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: Foundation.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version Ids cannot be edited.
    public var versionId: Swift.String?

    public init(
        advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        creationDate: Foundation.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.versionId = versionId
    }
}

public struct UpdateFrameworkInput: Swift.Sendable {
    /// The controls that make up the framework. Each control in the list has a name, input parameters, and scope.
    public var frameworkControls: [BackupClientTypes.FrameworkControl]?
    /// An optional description of the framework with a maximum 1,024 characters.
    public var frameworkDescription: Swift.String?
    /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var frameworkName: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to UpdateFrameworkInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?

    public init(
        frameworkControls: [BackupClientTypes.FrameworkControl]? = nil,
        frameworkDescription: Swift.String? = nil,
        frameworkName: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil
    )
    {
        self.frameworkControls = frameworkControls
        self.frameworkDescription = frameworkDescription
        self.frameworkName = frameworkName
        self.idempotencyToken = idempotencyToken
    }
}

public struct UpdateFrameworkOutput: Swift.Sendable {
    /// The date and time that a framework is created, in ISO 8601 representation. The value of CreationTime is accurate to milliseconds. For example, 2020-07-10T15:00:00.000-08:00 represents the 10th of July 2020 at 3:00 PM 8 hours behind UTC.
    public var creationTime: Foundation.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var frameworkArn: Swift.String?
    /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    public var frameworkName: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        frameworkArn: Swift.String? = nil,
        frameworkName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.frameworkArn = frameworkArn
        self.frameworkName = frameworkName
    }
}

public struct UpdateGlobalSettingsInput: Swift.Sendable {
    /// A value for isCrossAccountBackupEnabled and a Region. Example: update-global-settings --global-settings isCrossAccountBackupEnabled=false --region us-west-2.
    public var globalSettings: [Swift.String: Swift.String]?

    public init(
        globalSettings: [Swift.String: Swift.String]? = nil
    )
    {
        self.globalSettings = globalSettings
    }
}

public struct UpdateRecoveryPointLifecycleInput: Swift.Sendable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
    }
}

public struct UpdateRecoveryPointLifecycleOutput: Swift.Sendable {
    /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
    public var calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that can transition to cold storage are listed in the [Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/backup-feature-availability.html#features-by-resource) table. Backup ignores this expression for other resource types.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultArn: Swift.String? = nil,
        calculatedLifecycle: BackupClientTypes.CalculatedLifecycle? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.calculatedLifecycle = calculatedLifecycle
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
    }
}

public struct UpdateRegionSettingsInput: Swift.Sendable {
    /// Enables or disables full Backup management of backups for a resource type. To enable full Backup management for DynamoDB along with [ Backup's advanced DynamoDB backup features](https://docs.aws.amazon.com/aws-backup/latest/devguide/advanced-ddb-backup.html), follow the procedure to [ enable advanced DynamoDB backup programmatically](https://docs.aws.amazon.com/aws-backup/latest/devguide/advanced-ddb-backup.html#advanced-ddb-backup-enable-cli).
    public var resourceTypeManagementPreference: [Swift.String: Swift.Bool]?
    /// Updates the list of services along with the opt-in preferences for the Region. If resource assignments are only based on tags, then service opt-in settings are applied. If a resource type is explicitly assigned to a backup plan, such as Amazon S3, Amazon EC2, or Amazon RDS, it will be included in the backup even if the opt-in is not enabled for that particular service. If both a resource type and tags are specified in a resource assignment, the resource type specified in the backup plan takes priority over the tag condition. Service opt-in settings are disregarded in this situation.
    public var resourceTypeOptInPreference: [Swift.String: Swift.Bool]?

    public init(
        resourceTypeManagementPreference: [Swift.String: Swift.Bool]? = nil,
        resourceTypeOptInPreference: [Swift.String: Swift.Bool]? = nil
    )
    {
        self.resourceTypeManagementPreference = resourceTypeManagementPreference
        self.resourceTypeOptInPreference = resourceTypeOptInPreference
    }
}

public struct UpdateReportPlanInput: Swift.Sendable {
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to UpdateReportPlanInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// The information about where to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
    public var reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
    /// An optional description of the report plan with a maximum 1,024 characters.
    public var reportPlanDescription: Swift.String?
    /// The unique name of the report plan. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var reportPlanName: Swift.String?
    /// The report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
    public var reportSetting: BackupClientTypes.ReportSetting?

    public init(
        idempotencyToken: Swift.String? = nil,
        reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel? = nil,
        reportPlanDescription: Swift.String? = nil,
        reportPlanName: Swift.String? = nil,
        reportSetting: BackupClientTypes.ReportSetting? = nil
    )
    {
        self.idempotencyToken = idempotencyToken
        self.reportDeliveryChannel = reportDeliveryChannel
        self.reportPlanDescription = reportPlanDescription
        self.reportPlanName = reportPlanName
        self.reportSetting = reportSetting
    }
}

public struct UpdateReportPlanOutput: Swift.Sendable {
    /// The date and time that a report plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationTime: Foundation.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var reportPlanArn: Swift.String?
    /// The unique name of the report plan.
    public var reportPlanName: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        reportPlanArn: Swift.String? = nil,
        reportPlanName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.reportPlanArn = reportPlanArn
        self.reportPlanName = reportPlanName
    }
}

extension BackupClientTypes {

    /// This contains metadata about a restore testing plan.
    public struct RestoreTestingPlanForUpdate: Swift.Sendable {
        /// Required: Algorithm; RecoveryPointTypes; IncludeVaults (one or more). Optional: SelectionWindowDays ('30' if not specified); ExcludeVaults (defaults to empty list if not listed).
        public var recoveryPointSelection: BackupClientTypes.RestoreTestingRecoveryPointSelection?
        /// A CRON expression in specified timezone when a restore testing plan is executed.
        public var scheduleExpression: Swift.String?
        /// Optional. This is the timezone in which the schedule expression is set. By default, ScheduleExpressions are in UTC. You can modify this to a specified timezone.
        public var scheduleExpressionTimezone: Swift.String?
        /// Defaults to 24 hours. A value in hours after a restore test is scheduled before a job will be canceled if it doesn't start successfully. This value is optional. If this value is included, this parameter has a maximum value of 168 hours (one week).
        public var startWindowHours: Swift.Int

        public init(
            recoveryPointSelection: BackupClientTypes.RestoreTestingRecoveryPointSelection? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleExpressionTimezone: Swift.String? = nil,
            startWindowHours: Swift.Int = 0
        )
        {
            self.recoveryPointSelection = recoveryPointSelection
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startWindowHours = startWindowHours
        }
    }
}

public struct UpdateRestoreTestingPlanInput: Swift.Sendable {
    /// Specifies the body of a restore testing plan.
    /// This member is required.
    public var restoreTestingPlan: BackupClientTypes.RestoreTestingPlanForUpdate?
    /// The name of the restore testing plan name.
    /// This member is required.
    public var restoreTestingPlanName: Swift.String?

    public init(
        restoreTestingPlan: BackupClientTypes.RestoreTestingPlanForUpdate? = nil,
        restoreTestingPlanName: Swift.String? = nil
    )
    {
        self.restoreTestingPlan = restoreTestingPlan
        self.restoreTestingPlanName = restoreTestingPlanName
    }
}

public struct UpdateRestoreTestingPlanOutput: Swift.Sendable {
    /// The time the resource testing plan was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// Unique ARN (Amazon Resource Name) of the restore testing plan.
    /// This member is required.
    public var restoreTestingPlanArn: Swift.String?
    /// The name cannot be changed after creation. The name consists of only alphanumeric characters and underscores. Maximum length is 50.
    /// This member is required.
    public var restoreTestingPlanName: Swift.String?
    /// The time the update completed for the restore testing plan.
    /// This member is required.
    public var updateTime: Foundation.Date?

    public init(
        creationTime: Foundation.Date? = nil,
        restoreTestingPlanArn: Swift.String? = nil,
        restoreTestingPlanName: Swift.String? = nil,
        updateTime: Foundation.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.restoreTestingPlanArn = restoreTestingPlanArn
        self.restoreTestingPlanName = restoreTestingPlanName
        self.updateTime = updateTime
    }
}

extension BackupClientTypes {

    /// This contains metadata about a restore testing selection.
    public struct RestoreTestingSelectionForUpdate: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the IAM role that Backup uses to create the target resource; for example: arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// You can include a list of specific ARNs, such as ProtectedResourceArns: ["arn:aws:...", "arn:aws:..."] or you can include a wildcard: ProtectedResourceArns: ["*"], but not both.
        public var protectedResourceArns: [Swift.String]?
        /// The conditions that you define for resources in your restore testing plan using tags.
        public var protectedResourceConditions: BackupClientTypes.ProtectedResourceConditions?
        /// You can override certain restore metadata keys by including the parameter RestoreMetadataOverrides in the body of RestoreTestingSelection. Key values are not case sensitive. See the complete list of [restore testing inferred metadata](https://docs.aws.amazon.com/aws-backup/latest/devguide/restore-testing-inferred-metadata.html).
        public var restoreMetadataOverrides: [Swift.String: Swift.String]?
        /// This value represents the time, in hours, data is retained after a restore test so that optional validation can be completed. Accepted value is an integer between 0 and 168 (the hourly equivalent of seven days).
        public var validationWindowHours: Swift.Int

        public init(
            iamRoleArn: Swift.String? = nil,
            protectedResourceArns: [Swift.String]? = nil,
            protectedResourceConditions: BackupClientTypes.ProtectedResourceConditions? = nil,
            restoreMetadataOverrides: [Swift.String: Swift.String]? = nil,
            validationWindowHours: Swift.Int = 0
        )
        {
            self.iamRoleArn = iamRoleArn
            self.protectedResourceArns = protectedResourceArns
            self.protectedResourceConditions = protectedResourceConditions
            self.restoreMetadataOverrides = restoreMetadataOverrides
            self.validationWindowHours = validationWindowHours
        }
    }
}

extension BackupClientTypes.RestoreTestingSelectionForUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreTestingSelectionForUpdate(iamRoleArn: \(Swift.String(describing: iamRoleArn)), protectedResourceArns: \(Swift.String(describing: protectedResourceArns)), protectedResourceConditions: \(Swift.String(describing: protectedResourceConditions)), validationWindowHours: \(Swift.String(describing: validationWindowHours)), restoreMetadataOverrides: \"CONTENT_REDACTED\")"}
}

public struct UpdateRestoreTestingSelectionInput: Swift.Sendable {
    /// The restore testing plan name is required to update the indicated testing plan.
    /// This member is required.
    public var restoreTestingPlanName: Swift.String?
    /// To update your restore testing selection, you can use either protected resource ARNs or conditions, but not both. That is, if your selection has ProtectedResourceArns, requesting an update with the parameter ProtectedResourceConditions will be unsuccessful.
    /// This member is required.
    public var restoreTestingSelection: BackupClientTypes.RestoreTestingSelectionForUpdate?
    /// The required restore testing selection name of the restore testing selection you wish to update.
    /// This member is required.
    public var restoreTestingSelectionName: Swift.String?

    public init(
        restoreTestingPlanName: Swift.String? = nil,
        restoreTestingSelection: BackupClientTypes.RestoreTestingSelectionForUpdate? = nil,
        restoreTestingSelectionName: Swift.String? = nil
    )
    {
        self.restoreTestingPlanName = restoreTestingPlanName
        self.restoreTestingSelection = restoreTestingSelection
        self.restoreTestingSelectionName = restoreTestingSelectionName
    }
}

public struct UpdateRestoreTestingSelectionOutput: Swift.Sendable {
    /// The time the resource testing selection was updated successfully.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// Unique string that is the name of the restore testing plan.
    /// This member is required.
    public var restoreTestingPlanArn: Swift.String?
    /// The restore testing plan with which the updated restore testing selection is associated.
    /// This member is required.
    public var restoreTestingPlanName: Swift.String?
    /// The returned restore testing selection name.
    /// This member is required.
    public var restoreTestingSelectionName: Swift.String?
    /// The time the update completed for the restore testing selection.
    /// This member is required.
    public var updateTime: Foundation.Date?

    public init(
        creationTime: Foundation.Date? = nil,
        restoreTestingPlanArn: Swift.String? = nil,
        restoreTestingPlanName: Swift.String? = nil,
        restoreTestingSelectionName: Swift.String? = nil,
        updateTime: Foundation.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.restoreTestingPlanArn = restoreTestingPlanArn
        self.restoreTestingPlanName = restoreTestingPlanName
        self.restoreTestingSelectionName = restoreTestingSelectionName
        self.updateTime = updateTime
    }
}

extension CancelLegalHoldInput {

    static func urlPathProvider(_ value: CancelLegalHoldInput) -> Swift.String? {
        guard let legalHoldId = value.legalHoldId else {
            return nil
        }
        return "/legal-holds/\(legalHoldId.urlPercentEncoding())"
    }
}

extension CancelLegalHoldInput {

    static func queryItemProvider(_ value: CancelLegalHoldInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let cancelDescription = value.cancelDescription else {
            let message = "Creating a URL Query Item failed. cancelDescription is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let cancelDescriptionQueryItem = Smithy.URIQueryItem(name: "cancelDescription".urlPercentEncoding(), value: Swift.String(cancelDescription).urlPercentEncoding())
        items.append(cancelDescriptionQueryItem)
        if let retainRecordInDays = value.retainRecordInDays {
            let retainRecordInDaysQueryItem = Smithy.URIQueryItem(name: "retainRecordInDays".urlPercentEncoding(), value: Swift.String(retainRecordInDays).urlPercentEncoding())
            items.append(retainRecordInDaysQueryItem)
        }
        return items
    }
}

extension CreateBackupPlanInput {

    static func urlPathProvider(_ value: CreateBackupPlanInput) -> Swift.String? {
        return "/backup/plans"
    }
}

extension CreateBackupSelectionInput {

    static func urlPathProvider(_ value: CreateBackupSelectionInput) -> Swift.String? {
        guard let backupPlanId = value.backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections"
    }
}

extension CreateBackupVaultInput {

    static func urlPathProvider(_ value: CreateBackupVaultInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())"
    }
}

extension CreateFrameworkInput {

    static func urlPathProvider(_ value: CreateFrameworkInput) -> Swift.String? {
        return "/audit/frameworks"
    }
}

extension CreateLegalHoldInput {

    static func urlPathProvider(_ value: CreateLegalHoldInput) -> Swift.String? {
        return "/legal-holds"
    }
}

extension CreateLogicallyAirGappedBackupVaultInput {

    static func urlPathProvider(_ value: CreateLogicallyAirGappedBackupVaultInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        return "/logically-air-gapped-backup-vaults/\(backupVaultName.urlPercentEncoding())"
    }
}

extension CreateReportPlanInput {

    static func urlPathProvider(_ value: CreateReportPlanInput) -> Swift.String? {
        return "/audit/report-plans"
    }
}

extension CreateRestoreTestingPlanInput {

    static func urlPathProvider(_ value: CreateRestoreTestingPlanInput) -> Swift.String? {
        return "/restore-testing/plans"
    }
}

extension CreateRestoreTestingSelectionInput {

    static func urlPathProvider(_ value: CreateRestoreTestingSelectionInput) -> Swift.String? {
        guard let restoreTestingPlanName = value.restoreTestingPlanName else {
            return nil
        }
        return "/restore-testing/plans/\(restoreTestingPlanName.urlPercentEncoding())/selections"
    }
}

extension DeleteBackupPlanInput {

    static func urlPathProvider(_ value: DeleteBackupPlanInput) -> Swift.String? {
        guard let backupPlanId = value.backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())"
    }
}

extension DeleteBackupSelectionInput {

    static func urlPathProvider(_ value: DeleteBackupSelectionInput) -> Swift.String? {
        guard let backupPlanId = value.backupPlanId else {
            return nil
        }
        guard let selectionId = value.selectionId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections/\(selectionId.urlPercentEncoding())"
    }
}

extension DeleteBackupVaultInput {

    static func urlPathProvider(_ value: DeleteBackupVaultInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())"
    }
}

extension DeleteBackupVaultAccessPolicyInput {

    static func urlPathProvider(_ value: DeleteBackupVaultAccessPolicyInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/access-policy"
    }
}

extension DeleteBackupVaultLockConfigurationInput {

    static func urlPathProvider(_ value: DeleteBackupVaultLockConfigurationInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/vault-lock"
    }
}

extension DeleteBackupVaultNotificationsInput {

    static func urlPathProvider(_ value: DeleteBackupVaultNotificationsInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/notification-configuration"
    }
}

extension DeleteFrameworkInput {

    static func urlPathProvider(_ value: DeleteFrameworkInput) -> Swift.String? {
        guard let frameworkName = value.frameworkName else {
            return nil
        }
        return "/audit/frameworks/\(frameworkName.urlPercentEncoding())"
    }
}

extension DeleteRecoveryPointInput {

    static func urlPathProvider(_ value: DeleteRecoveryPointInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = value.recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())"
    }
}

extension DeleteReportPlanInput {

    static func urlPathProvider(_ value: DeleteReportPlanInput) -> Swift.String? {
        guard let reportPlanName = value.reportPlanName else {
            return nil
        }
        return "/audit/report-plans/\(reportPlanName.urlPercentEncoding())"
    }
}

extension DeleteRestoreTestingPlanInput {

    static func urlPathProvider(_ value: DeleteRestoreTestingPlanInput) -> Swift.String? {
        guard let restoreTestingPlanName = value.restoreTestingPlanName else {
            return nil
        }
        return "/restore-testing/plans/\(restoreTestingPlanName.urlPercentEncoding())"
    }
}

extension DeleteRestoreTestingSelectionInput {

    static func urlPathProvider(_ value: DeleteRestoreTestingSelectionInput) -> Swift.String? {
        guard let restoreTestingPlanName = value.restoreTestingPlanName else {
            return nil
        }
        guard let restoreTestingSelectionName = value.restoreTestingSelectionName else {
            return nil
        }
        return "/restore-testing/plans/\(restoreTestingPlanName.urlPercentEncoding())/selections/\(restoreTestingSelectionName.urlPercentEncoding())"
    }
}

extension DescribeBackupJobInput {

    static func urlPathProvider(_ value: DescribeBackupJobInput) -> Swift.String? {
        guard let backupJobId = value.backupJobId else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())"
    }
}

extension DescribeBackupVaultInput {

    static func urlPathProvider(_ value: DescribeBackupVaultInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())"
    }
}

extension DescribeBackupVaultInput {

    static func queryItemProvider(_ value: DescribeBackupVaultInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let backupVaultAccountId = value.backupVaultAccountId {
            let backupVaultAccountIdQueryItem = Smithy.URIQueryItem(name: "backupVaultAccountId".urlPercentEncoding(), value: Swift.String(backupVaultAccountId).urlPercentEncoding())
            items.append(backupVaultAccountIdQueryItem)
        }
        return items
    }
}

extension DescribeCopyJobInput {

    static func urlPathProvider(_ value: DescribeCopyJobInput) -> Swift.String? {
        guard let copyJobId = value.copyJobId else {
            return nil
        }
        return "/copy-jobs/\(copyJobId.urlPercentEncoding())"
    }
}

extension DescribeFrameworkInput {

    static func urlPathProvider(_ value: DescribeFrameworkInput) -> Swift.String? {
        guard let frameworkName = value.frameworkName else {
            return nil
        }
        return "/audit/frameworks/\(frameworkName.urlPercentEncoding())"
    }
}

extension DescribeGlobalSettingsInput {

    static func urlPathProvider(_ value: DescribeGlobalSettingsInput) -> Swift.String? {
        return "/global-settings"
    }
}

extension DescribeProtectedResourceInput {

    static func urlPathProvider(_ value: DescribeProtectedResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())"
    }
}

extension DescribeRecoveryPointInput {

    static func urlPathProvider(_ value: DescribeRecoveryPointInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = value.recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())"
    }
}

extension DescribeRecoveryPointInput {

    static func queryItemProvider(_ value: DescribeRecoveryPointInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let backupVaultAccountId = value.backupVaultAccountId {
            let backupVaultAccountIdQueryItem = Smithy.URIQueryItem(name: "backupVaultAccountId".urlPercentEncoding(), value: Swift.String(backupVaultAccountId).urlPercentEncoding())
            items.append(backupVaultAccountIdQueryItem)
        }
        return items
    }
}

extension DescribeRegionSettingsInput {

    static func urlPathProvider(_ value: DescribeRegionSettingsInput) -> Swift.String? {
        return "/account-settings"
    }
}

extension DescribeReportJobInput {

    static func urlPathProvider(_ value: DescribeReportJobInput) -> Swift.String? {
        guard let reportJobId = value.reportJobId else {
            return nil
        }
        return "/audit/report-jobs/\(reportJobId.urlPercentEncoding())"
    }
}

extension DescribeReportPlanInput {

    static func urlPathProvider(_ value: DescribeReportPlanInput) -> Swift.String? {
        guard let reportPlanName = value.reportPlanName else {
            return nil
        }
        return "/audit/report-plans/\(reportPlanName.urlPercentEncoding())"
    }
}

extension DescribeRestoreJobInput {

    static func urlPathProvider(_ value: DescribeRestoreJobInput) -> Swift.String? {
        guard let restoreJobId = value.restoreJobId else {
            return nil
        }
        return "/restore-jobs/\(restoreJobId.urlPercentEncoding())"
    }
}

extension DisassociateRecoveryPointInput {

    static func urlPathProvider(_ value: DisassociateRecoveryPointInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = value.recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())/disassociate"
    }
}

extension DisassociateRecoveryPointFromParentInput {

    static func urlPathProvider(_ value: DisassociateRecoveryPointFromParentInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = value.recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())/parentAssociation"
    }
}

extension ExportBackupPlanTemplateInput {

    static func urlPathProvider(_ value: ExportBackupPlanTemplateInput) -> Swift.String? {
        guard let backupPlanId = value.backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/toTemplate"
    }
}

extension GetBackupPlanInput {

    static func urlPathProvider(_ value: GetBackupPlanInput) -> Swift.String? {
        guard let backupPlanId = value.backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())"
    }
}

extension GetBackupPlanInput {

    static func queryItemProvider(_ value: GetBackupPlanInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let versionId = value.versionId {
            let versionIdQueryItem = Smithy.URIQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension GetBackupPlanFromJSONInput {

    static func urlPathProvider(_ value: GetBackupPlanFromJSONInput) -> Swift.String? {
        return "/backup/template/json/toPlan"
    }
}

extension GetBackupPlanFromTemplateInput {

    static func urlPathProvider(_ value: GetBackupPlanFromTemplateInput) -> Swift.String? {
        guard let backupPlanTemplateId = value.backupPlanTemplateId else {
            return nil
        }
        return "/backup/template/plans/\(backupPlanTemplateId.urlPercentEncoding())/toPlan"
    }
}

extension GetBackupSelectionInput {

    static func urlPathProvider(_ value: GetBackupSelectionInput) -> Swift.String? {
        guard let backupPlanId = value.backupPlanId else {
            return nil
        }
        guard let selectionId = value.selectionId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections/\(selectionId.urlPercentEncoding())"
    }
}

extension GetBackupVaultAccessPolicyInput {

    static func urlPathProvider(_ value: GetBackupVaultAccessPolicyInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/access-policy"
    }
}

extension GetBackupVaultNotificationsInput {

    static func urlPathProvider(_ value: GetBackupVaultNotificationsInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/notification-configuration"
    }
}

extension GetLegalHoldInput {

    static func urlPathProvider(_ value: GetLegalHoldInput) -> Swift.String? {
        guard let legalHoldId = value.legalHoldId else {
            return nil
        }
        return "/legal-holds/\(legalHoldId.urlPercentEncoding())"
    }
}

extension GetRecoveryPointRestoreMetadataInput {

    static func urlPathProvider(_ value: GetRecoveryPointRestoreMetadataInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = value.recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())/restore-metadata"
    }
}

extension GetRecoveryPointRestoreMetadataInput {

    static func queryItemProvider(_ value: GetRecoveryPointRestoreMetadataInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let backupVaultAccountId = value.backupVaultAccountId {
            let backupVaultAccountIdQueryItem = Smithy.URIQueryItem(name: "backupVaultAccountId".urlPercentEncoding(), value: Swift.String(backupVaultAccountId).urlPercentEncoding())
            items.append(backupVaultAccountIdQueryItem)
        }
        return items
    }
}

extension GetRestoreJobMetadataInput {

    static func urlPathProvider(_ value: GetRestoreJobMetadataInput) -> Swift.String? {
        guard let restoreJobId = value.restoreJobId else {
            return nil
        }
        return "/restore-jobs/\(restoreJobId.urlPercentEncoding())/metadata"
    }
}

extension GetRestoreTestingInferredMetadataInput {

    static func urlPathProvider(_ value: GetRestoreTestingInferredMetadataInput) -> Swift.String? {
        return "/restore-testing/inferred-metadata"
    }
}

extension GetRestoreTestingInferredMetadataInput {

    static func queryItemProvider(_ value: GetRestoreTestingInferredMetadataInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let backupVaultName = value.backupVaultName else {
            let message = "Creating a URL Query Item failed. backupVaultName is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let backupVaultNameQueryItem = Smithy.URIQueryItem(name: "BackupVaultName".urlPercentEncoding(), value: Swift.String(backupVaultName).urlPercentEncoding())
        items.append(backupVaultNameQueryItem)
        guard let recoveryPointArn = value.recoveryPointArn else {
            let message = "Creating a URL Query Item failed. recoveryPointArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let recoveryPointArnQueryItem = Smithy.URIQueryItem(name: "RecoveryPointArn".urlPercentEncoding(), value: Swift.String(recoveryPointArn).urlPercentEncoding())
        items.append(recoveryPointArnQueryItem)
        if let backupVaultAccountId = value.backupVaultAccountId {
            let backupVaultAccountIdQueryItem = Smithy.URIQueryItem(name: "BackupVaultAccountId".urlPercentEncoding(), value: Swift.String(backupVaultAccountId).urlPercentEncoding())
            items.append(backupVaultAccountIdQueryItem)
        }
        return items
    }
}

extension GetRestoreTestingPlanInput {

    static func urlPathProvider(_ value: GetRestoreTestingPlanInput) -> Swift.String? {
        guard let restoreTestingPlanName = value.restoreTestingPlanName else {
            return nil
        }
        return "/restore-testing/plans/\(restoreTestingPlanName.urlPercentEncoding())"
    }
}

extension GetRestoreTestingSelectionInput {

    static func urlPathProvider(_ value: GetRestoreTestingSelectionInput) -> Swift.String? {
        guard let restoreTestingPlanName = value.restoreTestingPlanName else {
            return nil
        }
        guard let restoreTestingSelectionName = value.restoreTestingSelectionName else {
            return nil
        }
        return "/restore-testing/plans/\(restoreTestingPlanName.urlPercentEncoding())/selections/\(restoreTestingSelectionName.urlPercentEncoding())"
    }
}

extension GetSupportedResourceTypesInput {

    static func urlPathProvider(_ value: GetSupportedResourceTypesInput) -> Swift.String? {
        return "/supported-resource-types"
    }
}

extension ListBackupJobsInput {

    static func urlPathProvider(_ value: ListBackupJobsInput) -> Swift.String? {
        return "/backup-jobs"
    }
}

extension ListBackupJobsInput {

    static func queryItemProvider(_ value: ListBackupJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let byResourceType = value.byResourceType {
            let byResourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(byResourceType).urlPercentEncoding())
            items.append(byResourceTypeQueryItem)
        }
        if let byBackupVaultName = value.byBackupVaultName {
            let byBackupVaultNameQueryItem = Smithy.URIQueryItem(name: "backupVaultName".urlPercentEncoding(), value: Swift.String(byBackupVaultName).urlPercentEncoding())
            items.append(byBackupVaultNameQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let byResourceArn = value.byResourceArn {
            let byResourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(byResourceArn).urlPercentEncoding())
            items.append(byResourceArnQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let byState = value.byState {
            let byStateQueryItem = Smithy.URIQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(byState.rawValue).urlPercentEncoding())
            items.append(byStateQueryItem)
        }
        if let byAccountId = value.byAccountId {
            let byAccountIdQueryItem = Smithy.URIQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(byAccountId).urlPercentEncoding())
            items.append(byAccountIdQueryItem)
        }
        if let byCreatedAfter = value.byCreatedAfter {
            let byCreatedAfterQueryItem = Smithy.URIQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCreatedAfter)).urlPercentEncoding())
            items.append(byCreatedAfterQueryItem)
        }
        if let byCreatedBefore = value.byCreatedBefore {
            let byCreatedBeforeQueryItem = Smithy.URIQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCreatedBefore)).urlPercentEncoding())
            items.append(byCreatedBeforeQueryItem)
        }
        if let byCompleteAfter = value.byCompleteAfter {
            let byCompleteAfterQueryItem = Smithy.URIQueryItem(name: "completeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCompleteAfter)).urlPercentEncoding())
            items.append(byCompleteAfterQueryItem)
        }
        if let byParentJobId = value.byParentJobId {
            let byParentJobIdQueryItem = Smithy.URIQueryItem(name: "parentJobId".urlPercentEncoding(), value: Swift.String(byParentJobId).urlPercentEncoding())
            items.append(byParentJobIdQueryItem)
        }
        if let byMessageCategory = value.byMessageCategory {
            let byMessageCategoryQueryItem = Smithy.URIQueryItem(name: "messageCategory".urlPercentEncoding(), value: Swift.String(byMessageCategory).urlPercentEncoding())
            items.append(byMessageCategoryQueryItem)
        }
        if let byCompleteBefore = value.byCompleteBefore {
            let byCompleteBeforeQueryItem = Smithy.URIQueryItem(name: "completeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCompleteBefore)).urlPercentEncoding())
            items.append(byCompleteBeforeQueryItem)
        }
        return items
    }
}

extension ListBackupJobSummariesInput {

    static func urlPathProvider(_ value: ListBackupJobSummariesInput) -> Swift.String? {
        return "/audit/backup-job-summaries"
    }
}

extension ListBackupJobSummariesInput {

    static func queryItemProvider(_ value: ListBackupJobSummariesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let aggregationPeriod = value.aggregationPeriod {
            let aggregationPeriodQueryItem = Smithy.URIQueryItem(name: "AggregationPeriod".urlPercentEncoding(), value: Swift.String(aggregationPeriod.rawValue).urlPercentEncoding())
            items.append(aggregationPeriodQueryItem)
        }
        if let accountId = value.accountId {
            let accountIdQueryItem = Smithy.URIQueryItem(name: "AccountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
            items.append(accountIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let state = value.state {
            let stateQueryItem = Smithy.URIQueryItem(name: "State".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
            items.append(stateQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let resourceType = value.resourceType {
            let resourceTypeQueryItem = Smithy.URIQueryItem(name: "ResourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        if let messageCategory = value.messageCategory {
            let messageCategoryQueryItem = Smithy.URIQueryItem(name: "MessageCategory".urlPercentEncoding(), value: Swift.String(messageCategory).urlPercentEncoding())
            items.append(messageCategoryQueryItem)
        }
        return items
    }
}

extension ListBackupPlansInput {

    static func urlPathProvider(_ value: ListBackupPlansInput) -> Swift.String? {
        return "/backup/plans"
    }
}

extension ListBackupPlansInput {

    static func queryItemProvider(_ value: ListBackupPlansInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let includeDeleted = value.includeDeleted {
            let includeDeletedQueryItem = Smithy.URIQueryItem(name: "includeDeleted".urlPercentEncoding(), value: Swift.String(includeDeleted).urlPercentEncoding())
            items.append(includeDeletedQueryItem)
        }
        return items
    }
}

extension ListBackupPlanTemplatesInput {

    static func urlPathProvider(_ value: ListBackupPlanTemplatesInput) -> Swift.String? {
        return "/backup/template/plans"
    }
}

extension ListBackupPlanTemplatesInput {

    static func queryItemProvider(_ value: ListBackupPlanTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListBackupPlanVersionsInput {

    static func urlPathProvider(_ value: ListBackupPlanVersionsInput) -> Swift.String? {
        guard let backupPlanId = value.backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/versions"
    }
}

extension ListBackupPlanVersionsInput {

    static func queryItemProvider(_ value: ListBackupPlanVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListBackupSelectionsInput {

    static func urlPathProvider(_ value: ListBackupSelectionsInput) -> Swift.String? {
        guard let backupPlanId = value.backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections"
    }
}

extension ListBackupSelectionsInput {

    static func queryItemProvider(_ value: ListBackupSelectionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListBackupVaultsInput {

    static func urlPathProvider(_ value: ListBackupVaultsInput) -> Swift.String? {
        return "/backup-vaults"
    }
}

extension ListBackupVaultsInput {

    static func queryItemProvider(_ value: ListBackupVaultsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let byShared = value.byShared {
            let bySharedQueryItem = Smithy.URIQueryItem(name: "shared".urlPercentEncoding(), value: Swift.String(byShared).urlPercentEncoding())
            items.append(bySharedQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let byVaultType = value.byVaultType {
            let byVaultTypeQueryItem = Smithy.URIQueryItem(name: "vaultType".urlPercentEncoding(), value: Swift.String(byVaultType.rawValue).urlPercentEncoding())
            items.append(byVaultTypeQueryItem)
        }
        return items
    }
}

extension ListCopyJobsInput {

    static func urlPathProvider(_ value: ListCopyJobsInput) -> Swift.String? {
        return "/copy-jobs"
    }
}

extension ListCopyJobsInput {

    static func queryItemProvider(_ value: ListCopyJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let byResourceType = value.byResourceType {
            let byResourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(byResourceType).urlPercentEncoding())
            items.append(byResourceTypeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let byResourceArn = value.byResourceArn {
            let byResourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(byResourceArn).urlPercentEncoding())
            items.append(byResourceArnQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let byState = value.byState {
            let byStateQueryItem = Smithy.URIQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(byState.rawValue).urlPercentEncoding())
            items.append(byStateQueryItem)
        }
        if let byAccountId = value.byAccountId {
            let byAccountIdQueryItem = Smithy.URIQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(byAccountId).urlPercentEncoding())
            items.append(byAccountIdQueryItem)
        }
        if let byCreatedAfter = value.byCreatedAfter {
            let byCreatedAfterQueryItem = Smithy.URIQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCreatedAfter)).urlPercentEncoding())
            items.append(byCreatedAfterQueryItem)
        }
        if let byCreatedBefore = value.byCreatedBefore {
            let byCreatedBeforeQueryItem = Smithy.URIQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCreatedBefore)).urlPercentEncoding())
            items.append(byCreatedBeforeQueryItem)
        }
        if let byCompleteAfter = value.byCompleteAfter {
            let byCompleteAfterQueryItem = Smithy.URIQueryItem(name: "completeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCompleteAfter)).urlPercentEncoding())
            items.append(byCompleteAfterQueryItem)
        }
        if let byDestinationVaultArn = value.byDestinationVaultArn {
            let byDestinationVaultArnQueryItem = Smithy.URIQueryItem(name: "destinationVaultArn".urlPercentEncoding(), value: Swift.String(byDestinationVaultArn).urlPercentEncoding())
            items.append(byDestinationVaultArnQueryItem)
        }
        if let byParentJobId = value.byParentJobId {
            let byParentJobIdQueryItem = Smithy.URIQueryItem(name: "parentJobId".urlPercentEncoding(), value: Swift.String(byParentJobId).urlPercentEncoding())
            items.append(byParentJobIdQueryItem)
        }
        if let byMessageCategory = value.byMessageCategory {
            let byMessageCategoryQueryItem = Smithy.URIQueryItem(name: "messageCategory".urlPercentEncoding(), value: Swift.String(byMessageCategory).urlPercentEncoding())
            items.append(byMessageCategoryQueryItem)
        }
        if let byCompleteBefore = value.byCompleteBefore {
            let byCompleteBeforeQueryItem = Smithy.URIQueryItem(name: "completeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCompleteBefore)).urlPercentEncoding())
            items.append(byCompleteBeforeQueryItem)
        }
        return items
    }
}

extension ListCopyJobSummariesInput {

    static func urlPathProvider(_ value: ListCopyJobSummariesInput) -> Swift.String? {
        return "/audit/copy-job-summaries"
    }
}

extension ListCopyJobSummariesInput {

    static func queryItemProvider(_ value: ListCopyJobSummariesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let aggregationPeriod = value.aggregationPeriod {
            let aggregationPeriodQueryItem = Smithy.URIQueryItem(name: "AggregationPeriod".urlPercentEncoding(), value: Swift.String(aggregationPeriod.rawValue).urlPercentEncoding())
            items.append(aggregationPeriodQueryItem)
        }
        if let accountId = value.accountId {
            let accountIdQueryItem = Smithy.URIQueryItem(name: "AccountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
            items.append(accountIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let state = value.state {
            let stateQueryItem = Smithy.URIQueryItem(name: "State".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
            items.append(stateQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let resourceType = value.resourceType {
            let resourceTypeQueryItem = Smithy.URIQueryItem(name: "ResourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        if let messageCategory = value.messageCategory {
            let messageCategoryQueryItem = Smithy.URIQueryItem(name: "MessageCategory".urlPercentEncoding(), value: Swift.String(messageCategory).urlPercentEncoding())
            items.append(messageCategoryQueryItem)
        }
        return items
    }
}

extension ListFrameworksInput {

    static func urlPathProvider(_ value: ListFrameworksInput) -> Swift.String? {
        return "/audit/frameworks"
    }
}

extension ListFrameworksInput {

    static func queryItemProvider(_ value: ListFrameworksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListLegalHoldsInput {

    static func urlPathProvider(_ value: ListLegalHoldsInput) -> Swift.String? {
        return "/legal-holds"
    }
}

extension ListLegalHoldsInput {

    static func queryItemProvider(_ value: ListLegalHoldsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProtectedResourcesInput {

    static func urlPathProvider(_ value: ListProtectedResourcesInput) -> Swift.String? {
        return "/resources"
    }
}

extension ListProtectedResourcesInput {

    static func queryItemProvider(_ value: ListProtectedResourcesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProtectedResourcesByBackupVaultInput {

    static func urlPathProvider(_ value: ListProtectedResourcesByBackupVaultInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/resources"
    }
}

extension ListProtectedResourcesByBackupVaultInput {

    static func queryItemProvider(_ value: ListProtectedResourcesByBackupVaultInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let backupVaultAccountId = value.backupVaultAccountId {
            let backupVaultAccountIdQueryItem = Smithy.URIQueryItem(name: "backupVaultAccountId".urlPercentEncoding(), value: Swift.String(backupVaultAccountId).urlPercentEncoding())
            items.append(backupVaultAccountIdQueryItem)
        }
        return items
    }
}

extension ListRecoveryPointsByBackupVaultInput {

    static func urlPathProvider(_ value: ListRecoveryPointsByBackupVaultInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points"
    }
}

extension ListRecoveryPointsByBackupVaultInput {

    static func queryItemProvider(_ value: ListRecoveryPointsByBackupVaultInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let byResourceType = value.byResourceType {
            let byResourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(byResourceType).urlPercentEncoding())
            items.append(byResourceTypeQueryItem)
        }
        if let byCreatedBefore = value.byCreatedBefore {
            let byCreatedBeforeQueryItem = Smithy.URIQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCreatedBefore)).urlPercentEncoding())
            items.append(byCreatedBeforeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let byResourceArn = value.byResourceArn {
            let byResourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(byResourceArn).urlPercentEncoding())
            items.append(byResourceArnQueryItem)
        }
        if let byBackupPlanId = value.byBackupPlanId {
            let byBackupPlanIdQueryItem = Smithy.URIQueryItem(name: "backupPlanId".urlPercentEncoding(), value: Swift.String(byBackupPlanId).urlPercentEncoding())
            items.append(byBackupPlanIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let byParentRecoveryPointArn = value.byParentRecoveryPointArn {
            let byParentRecoveryPointArnQueryItem = Smithy.URIQueryItem(name: "parentRecoveryPointArn".urlPercentEncoding(), value: Swift.String(byParentRecoveryPointArn).urlPercentEncoding())
            items.append(byParentRecoveryPointArnQueryItem)
        }
        if let backupVaultAccountId = value.backupVaultAccountId {
            let backupVaultAccountIdQueryItem = Smithy.URIQueryItem(name: "backupVaultAccountId".urlPercentEncoding(), value: Swift.String(backupVaultAccountId).urlPercentEncoding())
            items.append(backupVaultAccountIdQueryItem)
        }
        if let byCreatedAfter = value.byCreatedAfter {
            let byCreatedAfterQueryItem = Smithy.URIQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCreatedAfter)).urlPercentEncoding())
            items.append(byCreatedAfterQueryItem)
        }
        return items
    }
}

extension ListRecoveryPointsByLegalHoldInput {

    static func urlPathProvider(_ value: ListRecoveryPointsByLegalHoldInput) -> Swift.String? {
        guard let legalHoldId = value.legalHoldId else {
            return nil
        }
        return "/legal-holds/\(legalHoldId.urlPercentEncoding())/recovery-points"
    }
}

extension ListRecoveryPointsByLegalHoldInput {

    static func queryItemProvider(_ value: ListRecoveryPointsByLegalHoldInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRecoveryPointsByResourceInput {

    static func urlPathProvider(_ value: ListRecoveryPointsByResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())/recovery-points"
    }
}

extension ListRecoveryPointsByResourceInput {

    static func queryItemProvider(_ value: ListRecoveryPointsByResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let managedByAWSBackupOnly = value.managedByAWSBackupOnly {
            let managedByAWSBackupOnlyQueryItem = Smithy.URIQueryItem(name: "managedByAWSBackupOnly".urlPercentEncoding(), value: Swift.String(managedByAWSBackupOnly).urlPercentEncoding())
            items.append(managedByAWSBackupOnlyQueryItem)
        }
        return items
    }
}

extension ListReportJobsInput {

    static func urlPathProvider(_ value: ListReportJobsInput) -> Swift.String? {
        return "/audit/report-jobs"
    }
}

extension ListReportJobsInput {

    static func queryItemProvider(_ value: ListReportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let byReportPlanName = value.byReportPlanName {
            let byReportPlanNameQueryItem = Smithy.URIQueryItem(name: "ReportPlanName".urlPercentEncoding(), value: Swift.String(byReportPlanName).urlPercentEncoding())
            items.append(byReportPlanNameQueryItem)
        }
        if let byCreationAfter = value.byCreationAfter {
            let byCreationAfterQueryItem = Smithy.URIQueryItem(name: "CreationAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCreationAfter)).urlPercentEncoding())
            items.append(byCreationAfterQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let byStatus = value.byStatus {
            let byStatusQueryItem = Smithy.URIQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(byStatus).urlPercentEncoding())
            items.append(byStatusQueryItem)
        }
        if let byCreationBefore = value.byCreationBefore {
            let byCreationBeforeQueryItem = Smithy.URIQueryItem(name: "CreationBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCreationBefore)).urlPercentEncoding())
            items.append(byCreationBeforeQueryItem)
        }
        return items
    }
}

extension ListReportPlansInput {

    static func urlPathProvider(_ value: ListReportPlansInput) -> Swift.String? {
        return "/audit/report-plans"
    }
}

extension ListReportPlansInput {

    static func queryItemProvider(_ value: ListReportPlansInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRestoreJobsInput {

    static func urlPathProvider(_ value: ListRestoreJobsInput) -> Swift.String? {
        return "/restore-jobs"
    }
}

extension ListRestoreJobsInput {

    static func queryItemProvider(_ value: ListRestoreJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let byResourceType = value.byResourceType {
            let byResourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(byResourceType).urlPercentEncoding())
            items.append(byResourceTypeQueryItem)
        }
        if let byCreatedBefore = value.byCreatedBefore {
            let byCreatedBeforeQueryItem = Smithy.URIQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCreatedBefore)).urlPercentEncoding())
            items.append(byCreatedBeforeQueryItem)
        }
        if let byCompleteAfter = value.byCompleteAfter {
            let byCompleteAfterQueryItem = Smithy.URIQueryItem(name: "completeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCompleteAfter)).urlPercentEncoding())
            items.append(byCompleteAfterQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let byAccountId = value.byAccountId {
            let byAccountIdQueryItem = Smithy.URIQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(byAccountId).urlPercentEncoding())
            items.append(byAccountIdQueryItem)
        }
        if let byCompleteBefore = value.byCompleteBefore {
            let byCompleteBeforeQueryItem = Smithy.URIQueryItem(name: "completeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCompleteBefore)).urlPercentEncoding())
            items.append(byCompleteBeforeQueryItem)
        }
        if let byCreatedAfter = value.byCreatedAfter {
            let byCreatedAfterQueryItem = Smithy.URIQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byCreatedAfter)).urlPercentEncoding())
            items.append(byCreatedAfterQueryItem)
        }
        if let byStatus = value.byStatus {
            let byStatusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(byStatus.rawValue).urlPercentEncoding())
            items.append(byStatusQueryItem)
        }
        if let byRestoreTestingPlanArn = value.byRestoreTestingPlanArn {
            let byRestoreTestingPlanArnQueryItem = Smithy.URIQueryItem(name: "restoreTestingPlanArn".urlPercentEncoding(), value: Swift.String(byRestoreTestingPlanArn).urlPercentEncoding())
            items.append(byRestoreTestingPlanArnQueryItem)
        }
        return items
    }
}

extension ListRestoreJobsByProtectedResourceInput {

    static func urlPathProvider(_ value: ListRestoreJobsByProtectedResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())/restore-jobs"
    }
}

extension ListRestoreJobsByProtectedResourceInput {

    static func queryItemProvider(_ value: ListRestoreJobsByProtectedResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let byRecoveryPointCreationDateAfter = value.byRecoveryPointCreationDateAfter {
            let byRecoveryPointCreationDateAfterQueryItem = Smithy.URIQueryItem(name: "recoveryPointCreationDateAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byRecoveryPointCreationDateAfter)).urlPercentEncoding())
            items.append(byRecoveryPointCreationDateAfterQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let byStatus = value.byStatus {
            let byStatusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(byStatus.rawValue).urlPercentEncoding())
            items.append(byStatusQueryItem)
        }
        if let byRecoveryPointCreationDateBefore = value.byRecoveryPointCreationDateBefore {
            let byRecoveryPointCreationDateBeforeQueryItem = Smithy.URIQueryItem(name: "recoveryPointCreationDateBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: byRecoveryPointCreationDateBefore)).urlPercentEncoding())
            items.append(byRecoveryPointCreationDateBeforeQueryItem)
        }
        return items
    }
}

extension ListRestoreJobSummariesInput {

    static func urlPathProvider(_ value: ListRestoreJobSummariesInput) -> Swift.String? {
        return "/audit/restore-job-summaries"
    }
}

extension ListRestoreJobSummariesInput {

    static func queryItemProvider(_ value: ListRestoreJobSummariesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let aggregationPeriod = value.aggregationPeriod {
            let aggregationPeriodQueryItem = Smithy.URIQueryItem(name: "AggregationPeriod".urlPercentEncoding(), value: Swift.String(aggregationPeriod.rawValue).urlPercentEncoding())
            items.append(aggregationPeriodQueryItem)
        }
        if let accountId = value.accountId {
            let accountIdQueryItem = Smithy.URIQueryItem(name: "AccountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
            items.append(accountIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let state = value.state {
            let stateQueryItem = Smithy.URIQueryItem(name: "State".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
            items.append(stateQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let resourceType = value.resourceType {
            let resourceTypeQueryItem = Smithy.URIQueryItem(name: "ResourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension ListRestoreTestingPlansInput {

    static func urlPathProvider(_ value: ListRestoreTestingPlansInput) -> Swift.String? {
        return "/restore-testing/plans"
    }
}

extension ListRestoreTestingPlansInput {

    static func queryItemProvider(_ value: ListRestoreTestingPlansInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRestoreTestingSelectionsInput {

    static func urlPathProvider(_ value: ListRestoreTestingSelectionsInput) -> Swift.String? {
        guard let restoreTestingPlanName = value.restoreTestingPlanName else {
            return nil
        }
        return "/restore-testing/plans/\(restoreTestingPlanName.urlPercentEncoding())/selections"
    }
}

extension ListRestoreTestingSelectionsInput {

    static func queryItemProvider(_ value: ListRestoreTestingSelectionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsInput {

    static func urlPathProvider(_ value: ListTagsInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListTagsInput {

    static func queryItemProvider(_ value: ListTagsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension PutBackupVaultAccessPolicyInput {

    static func urlPathProvider(_ value: PutBackupVaultAccessPolicyInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/access-policy"
    }
}

extension PutBackupVaultLockConfigurationInput {

    static func urlPathProvider(_ value: PutBackupVaultLockConfigurationInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/vault-lock"
    }
}

extension PutBackupVaultNotificationsInput {

    static func urlPathProvider(_ value: PutBackupVaultNotificationsInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/notification-configuration"
    }
}

extension PutRestoreValidationResultInput {

    static func urlPathProvider(_ value: PutRestoreValidationResultInput) -> Swift.String? {
        guard let restoreJobId = value.restoreJobId else {
            return nil
        }
        return "/restore-jobs/\(restoreJobId.urlPercentEncoding())/validations"
    }
}

extension StartBackupJobInput {

    static func urlPathProvider(_ value: StartBackupJobInput) -> Swift.String? {
        return "/backup-jobs"
    }
}

extension StartCopyJobInput {

    static func urlPathProvider(_ value: StartCopyJobInput) -> Swift.String? {
        return "/copy-jobs"
    }
}

extension StartReportJobInput {

    static func urlPathProvider(_ value: StartReportJobInput) -> Swift.String? {
        guard let reportPlanName = value.reportPlanName else {
            return nil
        }
        return "/audit/report-jobs/\(reportPlanName.urlPercentEncoding())"
    }
}

extension StartRestoreJobInput {

    static func urlPathProvider(_ value: StartRestoreJobInput) -> Swift.String? {
        return "/restore-jobs"
    }
}

extension StopBackupJobInput {

    static func urlPathProvider(_ value: StopBackupJobInput) -> Swift.String? {
        guard let backupJobId = value.backupJobId else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/untag/\(resourceArn.urlPercentEncoding())"
    }
}

extension UpdateBackupPlanInput {

    static func urlPathProvider(_ value: UpdateBackupPlanInput) -> Swift.String? {
        guard let backupPlanId = value.backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())"
    }
}

extension UpdateFrameworkInput {

    static func urlPathProvider(_ value: UpdateFrameworkInput) -> Swift.String? {
        guard let frameworkName = value.frameworkName else {
            return nil
        }
        return "/audit/frameworks/\(frameworkName.urlPercentEncoding())"
    }
}

extension UpdateGlobalSettingsInput {

    static func urlPathProvider(_ value: UpdateGlobalSettingsInput) -> Swift.String? {
        return "/global-settings"
    }
}

extension UpdateRecoveryPointLifecycleInput {

    static func urlPathProvider(_ value: UpdateRecoveryPointLifecycleInput) -> Swift.String? {
        guard let backupVaultName = value.backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = value.recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())"
    }
}

extension UpdateRegionSettingsInput {

    static func urlPathProvider(_ value: UpdateRegionSettingsInput) -> Swift.String? {
        return "/account-settings"
    }
}

extension UpdateReportPlanInput {

    static func urlPathProvider(_ value: UpdateReportPlanInput) -> Swift.String? {
        guard let reportPlanName = value.reportPlanName else {
            return nil
        }
        return "/audit/report-plans/\(reportPlanName.urlPercentEncoding())"
    }
}

extension UpdateRestoreTestingPlanInput {

    static func urlPathProvider(_ value: UpdateRestoreTestingPlanInput) -> Swift.String? {
        guard let restoreTestingPlanName = value.restoreTestingPlanName else {
            return nil
        }
        return "/restore-testing/plans/\(restoreTestingPlanName.urlPercentEncoding())"
    }
}

extension UpdateRestoreTestingSelectionInput {

    static func urlPathProvider(_ value: UpdateRestoreTestingSelectionInput) -> Swift.String? {
        guard let restoreTestingPlanName = value.restoreTestingPlanName else {
            return nil
        }
        guard let restoreTestingSelectionName = value.restoreTestingSelectionName else {
            return nil
        }
        return "/restore-testing/plans/\(restoreTestingPlanName.urlPercentEncoding())/selections/\(restoreTestingSelectionName.urlPercentEncoding())"
    }
}

extension CreateBackupPlanInput {

    static func write(value: CreateBackupPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupPlan"].write(value.backupPlan, with: BackupClientTypes.BackupPlanInput.write(value:to:))
        try writer["BackupPlanTags"].writeMap(value.backupPlanTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["CreatorRequestId"].write(value.creatorRequestId)
    }
}

extension CreateBackupSelectionInput {

    static func write(value: CreateBackupSelectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupSelection"].write(value.backupSelection, with: BackupClientTypes.BackupSelection.write(value:to:))
        try writer["CreatorRequestId"].write(value.creatorRequestId)
    }
}

extension CreateBackupVaultInput {

    static func write(value: CreateBackupVaultInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupVaultTags"].writeMap(value.backupVaultTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["EncryptionKeyArn"].write(value.encryptionKeyArn)
    }
}

extension CreateFrameworkInput {

    static func write(value: CreateFrameworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FrameworkControls"].writeList(value.frameworkControls, memberWritingClosure: BackupClientTypes.FrameworkControl.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FrameworkDescription"].write(value.frameworkDescription)
        try writer["FrameworkName"].write(value.frameworkName)
        try writer["FrameworkTags"].writeMap(value.frameworkTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
    }
}

extension CreateLegalHoldInput {

    static func write(value: CreateLegalHoldInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["RecoveryPointSelection"].write(value.recoveryPointSelection, with: BackupClientTypes.RecoveryPointSelection.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Title"].write(value.title)
    }
}

extension CreateLogicallyAirGappedBackupVaultInput {

    static func write(value: CreateLogicallyAirGappedBackupVaultInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupVaultTags"].writeMap(value.backupVaultTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["MaxRetentionDays"].write(value.maxRetentionDays)
        try writer["MinRetentionDays"].write(value.minRetentionDays)
    }
}

extension CreateReportPlanInput {

    static func write(value: CreateReportPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["ReportDeliveryChannel"].write(value.reportDeliveryChannel, with: BackupClientTypes.ReportDeliveryChannel.write(value:to:))
        try writer["ReportPlanDescription"].write(value.reportPlanDescription)
        try writer["ReportPlanName"].write(value.reportPlanName)
        try writer["ReportPlanTags"].writeMap(value.reportPlanTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ReportSetting"].write(value.reportSetting, with: BackupClientTypes.ReportSetting.write(value:to:))
    }
}

extension CreateRestoreTestingPlanInput {

    static func write(value: CreateRestoreTestingPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["RestoreTestingPlan"].write(value.restoreTestingPlan, with: BackupClientTypes.RestoreTestingPlanForCreate.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateRestoreTestingSelectionInput {

    static func write(value: CreateRestoreTestingSelectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["RestoreTestingSelection"].write(value.restoreTestingSelection, with: BackupClientTypes.RestoreTestingSelectionForCreate.write(value:to:))
    }
}

extension GetBackupPlanFromJSONInput {

    static func write(value: GetBackupPlanFromJSONInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupPlanTemplateJson"].write(value.backupPlanTemplateJson)
    }
}

extension PutBackupVaultAccessPolicyInput {

    static func write(value: PutBackupVaultAccessPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Policy"].write(value.policy)
    }
}

extension PutBackupVaultLockConfigurationInput {

    static func write(value: PutBackupVaultLockConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChangeableForDays"].write(value.changeableForDays)
        try writer["MaxRetentionDays"].write(value.maxRetentionDays)
        try writer["MinRetentionDays"].write(value.minRetentionDays)
    }
}

extension PutBackupVaultNotificationsInput {

    static func write(value: PutBackupVaultNotificationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupVaultEvents"].writeList(value.backupVaultEvents, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BackupClientTypes.BackupVaultEvent>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SNSTopicArn"].write(value.snsTopicArn)
    }
}

extension PutRestoreValidationResultInput {

    static func write(value: PutRestoreValidationResultInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValidationStatus"].write(value.validationStatus)
        try writer["ValidationStatusMessage"].write(value.validationStatusMessage)
    }
}

extension StartBackupJobInput {

    static func write(value: StartBackupJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupOptions"].writeMap(value.backupOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["BackupVaultName"].write(value.backupVaultName)
        try writer["CompleteWindowMinutes"].write(value.completeWindowMinutes)
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["Lifecycle"].write(value.lifecycle, with: BackupClientTypes.Lifecycle.write(value:to:))
        try writer["RecoveryPointTags"].writeMap(value.recoveryPointTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["StartWindowMinutes"].write(value.startWindowMinutes)
    }
}

extension StartCopyJobInput {

    static func write(value: StartCopyJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationBackupVaultArn"].write(value.destinationBackupVaultArn)
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["Lifecycle"].write(value.lifecycle, with: BackupClientTypes.Lifecycle.write(value:to:))
        try writer["RecoveryPointArn"].write(value.recoveryPointArn)
        try writer["SourceBackupVaultName"].write(value.sourceBackupVaultName)
    }
}

extension StartReportJobInput {

    static func write(value: StartReportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdempotencyToken"].write(value.idempotencyToken)
    }
}

extension StartRestoreJobInput {

    static func write(value: StartRestoreJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CopySourceTagsToRestoredResource"].write(value.copySourceTagsToRestoredResource)
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["Metadata"].writeMap(value.metadata, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RecoveryPointArn"].write(value.recoveryPointArn)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagKeyList"].writeList(value.tagKeyList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateBackupPlanInput {

    static func write(value: UpdateBackupPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupPlan"].write(value.backupPlan, with: BackupClientTypes.BackupPlanInput.write(value:to:))
    }
}

extension UpdateFrameworkInput {

    static func write(value: UpdateFrameworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FrameworkControls"].writeList(value.frameworkControls, memberWritingClosure: BackupClientTypes.FrameworkControl.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FrameworkDescription"].write(value.frameworkDescription)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
    }
}

extension UpdateGlobalSettingsInput {

    static func write(value: UpdateGlobalSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GlobalSettings"].writeMap(value.globalSettings, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateRecoveryPointLifecycleInput {

    static func write(value: UpdateRecoveryPointLifecycleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Lifecycle"].write(value.lifecycle, with: BackupClientTypes.Lifecycle.write(value:to:))
    }
}

extension UpdateRegionSettingsInput {

    static func write(value: UpdateRegionSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceTypeManagementPreference"].writeMap(value.resourceTypeManagementPreference, valueWritingClosure: SmithyReadWrite.WritingClosures.writeBool(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ResourceTypeOptInPreference"].writeMap(value.resourceTypeOptInPreference, valueWritingClosure: SmithyReadWrite.WritingClosures.writeBool(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateReportPlanInput {

    static func write(value: UpdateReportPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["ReportDeliveryChannel"].write(value.reportDeliveryChannel, with: BackupClientTypes.ReportDeliveryChannel.write(value:to:))
        try writer["ReportPlanDescription"].write(value.reportPlanDescription)
        try writer["ReportSetting"].write(value.reportSetting, with: BackupClientTypes.ReportSetting.write(value:to:))
    }
}

extension UpdateRestoreTestingPlanInput {

    static func write(value: UpdateRestoreTestingPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RestoreTestingPlan"].write(value.restoreTestingPlan, with: BackupClientTypes.RestoreTestingPlanForUpdate.write(value:to:))
    }
}

extension UpdateRestoreTestingSelectionInput {

    static func write(value: UpdateRestoreTestingSelectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RestoreTestingSelection"].write(value.restoreTestingSelection, with: BackupClientTypes.RestoreTestingSelectionForUpdate.write(value:to:))
    }
}

extension CancelLegalHoldOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelLegalHoldOutput {
        return CancelLegalHoldOutput()
    }
}

extension CreateBackupPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBackupPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBackupPlanOutput()
        value.advancedBackupSettings = try reader["AdvancedBackupSettings"].readListIfPresent(memberReadingClosure: BackupClientTypes.AdvancedBackupSetting.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.backupPlanArn = try reader["BackupPlanArn"].readIfPresent()
        value.backupPlanId = try reader["BackupPlanId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.versionId = try reader["VersionId"].readIfPresent()
        return value
    }
}

extension CreateBackupSelectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBackupSelectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBackupSelectionOutput()
        value.backupPlanId = try reader["BackupPlanId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.selectionId = try reader["SelectionId"].readIfPresent()
        return value
    }
}

extension CreateBackupVaultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBackupVaultOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBackupVaultOutput()
        value.backupVaultArn = try reader["BackupVaultArn"].readIfPresent()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension CreateFrameworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFrameworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFrameworkOutput()
        value.frameworkArn = try reader["FrameworkArn"].readIfPresent()
        value.frameworkName = try reader["FrameworkName"].readIfPresent()
        return value
    }
}

extension CreateLegalHoldOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLegalHoldOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLegalHoldOutput()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.legalHoldArn = try reader["LegalHoldArn"].readIfPresent()
        value.legalHoldId = try reader["LegalHoldId"].readIfPresent()
        value.recoveryPointSelection = try reader["RecoveryPointSelection"].readIfPresent(with: BackupClientTypes.RecoveryPointSelection.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        return value
    }
}

extension CreateLogicallyAirGappedBackupVaultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLogicallyAirGappedBackupVaultOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLogicallyAirGappedBackupVaultOutput()
        value.backupVaultArn = try reader["BackupVaultArn"].readIfPresent()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vaultState = try reader["VaultState"].readIfPresent()
        return value
    }
}

extension CreateReportPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateReportPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateReportPlanOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.reportPlanArn = try reader["ReportPlanArn"].readIfPresent()
        value.reportPlanName = try reader["ReportPlanName"].readIfPresent()
        return value
    }
}

extension CreateRestoreTestingPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRestoreTestingPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRestoreTestingPlanOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.restoreTestingPlanArn = try reader["RestoreTestingPlanArn"].readIfPresent() ?? ""
        value.restoreTestingPlanName = try reader["RestoreTestingPlanName"].readIfPresent() ?? ""
        return value
    }
}

extension CreateRestoreTestingSelectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRestoreTestingSelectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRestoreTestingSelectionOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.restoreTestingPlanArn = try reader["RestoreTestingPlanArn"].readIfPresent() ?? ""
        value.restoreTestingPlanName = try reader["RestoreTestingPlanName"].readIfPresent() ?? ""
        value.restoreTestingSelectionName = try reader["RestoreTestingSelectionName"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteBackupPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBackupPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBackupPlanOutput()
        value.backupPlanArn = try reader["BackupPlanArn"].readIfPresent()
        value.backupPlanId = try reader["BackupPlanId"].readIfPresent()
        value.deletionDate = try reader["DeletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.versionId = try reader["VersionId"].readIfPresent()
        return value
    }
}

extension DeleteBackupSelectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBackupSelectionOutput {
        return DeleteBackupSelectionOutput()
    }
}

extension DeleteBackupVaultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBackupVaultOutput {
        return DeleteBackupVaultOutput()
    }
}

extension DeleteBackupVaultAccessPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBackupVaultAccessPolicyOutput {
        return DeleteBackupVaultAccessPolicyOutput()
    }
}

extension DeleteBackupVaultLockConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBackupVaultLockConfigurationOutput {
        return DeleteBackupVaultLockConfigurationOutput()
    }
}

extension DeleteBackupVaultNotificationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBackupVaultNotificationsOutput {
        return DeleteBackupVaultNotificationsOutput()
    }
}

extension DeleteFrameworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFrameworkOutput {
        return DeleteFrameworkOutput()
    }
}

extension DeleteRecoveryPointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRecoveryPointOutput {
        return DeleteRecoveryPointOutput()
    }
}

extension DeleteReportPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteReportPlanOutput {
        return DeleteReportPlanOutput()
    }
}

extension DeleteRestoreTestingPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRestoreTestingPlanOutput {
        return DeleteRestoreTestingPlanOutput()
    }
}

extension DeleteRestoreTestingSelectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRestoreTestingSelectionOutput {
        return DeleteRestoreTestingSelectionOutput()
    }
}

extension DescribeBackupJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBackupJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBackupJobOutput()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.backupJobId = try reader["BackupJobId"].readIfPresent()
        value.backupOptions = try reader["BackupOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.backupSizeInBytes = try reader["BackupSizeInBytes"].readIfPresent()
        value.backupType = try reader["BackupType"].readIfPresent()
        value.backupVaultArn = try reader["BackupVaultArn"].readIfPresent()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.bytesTransferred = try reader["BytesTransferred"].readIfPresent()
        value.childJobsInState = try reader["ChildJobsInState"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.completionDate = try reader["CompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: BackupClientTypes.RecoveryPointCreator.read(from:))
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expectedCompletionDate = try reader["ExpectedCompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        value.initiationDate = try reader["InitiationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.isParent = try reader["IsParent"].readIfPresent() ?? false
        value.messageCategory = try reader["MessageCategory"].readIfPresent()
        value.numberOfChildJobs = try reader["NumberOfChildJobs"].readIfPresent()
        value.parentJobId = try reader["ParentJobId"].readIfPresent()
        value.percentDone = try reader["PercentDone"].readIfPresent()
        value.recoveryPointArn = try reader["RecoveryPointArn"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourceName = try reader["ResourceName"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.startBy = try reader["StartBy"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension DescribeBackupVaultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBackupVaultOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBackupVaultOutput()
        value.backupVaultArn = try reader["BackupVaultArn"].readIfPresent()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.encryptionKeyArn = try reader["EncryptionKeyArn"].readIfPresent()
        value.lockDate = try reader["LockDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.locked = try reader["Locked"].readIfPresent()
        value.maxRetentionDays = try reader["MaxRetentionDays"].readIfPresent()
        value.minRetentionDays = try reader["MinRetentionDays"].readIfPresent()
        value.numberOfRecoveryPoints = try reader["NumberOfRecoveryPoints"].readIfPresent() ?? 0
        value.vaultState = try reader["VaultState"].readIfPresent()
        value.vaultType = try reader["VaultType"].readIfPresent()
        return value
    }
}

extension DescribeCopyJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCopyJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCopyJobOutput()
        value.copyJob = try reader["CopyJob"].readIfPresent(with: BackupClientTypes.CopyJob.read(from:))
        return value
    }
}

extension DescribeFrameworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFrameworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFrameworkOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deploymentStatus = try reader["DeploymentStatus"].readIfPresent()
        value.frameworkArn = try reader["FrameworkArn"].readIfPresent()
        value.frameworkControls = try reader["FrameworkControls"].readListIfPresent(memberReadingClosure: BackupClientTypes.FrameworkControl.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.frameworkDescription = try reader["FrameworkDescription"].readIfPresent()
        value.frameworkName = try reader["FrameworkName"].readIfPresent()
        value.frameworkStatus = try reader["FrameworkStatus"].readIfPresent()
        value.idempotencyToken = try reader["IdempotencyToken"].readIfPresent()
        return value
    }
}

extension DescribeGlobalSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeGlobalSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGlobalSettingsOutput()
        value.globalSettings = try reader["GlobalSettings"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DescribeProtectedResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProtectedResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProtectedResourceOutput()
        value.lastBackupTime = try reader["LastBackupTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastBackupVaultArn = try reader["LastBackupVaultArn"].readIfPresent()
        value.lastRecoveryPointArn = try reader["LastRecoveryPointArn"].readIfPresent()
        value.latestRestoreExecutionTimeMinutes = try reader["LatestRestoreExecutionTimeMinutes"].readIfPresent()
        value.latestRestoreJobCreationDate = try reader["LatestRestoreJobCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.latestRestoreRecoveryPointCreationDate = try reader["LatestRestoreRecoveryPointCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourceName = try reader["ResourceName"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        return value
    }
}

extension DescribeRecoveryPointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRecoveryPointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRecoveryPointOutput()
        value.backupSizeInBytes = try reader["BackupSizeInBytes"].readIfPresent()
        value.backupVaultArn = try reader["BackupVaultArn"].readIfPresent()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.calculatedLifecycle = try reader["CalculatedLifecycle"].readIfPresent(with: BackupClientTypes.CalculatedLifecycle.read(from:))
        value.completionDate = try reader["CompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.compositeMemberIdentifier = try reader["CompositeMemberIdentifier"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: BackupClientTypes.RecoveryPointCreator.read(from:))
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.encryptionKeyArn = try reader["EncryptionKeyArn"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        value.isEncrypted = try reader["IsEncrypted"].readIfPresent() ?? false
        value.isParent = try reader["IsParent"].readIfPresent() ?? false
        value.lastRestoreTime = try reader["LastRestoreTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lifecycle = try reader["Lifecycle"].readIfPresent(with: BackupClientTypes.Lifecycle.read(from:))
        value.parentRecoveryPointArn = try reader["ParentRecoveryPointArn"].readIfPresent()
        value.recoveryPointArn = try reader["RecoveryPointArn"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourceName = try reader["ResourceName"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.sourceBackupVaultArn = try reader["SourceBackupVaultArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.storageClass = try reader["StorageClass"].readIfPresent()
        value.vaultType = try reader["VaultType"].readIfPresent()
        return value
    }
}

extension DescribeRegionSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRegionSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRegionSettingsOutput()
        value.resourceTypeManagementPreference = try reader["ResourceTypeManagementPreference"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readBool(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.resourceTypeOptInPreference = try reader["ResourceTypeOptInPreference"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readBool(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeReportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReportJobOutput()
        value.reportJob = try reader["ReportJob"].readIfPresent(with: BackupClientTypes.ReportJob.read(from:))
        return value
    }
}

extension DescribeReportPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReportPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReportPlanOutput()
        value.reportPlan = try reader["ReportPlan"].readIfPresent(with: BackupClientTypes.ReportPlan.read(from:))
        return value
    }
}

extension DescribeRestoreJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRestoreJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRestoreJobOutput()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.backupSizeInBytes = try reader["BackupSizeInBytes"].readIfPresent()
        value.completionDate = try reader["CompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: BackupClientTypes.RestoreJobCreator.read(from:))
        value.createdResourceArn = try reader["CreatedResourceArn"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionStatus = try reader["DeletionStatus"].readIfPresent()
        value.deletionStatusMessage = try reader["DeletionStatusMessage"].readIfPresent()
        value.expectedCompletionTimeMinutes = try reader["ExpectedCompletionTimeMinutes"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        value.percentDone = try reader["PercentDone"].readIfPresent()
        value.recoveryPointArn = try reader["RecoveryPointArn"].readIfPresent()
        value.recoveryPointCreationDate = try reader["RecoveryPointCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.restoreJobId = try reader["RestoreJobId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.validationStatus = try reader["ValidationStatus"].readIfPresent()
        value.validationStatusMessage = try reader["ValidationStatusMessage"].readIfPresent()
        return value
    }
}

extension DisassociateRecoveryPointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateRecoveryPointOutput {
        return DisassociateRecoveryPointOutput()
    }
}

extension DisassociateRecoveryPointFromParentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateRecoveryPointFromParentOutput {
        return DisassociateRecoveryPointFromParentOutput()
    }
}

extension ExportBackupPlanTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExportBackupPlanTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExportBackupPlanTemplateOutput()
        value.backupPlanTemplateJson = try reader["BackupPlanTemplateJson"].readIfPresent()
        return value
    }
}

extension GetBackupPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBackupPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBackupPlanOutput()
        value.advancedBackupSettings = try reader["AdvancedBackupSettings"].readListIfPresent(memberReadingClosure: BackupClientTypes.AdvancedBackupSetting.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.backupPlan = try reader["BackupPlan"].readIfPresent(with: BackupClientTypes.BackupPlan.read(from:))
        value.backupPlanArn = try reader["BackupPlanArn"].readIfPresent()
        value.backupPlanId = try reader["BackupPlanId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.deletionDate = try reader["DeletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastExecutionDate = try reader["LastExecutionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.versionId = try reader["VersionId"].readIfPresent()
        return value
    }
}

extension GetBackupPlanFromJSONOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBackupPlanFromJSONOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBackupPlanFromJSONOutput()
        value.backupPlan = try reader["BackupPlan"].readIfPresent(with: BackupClientTypes.BackupPlan.read(from:))
        return value
    }
}

extension GetBackupPlanFromTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBackupPlanFromTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBackupPlanFromTemplateOutput()
        value.backupPlanDocument = try reader["BackupPlanDocument"].readIfPresent(with: BackupClientTypes.BackupPlan.read(from:))
        return value
    }
}

extension GetBackupSelectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBackupSelectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBackupSelectionOutput()
        value.backupPlanId = try reader["BackupPlanId"].readIfPresent()
        value.backupSelection = try reader["BackupSelection"].readIfPresent(with: BackupClientTypes.BackupSelection.read(from:))
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.selectionId = try reader["SelectionId"].readIfPresent()
        return value
    }
}

extension GetBackupVaultAccessPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBackupVaultAccessPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBackupVaultAccessPolicyOutput()
        value.backupVaultArn = try reader["BackupVaultArn"].readIfPresent()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.policy = try reader["Policy"].readIfPresent()
        return value
    }
}

extension GetBackupVaultNotificationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBackupVaultNotificationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBackupVaultNotificationsOutput()
        value.backupVaultArn = try reader["BackupVaultArn"].readIfPresent()
        value.backupVaultEvents = try reader["BackupVaultEvents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BackupClientTypes.BackupVaultEvent>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.snsTopicArn = try reader["SNSTopicArn"].readIfPresent()
        return value
    }
}

extension GetLegalHoldOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLegalHoldOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLegalHoldOutput()
        value.cancelDescription = try reader["CancelDescription"].readIfPresent()
        value.cancellationDate = try reader["CancellationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.legalHoldArn = try reader["LegalHoldArn"].readIfPresent()
        value.legalHoldId = try reader["LegalHoldId"].readIfPresent()
        value.recoveryPointSelection = try reader["RecoveryPointSelection"].readIfPresent(with: BackupClientTypes.RecoveryPointSelection.read(from:))
        value.retainRecordUntil = try reader["RetainRecordUntil"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        return value
    }
}

extension GetRecoveryPointRestoreMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRecoveryPointRestoreMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRecoveryPointRestoreMetadataOutput()
        value.backupVaultArn = try reader["BackupVaultArn"].readIfPresent()
        value.recoveryPointArn = try reader["RecoveryPointArn"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.restoreMetadata = try reader["RestoreMetadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetRestoreJobMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRestoreJobMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRestoreJobMetadataOutput()
        value.metadata = try reader["Metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.restoreJobId = try reader["RestoreJobId"].readIfPresent()
        return value
    }
}

extension GetRestoreTestingInferredMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRestoreTestingInferredMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRestoreTestingInferredMetadataOutput()
        value.inferredMetadata = try reader["InferredMetadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension GetRestoreTestingPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRestoreTestingPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRestoreTestingPlanOutput()
        value.restoreTestingPlan = try reader["RestoreTestingPlan"].readIfPresent(with: BackupClientTypes.RestoreTestingPlanForGet.read(from:))
        return value
    }
}

extension GetRestoreTestingSelectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRestoreTestingSelectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRestoreTestingSelectionOutput()
        value.restoreTestingSelection = try reader["RestoreTestingSelection"].readIfPresent(with: BackupClientTypes.RestoreTestingSelectionForGet.read(from:))
        return value
    }
}

extension GetSupportedResourceTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSupportedResourceTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSupportedResourceTypesOutput()
        value.resourceTypes = try reader["ResourceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListBackupJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBackupJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBackupJobsOutput()
        value.backupJobs = try reader["BackupJobs"].readListIfPresent(memberReadingClosure: BackupClientTypes.BackupJob.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListBackupJobSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBackupJobSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBackupJobSummariesOutput()
        value.aggregationPeriod = try reader["AggregationPeriod"].readIfPresent()
        value.backupJobSummaries = try reader["BackupJobSummaries"].readListIfPresent(memberReadingClosure: BackupClientTypes.BackupJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListBackupPlansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBackupPlansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBackupPlansOutput()
        value.backupPlansList = try reader["BackupPlansList"].readListIfPresent(memberReadingClosure: BackupClientTypes.BackupPlansListMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListBackupPlanTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBackupPlanTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBackupPlanTemplatesOutput()
        value.backupPlanTemplatesList = try reader["BackupPlanTemplatesList"].readListIfPresent(memberReadingClosure: BackupClientTypes.BackupPlanTemplatesListMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListBackupPlanVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBackupPlanVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBackupPlanVersionsOutput()
        value.backupPlanVersionsList = try reader["BackupPlanVersionsList"].readListIfPresent(memberReadingClosure: BackupClientTypes.BackupPlansListMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListBackupSelectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBackupSelectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBackupSelectionsOutput()
        value.backupSelectionsList = try reader["BackupSelectionsList"].readListIfPresent(memberReadingClosure: BackupClientTypes.BackupSelectionsListMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListBackupVaultsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBackupVaultsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBackupVaultsOutput()
        value.backupVaultList = try reader["BackupVaultList"].readListIfPresent(memberReadingClosure: BackupClientTypes.BackupVaultListMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCopyJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCopyJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCopyJobsOutput()
        value.copyJobs = try reader["CopyJobs"].readListIfPresent(memberReadingClosure: BackupClientTypes.CopyJob.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCopyJobSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCopyJobSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCopyJobSummariesOutput()
        value.aggregationPeriod = try reader["AggregationPeriod"].readIfPresent()
        value.copyJobSummaries = try reader["CopyJobSummaries"].readListIfPresent(memberReadingClosure: BackupClientTypes.CopyJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFrameworksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFrameworksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFrameworksOutput()
        value.frameworks = try reader["Frameworks"].readListIfPresent(memberReadingClosure: BackupClientTypes.Framework.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLegalHoldsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLegalHoldsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLegalHoldsOutput()
        value.legalHolds = try reader["LegalHolds"].readListIfPresent(memberReadingClosure: BackupClientTypes.LegalHold.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListProtectedResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProtectedResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProtectedResourcesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.results = try reader["Results"].readListIfPresent(memberReadingClosure: BackupClientTypes.ProtectedResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProtectedResourcesByBackupVaultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProtectedResourcesByBackupVaultOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProtectedResourcesByBackupVaultOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.results = try reader["Results"].readListIfPresent(memberReadingClosure: BackupClientTypes.ProtectedResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRecoveryPointsByBackupVaultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRecoveryPointsByBackupVaultOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRecoveryPointsByBackupVaultOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.recoveryPoints = try reader["RecoveryPoints"].readListIfPresent(memberReadingClosure: BackupClientTypes.RecoveryPointByBackupVault.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRecoveryPointsByLegalHoldOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRecoveryPointsByLegalHoldOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRecoveryPointsByLegalHoldOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.recoveryPoints = try reader["RecoveryPoints"].readListIfPresent(memberReadingClosure: BackupClientTypes.RecoveryPointMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRecoveryPointsByResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRecoveryPointsByResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRecoveryPointsByResourceOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.recoveryPoints = try reader["RecoveryPoints"].readListIfPresent(memberReadingClosure: BackupClientTypes.RecoveryPointByResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListReportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListReportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReportJobsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.reportJobs = try reader["ReportJobs"].readListIfPresent(memberReadingClosure: BackupClientTypes.ReportJob.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListReportPlansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListReportPlansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReportPlansOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.reportPlans = try reader["ReportPlans"].readListIfPresent(memberReadingClosure: BackupClientTypes.ReportPlan.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRestoreJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRestoreJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRestoreJobsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.restoreJobs = try reader["RestoreJobs"].readListIfPresent(memberReadingClosure: BackupClientTypes.RestoreJobsListMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRestoreJobsByProtectedResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRestoreJobsByProtectedResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRestoreJobsByProtectedResourceOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.restoreJobs = try reader["RestoreJobs"].readListIfPresent(memberReadingClosure: BackupClientTypes.RestoreJobsListMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRestoreJobSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRestoreJobSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRestoreJobSummariesOutput()
        value.aggregationPeriod = try reader["AggregationPeriod"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.restoreJobSummaries = try reader["RestoreJobSummaries"].readListIfPresent(memberReadingClosure: BackupClientTypes.RestoreJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRestoreTestingPlansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRestoreTestingPlansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRestoreTestingPlansOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.restoreTestingPlans = try reader["RestoreTestingPlans"].readListIfPresent(memberReadingClosure: BackupClientTypes.RestoreTestingPlanForList.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListRestoreTestingSelectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRestoreTestingSelectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRestoreTestingSelectionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.restoreTestingSelections = try reader["RestoreTestingSelections"].readListIfPresent(memberReadingClosure: BackupClientTypes.RestoreTestingSelectionForList.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PutBackupVaultAccessPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutBackupVaultAccessPolicyOutput {
        return PutBackupVaultAccessPolicyOutput()
    }
}

extension PutBackupVaultLockConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutBackupVaultLockConfigurationOutput {
        return PutBackupVaultLockConfigurationOutput()
    }
}

extension PutBackupVaultNotificationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutBackupVaultNotificationsOutput {
        return PutBackupVaultNotificationsOutput()
    }
}

extension PutRestoreValidationResultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRestoreValidationResultOutput {
        return PutRestoreValidationResultOutput()
    }
}

extension StartBackupJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartBackupJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartBackupJobOutput()
        value.backupJobId = try reader["BackupJobId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.isParent = try reader["IsParent"].readIfPresent() ?? false
        value.recoveryPointArn = try reader["RecoveryPointArn"].readIfPresent()
        return value
    }
}

extension StartCopyJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartCopyJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartCopyJobOutput()
        value.copyJobId = try reader["CopyJobId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.isParent = try reader["IsParent"].readIfPresent() ?? false
        return value
    }
}

extension StartReportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartReportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartReportJobOutput()
        value.reportJobId = try reader["ReportJobId"].readIfPresent()
        return value
    }
}

extension StartRestoreJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartRestoreJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartRestoreJobOutput()
        value.restoreJobId = try reader["RestoreJobId"].readIfPresent()
        return value
    }
}

extension StopBackupJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopBackupJobOutput {
        return StopBackupJobOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateBackupPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBackupPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBackupPlanOutput()
        value.advancedBackupSettings = try reader["AdvancedBackupSettings"].readListIfPresent(memberReadingClosure: BackupClientTypes.AdvancedBackupSetting.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.backupPlanArn = try reader["BackupPlanArn"].readIfPresent()
        value.backupPlanId = try reader["BackupPlanId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.versionId = try reader["VersionId"].readIfPresent()
        return value
    }
}

extension UpdateFrameworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFrameworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFrameworkOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.frameworkArn = try reader["FrameworkArn"].readIfPresent()
        value.frameworkName = try reader["FrameworkName"].readIfPresent()
        return value
    }
}

extension UpdateGlobalSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGlobalSettingsOutput {
        return UpdateGlobalSettingsOutput()
    }
}

extension UpdateRecoveryPointLifecycleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRecoveryPointLifecycleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRecoveryPointLifecycleOutput()
        value.backupVaultArn = try reader["BackupVaultArn"].readIfPresent()
        value.calculatedLifecycle = try reader["CalculatedLifecycle"].readIfPresent(with: BackupClientTypes.CalculatedLifecycle.read(from:))
        value.lifecycle = try reader["Lifecycle"].readIfPresent(with: BackupClientTypes.Lifecycle.read(from:))
        value.recoveryPointArn = try reader["RecoveryPointArn"].readIfPresent()
        return value
    }
}

extension UpdateRegionSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRegionSettingsOutput {
        return UpdateRegionSettingsOutput()
    }
}

extension UpdateReportPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateReportPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateReportPlanOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.reportPlanArn = try reader["ReportPlanArn"].readIfPresent()
        value.reportPlanName = try reader["ReportPlanName"].readIfPresent()
        return value
    }
}

extension UpdateRestoreTestingPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRestoreTestingPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRestoreTestingPlanOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.restoreTestingPlanArn = try reader["RestoreTestingPlanArn"].readIfPresent() ?? ""
        value.restoreTestingPlanName = try reader["RestoreTestingPlanName"].readIfPresent() ?? ""
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension UpdateRestoreTestingSelectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRestoreTestingSelectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRestoreTestingSelectionOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.restoreTestingPlanArn = try reader["RestoreTestingPlanArn"].readIfPresent() ?? ""
        value.restoreTestingPlanName = try reader["RestoreTestingPlanName"].readIfPresent() ?? ""
        value.restoreTestingSelectionName = try reader["RestoreTestingSelectionName"].readIfPresent() ?? ""
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

enum CancelLegalHoldOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBackupPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBackupSelectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBackupVaultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFrameworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLegalHoldOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLogicallyAirGappedBackupVaultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateReportPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRestoreTestingPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRestoreTestingSelectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBackupPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBackupSelectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBackupVaultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBackupVaultAccessPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBackupVaultLockConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBackupVaultNotificationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFrameworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRecoveryPointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteReportPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRestoreTestingPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRestoreTestingSelectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBackupJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyFailureException": return try DependencyFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBackupVaultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCopyJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFrameworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeGlobalSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProtectedResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRecoveryPointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRegionSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReportPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRestoreJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyFailureException": return try DependencyFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateRecoveryPointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateRecoveryPointFromParentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExportBackupPlanTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBackupPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBackupPlanFromJSONOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBackupPlanFromTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBackupSelectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBackupVaultAccessPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBackupVaultNotificationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLegalHoldOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRecoveryPointRestoreMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRestoreJobMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRestoreTestingInferredMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRestoreTestingPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRestoreTestingSelectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSupportedResourceTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBackupJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBackupJobSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBackupPlansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBackupPlanTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBackupPlanVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBackupSelectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBackupVaultsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCopyJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCopyJobSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFrameworksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLegalHoldsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProtectedResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProtectedResourcesByBackupVaultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRecoveryPointsByBackupVaultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRecoveryPointsByLegalHoldOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRecoveryPointsByResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListReportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListReportPlansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRestoreJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRestoreJobsByProtectedResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRestoreJobSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRestoreTestingPlansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRestoreTestingSelectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutBackupVaultAccessPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutBackupVaultLockConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutBackupVaultNotificationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRestoreValidationResultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartBackupJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartCopyJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartReportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartRestoreJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopBackupJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBackupPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFrameworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGlobalSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRecoveryPointLifecycleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRegionSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateReportPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRestoreTestingPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRestoreTestingSelectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MissingParameterValueException": return try MissingParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.context = try reader["Context"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MissingParameterValueException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MissingParameterValueException {
        let reader = baseError.errorBodyReader
        var value = MissingParameterValueException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.context = try reader["Context"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterValueException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterValueException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterValueException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.context = try reader["Context"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResourceStateException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidResourceStateException {
        let reader = baseError.errorBodyReader
        var value = InvalidResourceStateException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.context = try reader["Context"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.context = try reader["Context"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.context = try reader["Context"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = AlreadyExistsException()
        value.properties.arn = try reader["Arn"].readIfPresent()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.context = try reader["Context"].readIfPresent()
        value.properties.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.context = try reader["Context"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.context = try reader["Context"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DependencyFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DependencyFailureException {
        let reader = baseError.errorBodyReader
        var value = DependencyFailureException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.context = try reader["Context"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BackupClientTypes.AdvancedBackupSetting {

    static func write(value: BackupClientTypes.AdvancedBackupSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupOptions"].writeMap(value.backupOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ResourceType"].write(value.resourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.AdvancedBackupSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.AdvancedBackupSetting()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.backupOptions = try reader["BackupOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BackupClientTypes.RecoveryPointSelection {

    static func write(value: BackupClientTypes.RecoveryPointSelection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateRange"].write(value.dateRange, with: BackupClientTypes.DateRange.write(value:to:))
        try writer["ResourceIdentifiers"].writeList(value.resourceIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VaultNames"].writeList(value.vaultNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.RecoveryPointSelection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.RecoveryPointSelection()
        value.vaultNames = try reader["VaultNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceIdentifiers = try reader["ResourceIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dateRange = try reader["DateRange"].readIfPresent(with: BackupClientTypes.DateRange.read(from:))
        return value
    }
}

extension BackupClientTypes.DateRange {

    static func write(value: BackupClientTypes.DateRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FromDate"].writeTimestamp(value.fromDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ToDate"].writeTimestamp(value.toDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.DateRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.DateRange()
        value.fromDate = try reader["FromDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.toDate = try reader["ToDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BackupClientTypes.RecoveryPointCreator {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.RecoveryPointCreator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.RecoveryPointCreator()
        value.backupPlanId = try reader["BackupPlanId"].readIfPresent()
        value.backupPlanArn = try reader["BackupPlanArn"].readIfPresent()
        value.backupPlanVersion = try reader["BackupPlanVersion"].readIfPresent()
        value.backupRuleId = try reader["BackupRuleId"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.CopyJob {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.CopyJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.CopyJob()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.copyJobId = try reader["CopyJobId"].readIfPresent()
        value.sourceBackupVaultArn = try reader["SourceBackupVaultArn"].readIfPresent()
        value.sourceRecoveryPointArn = try reader["SourceRecoveryPointArn"].readIfPresent()
        value.destinationBackupVaultArn = try reader["DestinationBackupVaultArn"].readIfPresent()
        value.destinationRecoveryPointArn = try reader["DestinationRecoveryPointArn"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionDate = try reader["CompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.backupSizeInBytes = try reader["BackupSizeInBytes"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: BackupClientTypes.RecoveryPointCreator.read(from:))
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.parentJobId = try reader["ParentJobId"].readIfPresent()
        value.isParent = try reader["IsParent"].readIfPresent() ?? false
        value.compositeMemberIdentifier = try reader["CompositeMemberIdentifier"].readIfPresent()
        value.numberOfChildJobs = try reader["NumberOfChildJobs"].readIfPresent()
        value.childJobsInState = try reader["ChildJobsInState"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.resourceName = try reader["ResourceName"].readIfPresent()
        value.messageCategory = try reader["MessageCategory"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.FrameworkControl {

    static func write(value: BackupClientTypes.FrameworkControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ControlInputParameters"].writeList(value.controlInputParameters, memberWritingClosure: BackupClientTypes.ControlInputParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ControlName"].write(value.controlName)
        try writer["ControlScope"].write(value.controlScope, with: BackupClientTypes.ControlScope.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.FrameworkControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.FrameworkControl()
        value.controlName = try reader["ControlName"].readIfPresent() ?? ""
        value.controlInputParameters = try reader["ControlInputParameters"].readListIfPresent(memberReadingClosure: BackupClientTypes.ControlInputParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.controlScope = try reader["ControlScope"].readIfPresent(with: BackupClientTypes.ControlScope.read(from:))
        return value
    }
}

extension BackupClientTypes.ControlScope {

    static func write(value: BackupClientTypes.ControlScope?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComplianceResourceIds"].writeList(value.complianceResourceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComplianceResourceTypes"].writeList(value.complianceResourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.ControlScope {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.ControlScope()
        value.complianceResourceIds = try reader["ComplianceResourceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.complianceResourceTypes = try reader["ComplianceResourceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BackupClientTypes.ControlInputParameter {

    static func write(value: BackupClientTypes.ControlInputParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ParameterName"].write(value.parameterName)
        try writer["ParameterValue"].write(value.parameterValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.ControlInputParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.ControlInputParameter()
        value.parameterName = try reader["ParameterName"].readIfPresent()
        value.parameterValue = try reader["ParameterValue"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.CalculatedLifecycle {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.CalculatedLifecycle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.CalculatedLifecycle()
        value.moveToColdStorageAt = try reader["MoveToColdStorageAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deleteAt = try reader["DeleteAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BackupClientTypes.Lifecycle {

    static func write(value: BackupClientTypes.Lifecycle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteAfterDays"].write(value.deleteAfterDays)
        try writer["MoveToColdStorageAfterDays"].write(value.moveToColdStorageAfterDays)
        try writer["OptInToArchiveForSupportedResources"].write(value.optInToArchiveForSupportedResources)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.Lifecycle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.Lifecycle()
        value.moveToColdStorageAfterDays = try reader["MoveToColdStorageAfterDays"].readIfPresent()
        value.deleteAfterDays = try reader["DeleteAfterDays"].readIfPresent()
        value.optInToArchiveForSupportedResources = try reader["OptInToArchiveForSupportedResources"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.ReportJob {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.ReportJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.ReportJob()
        value.reportJobId = try reader["ReportJobId"].readIfPresent()
        value.reportPlanArn = try reader["ReportPlanArn"].readIfPresent()
        value.reportTemplate = try reader["ReportTemplate"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.reportDestination = try reader["ReportDestination"].readIfPresent(with: BackupClientTypes.ReportDestination.read(from:))
        return value
    }
}

extension BackupClientTypes.ReportDestination {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.ReportDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.ReportDestination()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.s3Keys = try reader["S3Keys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BackupClientTypes.ReportPlan {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.ReportPlan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.ReportPlan()
        value.reportPlanArn = try reader["ReportPlanArn"].readIfPresent()
        value.reportPlanName = try reader["ReportPlanName"].readIfPresent()
        value.reportPlanDescription = try reader["ReportPlanDescription"].readIfPresent()
        value.reportSetting = try reader["ReportSetting"].readIfPresent(with: BackupClientTypes.ReportSetting.read(from:))
        value.reportDeliveryChannel = try reader["ReportDeliveryChannel"].readIfPresent(with: BackupClientTypes.ReportDeliveryChannel.read(from:))
        value.deploymentStatus = try reader["DeploymentStatus"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastAttemptedExecutionTime = try reader["LastAttemptedExecutionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastSuccessfulExecutionTime = try reader["LastSuccessfulExecutionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BackupClientTypes.ReportDeliveryChannel {

    static func write(value: BackupClientTypes.ReportDeliveryChannel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Formats"].writeList(value.formats, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["S3KeyPrefix"].write(value.s3KeyPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.ReportDeliveryChannel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.ReportDeliveryChannel()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent() ?? ""
        value.s3KeyPrefix = try reader["S3KeyPrefix"].readIfPresent()
        value.formats = try reader["Formats"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BackupClientTypes.ReportSetting {

    static func write(value: BackupClientTypes.ReportSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Accounts"].writeList(value.accounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FrameworkArns"].writeList(value.frameworkArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NumberOfFrameworks"].write(value.numberOfFrameworks)
        try writer["OrganizationUnits"].writeList(value.organizationUnits, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Regions"].writeList(value.regions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReportTemplate"].write(value.reportTemplate)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.ReportSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.ReportSetting()
        value.reportTemplate = try reader["ReportTemplate"].readIfPresent() ?? ""
        value.frameworkArns = try reader["FrameworkArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.numberOfFrameworks = try reader["NumberOfFrameworks"].readIfPresent() ?? 0
        value.accounts = try reader["Accounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.organizationUnits = try reader["OrganizationUnits"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.regions = try reader["Regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BackupClientTypes.RestoreJobCreator {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.RestoreJobCreator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.RestoreJobCreator()
        value.restoreTestingPlanArn = try reader["RestoreTestingPlanArn"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.BackupPlan {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.BackupPlan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.BackupPlan()
        value.backupPlanName = try reader["BackupPlanName"].readIfPresent() ?? ""
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: BackupClientTypes.BackupRule.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.advancedBackupSettings = try reader["AdvancedBackupSettings"].readListIfPresent(memberReadingClosure: BackupClientTypes.AdvancedBackupSetting.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BackupClientTypes.BackupRule {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.BackupRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.BackupRule()
        value.ruleName = try reader["RuleName"].readIfPresent() ?? ""
        value.targetBackupVaultName = try reader["TargetBackupVaultName"].readIfPresent() ?? ""
        value.scheduleExpression = try reader["ScheduleExpression"].readIfPresent()
        value.startWindowMinutes = try reader["StartWindowMinutes"].readIfPresent()
        value.completionWindowMinutes = try reader["CompletionWindowMinutes"].readIfPresent()
        value.lifecycle = try reader["Lifecycle"].readIfPresent(with: BackupClientTypes.Lifecycle.read(from:))
        value.recoveryPointTags = try reader["RecoveryPointTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.ruleId = try reader["RuleId"].readIfPresent()
        value.copyActions = try reader["CopyActions"].readListIfPresent(memberReadingClosure: BackupClientTypes.CopyAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.enableContinuousBackup = try reader["EnableContinuousBackup"].readIfPresent()
        value.scheduleExpressionTimezone = try reader["ScheduleExpressionTimezone"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.CopyAction {

    static func write(value: BackupClientTypes.CopyAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationBackupVaultArn"].write(value.destinationBackupVaultArn)
        try writer["Lifecycle"].write(value.lifecycle, with: BackupClientTypes.Lifecycle.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.CopyAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.CopyAction()
        value.lifecycle = try reader["Lifecycle"].readIfPresent(with: BackupClientTypes.Lifecycle.read(from:))
        value.destinationBackupVaultArn = try reader["DestinationBackupVaultArn"].readIfPresent() ?? ""
        return value
    }
}

extension BackupClientTypes.BackupSelection {

    static func write(value: BackupClientTypes.BackupSelection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Conditions"].write(value.conditions, with: BackupClientTypes.Conditions.write(value:to:))
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["ListOfTags"].writeList(value.listOfTags, memberWritingClosure: BackupClientTypes.Condition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotResources"].writeList(value.notResources, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Resources"].writeList(value.resources, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SelectionName"].write(value.selectionName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.BackupSelection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.BackupSelection()
        value.selectionName = try reader["SelectionName"].readIfPresent() ?? ""
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent() ?? ""
        value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.listOfTags = try reader["ListOfTags"].readListIfPresent(memberReadingClosure: BackupClientTypes.Condition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.notResources = try reader["NotResources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.conditions = try reader["Conditions"].readIfPresent(with: BackupClientTypes.Conditions.read(from:))
        return value
    }
}

extension BackupClientTypes.Conditions {

    static func write(value: BackupClientTypes.Conditions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StringEquals"].writeList(value.stringEquals, memberWritingClosure: BackupClientTypes.ConditionParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringLike"].writeList(value.stringLike, memberWritingClosure: BackupClientTypes.ConditionParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringNotEquals"].writeList(value.stringNotEquals, memberWritingClosure: BackupClientTypes.ConditionParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringNotLike"].writeList(value.stringNotLike, memberWritingClosure: BackupClientTypes.ConditionParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.Conditions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.Conditions()
        value.stringEquals = try reader["StringEquals"].readListIfPresent(memberReadingClosure: BackupClientTypes.ConditionParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.stringNotEquals = try reader["StringNotEquals"].readListIfPresent(memberReadingClosure: BackupClientTypes.ConditionParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.stringLike = try reader["StringLike"].readListIfPresent(memberReadingClosure: BackupClientTypes.ConditionParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.stringNotLike = try reader["StringNotLike"].readListIfPresent(memberReadingClosure: BackupClientTypes.ConditionParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BackupClientTypes.ConditionParameter {

    static func write(value: BackupClientTypes.ConditionParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConditionKey"].write(value.conditionKey)
        try writer["ConditionValue"].write(value.conditionValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.ConditionParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.ConditionParameter()
        value.conditionKey = try reader["ConditionKey"].readIfPresent()
        value.conditionValue = try reader["ConditionValue"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.Condition {

    static func write(value: BackupClientTypes.Condition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConditionKey"].write(value.conditionKey)
        try writer["ConditionType"].write(value.conditionType)
        try writer["ConditionValue"].write(value.conditionValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.Condition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.Condition()
        value.conditionType = try reader["ConditionType"].readIfPresent() ?? .sdkUnknown("")
        value.conditionKey = try reader["ConditionKey"].readIfPresent() ?? ""
        value.conditionValue = try reader["ConditionValue"].readIfPresent() ?? ""
        return value
    }
}

extension BackupClientTypes.RestoreTestingPlanForGet {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.RestoreTestingPlanForGet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.RestoreTestingPlanForGet()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.lastExecutionTime = try reader["LastExecutionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.recoveryPointSelection = try reader["RecoveryPointSelection"].readIfPresent(with: BackupClientTypes.RestoreTestingRecoveryPointSelection.read(from:))
        value.restoreTestingPlanArn = try reader["RestoreTestingPlanArn"].readIfPresent() ?? ""
        value.restoreTestingPlanName = try reader["RestoreTestingPlanName"].readIfPresent() ?? ""
        value.scheduleExpression = try reader["ScheduleExpression"].readIfPresent() ?? ""
        value.scheduleExpressionTimezone = try reader["ScheduleExpressionTimezone"].readIfPresent()
        value.startWindowHours = try reader["StartWindowHours"].readIfPresent() ?? 0
        return value
    }
}

extension BackupClientTypes.RestoreTestingRecoveryPointSelection {

    static func write(value: BackupClientTypes.RestoreTestingRecoveryPointSelection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Algorithm"].write(value.algorithm)
        try writer["ExcludeVaults"].writeList(value.excludeVaults, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludeVaults"].writeList(value.includeVaults, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RecoveryPointTypes"].writeList(value.recoveryPointTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BackupClientTypes.RestoreTestingRecoveryPointType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SelectionWindowDays"].write(value.selectionWindowDays)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.RestoreTestingRecoveryPointSelection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.RestoreTestingRecoveryPointSelection()
        value.algorithm = try reader["Algorithm"].readIfPresent()
        value.excludeVaults = try reader["ExcludeVaults"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.includeVaults = try reader["IncludeVaults"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.recoveryPointTypes = try reader["RecoveryPointTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BackupClientTypes.RestoreTestingRecoveryPointType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectionWindowDays = try reader["SelectionWindowDays"].readIfPresent() ?? 0
        return value
    }
}

extension BackupClientTypes.RestoreTestingSelectionForGet {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.RestoreTestingSelectionForGet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.RestoreTestingSelectionForGet()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent() ?? ""
        value.protectedResourceArns = try reader["ProtectedResourceArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.protectedResourceConditions = try reader["ProtectedResourceConditions"].readIfPresent(with: BackupClientTypes.ProtectedResourceConditions.read(from:))
        value.protectedResourceType = try reader["ProtectedResourceType"].readIfPresent() ?? ""
        value.restoreMetadataOverrides = try reader["RestoreMetadataOverrides"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.restoreTestingPlanName = try reader["RestoreTestingPlanName"].readIfPresent() ?? ""
        value.restoreTestingSelectionName = try reader["RestoreTestingSelectionName"].readIfPresent() ?? ""
        value.validationWindowHours = try reader["ValidationWindowHours"].readIfPresent() ?? 0
        return value
    }
}

extension BackupClientTypes.ProtectedResourceConditions {

    static func write(value: BackupClientTypes.ProtectedResourceConditions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StringEquals"].writeList(value.stringEquals, memberWritingClosure: BackupClientTypes.KeyValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringNotEquals"].writeList(value.stringNotEquals, memberWritingClosure: BackupClientTypes.KeyValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.ProtectedResourceConditions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.ProtectedResourceConditions()
        value.stringEquals = try reader["StringEquals"].readListIfPresent(memberReadingClosure: BackupClientTypes.KeyValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.stringNotEquals = try reader["StringNotEquals"].readListIfPresent(memberReadingClosure: BackupClientTypes.KeyValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BackupClientTypes.KeyValue {

    static func write(value: BackupClientTypes.KeyValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.KeyValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.KeyValue()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension BackupClientTypes.BackupJob {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.BackupJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.BackupJob()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.backupJobId = try reader["BackupJobId"].readIfPresent()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.backupVaultArn = try reader["BackupVaultArn"].readIfPresent()
        value.recoveryPointArn = try reader["RecoveryPointArn"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionDate = try reader["CompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.percentDone = try reader["PercentDone"].readIfPresent()
        value.backupSizeInBytes = try reader["BackupSizeInBytes"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: BackupClientTypes.RecoveryPointCreator.read(from:))
        value.expectedCompletionDate = try reader["ExpectedCompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startBy = try reader["StartBy"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.bytesTransferred = try reader["BytesTransferred"].readIfPresent()
        value.backupOptions = try reader["BackupOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.backupType = try reader["BackupType"].readIfPresent()
        value.parentJobId = try reader["ParentJobId"].readIfPresent()
        value.isParent = try reader["IsParent"].readIfPresent() ?? false
        value.resourceName = try reader["ResourceName"].readIfPresent()
        value.initiationDate = try reader["InitiationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.messageCategory = try reader["MessageCategory"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.BackupJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.BackupJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.BackupJobSummary()
        value.region = try reader["Region"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.messageCategory = try reader["MessageCategory"].readIfPresent()
        value.count = try reader["Count"].readIfPresent() ?? 0
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BackupClientTypes.BackupPlansListMember {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.BackupPlansListMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.BackupPlansListMember()
        value.backupPlanArn = try reader["BackupPlanArn"].readIfPresent()
        value.backupPlanId = try reader["BackupPlanId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionDate = try reader["DeletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.versionId = try reader["VersionId"].readIfPresent()
        value.backupPlanName = try reader["BackupPlanName"].readIfPresent()
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.lastExecutionDate = try reader["LastExecutionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.advancedBackupSettings = try reader["AdvancedBackupSettings"].readListIfPresent(memberReadingClosure: BackupClientTypes.AdvancedBackupSetting.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BackupClientTypes.BackupPlanTemplatesListMember {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.BackupPlanTemplatesListMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.BackupPlanTemplatesListMember()
        value.backupPlanTemplateId = try reader["BackupPlanTemplateId"].readIfPresent()
        value.backupPlanTemplateName = try reader["BackupPlanTemplateName"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.BackupSelectionsListMember {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.BackupSelectionsListMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.BackupSelectionsListMember()
        value.selectionId = try reader["SelectionId"].readIfPresent()
        value.selectionName = try reader["SelectionName"].readIfPresent()
        value.backupPlanId = try reader["BackupPlanId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.BackupVaultListMember {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.BackupVaultListMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.BackupVaultListMember()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.backupVaultArn = try reader["BackupVaultArn"].readIfPresent()
        value.vaultType = try reader["VaultType"].readIfPresent()
        value.vaultState = try reader["VaultState"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.encryptionKeyArn = try reader["EncryptionKeyArn"].readIfPresent()
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.numberOfRecoveryPoints = try reader["NumberOfRecoveryPoints"].readIfPresent() ?? 0
        value.locked = try reader["Locked"].readIfPresent()
        value.minRetentionDays = try reader["MinRetentionDays"].readIfPresent()
        value.maxRetentionDays = try reader["MaxRetentionDays"].readIfPresent()
        value.lockDate = try reader["LockDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BackupClientTypes.CopyJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.CopyJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.CopyJobSummary()
        value.region = try reader["Region"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.messageCategory = try reader["MessageCategory"].readIfPresent()
        value.count = try reader["Count"].readIfPresent() ?? 0
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BackupClientTypes.Framework {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.Framework {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.Framework()
        value.frameworkName = try reader["FrameworkName"].readIfPresent()
        value.frameworkArn = try reader["FrameworkArn"].readIfPresent()
        value.frameworkDescription = try reader["FrameworkDescription"].readIfPresent()
        value.numberOfControls = try reader["NumberOfControls"].readIfPresent() ?? 0
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deploymentStatus = try reader["DeploymentStatus"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.LegalHold {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.LegalHold {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.LegalHold()
        value.title = try reader["Title"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.legalHoldId = try reader["LegalHoldId"].readIfPresent()
        value.legalHoldArn = try reader["LegalHoldArn"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.cancellationDate = try reader["CancellationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BackupClientTypes.ProtectedResource {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.ProtectedResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.ProtectedResource()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.lastBackupTime = try reader["LastBackupTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceName = try reader["ResourceName"].readIfPresent()
        value.lastBackupVaultArn = try reader["LastBackupVaultArn"].readIfPresent()
        value.lastRecoveryPointArn = try reader["LastRecoveryPointArn"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.RecoveryPointByBackupVault {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.RecoveryPointByBackupVault {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.RecoveryPointByBackupVault()
        value.recoveryPointArn = try reader["RecoveryPointArn"].readIfPresent()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.backupVaultArn = try reader["BackupVaultArn"].readIfPresent()
        value.sourceBackupVaultArn = try reader["SourceBackupVaultArn"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: BackupClientTypes.RecoveryPointCreator.read(from:))
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionDate = try reader["CompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.backupSizeInBytes = try reader["BackupSizeInBytes"].readIfPresent()
        value.calculatedLifecycle = try reader["CalculatedLifecycle"].readIfPresent(with: BackupClientTypes.CalculatedLifecycle.read(from:))
        value.lifecycle = try reader["Lifecycle"].readIfPresent(with: BackupClientTypes.Lifecycle.read(from:))
        value.encryptionKeyArn = try reader["EncryptionKeyArn"].readIfPresent()
        value.isEncrypted = try reader["IsEncrypted"].readIfPresent() ?? false
        value.lastRestoreTime = try reader["LastRestoreTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.parentRecoveryPointArn = try reader["ParentRecoveryPointArn"].readIfPresent()
        value.compositeMemberIdentifier = try reader["CompositeMemberIdentifier"].readIfPresent()
        value.isParent = try reader["IsParent"].readIfPresent() ?? false
        value.resourceName = try reader["ResourceName"].readIfPresent()
        value.vaultType = try reader["VaultType"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.RecoveryPointMember {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.RecoveryPointMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.RecoveryPointMember()
        value.recoveryPointArn = try reader["RecoveryPointArn"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.RecoveryPointByResource {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.RecoveryPointByResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.RecoveryPointByResource()
        value.recoveryPointArn = try reader["RecoveryPointArn"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.encryptionKeyArn = try reader["EncryptionKeyArn"].readIfPresent()
        value.backupSizeBytes = try reader["BackupSizeBytes"].readIfPresent()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.isParent = try reader["IsParent"].readIfPresent() ?? false
        value.parentRecoveryPointArn = try reader["ParentRecoveryPointArn"].readIfPresent()
        value.resourceName = try reader["ResourceName"].readIfPresent()
        value.vaultType = try reader["VaultType"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.RestoreJobsListMember {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.RestoreJobsListMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.RestoreJobsListMember()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.restoreJobId = try reader["RestoreJobId"].readIfPresent()
        value.recoveryPointArn = try reader["RecoveryPointArn"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionDate = try reader["CompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.percentDone = try reader["PercentDone"].readIfPresent()
        value.backupSizeInBytes = try reader["BackupSizeInBytes"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        value.expectedCompletionTimeMinutes = try reader["ExpectedCompletionTimeMinutes"].readIfPresent()
        value.createdResourceArn = try reader["CreatedResourceArn"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.recoveryPointCreationDate = try reader["RecoveryPointCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: BackupClientTypes.RestoreJobCreator.read(from:))
        value.validationStatus = try reader["ValidationStatus"].readIfPresent()
        value.validationStatusMessage = try reader["ValidationStatusMessage"].readIfPresent()
        value.deletionStatus = try reader["DeletionStatus"].readIfPresent()
        value.deletionStatusMessage = try reader["DeletionStatusMessage"].readIfPresent()
        return value
    }
}

extension BackupClientTypes.RestoreJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.RestoreJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.RestoreJobSummary()
        value.region = try reader["Region"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.count = try reader["Count"].readIfPresent() ?? 0
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BackupClientTypes.RestoreTestingPlanForList {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.RestoreTestingPlanForList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.RestoreTestingPlanForList()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastExecutionTime = try reader["LastExecutionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.restoreTestingPlanArn = try reader["RestoreTestingPlanArn"].readIfPresent() ?? ""
        value.restoreTestingPlanName = try reader["RestoreTestingPlanName"].readIfPresent() ?? ""
        value.scheduleExpression = try reader["ScheduleExpression"].readIfPresent() ?? ""
        value.scheduleExpressionTimezone = try reader["ScheduleExpressionTimezone"].readIfPresent()
        value.startWindowHours = try reader["StartWindowHours"].readIfPresent() ?? 0
        return value
    }
}

extension BackupClientTypes.RestoreTestingSelectionForList {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupClientTypes.RestoreTestingSelectionForList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupClientTypes.RestoreTestingSelectionForList()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent() ?? ""
        value.protectedResourceType = try reader["ProtectedResourceType"].readIfPresent() ?? ""
        value.restoreTestingPlanName = try reader["RestoreTestingPlanName"].readIfPresent() ?? ""
        value.restoreTestingSelectionName = try reader["RestoreTestingSelectionName"].readIfPresent() ?? ""
        value.validationWindowHours = try reader["ValidationWindowHours"].readIfPresent() ?? 0
        return value
    }
}

extension BackupClientTypes.BackupPlanInput {

    static func write(value: BackupClientTypes.BackupPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdvancedBackupSettings"].writeList(value.advancedBackupSettings, memberWritingClosure: BackupClientTypes.AdvancedBackupSetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BackupPlanName"].write(value.backupPlanName)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: BackupClientTypes.BackupRuleInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BackupClientTypes.BackupRuleInput {

    static func write(value: BackupClientTypes.BackupRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CompletionWindowMinutes"].write(value.completionWindowMinutes)
        try writer["CopyActions"].writeList(value.copyActions, memberWritingClosure: BackupClientTypes.CopyAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EnableContinuousBackup"].write(value.enableContinuousBackup)
        try writer["Lifecycle"].write(value.lifecycle, with: BackupClientTypes.Lifecycle.write(value:to:))
        try writer["RecoveryPointTags"].writeMap(value.recoveryPointTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RuleName"].write(value.ruleName)
        try writer["ScheduleExpression"].write(value.scheduleExpression)
        try writer["ScheduleExpressionTimezone"].write(value.scheduleExpressionTimezone)
        try writer["StartWindowMinutes"].write(value.startWindowMinutes)
        try writer["TargetBackupVaultName"].write(value.targetBackupVaultName)
    }
}

extension BackupClientTypes.RestoreTestingPlanForCreate {

    static func write(value: BackupClientTypes.RestoreTestingPlanForCreate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecoveryPointSelection"].write(value.recoveryPointSelection, with: BackupClientTypes.RestoreTestingRecoveryPointSelection.write(value:to:))
        try writer["RestoreTestingPlanName"].write(value.restoreTestingPlanName)
        try writer["ScheduleExpression"].write(value.scheduleExpression)
        try writer["ScheduleExpressionTimezone"].write(value.scheduleExpressionTimezone)
        try writer["StartWindowHours"].write(value.startWindowHours)
    }
}

extension BackupClientTypes.RestoreTestingSelectionForCreate {

    static func write(value: BackupClientTypes.RestoreTestingSelectionForCreate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["ProtectedResourceArns"].writeList(value.protectedResourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProtectedResourceConditions"].write(value.protectedResourceConditions, with: BackupClientTypes.ProtectedResourceConditions.write(value:to:))
        try writer["ProtectedResourceType"].write(value.protectedResourceType)
        try writer["RestoreMetadataOverrides"].writeMap(value.restoreMetadataOverrides, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RestoreTestingSelectionName"].write(value.restoreTestingSelectionName)
        try writer["ValidationWindowHours"].write(value.validationWindowHours)
    }
}

extension BackupClientTypes.RestoreTestingPlanForUpdate {

    static func write(value: BackupClientTypes.RestoreTestingPlanForUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecoveryPointSelection"].write(value.recoveryPointSelection, with: BackupClientTypes.RestoreTestingRecoveryPointSelection.write(value:to:))
        try writer["ScheduleExpression"].write(value.scheduleExpression)
        try writer["ScheduleExpressionTimezone"].write(value.scheduleExpressionTimezone)
        try writer["StartWindowHours"].write(value.startWindowHours)
    }
}

extension BackupClientTypes.RestoreTestingSelectionForUpdate {

    static func write(value: BackupClientTypes.RestoreTestingSelectionForUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["ProtectedResourceArns"].writeList(value.protectedResourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProtectedResourceConditions"].write(value.protectedResourceConditions, with: BackupClientTypes.ProtectedResourceConditions.write(value:to:))
        try writer["RestoreMetadataOverrides"].writeMap(value.restoreMetadataOverrides, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ValidationWindowHours"].write(value.validationWindowHours)
    }
}

public enum BackupClientTypes {}
