// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BackupClientTypes.AdvancedBackupSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupOptions = "BackupOptions"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupOptions = backupOptions {
            var backupOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupOptions)
            for (dictKey0, backupOptions0) in backupOptions {
                try backupOptionsContainer.encode(backupOptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let backupOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
    }
}

extension BackupClientTypes {
    /// A list of backup options for each resource type.
    public struct AdvancedBackupSetting: Swift.Equatable {
        /// Specifies the backup option for a selected resource. This option is only available for Windows VSS backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS":"disabled" to create a regular backup. The WindowsVSS option is not enabled by default. If you specify an invalid option, you get an InvalidParameterValueException exception. For more information about Windows VSS backups, see [Creating a VSS-Enabled Windows Backup](https://docs.aws.amazon.com/aws-backup/latest/devguide/windows-backups.html).
        public var backupOptions: [Swift.String:Swift.String]?
        /// Specifies an object containing resource type and backup options. The only supported resource type is Amazon EC2 instances with Windows Volume Shadow Copy Service (VSS). For a CloudFormation example, see the [sample CloudFormation template to enable Windows VSS](https://docs.aws.amazon.com/aws-backup/latest/devguide/integrate-cloudformation-with-aws-backup.html) in the Backup User Guide. Valid values: EC2.
        public var resourceType: Swift.String?

        public init(
            backupOptions: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.backupOptions = backupOptions
            self.resourceType = resourceType
        }
    }

}

extension AlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.arn = output.arn
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.creatorRequestId = output.creatorRequestId
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.arn = nil
            self.properties.code = nil
            self.properties.context = nil
            self.properties.creatorRequestId = nil
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The required resource already exists.
public struct AlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var arn: Swift.String? = nil
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        ///
        public internal(set) var creatorRequestId: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        arn: Swift.String? = nil,
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        creatorRequestId: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.arn = arn
        self.properties.code = code
        self.properties.context = context
        self.properties.creatorRequestId = creatorRequestId
        self.properties.message = message
        self.properties.type = type
    }
}

struct AlreadyExistsExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let creatorRequestId: Swift.String?
    let arn: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension AlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case code = "Code"
        case context = "Context"
        case creatorRequestId = "CreatorRequestId"
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes.BackupJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupJobId = "BackupJobId"
        case backupOptions = "BackupOptions"
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupType = "BackupType"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case bytesTransferred = "BytesTransferred"
        case completionDate = "CompletionDate"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case expectedCompletionDate = "ExpectedCompletionDate"
        case iamRoleArn = "IamRoleArn"
        case isParent = "IsParent"
        case parentJobId = "ParentJobId"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case startBy = "StartBy"
        case state = "State"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let backupJobId = self.backupJobId {
            try encodeContainer.encode(backupJobId, forKey: .backupJobId)
        }
        if let backupOptions = backupOptions {
            var backupOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupOptions)
            for (dictKey0, backupOptions0) in backupOptions {
                try backupOptionsContainer.encode(backupOptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let backupSizeInBytes = self.backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let backupType = self.backupType {
            try encodeContainer.encode(backupType, forKey: .backupType)
        }
        if let backupVaultArn = self.backupVaultArn {
            try encodeContainer.encode(backupVaultArn, forKey: .backupVaultArn)
        }
        if let backupVaultName = self.backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let bytesTransferred = self.bytesTransferred {
            try encodeContainer.encode(bytesTransferred, forKey: .bytesTransferred)
        }
        if let completionDate = self.completionDate {
            try encodeContainer.encodeTimestamp(completionDate, format: .epochSeconds, forKey: .completionDate)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let expectedCompletionDate = self.expectedCompletionDate {
            try encodeContainer.encodeTimestamp(expectedCompletionDate, format: .epochSeconds, forKey: .expectedCompletionDate)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if isParent != false {
            try encodeContainer.encode(isParent, forKey: .isParent)
        }
        if let parentJobId = self.parentJobId {
            try encodeContainer.encode(parentJobId, forKey: .parentJobId)
        }
        if let percentDone = self.percentDone {
            try encodeContainer.encode(percentDone, forKey: .percentDone)
        }
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let startBy = self.startBy {
            try encodeContainer.encodeTimestamp(startBy, format: .epochSeconds, forKey: .startBy)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let backupJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupJobId)
        backupJobId = backupJobIdDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDate)
        completionDate = completionDateDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupJobState.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let expectedCompletionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expectedCompletionDate)
        expectedCompletionDate = expectedCompletionDateDecoded
        let startByDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startBy)
        startBy = startByDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let bytesTransferredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesTransferred)
        bytesTransferred = bytesTransferredDecoded
        let backupOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
        let backupTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupType)
        backupType = backupTypeDecoded
        let parentJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentJobId)
        parentJobId = parentJobIdDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about a backup job.
    public struct BackupJob: Swift.Equatable {
        /// The account ID that owns the backup job.
        public var accountId: Swift.String?
        /// Uniquely identifies a request to Backup to back up a resource.
        public var backupJobId: Swift.String?
        /// Specifies the backup option for a selected resource. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS":"disabled" to create a regular backup. If you specify an invalid option, you get an InvalidParameterValueException exception.
        public var backupOptions: [Swift.String:Swift.String]?
        /// The size, in bytes, of a backup.
        public var backupSizeInBytes: Swift.Int?
        /// Represents the type of backup for a backup job.
        public var backupType: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// The size in bytes transferred to a backup vault at the time that the job status was queried.
        public var bytesTransferred: Swift.Int?
        /// The date and time a job to create a backup job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: ClientRuntime.Date?
        /// Contains identifying information about the creation of a backup job, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan used to create it.
        public var createdBy: BackupClientTypes.RecoveryPointCreator?
        /// The date and time a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// The date and time a job to back up resources is expected to be completed, in Unix format and Coordinated Universal Time (UTC). The value of ExpectedCompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var expectedCompletionDate: ClientRuntime.Date?
        /// Specifies the IAM role ARN used to create the target recovery point. IAM roles other than the default role must include either AWSBackup or AwsBackup in the role name. For example, arn:aws:iam::123456789012:role/AWSBackupRDSAccess. Role names without those strings lack permissions to perform backup jobs.
        public var iamRoleArn: Swift.String?
        /// This is a boolean value indicating this is a parent (composite) backup job.
        public var isParent: Swift.Bool
        /// This uniquely identifies a request to Backup to back up a resource. The return will be the parent (composite) job ID.
        public var parentJobId: Swift.String?
        /// Contains an estimated percentage complete of a job at the time the job status was queried.
        public var percentDone: Swift.String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var resourceArn: Swift.String?
        /// This is the non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?
        /// Specifies the time in Unix format and Coordinated Universal Time (UTC) when a backup job must be started before it is canceled. The value is calculated by adding the start window to the scheduled time. So if the scheduled time were 6:00 PM and the start window is 2 hours, the StartBy time would be 8:00 PM on the date specified. The value of StartBy is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var startBy: ClientRuntime.Date?
        /// The current state of a backup job.
        public var state: BackupClientTypes.BackupJobState?
        /// A detailed message explaining the status of the job to back up a resource.
        public var statusMessage: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            backupJobId: Swift.String? = nil,
            backupOptions: [Swift.String:Swift.String]? = nil,
            backupSizeInBytes: Swift.Int? = nil,
            backupType: Swift.String? = nil,
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            bytesTransferred: Swift.Int? = nil,
            completionDate: ClientRuntime.Date? = nil,
            createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
            creationDate: ClientRuntime.Date? = nil,
            expectedCompletionDate: ClientRuntime.Date? = nil,
            iamRoleArn: Swift.String? = nil,
            isParent: Swift.Bool = false,
            parentJobId: Swift.String? = nil,
            percentDone: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            startBy: ClientRuntime.Date? = nil,
            state: BackupClientTypes.BackupJobState? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.backupJobId = backupJobId
            self.backupOptions = backupOptions
            self.backupSizeInBytes = backupSizeInBytes
            self.backupType = backupType
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.bytesTransferred = bytesTransferred
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.expectedCompletionDate = expectedCompletionDate
            self.iamRoleArn = iamRoleArn
            self.isParent = isParent
            self.parentJobId = parentJobId
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.startBy = startBy
            self.state = state
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes {
    public enum BackupJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case aborting
        case completed
        case created
        case expired
        case failed
        case partial
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupJobState] {
            return [
                .aborted,
                .aborting,
                .completed,
                .created,
                .expired,
                .failed,
                .partial,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .aborting: return "ABORTING"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .expired: return "EXPIRED"
            case .failed: return "FAILED"
            case .partial: return "PARTIAL"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupJobState(rawValue: rawValue) ?? BackupJobState.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.BackupPlan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanName = "BackupPlanName"
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedBackupSettings = advancedBackupSettings {
            var advancedBackupSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedBackupSettings)
            for advancedbackupsetting0 in advancedBackupSettings {
                try advancedBackupSettingsContainer.encode(advancedbackupsetting0)
            }
        }
        if let backupPlanName = self.backupPlanName {
            try encodeContainer.encode(backupPlanName, forKey: .backupPlanName)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for backuprule0 in rules {
                try rulesContainer.encode(backuprule0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanName)
        backupPlanName = backupPlanNameDecoded
        let rulesContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupRule?].self, forKey: .rules)
        var rulesDecoded0:[BackupClientTypes.BackupRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [BackupClientTypes.BackupRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension BackupClientTypes {
    /// Contains an optional backup plan display name and an array of BackupRule objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task and can back up a different selection of Amazon Web Services resources.
    public struct BackupPlan: Swift.Equatable {
        /// Contains a list of BackupOptions for each resource type.
        public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
        /// The display name of a backup plan. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var backupPlanName: Swift.String?
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        /// This member is required.
        public var rules: [BackupClientTypes.BackupRule]?

        public init(
            advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
            backupPlanName: Swift.String? = nil,
            rules: [BackupClientTypes.BackupRule]? = nil
        )
        {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.rules = rules
        }
    }

}

extension BackupClientTypes.BackupPlanInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanName = "BackupPlanName"
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedBackupSettings = advancedBackupSettings {
            var advancedBackupSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedBackupSettings)
            for advancedbackupsetting0 in advancedBackupSettings {
                try advancedBackupSettingsContainer.encode(advancedbackupsetting0)
            }
        }
        if let backupPlanName = self.backupPlanName {
            try encodeContainer.encode(backupPlanName, forKey: .backupPlanName)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for backupruleinput0 in rules {
                try rulesContainer.encode(backupruleinput0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanName)
        backupPlanName = backupPlanNameDecoded
        let rulesContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupRuleInput?].self, forKey: .rules)
        var rulesDecoded0:[BackupClientTypes.BackupRuleInput]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [BackupClientTypes.BackupRuleInput]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension BackupClientTypes {
    /// Contains an optional backup plan display name and an array of BackupRule objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task.
    public struct BackupPlanInput: Swift.Equatable {
        /// Specifies a list of BackupOptions for each resource type. These settings are only available for Windows Volume Shadow Copy Service (VSS) backup jobs.
        public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
        /// The display name of a backup plan. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var backupPlanName: Swift.String?
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        /// This member is required.
        public var rules: [BackupClientTypes.BackupRuleInput]?

        public init(
            advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
            backupPlanName: Swift.String? = nil,
            rules: [BackupClientTypes.BackupRuleInput]? = nil
        )
        {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.rules = rules
        }
    }

}

extension BackupClientTypes.BackupPlanTemplatesListMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplateId = "BackupPlanTemplateId"
        case backupPlanTemplateName = "BackupPlanTemplateName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanTemplateId = self.backupPlanTemplateId {
            try encodeContainer.encode(backupPlanTemplateId, forKey: .backupPlanTemplateId)
        }
        if let backupPlanTemplateName = self.backupPlanTemplateName {
            try encodeContainer.encode(backupPlanTemplateName, forKey: .backupPlanTemplateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanTemplateId)
        backupPlanTemplateId = backupPlanTemplateIdDecoded
        let backupPlanTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanTemplateName)
        backupPlanTemplateName = backupPlanTemplateNameDecoded
    }
}

extension BackupClientTypes {
    /// An object specifying metadata associated with a backup plan template.
    public struct BackupPlanTemplatesListMember: Swift.Equatable {
        /// Uniquely identifies a stored backup plan template.
        public var backupPlanTemplateId: Swift.String?
        /// The optional display name of a backup plan template.
        public var backupPlanTemplateName: Swift.String?

        public init(
            backupPlanTemplateId: Swift.String? = nil,
            backupPlanTemplateName: Swift.String? = nil
        )
        {
            self.backupPlanTemplateId = backupPlanTemplateId
            self.backupPlanTemplateName = backupPlanTemplateName
        }
    }

}

extension BackupClientTypes.BackupPlansListMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case backupPlanName = "BackupPlanName"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case deletionDate = "DeletionDate"
        case lastExecutionDate = "LastExecutionDate"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedBackupSettings = advancedBackupSettings {
            var advancedBackupSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedBackupSettings)
            for advancedbackupsetting0 in advancedBackupSettings {
                try advancedBackupSettingsContainer.encode(advancedbackupsetting0)
            }
        }
        if let backupPlanArn = self.backupPlanArn {
            try encodeContainer.encode(backupPlanArn, forKey: .backupPlanArn)
        }
        if let backupPlanId = self.backupPlanId {
            try encodeContainer.encode(backupPlanId, forKey: .backupPlanId)
        }
        if let backupPlanName = self.backupPlanName {
            try encodeContainer.encode(backupPlanName, forKey: .backupPlanName)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let deletionDate = self.deletionDate {
            try encodeContainer.encodeTimestamp(deletionDate, format: .epochSeconds, forKey: .deletionDate)
        }
        if let lastExecutionDate = self.lastExecutionDate {
            try encodeContainer.encodeTimestamp(lastExecutionDate, format: .epochSeconds, forKey: .lastExecutionDate)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let deletionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let backupPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanName)
        backupPlanName = backupPlanNameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let lastExecutionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension BackupClientTypes {
    /// Contains metadata about a backup plan.
    public struct BackupPlansListMember: Swift.Equatable {
        /// Contains a list of BackupOptions for a resource type.
        public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public var backupPlanArn: Swift.String?
        /// Uniquely identifies a backup plan.
        public var backupPlanId: Swift.String?
        /// The display name of a saved backup plan.
        public var backupPlanName: Swift.String?
        /// The date and time a resource backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public var creatorRequestId: Swift.String?
        /// The date and time a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var deletionDate: ClientRuntime.Date?
        /// The last time a job to back up resources was run with this rule. A date and time, in Unix format and Coordinated Universal Time (UTC). The value of LastExecutionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastExecutionDate: ClientRuntime.Date?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
        public var versionId: Swift.String?

        public init(
            advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
            backupPlanArn: Swift.String? = nil,
            backupPlanId: Swift.String? = nil,
            backupPlanName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            deletionDate: ClientRuntime.Date? = nil,
            lastExecutionDate: ClientRuntime.Date? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanName = backupPlanName
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.deletionDate = deletionDate
            self.lastExecutionDate = lastExecutionDate
            self.versionId = versionId
        }
    }

}

extension BackupClientTypes.BackupRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionWindowMinutes = "CompletionWindowMinutes"
        case copyActions = "CopyActions"
        case enableContinuousBackup = "EnableContinuousBackup"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case ruleId = "RuleId"
        case ruleName = "RuleName"
        case scheduleExpression = "ScheduleExpression"
        case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
        case startWindowMinutes = "StartWindowMinutes"
        case targetBackupVaultName = "TargetBackupVaultName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionWindowMinutes = self.completionWindowMinutes {
            try encodeContainer.encode(completionWindowMinutes, forKey: .completionWindowMinutes)
        }
        if let copyActions = copyActions {
            var copyActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .copyActions)
            for copyaction0 in copyActions {
                try copyActionsContainer.encode(copyaction0)
            }
        }
        if let enableContinuousBackup = self.enableContinuousBackup {
            try encodeContainer.encode(enableContinuousBackup, forKey: .enableContinuousBackup)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointTags = recoveryPointTags {
            var recoveryPointTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .recoveryPointTags)
            for (dictKey0, tags0) in recoveryPointTags {
                try recoveryPointTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let scheduleExpressionTimezone = self.scheduleExpressionTimezone {
            try encodeContainer.encode(scheduleExpressionTimezone, forKey: .scheduleExpressionTimezone)
        }
        if let startWindowMinutes = self.startWindowMinutes {
            try encodeContainer.encode(startWindowMinutes, forKey: .startWindowMinutes)
        }
        if let targetBackupVaultName = self.targetBackupVaultName {
            try encodeContainer.encode(targetBackupVaultName, forKey: .targetBackupVaultName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let targetBackupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBackupVaultName)
        targetBackupVaultName = targetBackupVaultNameDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let startWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startWindowMinutes)
        startWindowMinutes = startWindowMinutesDecoded
        let completionWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completionWindowMinutes)
        completionWindowMinutes = completionWindowMinutesDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let recoveryPointTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .recoveryPointTags)
        var recoveryPointTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let recoveryPointTagsContainer = recoveryPointTagsContainer {
            recoveryPointTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in recoveryPointTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    recoveryPointTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        recoveryPointTags = recoveryPointTagsDecoded0
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let copyActionsContainer = try containerValues.decodeIfPresent([BackupClientTypes.CopyAction?].self, forKey: .copyActions)
        var copyActionsDecoded0:[BackupClientTypes.CopyAction]? = nil
        if let copyActionsContainer = copyActionsContainer {
            copyActionsDecoded0 = [BackupClientTypes.CopyAction]()
            for structure0 in copyActionsContainer {
                if let structure0 = structure0 {
                    copyActionsDecoded0?.append(structure0)
                }
            }
        }
        copyActions = copyActionsDecoded0
        let enableContinuousBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableContinuousBackup)
        enableContinuousBackup = enableContinuousBackupDecoded
        let scheduleExpressionTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpressionTimezone)
        scheduleExpressionTimezone = scheduleExpressionTimezoneDecoded
    }
}

extension BackupClientTypes.BackupRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupRule(completionWindowMinutes: \(Swift.String(describing: completionWindowMinutes)), copyActions: \(Swift.String(describing: copyActions)), enableContinuousBackup: \(Swift.String(describing: enableContinuousBackup)), lifecycle: \(Swift.String(describing: lifecycle)), ruleId: \(Swift.String(describing: ruleId)), ruleName: \(Swift.String(describing: ruleName)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), scheduleExpressionTimezone: \(Swift.String(describing: scheduleExpressionTimezone)), startWindowMinutes: \(Swift.String(describing: startWindowMinutes)), targetBackupVaultName: \(Swift.String(describing: targetBackupVaultName)), recoveryPointTags: \"CONTENT_REDACTED\")"}
}

extension BackupClientTypes {
    /// Specifies a scheduled task used to back up a selection of resources.
    public struct BackupRule: Swift.Equatable {
        /// A value in minutes after a backup job is successfully started before it must be completed or it will be canceled by Backup. This value is optional.
        public var completionWindowMinutes: Swift.Int?
        /// An array of CopyAction objects, which contains the details of the copy operation.
        public var copyActions: [BackupClientTypes.CopyAction]?
        /// Specifies whether Backup creates continuous backups. True causes Backup to create continuous backups capable of point-in-time restore (PITR). False (or not specified) causes Backup to create snapshot backups.
        public var enableContinuousBackup: Swift.Bool?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the retention setting must be 90 days greater than the transition to cold after days setting. The transition to cold after days setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
        public var lifecycle: BackupClientTypes.Lifecycle?
        /// An array of key-value pair strings that are assigned to resources that are associated with this rule when restored from backup.
        public var recoveryPointTags: [Swift.String:Swift.String]?
        /// Uniquely identifies a rule that is used to schedule the backup of a selection of resources.
        public var ruleId: Swift.String?
        /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var ruleName: Swift.String?
        /// A cron expression in UTC specifying when Backup initiates a backup job. For more information about Amazon Web Services cron expressions, see [Schedule Expressions for Rules](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html) in the Amazon CloudWatch Events User Guide.. Two examples of Amazon Web Services cron expressions are  15 * ? * * * (take a backup every hour at 15 minutes past the hour) and 0 12 * * ? * (take a backup every day at 12 noon UTC). For a table of examples, click the preceding link and scroll down the page.
        public var scheduleExpression: Swift.String?
        /// This is the timezone in which the schedule expression is set. By default, ScheduleExpressions are in UTC. You can modify this to a specified timezone.
        public var scheduleExpressionTimezone: Swift.String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional. If this value is included, it must be at least 60 minutes to avoid errors. During the start window, the backup job status remains in CREATED status until it has successfully begun or until the start window time has run out. If within the start window time Backup receives an error that allows the job to be retried, Backup will automatically retry to begin the job at least every 10 minutes until the backup successfully begins (the job status changes to RUNNING) or until the job status changes to EXPIRED (which is expected to occur when the start window time is over).
        public var startWindowMinutes: Swift.Int?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        /// This member is required.
        public var targetBackupVaultName: Swift.String?

        public init(
            completionWindowMinutes: Swift.Int? = nil,
            copyActions: [BackupClientTypes.CopyAction]? = nil,
            enableContinuousBackup: Swift.Bool? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil,
            recoveryPointTags: [Swift.String:Swift.String]? = nil,
            ruleId: Swift.String? = nil,
            ruleName: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleExpressionTimezone: Swift.String? = nil,
            startWindowMinutes: Swift.Int? = nil,
            targetBackupVaultName: Swift.String? = nil
        )
        {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.lifecycle = lifecycle
            self.recoveryPointTags = recoveryPointTags
            self.ruleId = ruleId
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVaultName = targetBackupVaultName
        }
    }

}

extension BackupClientTypes.BackupRuleInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionWindowMinutes = "CompletionWindowMinutes"
        case copyActions = "CopyActions"
        case enableContinuousBackup = "EnableContinuousBackup"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case ruleName = "RuleName"
        case scheduleExpression = "ScheduleExpression"
        case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
        case startWindowMinutes = "StartWindowMinutes"
        case targetBackupVaultName = "TargetBackupVaultName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionWindowMinutes = self.completionWindowMinutes {
            try encodeContainer.encode(completionWindowMinutes, forKey: .completionWindowMinutes)
        }
        if let copyActions = copyActions {
            var copyActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .copyActions)
            for copyaction0 in copyActions {
                try copyActionsContainer.encode(copyaction0)
            }
        }
        if let enableContinuousBackup = self.enableContinuousBackup {
            try encodeContainer.encode(enableContinuousBackup, forKey: .enableContinuousBackup)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointTags = recoveryPointTags {
            var recoveryPointTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .recoveryPointTags)
            for (dictKey0, tags0) in recoveryPointTags {
                try recoveryPointTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let scheduleExpressionTimezone = self.scheduleExpressionTimezone {
            try encodeContainer.encode(scheduleExpressionTimezone, forKey: .scheduleExpressionTimezone)
        }
        if let startWindowMinutes = self.startWindowMinutes {
            try encodeContainer.encode(startWindowMinutes, forKey: .startWindowMinutes)
        }
        if let targetBackupVaultName = self.targetBackupVaultName {
            try encodeContainer.encode(targetBackupVaultName, forKey: .targetBackupVaultName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let targetBackupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBackupVaultName)
        targetBackupVaultName = targetBackupVaultNameDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let startWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startWindowMinutes)
        startWindowMinutes = startWindowMinutesDecoded
        let completionWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completionWindowMinutes)
        completionWindowMinutes = completionWindowMinutesDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let recoveryPointTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .recoveryPointTags)
        var recoveryPointTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let recoveryPointTagsContainer = recoveryPointTagsContainer {
            recoveryPointTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in recoveryPointTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    recoveryPointTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        recoveryPointTags = recoveryPointTagsDecoded0
        let copyActionsContainer = try containerValues.decodeIfPresent([BackupClientTypes.CopyAction?].self, forKey: .copyActions)
        var copyActionsDecoded0:[BackupClientTypes.CopyAction]? = nil
        if let copyActionsContainer = copyActionsContainer {
            copyActionsDecoded0 = [BackupClientTypes.CopyAction]()
            for structure0 in copyActionsContainer {
                if let structure0 = structure0 {
                    copyActionsDecoded0?.append(structure0)
                }
            }
        }
        copyActions = copyActionsDecoded0
        let enableContinuousBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableContinuousBackup)
        enableContinuousBackup = enableContinuousBackupDecoded
        let scheduleExpressionTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpressionTimezone)
        scheduleExpressionTimezone = scheduleExpressionTimezoneDecoded
    }
}

extension BackupClientTypes.BackupRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupRuleInput(completionWindowMinutes: \(Swift.String(describing: completionWindowMinutes)), copyActions: \(Swift.String(describing: copyActions)), enableContinuousBackup: \(Swift.String(describing: enableContinuousBackup)), lifecycle: \(Swift.String(describing: lifecycle)), ruleName: \(Swift.String(describing: ruleName)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), scheduleExpressionTimezone: \(Swift.String(describing: scheduleExpressionTimezone)), startWindowMinutes: \(Swift.String(describing: startWindowMinutes)), targetBackupVaultName: \(Swift.String(describing: targetBackupVaultName)), recoveryPointTags: \"CONTENT_REDACTED\")"}
}

extension BackupClientTypes {
    /// Specifies a scheduled task used to back up a selection of resources.
    public struct BackupRuleInput: Swift.Equatable {
        /// A value in minutes after a backup job is successfully started before it must be completed or it will be canceled by Backup. This value is optional.
        public var completionWindowMinutes: Swift.Int?
        /// An array of CopyAction objects, which contains the details of the copy operation.
        public var copyActions: [BackupClientTypes.CopyAction]?
        /// Specifies whether Backup creates continuous backups. True causes Backup to create continuous backups capable of point-in-time restore (PITR). False (or not specified) causes Backup to create snapshot backups.
        public var enableContinuousBackup: Swift.Bool?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup will transition and expire backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the retention setting must be 90 days greater than the transition to cold after days setting. The transition to cold after days setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types. This parameter has a maximum value of 100 years (36,500 days).
        public var lifecycle: BackupClientTypes.Lifecycle?
        /// To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair.
        public var recoveryPointTags: [Swift.String:Swift.String]?
        /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var ruleName: Swift.String?
        /// A CRON expression in UTC specifying when Backup initiates a backup job.
        public var scheduleExpression: Swift.String?
        /// This is the timezone in which the schedule expression is set. By default, ScheduleExpressions are in UTC. You can modify this to a specified timezone.
        public var scheduleExpressionTimezone: Swift.String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional. If this value is included, it must be at least 60 minutes to avoid errors. This parameter has a maximum value of 100 years (52,560,000 minutes). During the start window, the backup job status remains in CREATED status until it has successfully begun or until the start window time has run out. If within the start window time Backup receives an error that allows the job to be retried, Backup will automatically retry to begin the job at least every 10 minutes until the backup successfully begins (the job status changes to RUNNING) or until the job status changes to EXPIRED (which is expected to occur when the start window time is over).
        public var startWindowMinutes: Swift.Int?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        /// This member is required.
        public var targetBackupVaultName: Swift.String?

        public init(
            completionWindowMinutes: Swift.Int? = nil,
            copyActions: [BackupClientTypes.CopyAction]? = nil,
            enableContinuousBackup: Swift.Bool? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil,
            recoveryPointTags: [Swift.String:Swift.String]? = nil,
            ruleName: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleExpressionTimezone: Swift.String? = nil,
            startWindowMinutes: Swift.Int? = nil,
            targetBackupVaultName: Swift.String? = nil
        )
        {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.lifecycle = lifecycle
            self.recoveryPointTags = recoveryPointTags
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVaultName = targetBackupVaultName
        }
    }

}

extension BackupClientTypes.BackupSelection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditions = "Conditions"
        case iamRoleArn = "IamRoleArn"
        case listOfTags = "ListOfTags"
        case notResources = "NotResources"
        case resources = "Resources"
        case selectionName = "SelectionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditions = self.conditions {
            try encodeContainer.encode(conditions, forKey: .conditions)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let listOfTags = listOfTags {
            var listOfTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listOfTags)
            for condition0 in listOfTags {
                try listOfTagsContainer.encode(condition0)
            }
        }
        if let notResources = notResources {
            var notResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notResources)
            for arn0 in notResources {
                try notResourcesContainer.encode(arn0)
            }
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for arn0 in resources {
                try resourcesContainer.encode(arn0)
            }
        }
        if let selectionName = self.selectionName {
            try encodeContainer.encode(selectionName, forKey: .selectionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionName)
        selectionName = selectionNameDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resources)
        var resourcesDecoded0:[Swift.String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Swift.String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
        let listOfTagsContainer = try containerValues.decodeIfPresent([BackupClientTypes.Condition?].self, forKey: .listOfTags)
        var listOfTagsDecoded0:[BackupClientTypes.Condition]? = nil
        if let listOfTagsContainer = listOfTagsContainer {
            listOfTagsDecoded0 = [BackupClientTypes.Condition]()
            for structure0 in listOfTagsContainer {
                if let structure0 = structure0 {
                    listOfTagsDecoded0?.append(structure0)
                }
            }
        }
        listOfTags = listOfTagsDecoded0
        let notResourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notResources)
        var notResourcesDecoded0:[Swift.String]? = nil
        if let notResourcesContainer = notResourcesContainer {
            notResourcesDecoded0 = [Swift.String]()
            for string0 in notResourcesContainer {
                if let string0 = string0 {
                    notResourcesDecoded0?.append(string0)
                }
            }
        }
        notResources = notResourcesDecoded0
        let conditionsDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Conditions.self, forKey: .conditions)
        conditions = conditionsDecoded
    }
}

extension BackupClientTypes {
    /// Used to specify a set of resources to a backup plan. Specifying your desired Conditions, ListOfTags, NotResources, and/or Resources is recommended. If none of these are specified, Backup will attempt to select all supported and opted-in storage resources, which could have unintended cost implications.
    public struct BackupSelection: Swift.Equatable {
        /// A list of conditions that you define to assign resources to your backup plans using tags. For example, "StringEquals": { "ConditionKey": "aws:ResourceTag/CreatedByCryo", "ConditionValue": "true" },. Condition operators are case sensitive. Conditions differs from ListOfTags as follows:
        ///
        /// * When you specify more than one condition, you only assign the resources that match ALL conditions (using AND logic).
        ///
        /// * Conditions supports StringEquals, StringLike, StringNotEquals, and StringNotLike. ListOfTags only supports StringEquals.
        public var conditions: BackupClientTypes.Conditions?
        /// The ARN of the IAM role that Backup uses to authenticate when backing up the target resource; for example, arn:aws:iam::123456789012:role/S3Access.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// A list of conditions that you define to assign resources to your backup plans using tags. For example, "StringEquals": { "ConditionKey": "aws:ResourceTag/CreatedByCryo", "ConditionValue": "true" },. Condition operators are case sensitive. ListOfTags differs from Conditions as follows:
        ///
        /// * When you specify more than one condition, you assign all resources that match AT LEAST ONE condition (using OR logic).
        ///
        /// * ListOfTags only supports StringEquals. Conditions supports StringEquals, StringLike, StringNotEquals, and StringNotLike.
        public var listOfTags: [BackupClientTypes.Condition]?
        /// A list of Amazon Resource Names (ARNs) to exclude from a backup plan. The maximum number of ARNs is 500 without wildcards, or 30 ARNs with wildcards. If you need to exclude many resources from a backup plan, consider a different resource selection strategy, such as assigning only one or a few resource types or refining your resource selection using tags.
        public var notResources: [Swift.String]?
        /// A list of Amazon Resource Names (ARNs) to assign to a backup plan. The maximum number of ARNs is 500 without wildcards, or 30 ARNs with wildcards. If you need to assign many resources to a backup plan, consider a different resource selection strategy, such as assigning all resources of a resource type or refining your resource selection using tags.
        public var resources: [Swift.String]?
        /// The display name of a resource selection document. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var selectionName: Swift.String?

        public init(
            conditions: BackupClientTypes.Conditions? = nil,
            iamRoleArn: Swift.String? = nil,
            listOfTags: [BackupClientTypes.Condition]? = nil,
            notResources: [Swift.String]? = nil,
            resources: [Swift.String]? = nil,
            selectionName: Swift.String? = nil
        )
        {
            self.conditions = conditions
            self.iamRoleArn = iamRoleArn
            self.listOfTags = listOfTags
            self.notResources = notResources
            self.resources = resources
            self.selectionName = selectionName
        }
    }

}

extension BackupClientTypes.BackupSelectionsListMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case iamRoleArn = "IamRoleArn"
        case selectionId = "SelectionId"
        case selectionName = "SelectionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanId = self.backupPlanId {
            try encodeContainer.encode(backupPlanId, forKey: .backupPlanId)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let selectionId = self.selectionId {
            try encodeContainer.encode(selectionId, forKey: .selectionId)
        }
        if let selectionName = self.selectionName {
            try encodeContainer.encode(selectionName, forKey: .selectionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionId)
        selectionId = selectionIdDecoded
        let selectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionName)
        selectionName = selectionNameDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

extension BackupClientTypes {
    /// Contains metadata about a BackupSelection object.
    public struct BackupSelectionsListMember: Swift.Equatable {
        /// Uniquely identifies a backup plan.
        public var backupPlanId: Swift.String?
        /// The date and time a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public var creatorRequestId: Swift.String?
        /// Specifies the IAM role Amazon Resource Name (ARN) to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// Uniquely identifies a request to assign a set of resources to a backup plan.
        public var selectionId: Swift.String?
        /// The display name of a resource selection document.
        public var selectionName: Swift.String?

        public init(
            backupPlanId: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            selectionId: Swift.String? = nil,
            selectionName: Swift.String? = nil
        )
        {
            self.backupPlanId = backupPlanId
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.iamRoleArn = iamRoleArn
            self.selectionId = selectionId
            self.selectionName = selectionName
        }
    }

}

extension BackupClientTypes {
    public enum BackupVaultEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backupJobCompleted
        case backupJobExpired
        case backupJobFailed
        case backupJobStarted
        case backupJobSuccessful
        case backupPlanCreated
        case backupPlanModified
        case copyJobFailed
        case copyJobStarted
        case copyJobSuccessful
        case recoveryPointModified
        case restoreJobCompleted
        case restoreJobFailed
        case restoreJobStarted
        case restoreJobSuccessful
        case s3BackupObjectFailed
        case s3RestoreObjectFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupVaultEvent] {
            return [
                .backupJobCompleted,
                .backupJobExpired,
                .backupJobFailed,
                .backupJobStarted,
                .backupJobSuccessful,
                .backupPlanCreated,
                .backupPlanModified,
                .copyJobFailed,
                .copyJobStarted,
                .copyJobSuccessful,
                .recoveryPointModified,
                .restoreJobCompleted,
                .restoreJobFailed,
                .restoreJobStarted,
                .restoreJobSuccessful,
                .s3BackupObjectFailed,
                .s3RestoreObjectFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backupJobCompleted: return "BACKUP_JOB_COMPLETED"
            case .backupJobExpired: return "BACKUP_JOB_EXPIRED"
            case .backupJobFailed: return "BACKUP_JOB_FAILED"
            case .backupJobStarted: return "BACKUP_JOB_STARTED"
            case .backupJobSuccessful: return "BACKUP_JOB_SUCCESSFUL"
            case .backupPlanCreated: return "BACKUP_PLAN_CREATED"
            case .backupPlanModified: return "BACKUP_PLAN_MODIFIED"
            case .copyJobFailed: return "COPY_JOB_FAILED"
            case .copyJobStarted: return "COPY_JOB_STARTED"
            case .copyJobSuccessful: return "COPY_JOB_SUCCESSFUL"
            case .recoveryPointModified: return "RECOVERY_POINT_MODIFIED"
            case .restoreJobCompleted: return "RESTORE_JOB_COMPLETED"
            case .restoreJobFailed: return "RESTORE_JOB_FAILED"
            case .restoreJobStarted: return "RESTORE_JOB_STARTED"
            case .restoreJobSuccessful: return "RESTORE_JOB_SUCCESSFUL"
            case .s3BackupObjectFailed: return "S3_BACKUP_OBJECT_FAILED"
            case .s3RestoreObjectFailed: return "S3_RESTORE_OBJECT_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupVaultEvent(rawValue: rawValue) ?? BackupVaultEvent.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.BackupVaultListMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
        case lockDate = "LockDate"
        case locked = "Locked"
        case maxRetentionDays = "MaxRetentionDays"
        case minRetentionDays = "MinRetentionDays"
        case numberOfRecoveryPoints = "NumberOfRecoveryPoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultArn = self.backupVaultArn {
            try encodeContainer.encode(backupVaultArn, forKey: .backupVaultArn)
        }
        if let backupVaultName = self.backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let lockDate = self.lockDate {
            try encodeContainer.encodeTimestamp(lockDate, format: .epochSeconds, forKey: .lockDate)
        }
        if let locked = self.locked {
            try encodeContainer.encode(locked, forKey: .locked)
        }
        if let maxRetentionDays = self.maxRetentionDays {
            try encodeContainer.encode(maxRetentionDays, forKey: .maxRetentionDays)
        }
        if let minRetentionDays = self.minRetentionDays {
            try encodeContainer.encode(minRetentionDays, forKey: .minRetentionDays)
        }
        if numberOfRecoveryPoints != 0 {
            try encodeContainer.encode(numberOfRecoveryPoints, forKey: .numberOfRecoveryPoints)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let numberOfRecoveryPointsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecoveryPoints) ?? 0
        numberOfRecoveryPoints = numberOfRecoveryPointsDecoded
        let lockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .locked)
        locked = lockedDecoded
        let minRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minRetentionDays)
        minRetentionDays = minRetentionDaysDecoded
        let maxRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetentionDays)
        maxRetentionDays = maxRetentionDaysDecoded
        let lockDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lockDate)
        lockDate = lockDateDecoded
    }
}

extension BackupClientTypes {
    /// Contains metadata about a backup vault.
    public struct BackupVaultListMember: Swift.Equatable {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// The date and time a resource backup is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public var creatorRequestId: Swift.String?
        /// A server-side encryption key you can specify to encrypt your backups from services that support full Backup management; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab. If you specify a key, you must specify its ARN, not its alias. If you do not specify a key, Backup creates a KMS key for you by default. To learn which Backup services support full Backup management and how Backup handles encryption for backups from services that do not yet support full Backup, see [ Encryption for backups in Backup](https://docs.aws.amazon.com/aws-backup/latest/devguide/encryption.html)
        public var encryptionKeyArn: Swift.String?
        /// The date and time when Backup Vault Lock configuration becomes immutable, meaning it cannot be changed or deleted. If you applied Vault Lock to your vault without specifying a lock date, you can change your Vault Lock settings, or delete Vault Lock from the vault entirely, at any time. This value is in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lockDate: ClientRuntime.Date?
        /// A Boolean value that indicates whether Backup Vault Lock applies to the selected backup vault. If true, Vault Lock prevents delete and update operations on the recovery points in the selected vault.
        public var locked: Swift.Bool?
        /// The Backup Vault Lock setting that specifies the maximum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a maximum retention period on the recovery points in the vault (allowing indefinite storage). If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
        public var maxRetentionDays: Swift.Int?
        /// The Backup Vault Lock setting that specifies the minimum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a minimum retention period. If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
        public var minRetentionDays: Swift.Int?
        /// The number of recovery points that are stored in a backup vault.
        public var numberOfRecoveryPoints: Swift.Int

        public init(
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            encryptionKeyArn: Swift.String? = nil,
            lockDate: ClientRuntime.Date? = nil,
            locked: Swift.Bool? = nil,
            maxRetentionDays: Swift.Int? = nil,
            minRetentionDays: Swift.Int? = nil,
            numberOfRecoveryPoints: Swift.Int = 0
        )
        {
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.encryptionKeyArn = encryptionKeyArn
            self.lockDate = lockDate
            self.locked = locked
            self.maxRetentionDays = maxRetentionDays
            self.minRetentionDays = minRetentionDays
            self.numberOfRecoveryPoints = numberOfRecoveryPoints
        }
    }

}

extension BackupClientTypes.CalculatedLifecycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAt = "DeleteAt"
        case moveToColdStorageAt = "MoveToColdStorageAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteAt = self.deleteAt {
            try encodeContainer.encodeTimestamp(deleteAt, format: .epochSeconds, forKey: .deleteAt)
        }
        if let moveToColdStorageAt = self.moveToColdStorageAt {
            try encodeContainer.encodeTimestamp(moveToColdStorageAt, format: .epochSeconds, forKey: .moveToColdStorageAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moveToColdStorageAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .moveToColdStorageAt)
        moveToColdStorageAt = moveToColdStorageAtDecoded
        let deleteAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deleteAt)
        deleteAt = deleteAtDecoded
    }
}

extension BackupClientTypes {
    /// Contains DeleteAt and MoveToColdStorageAt timestamps, which are used to specify a lifecycle for a recovery point. The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the retention setting must be 90 days greater than the transition to cold after days setting. The transition to cold after days setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
    public struct CalculatedLifecycle: Swift.Equatable {
        /// A timestamp that specifies when to delete a recovery point.
        public var deleteAt: ClientRuntime.Date?
        /// A timestamp that specifies when to transition a recovery point to cold storage.
        public var moveToColdStorageAt: ClientRuntime.Date?

        public init(
            deleteAt: ClientRuntime.Date? = nil,
            moveToColdStorageAt: ClientRuntime.Date? = nil
        )
        {
            self.deleteAt = deleteAt
            self.moveToColdStorageAt = moveToColdStorageAt
        }
    }

}

extension CancelLegalHoldInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let cancelDescription = cancelDescription else {
                let message = "Creating a URL Query Item failed. cancelDescription is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let cancelDescriptionQueryItem = ClientRuntime.URLQueryItem(name: "cancelDescription".urlPercentEncoding(), value: Swift.String(cancelDescription).urlPercentEncoding())
            items.append(cancelDescriptionQueryItem)
            if let retainRecordInDays = retainRecordInDays {
                let retainRecordInDaysQueryItem = ClientRuntime.URLQueryItem(name: "retainRecordInDays".urlPercentEncoding(), value: Swift.String(retainRecordInDays).urlPercentEncoding())
                items.append(retainRecordInDaysQueryItem)
            }
            return items
        }
    }
}

extension CancelLegalHoldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let legalHoldId = legalHoldId else {
            return nil
        }
        return "/legal-holds/\(legalHoldId.urlPercentEncoding())"
    }
}

public struct CancelLegalHoldInput: Swift.Equatable {
    /// String describing the reason for removing the legal hold.
    /// This member is required.
    public var cancelDescription: Swift.String?
    /// Legal hold ID required to remove the specified legal hold on a recovery point.
    /// This member is required.
    public var legalHoldId: Swift.String?
    /// The integer amount in days specifying amount of days after this API operation to remove legal hold.
    public var retainRecordInDays: Swift.Int?

    public init(
        cancelDescription: Swift.String? = nil,
        legalHoldId: Swift.String? = nil,
        retainRecordInDays: Swift.Int? = nil
    )
    {
        self.cancelDescription = cancelDescription
        self.legalHoldId = legalHoldId
        self.retainRecordInDays = retainRecordInDays
    }
}

struct CancelLegalHoldInputBody: Swift.Equatable {
}

extension CancelLegalHoldInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelLegalHoldOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelLegalHoldOutput: Swift.Equatable {

    public init() { }
}

enum CancelLegalHoldOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BackupClientTypes.Condition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionKey = "ConditionKey"
        case conditionType = "ConditionType"
        case conditionValue = "ConditionValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionKey = self.conditionKey {
            try encodeContainer.encode(conditionKey, forKey: .conditionKey)
        }
        if let conditionType = self.conditionType {
            try encodeContainer.encode(conditionType.rawValue, forKey: .conditionType)
        }
        if let conditionValue = self.conditionValue {
            try encodeContainer.encode(conditionValue, forKey: .conditionValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionTypeDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ConditionType.self, forKey: .conditionType)
        conditionType = conditionTypeDecoded
        let conditionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionKey)
        conditionKey = conditionKeyDecoded
        let conditionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionValue)
        conditionValue = conditionValueDecoded
    }
}

extension BackupClientTypes {
    /// Contains an array of triplets made up of a condition type (such as StringEquals), a key, and a value. Used to filter resources using their tags and assign them to a backup plan. Case sensitive.
    public struct Condition: Swift.Equatable {
        /// The key in a key-value pair. For example, in the tag Department: Accounting, Department is the key.
        /// This member is required.
        public var conditionKey: Swift.String?
        /// An operation applied to a key-value pair used to assign resources to your backup plan. Condition only supports StringEquals. For more flexible assignment options, including StringLike and the ability to exclude resources from your backup plan, use Conditions (with an "s" on the end) for your [BackupSelection](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BackupSelection.html).
        /// This member is required.
        public var conditionType: BackupClientTypes.ConditionType?
        /// The value in a key-value pair. For example, in the tag Department: Accounting, Accounting is the value.
        /// This member is required.
        public var conditionValue: Swift.String?

        public init(
            conditionKey: Swift.String? = nil,
            conditionType: BackupClientTypes.ConditionType? = nil,
            conditionValue: Swift.String? = nil
        )
        {
            self.conditionKey = conditionKey
            self.conditionType = conditionType
            self.conditionValue = conditionValue
        }
    }

}

extension BackupClientTypes.ConditionParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionKey = "ConditionKey"
        case conditionValue = "ConditionValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionKey = self.conditionKey {
            try encodeContainer.encode(conditionKey, forKey: .conditionKey)
        }
        if let conditionValue = self.conditionValue {
            try encodeContainer.encode(conditionValue, forKey: .conditionValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionKey)
        conditionKey = conditionKeyDecoded
        let conditionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionValue)
        conditionValue = conditionValueDecoded
    }
}

extension BackupClientTypes {
    /// Includes information about tags you define to assign tagged resources to a backup plan.
    public struct ConditionParameter: Swift.Equatable {
        /// The key in a key-value pair. For example, in the tag Department: Accounting, Department is the key.
        public var conditionKey: Swift.String?
        /// The value in a key-value pair. For example, in the tag Department: Accounting, Accounting is the value.
        public var conditionValue: Swift.String?

        public init(
            conditionKey: Swift.String? = nil,
            conditionValue: Swift.String? = nil
        )
        {
            self.conditionKey = conditionKey
            self.conditionValue = conditionValue
        }
    }

}

extension BackupClientTypes {
    public enum ConditionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stringequals
        case sdkUnknown(Swift.String)

        public static var allCases: [ConditionType] {
            return [
                .stringequals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stringequals: return "STRINGEQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConditionType(rawValue: rawValue) ?? ConditionType.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.Conditions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stringEquals = "StringEquals"
        case stringLike = "StringLike"
        case stringNotEquals = "StringNotEquals"
        case stringNotLike = "StringNotLike"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stringEquals = stringEquals {
            var stringEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringEquals)
            for conditionparameter0 in stringEquals {
                try stringEqualsContainer.encode(conditionparameter0)
            }
        }
        if let stringLike = stringLike {
            var stringLikeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringLike)
            for conditionparameter0 in stringLike {
                try stringLikeContainer.encode(conditionparameter0)
            }
        }
        if let stringNotEquals = stringNotEquals {
            var stringNotEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringNotEquals)
            for conditionparameter0 in stringNotEquals {
                try stringNotEqualsContainer.encode(conditionparameter0)
            }
        }
        if let stringNotLike = stringNotLike {
            var stringNotLikeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringNotLike)
            for conditionparameter0 in stringNotLike {
                try stringNotLikeContainer.encode(conditionparameter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringEqualsContainer = try containerValues.decodeIfPresent([BackupClientTypes.ConditionParameter?].self, forKey: .stringEquals)
        var stringEqualsDecoded0:[BackupClientTypes.ConditionParameter]? = nil
        if let stringEqualsContainer = stringEqualsContainer {
            stringEqualsDecoded0 = [BackupClientTypes.ConditionParameter]()
            for structure0 in stringEqualsContainer {
                if let structure0 = structure0 {
                    stringEqualsDecoded0?.append(structure0)
                }
            }
        }
        stringEquals = stringEqualsDecoded0
        let stringNotEqualsContainer = try containerValues.decodeIfPresent([BackupClientTypes.ConditionParameter?].self, forKey: .stringNotEquals)
        var stringNotEqualsDecoded0:[BackupClientTypes.ConditionParameter]? = nil
        if let stringNotEqualsContainer = stringNotEqualsContainer {
            stringNotEqualsDecoded0 = [BackupClientTypes.ConditionParameter]()
            for structure0 in stringNotEqualsContainer {
                if let structure0 = structure0 {
                    stringNotEqualsDecoded0?.append(structure0)
                }
            }
        }
        stringNotEquals = stringNotEqualsDecoded0
        let stringLikeContainer = try containerValues.decodeIfPresent([BackupClientTypes.ConditionParameter?].self, forKey: .stringLike)
        var stringLikeDecoded0:[BackupClientTypes.ConditionParameter]? = nil
        if let stringLikeContainer = stringLikeContainer {
            stringLikeDecoded0 = [BackupClientTypes.ConditionParameter]()
            for structure0 in stringLikeContainer {
                if let structure0 = structure0 {
                    stringLikeDecoded0?.append(structure0)
                }
            }
        }
        stringLike = stringLikeDecoded0
        let stringNotLikeContainer = try containerValues.decodeIfPresent([BackupClientTypes.ConditionParameter?].self, forKey: .stringNotLike)
        var stringNotLikeDecoded0:[BackupClientTypes.ConditionParameter]? = nil
        if let stringNotLikeContainer = stringNotLikeContainer {
            stringNotLikeDecoded0 = [BackupClientTypes.ConditionParameter]()
            for structure0 in stringNotLikeContainer {
                if let structure0 = structure0 {
                    stringNotLikeDecoded0?.append(structure0)
                }
            }
        }
        stringNotLike = stringNotLikeDecoded0
    }
}

extension BackupClientTypes {
    /// Contains information about which resources to include or exclude from a backup plan using their tags. Conditions are case sensitive.
    public struct Conditions: Swift.Equatable {
        /// Filters the values of your tagged resources for only those resources that you tagged with the same value. Also called "exact matching."
        public var stringEquals: [BackupClientTypes.ConditionParameter]?
        /// Filters the values of your tagged resources for matching tag values with the use of a wildcard character (*) anywhere in the string. For example, "prod*" or "*rod*" matches the tag value "production".
        public var stringLike: [BackupClientTypes.ConditionParameter]?
        /// Filters the values of your tagged resources for only those resources that you tagged that do not have the same value. Also called "negated matching."
        public var stringNotEquals: [BackupClientTypes.ConditionParameter]?
        /// Filters the values of your tagged resources for non-matching tag values with the use of a wildcard character (*) anywhere in the string.
        public var stringNotLike: [BackupClientTypes.ConditionParameter]?

        public init(
            stringEquals: [BackupClientTypes.ConditionParameter]? = nil,
            stringLike: [BackupClientTypes.ConditionParameter]? = nil,
            stringNotEquals: [BackupClientTypes.ConditionParameter]? = nil,
            stringNotLike: [BackupClientTypes.ConditionParameter]? = nil
        )
        {
            self.stringEquals = stringEquals
            self.stringLike = stringLike
            self.stringNotEquals = stringNotEquals
            self.stringNotLike = stringNotLike
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Backup can't perform the action that you requested until it finishes performing a previous action. Try again later.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes.ControlInputParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterValue = self.parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension BackupClientTypes {
    /// A list of parameters for a control. A control can have zero, one, or more than one parameter. An example of a control with two parameters is: "backup plan frequency is at least daily and the retention period is at least 1 year". The first parameter is daily. The second parameter is 1 year.
    public struct ControlInputParameter: Swift.Equatable {
        /// The name of a parameter, for example, BackupPlanFrequency.
        public var parameterName: Swift.String?
        /// The value of parameter, for example, hourly.
        public var parameterValue: Swift.String?

        public init(
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }
    }

}

extension BackupClientTypes.ControlScope: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceResourceIds = "ComplianceResourceIds"
        case complianceResourceTypes = "ComplianceResourceTypes"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceResourceIds = complianceResourceIds {
            var complianceResourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceResourceIds)
            for string0 in complianceResourceIds {
                try complianceResourceIdsContainer.encode(string0)
            }
        }
        if let complianceResourceTypes = complianceResourceTypes {
            var complianceResourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceResourceTypes)
            for arn0 in complianceResourceTypes {
                try complianceResourceTypesContainer.encode(arn0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, stringMap0) in tags {
                try tagsContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceResourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .complianceResourceIds)
        var complianceResourceIdsDecoded0:[Swift.String]? = nil
        if let complianceResourceIdsContainer = complianceResourceIdsContainer {
            complianceResourceIdsDecoded0 = [Swift.String]()
            for string0 in complianceResourceIdsContainer {
                if let string0 = string0 {
                    complianceResourceIdsDecoded0?.append(string0)
                }
            }
        }
        complianceResourceIds = complianceResourceIdsDecoded0
        let complianceResourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .complianceResourceTypes)
        var complianceResourceTypesDecoded0:[Swift.String]? = nil
        if let complianceResourceTypesContainer = complianceResourceTypesContainer {
            complianceResourceTypesDecoded0 = [Swift.String]()
            for string0 in complianceResourceTypesContainer {
                if let string0 = string0 {
                    complianceResourceTypesDecoded0?.append(string0)
                }
            }
        }
        complianceResourceTypes = complianceResourceTypesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension BackupClientTypes {
    /// A framework consists of one or more controls. Each control has its own control scope. The control scope can include one or more resource types, a combination of a tag key and value, or a combination of one resource type and one resource ID. If no scope is specified, evaluations for the rule are triggered when any resource in your recording group changes in configuration. To set a control scope that includes all of a particular resource, leave the ControlScope empty or do not pass it when calling CreateFramework.
    public struct ControlScope: Swift.Equatable {
        /// The ID of the only Amazon Web Services resource that you want your control scope to contain.
        public var complianceResourceIds: [Swift.String]?
        /// Describes whether the control scope includes one or more types of resources, such as EFS or RDS.
        public var complianceResourceTypes: [Swift.String]?
        /// The tag key-value pair applied to those Amazon Web Services resources that you want to trigger an evaluation for a rule. A maximum of one key-value pair can be provided. The tag value is optional, but it cannot be an empty string. The structure to assign a tag is: [{"Key":"string","Value":"string"}].
        public var tags: [Swift.String:Swift.String]?

        public init(
            complianceResourceIds: [Swift.String]? = nil,
            complianceResourceTypes: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.complianceResourceIds = complianceResourceIds
            self.complianceResourceTypes = complianceResourceTypes
            self.tags = tags
        }
    }

}

extension BackupClientTypes.CopyAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case lifecycle = "Lifecycle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationBackupVaultArn = self.destinationBackupVaultArn {
            try encodeContainer.encode(destinationBackupVaultArn, forKey: .destinationBackupVaultArn)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let destinationBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationBackupVaultArn)
        destinationBackupVaultArn = destinationBackupVaultArnDecoded
    }
}

extension BackupClientTypes {
    /// The details of the copy operation.
    public struct CopyAction: Swift.Equatable {
        /// An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup. For example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        /// This member is required.
        public var destinationBackupVaultArn: Swift.String?
        /// Contains an array of Transition objects specifying how long in days before a recovery point transitions to cold storage or is deleted. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the retention setting must be 90 days greater than the transition to cold after days setting. The transition to cold after days setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
        public var lifecycle: BackupClientTypes.Lifecycle?

        public init(
            destinationBackupVaultArn: Swift.String? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil
        )
        {
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.lifecycle = lifecycle
        }
    }

}

extension BackupClientTypes.CopyJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupSizeInBytes = "BackupSizeInBytes"
        case childJobsInState = "ChildJobsInState"
        case completionDate = "CompletionDate"
        case compositeMemberIdentifier = "CompositeMemberIdentifier"
        case copyJobId = "CopyJobId"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case destinationRecoveryPointArn = "DestinationRecoveryPointArn"
        case iamRoleArn = "IamRoleArn"
        case isParent = "IsParent"
        case numberOfChildJobs = "NumberOfChildJobs"
        case parentJobId = "ParentJobId"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case sourceBackupVaultArn = "SourceBackupVaultArn"
        case sourceRecoveryPointArn = "SourceRecoveryPointArn"
        case state = "State"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let backupSizeInBytes = self.backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let childJobsInState = childJobsInState {
            var childJobsInStateContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .childJobsInState)
            for (dictKey0, copyJobChildJobsInState0) in childJobsInState {
                try childJobsInStateContainer.encode(copyJobChildJobsInState0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let completionDate = self.completionDate {
            try encodeContainer.encodeTimestamp(completionDate, format: .epochSeconds, forKey: .completionDate)
        }
        if let compositeMemberIdentifier = self.compositeMemberIdentifier {
            try encodeContainer.encode(compositeMemberIdentifier, forKey: .compositeMemberIdentifier)
        }
        if let copyJobId = self.copyJobId {
            try encodeContainer.encode(copyJobId, forKey: .copyJobId)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let destinationBackupVaultArn = self.destinationBackupVaultArn {
            try encodeContainer.encode(destinationBackupVaultArn, forKey: .destinationBackupVaultArn)
        }
        if let destinationRecoveryPointArn = self.destinationRecoveryPointArn {
            try encodeContainer.encode(destinationRecoveryPointArn, forKey: .destinationRecoveryPointArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if isParent != false {
            try encodeContainer.encode(isParent, forKey: .isParent)
        }
        if let numberOfChildJobs = self.numberOfChildJobs {
            try encodeContainer.encode(numberOfChildJobs, forKey: .numberOfChildJobs)
        }
        if let parentJobId = self.parentJobId {
            try encodeContainer.encode(parentJobId, forKey: .parentJobId)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let sourceBackupVaultArn = self.sourceBackupVaultArn {
            try encodeContainer.encode(sourceBackupVaultArn, forKey: .sourceBackupVaultArn)
        }
        if let sourceRecoveryPointArn = self.sourceRecoveryPointArn {
            try encodeContainer.encode(sourceRecoveryPointArn, forKey: .sourceRecoveryPointArn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let copyJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .copyJobId)
        copyJobId = copyJobIdDecoded
        let sourceBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupVaultArn)
        sourceBackupVaultArn = sourceBackupVaultArnDecoded
        let sourceRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRecoveryPointArn)
        sourceRecoveryPointArn = sourceRecoveryPointArnDecoded
        let destinationBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationBackupVaultArn)
        destinationBackupVaultArn = destinationBackupVaultArnDecoded
        let destinationRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRecoveryPointArn)
        destinationRecoveryPointArn = destinationRecoveryPointArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDate)
        completionDate = completionDateDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CopyJobState.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let parentJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentJobId)
        parentJobId = parentJobIdDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
        let compositeMemberIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .compositeMemberIdentifier)
        compositeMemberIdentifier = compositeMemberIdentifierDecoded
        let numberOfChildJobsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfChildJobs)
        numberOfChildJobs = numberOfChildJobsDecoded
        let childJobsInStateContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .childJobsInState)
        var childJobsInStateDecoded0: [Swift.String:Swift.Int]? = nil
        if let childJobsInStateContainer = childJobsInStateContainer {
            childJobsInStateDecoded0 = [Swift.String:Swift.Int]()
            for (key0, long0) in childJobsInStateContainer {
                if let long0 = long0 {
                    childJobsInStateDecoded0?[key0] = long0
                }
            }
        }
        childJobsInState = childJobsInStateDecoded0
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about a copy job.
    public struct CopyJob: Swift.Equatable {
        /// The account ID that owns the copy job.
        public var accountId: Swift.String?
        /// The size, in bytes, of a copy job.
        public var backupSizeInBytes: Swift.Int?
        /// This returns the statistics of the included child (nested) copy jobs.
        public var childJobsInState: [Swift.String:Swift.Int]?
        /// The date and time a copy job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: ClientRuntime.Date?
        /// This is the identifier of a resource within a composite group, such as nested (child) recovery point belonging to a composite (parent) stack. The ID is transferred from the [ logical ID](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html#resources-section-structure-syntax) within a stack.
        public var compositeMemberIdentifier: Swift.String?
        /// Uniquely identifies a copy job.
        public var copyJobId: Swift.String?
        /// Contains information about the backup plan and rule that Backup used to initiate the recovery point backup.
        public var createdBy: BackupClientTypes.RecoveryPointCreator?
        /// The date and time a copy job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a destination copy vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var destinationBackupVaultArn: Swift.String?
        /// An ARN that uniquely identifies a destination recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var destinationRecoveryPointArn: Swift.String?
        /// Specifies the IAM role ARN used to copy the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// This is a boolean value indicating this is a parent (composite) copy job.
        public var isParent: Swift.Bool
        /// This is the number of child (nested) copy jobs.
        public var numberOfChildJobs: Swift.Int?
        /// This uniquely identifies a request to Backup to copy a resource. The return will be the parent (composite) job ID.
        public var parentJobId: Swift.String?
        /// The Amazon Web Services resource to be copied; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public var resourceArn: Swift.String?
        /// This is the non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource to be copied; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public var resourceType: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a source copy vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var sourceBackupVaultArn: Swift.String?
        /// An ARN that uniquely identifies a source recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var sourceRecoveryPointArn: Swift.String?
        /// The current state of a copy job.
        public var state: BackupClientTypes.CopyJobState?
        /// A detailed message explaining the status of the job to copy a resource.
        public var statusMessage: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            backupSizeInBytes: Swift.Int? = nil,
            childJobsInState: [Swift.String:Swift.Int]? = nil,
            completionDate: ClientRuntime.Date? = nil,
            compositeMemberIdentifier: Swift.String? = nil,
            copyJobId: Swift.String? = nil,
            createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
            creationDate: ClientRuntime.Date? = nil,
            destinationBackupVaultArn: Swift.String? = nil,
            destinationRecoveryPointArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            isParent: Swift.Bool = false,
            numberOfChildJobs: Swift.Int? = nil,
            parentJobId: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            sourceBackupVaultArn: Swift.String? = nil,
            sourceRecoveryPointArn: Swift.String? = nil,
            state: BackupClientTypes.CopyJobState? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.backupSizeInBytes = backupSizeInBytes
            self.childJobsInState = childJobsInState
            self.completionDate = completionDate
            self.compositeMemberIdentifier = compositeMemberIdentifier
            self.copyJobId = copyJobId
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.destinationRecoveryPointArn = destinationRecoveryPointArn
            self.iamRoleArn = iamRoleArn
            self.isParent = isParent
            self.numberOfChildJobs = numberOfChildJobs
            self.parentJobId = parentJobId
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.sourceRecoveryPointArn = sourceRecoveryPointArn
            self.state = state
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes {
    public enum CopyJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case created
        case failed
        case partial
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [CopyJobState] {
            return [
                .completed,
                .created,
                .failed,
                .partial,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .partial: return "PARTIAL"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CopyJobState(rawValue: rawValue) ?? CopyJobState.sdkUnknown(rawValue)
        }
    }
}

extension CreateBackupPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupPlanInput(backupPlan: \(Swift.String(describing: backupPlan)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), backupPlanTags: \"CONTENT_REDACTED\")"}
}

extension CreateBackupPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
        case backupPlanTags = "BackupPlanTags"
        case creatorRequestId = "CreatorRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlan = self.backupPlan {
            try encodeContainer.encode(backupPlan, forKey: .backupPlan)
        }
        if let backupPlanTags = backupPlanTags {
            var backupPlanTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupPlanTags)
            for (dictKey0, tags0) in backupPlanTags {
                try backupPlanTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
    }
}

extension CreateBackupPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backup/plans"
    }
}

public struct CreateBackupPlanInput: Swift.Equatable {
    /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    /// This member is required.
    public var backupPlan: BackupClientTypes.BackupPlanInput?
    /// To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair. The specified tags are assigned to all backups created with this plan.
    public var backupPlanTags: [Swift.String:Swift.String]?
    /// Identifies the request and allows failed requests to be retried without the risk of running the operation twice. If the request includes a CreatorRequestId that matches an existing backup plan, that plan is returned. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?

    public init(
        backupPlan: BackupClientTypes.BackupPlanInput? = nil,
        backupPlanTags: [Swift.String:Swift.String]? = nil,
        creatorRequestId: Swift.String? = nil
    )
    {
        self.backupPlan = backupPlan
        self.backupPlanTags = backupPlanTags
        self.creatorRequestId = creatorRequestId
    }
}

struct CreateBackupPlanInputBody: Swift.Equatable {
    let backupPlan: BackupClientTypes.BackupPlanInput?
    let backupPlanTags: [Swift.String:Swift.String]?
    let creatorRequestId: Swift.String?
}

extension CreateBackupPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
        case backupPlanTags = "BackupPlanTags"
        case creatorRequestId = "CreatorRequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlanInput.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
        let backupPlanTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupPlanTags)
        var backupPlanTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupPlanTagsContainer = backupPlanTagsContainer {
            backupPlanTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in backupPlanTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    backupPlanTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        backupPlanTags = backupPlanTagsDecoded0
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension CreateBackupPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBackupPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.advancedBackupSettings = output.advancedBackupSettings
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.versionId = output.versionId
        } else {
            self.advancedBackupSettings = nil
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.creationDate = nil
            self.versionId = nil
        }
    }
}

public struct CreateBackupPlanOutput: Swift.Equatable {
    /// A list of BackupOptions settings for a resource type. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs.
    public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time that a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. They cannot be edited.
    public var versionId: Swift.String?

    public init(
        advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.versionId = versionId
    }
}

struct CreateBackupPlanOutputBody: Swift.Equatable {
    let backupPlanId: Swift.String?
    let backupPlanArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let versionId: Swift.String?
    let advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
}

extension CreateBackupPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case versionId = "VersionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

enum CreateBackupPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBackupSelectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSelection = "BackupSelection"
        case creatorRequestId = "CreatorRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupSelection = self.backupSelection {
            try encodeContainer.encode(backupSelection, forKey: .backupSelection)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
    }
}

extension CreateBackupSelectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections"
    }
}

public struct CreateBackupSelectionInput: Swift.Equatable {
    /// Uniquely identifies the backup plan to be associated with the selection of resources.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Specifies the body of a request to assign a set of resources to a backup plan.
    /// This member is required.
    public var backupSelection: BackupClientTypes.BackupSelection?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        backupSelection: BackupClientTypes.BackupSelection? = nil,
        creatorRequestId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.backupSelection = backupSelection
        self.creatorRequestId = creatorRequestId
    }
}

struct CreateBackupSelectionInputBody: Swift.Equatable {
    let backupSelection: BackupClientTypes.BackupSelection?
    let creatorRequestId: Swift.String?
}

extension CreateBackupSelectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSelection = "BackupSelection"
        case creatorRequestId = "CreatorRequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupSelectionDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupSelection.self, forKey: .backupSelection)
        backupSelection = backupSelectionDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension CreateBackupSelectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBackupSelectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.selectionId = output.selectionId
        } else {
            self.backupPlanId = nil
            self.creationDate = nil
            self.selectionId = nil
        }
    }
}

public struct CreateBackupSelectionOutput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time a backup selection is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    public var selectionId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.selectionId = selectionId
    }
}

struct CreateBackupSelectionOutputBody: Swift.Equatable {
    let selectionId: Swift.String?
    let backupPlanId: Swift.String?
    let creationDate: ClientRuntime.Date?
}

extension CreateBackupSelectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case selectionId = "SelectionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionId)
        selectionId = selectionIdDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

enum CreateBackupSelectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBackupVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupVaultInput(backupVaultName: \(Swift.String(describing: backupVaultName)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), encryptionKeyArn: \(Swift.String(describing: encryptionKeyArn)), backupVaultTags: \"CONTENT_REDACTED\")"}
}

extension CreateBackupVaultInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultTags = "BackupVaultTags"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultTags = backupVaultTags {
            var backupVaultTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupVaultTags)
            for (dictKey0, tags0) in backupVaultTags {
                try backupVaultTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
    }
}

extension CreateBackupVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())"
    }
}

public struct CreateBackupVaultInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// Metadata that you can assign to help organize the resources that you create. Each tag is a key-value pair.
    public var backupVaultTags: [Swift.String:Swift.String]?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?
    /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    public var encryptionKeyArn: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil,
        backupVaultTags: [Swift.String:Swift.String]? = nil,
        creatorRequestId: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.backupVaultTags = backupVaultTags
        self.creatorRequestId = creatorRequestId
        self.encryptionKeyArn = encryptionKeyArn
    }
}

struct CreateBackupVaultInputBody: Swift.Equatable {
    let backupVaultTags: [Swift.String:Swift.String]?
    let encryptionKeyArn: Swift.String?
    let creatorRequestId: Swift.String?
}

extension CreateBackupVaultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultTags = "BackupVaultTags"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupVaultTags)
        var backupVaultTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupVaultTagsContainer = backupVaultTagsContainer {
            backupVaultTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in backupVaultTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    backupVaultTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        backupVaultTags = backupVaultTagsDecoded0
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension CreateBackupVaultOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBackupVaultOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.creationDate = output.creationDate
        } else {
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.creationDate = nil
        }
    }
}

public struct CreateBackupVaultOutput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// The date and time a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?

    public init(
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.creationDate = creationDate
    }
}

struct CreateBackupVaultOutputBody: Swift.Equatable {
    let backupVaultName: Swift.String?
    let backupVaultArn: Swift.String?
    let creationDate: ClientRuntime.Date?
}

extension CreateBackupVaultOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

enum CreateBackupVaultOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFrameworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case frameworkName = "FrameworkName"
        case frameworkTags = "FrameworkTags"
        case idempotencyToken = "IdempotencyToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameworkControls = frameworkControls {
            var frameworkControlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .frameworkControls)
            for frameworkcontrol0 in frameworkControls {
                try frameworkControlsContainer.encode(frameworkcontrol0)
            }
        }
        if let frameworkDescription = self.frameworkDescription {
            try encodeContainer.encode(frameworkDescription, forKey: .frameworkDescription)
        }
        if let frameworkName = self.frameworkName {
            try encodeContainer.encode(frameworkName, forKey: .frameworkName)
        }
        if let frameworkTags = frameworkTags {
            var frameworkTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .frameworkTags)
            for (dictKey0, stringMap0) in frameworkTags {
                try frameworkTagsContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
    }
}

extension CreateFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/frameworks"
    }
}

public struct CreateFrameworkInput: Swift.Equatable {
    /// A list of the controls that make up the framework. Each control in the list has a name, input parameters, and scope.
    /// This member is required.
    public var frameworkControls: [BackupClientTypes.FrameworkControl]?
    /// An optional description of the framework with a maximum of 1,024 characters.
    public var frameworkDescription: Swift.String?
    /// The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var frameworkName: Swift.String?
    /// Metadata that you can assign to help organize the frameworks that you create. Each tag is a key-value pair.
    public var frameworkTags: [Swift.String:Swift.String]?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to CreateFrameworkInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?

    public init(
        frameworkControls: [BackupClientTypes.FrameworkControl]? = nil,
        frameworkDescription: Swift.String? = nil,
        frameworkName: Swift.String? = nil,
        frameworkTags: [Swift.String:Swift.String]? = nil,
        idempotencyToken: Swift.String? = nil
    )
    {
        self.frameworkControls = frameworkControls
        self.frameworkDescription = frameworkDescription
        self.frameworkName = frameworkName
        self.frameworkTags = frameworkTags
        self.idempotencyToken = idempotencyToken
    }
}

struct CreateFrameworkInputBody: Swift.Equatable {
    let frameworkName: Swift.String?
    let frameworkDescription: Swift.String?
    let frameworkControls: [BackupClientTypes.FrameworkControl]?
    let idempotencyToken: Swift.String?
    let frameworkTags: [Swift.String:Swift.String]?
}

extension CreateFrameworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case frameworkName = "FrameworkName"
        case frameworkTags = "FrameworkTags"
        case idempotencyToken = "IdempotencyToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkDescription)
        frameworkDescription = frameworkDescriptionDecoded
        let frameworkControlsContainer = try containerValues.decodeIfPresent([BackupClientTypes.FrameworkControl?].self, forKey: .frameworkControls)
        var frameworkControlsDecoded0:[BackupClientTypes.FrameworkControl]? = nil
        if let frameworkControlsContainer = frameworkControlsContainer {
            frameworkControlsDecoded0 = [BackupClientTypes.FrameworkControl]()
            for structure0 in frameworkControlsContainer {
                if let structure0 = structure0 {
                    frameworkControlsDecoded0?.append(structure0)
                }
            }
        }
        frameworkControls = frameworkControlsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let frameworkTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .frameworkTags)
        var frameworkTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let frameworkTagsContainer = frameworkTagsContainer {
            frameworkTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in frameworkTagsContainer {
                if let string0 = string0 {
                    frameworkTagsDecoded0?[key0] = string0
                }
            }
        }
        frameworkTags = frameworkTagsDecoded0
    }
}

extension CreateFrameworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFrameworkOutputBody = try responseDecoder.decode(responseBody: data)
            self.frameworkArn = output.frameworkArn
            self.frameworkName = output.frameworkName
        } else {
            self.frameworkArn = nil
            self.frameworkName = nil
        }
    }
}

public struct CreateFrameworkOutput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var frameworkArn: Swift.String?
    /// The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    public var frameworkName: Swift.String?

    public init(
        frameworkArn: Swift.String? = nil,
        frameworkName: Swift.String? = nil
    )
    {
        self.frameworkArn = frameworkArn
        self.frameworkName = frameworkName
    }
}

struct CreateFrameworkOutputBody: Swift.Equatable {
    let frameworkName: Swift.String?
    let frameworkArn: Swift.String?
}

extension CreateFrameworkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkArn = "FrameworkArn"
        case frameworkName = "FrameworkName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkArn)
        frameworkArn = frameworkArnDecoded
    }
}

enum CreateFrameworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLegalHoldInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLegalHoldInput(description: \(Swift.String(describing: description)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), recoveryPointSelection: \(Swift.String(describing: recoveryPointSelection)), title: \(Swift.String(describing: title)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateLegalHoldInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case recoveryPointSelection = "RecoveryPointSelection"
        case tags = "Tags"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let recoveryPointSelection = self.recoveryPointSelection {
            try encodeContainer.encode(recoveryPointSelection, forKey: .recoveryPointSelection)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

extension CreateLegalHoldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/legal-holds"
    }
}

public struct CreateLegalHoldInput: Swift.Equatable {
    /// This is the string description of the legal hold.
    /// This member is required.
    public var description: Swift.String?
    /// This is a user-chosen string used to distinguish between otherwise identical calls. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// This specifies criteria to assign a set of resources, such as resource types or backup vaults.
    public var recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
    /// Optional tags to include. A tag is a key-value pair you can use to manage, filter, and search for your resources. Allowed characters include UTF-8 letters, numbers, spaces, and the following characters: + - = . _ : /.
    public var tags: [Swift.String:Swift.String]?
    /// This is the string title of the legal hold.
    /// This member is required.
    public var title: Swift.String?

    public init(
        description: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        recoveryPointSelection: BackupClientTypes.RecoveryPointSelection? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        title: Swift.String? = nil
    )
    {
        self.description = description
        self.idempotencyToken = idempotencyToken
        self.recoveryPointSelection = recoveryPointSelection
        self.tags = tags
        self.title = title
    }
}

struct CreateLegalHoldInputBody: Swift.Equatable {
    let title: Swift.String?
    let description: Swift.String?
    let idempotencyToken: Swift.String?
    let recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLegalHoldInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case recoveryPointSelection = "RecoveryPointSelection"
        case tags = "Tags"
        case title = "Title"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let recoveryPointSelectionDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointSelection.self, forKey: .recoveryPointSelection)
        recoveryPointSelection = recoveryPointSelectionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLegalHoldOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLegalHoldOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.description = output.description
            self.legalHoldArn = output.legalHoldArn
            self.legalHoldId = output.legalHoldId
            self.recoveryPointSelection = output.recoveryPointSelection
            self.status = output.status
            self.title = output.title
        } else {
            self.creationDate = nil
            self.description = nil
            self.legalHoldArn = nil
            self.legalHoldId = nil
            self.recoveryPointSelection = nil
            self.status = nil
            self.title = nil
        }
    }
}

public struct CreateLegalHoldOutput: Swift.Equatable {
    /// Time in number format when legal hold was created.
    public var creationDate: ClientRuntime.Date?
    /// This is the returned string description of the legal hold.
    public var description: Swift.String?
    /// This is the ARN (Amazon Resource Number) of the created legal hold.
    public var legalHoldArn: Swift.String?
    /// Legal hold ID returned for the specified legal hold on a recovery point.
    public var legalHoldId: Swift.String?
    /// This specifies criteria to assign a set of resources, such as resource types or backup vaults.
    public var recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
    /// This displays the status of the legal hold returned after creating the legal hold. Statuses can be ACTIVE, PENDING, CANCELED, CANCELING, or FAILED.
    public var status: BackupClientTypes.LegalHoldStatus?
    /// This is the string title of the legal hold returned after creating the legal hold.
    public var title: Swift.String?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        legalHoldArn: Swift.String? = nil,
        legalHoldId: Swift.String? = nil,
        recoveryPointSelection: BackupClientTypes.RecoveryPointSelection? = nil,
        status: BackupClientTypes.LegalHoldStatus? = nil,
        title: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.description = description
        self.legalHoldArn = legalHoldArn
        self.legalHoldId = legalHoldId
        self.recoveryPointSelection = recoveryPointSelection
        self.status = status
        self.title = title
    }
}

struct CreateLegalHoldOutputBody: Swift.Equatable {
    let title: Swift.String?
    let status: BackupClientTypes.LegalHoldStatus?
    let description: Swift.String?
    let legalHoldId: Swift.String?
    let legalHoldArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
}

extension CreateLegalHoldOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case description = "Description"
        case legalHoldArn = "LegalHoldArn"
        case legalHoldId = "LegalHoldId"
        case recoveryPointSelection = "RecoveryPointSelection"
        case status = "Status"
        case title = "Title"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.LegalHoldStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let legalHoldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .legalHoldId)
        legalHoldId = legalHoldIdDecoded
        let legalHoldArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .legalHoldArn)
        legalHoldArn = legalHoldArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let recoveryPointSelectionDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointSelection.self, forKey: .recoveryPointSelection)
        recoveryPointSelection = recoveryPointSelectionDecoded
    }
}

enum CreateLegalHoldOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLogicallyAirGappedBackupVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLogicallyAirGappedBackupVaultInput(backupVaultName: \(Swift.String(describing: backupVaultName)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), maxRetentionDays: \(Swift.String(describing: maxRetentionDays)), minRetentionDays: \(Swift.String(describing: minRetentionDays)), backupVaultTags: \"CONTENT_REDACTED\")"}
}

extension CreateLogicallyAirGappedBackupVaultInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultTags = "BackupVaultTags"
        case creatorRequestId = "CreatorRequestId"
        case maxRetentionDays = "MaxRetentionDays"
        case minRetentionDays = "MinRetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultTags = backupVaultTags {
            var backupVaultTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupVaultTags)
            for (dictKey0, tags0) in backupVaultTags {
                try backupVaultTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let maxRetentionDays = self.maxRetentionDays {
            try encodeContainer.encode(maxRetentionDays, forKey: .maxRetentionDays)
        }
        if let minRetentionDays = self.minRetentionDays {
            try encodeContainer.encode(minRetentionDays, forKey: .minRetentionDays)
        }
    }
}

extension CreateLogicallyAirGappedBackupVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/logically-air-gapped-backup-vaults/\(backupVaultName.urlPercentEncoding())"
    }
}

public struct CreateLogicallyAirGappedBackupVaultInput: Swift.Equatable {
    /// This is the name of the vault that is being created.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// These are the tags that will be included in the newly-created vault.
    public var backupVaultTags: [Swift.String:Swift.String]?
    /// This is the ID of the creation request.
    public var creatorRequestId: Swift.String?
    /// This is the setting that specifies the maximum retention period that the vault retains its recovery points. If this parameter is not specified, Backup does not enforce a maximum retention period on the recovery points in the vault (allowing indefinite storage). If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault.
    /// This member is required.
    public var maxRetentionDays: Swift.Int?
    /// This setting specifies the minimum retention period that the vault retains its recovery points. If this parameter is not specified, no minimum retention period is enforced. If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If a job retention period is shorter than that minimum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault.
    /// This member is required.
    public var minRetentionDays: Swift.Int?

    public init(
        backupVaultName: Swift.String? = nil,
        backupVaultTags: [Swift.String:Swift.String]? = nil,
        creatorRequestId: Swift.String? = nil,
        maxRetentionDays: Swift.Int? = nil,
        minRetentionDays: Swift.Int? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.backupVaultTags = backupVaultTags
        self.creatorRequestId = creatorRequestId
        self.maxRetentionDays = maxRetentionDays
        self.minRetentionDays = minRetentionDays
    }
}

struct CreateLogicallyAirGappedBackupVaultInputBody: Swift.Equatable {
    let backupVaultTags: [Swift.String:Swift.String]?
    let creatorRequestId: Swift.String?
    let minRetentionDays: Swift.Int?
    let maxRetentionDays: Swift.Int?
}

extension CreateLogicallyAirGappedBackupVaultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultTags = "BackupVaultTags"
        case creatorRequestId = "CreatorRequestId"
        case maxRetentionDays = "MaxRetentionDays"
        case minRetentionDays = "MinRetentionDays"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupVaultTags)
        var backupVaultTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupVaultTagsContainer = backupVaultTagsContainer {
            backupVaultTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in backupVaultTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    backupVaultTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        backupVaultTags = backupVaultTagsDecoded0
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let minRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minRetentionDays)
        minRetentionDays = minRetentionDaysDecoded
        let maxRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetentionDays)
        maxRetentionDays = maxRetentionDaysDecoded
    }
}

extension CreateLogicallyAirGappedBackupVaultOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLogicallyAirGappedBackupVaultOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.creationDate = output.creationDate
            self.vaultState = output.vaultState
        } else {
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.creationDate = nil
            self.vaultState = nil
        }
    }
}

public struct CreateLogicallyAirGappedBackupVaultOutput: Swift.Equatable {
    /// This is the ARN (Amazon Resource Name) of the vault being created.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Logically air-gapped backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// The date and time when the vault was created. This value is in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// This is the current state of the vault.
    public var vaultState: BackupClientTypes.VaultState?

    public init(
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        vaultState: BackupClientTypes.VaultState? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.creationDate = creationDate
        self.vaultState = vaultState
    }
}

struct CreateLogicallyAirGappedBackupVaultOutputBody: Swift.Equatable {
    let backupVaultName: Swift.String?
    let backupVaultArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let vaultState: BackupClientTypes.VaultState?
}

extension CreateLogicallyAirGappedBackupVaultOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
        case vaultState = "VaultState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let vaultStateDecoded = try containerValues.decodeIfPresent(BackupClientTypes.VaultState.self, forKey: .vaultState)
        vaultState = vaultStateDecoded
    }
}

enum CreateLogicallyAirGappedBackupVaultOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateReportPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanDescription = "ReportPlanDescription"
        case reportPlanName = "ReportPlanName"
        case reportPlanTags = "ReportPlanTags"
        case reportSetting = "ReportSetting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let reportDeliveryChannel = self.reportDeliveryChannel {
            try encodeContainer.encode(reportDeliveryChannel, forKey: .reportDeliveryChannel)
        }
        if let reportPlanDescription = self.reportPlanDescription {
            try encodeContainer.encode(reportPlanDescription, forKey: .reportPlanDescription)
        }
        if let reportPlanName = self.reportPlanName {
            try encodeContainer.encode(reportPlanName, forKey: .reportPlanName)
        }
        if let reportPlanTags = reportPlanTags {
            var reportPlanTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .reportPlanTags)
            for (dictKey0, stringMap0) in reportPlanTags {
                try reportPlanTagsContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let reportSetting = self.reportSetting {
            try encodeContainer.encode(reportSetting, forKey: .reportSetting)
        }
    }
}

extension CreateReportPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/report-plans"
    }
}

public struct CreateReportPlanInput: Swift.Equatable {
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to CreateReportPlanInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// A structure that contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
    /// This member is required.
    public var reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
    /// An optional description of the report plan with a maximum of 1,024 characters.
    public var reportPlanDescription: Swift.String?
    /// The unique name of the report plan. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var reportPlanName: Swift.String?
    /// Metadata that you can assign to help organize the report plans that you create. Each tag is a key-value pair.
    public var reportPlanTags: [Swift.String:Swift.String]?
    /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
    /// This member is required.
    public var reportSetting: BackupClientTypes.ReportSetting?

    public init(
        idempotencyToken: Swift.String? = nil,
        reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel? = nil,
        reportPlanDescription: Swift.String? = nil,
        reportPlanName: Swift.String? = nil,
        reportPlanTags: [Swift.String:Swift.String]? = nil,
        reportSetting: BackupClientTypes.ReportSetting? = nil
    )
    {
        self.idempotencyToken = idempotencyToken
        self.reportDeliveryChannel = reportDeliveryChannel
        self.reportPlanDescription = reportPlanDescription
        self.reportPlanName = reportPlanName
        self.reportPlanTags = reportPlanTags
        self.reportSetting = reportSetting
    }
}

struct CreateReportPlanInputBody: Swift.Equatable {
    let reportPlanName: Swift.String?
    let reportPlanDescription: Swift.String?
    let reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
    let reportSetting: BackupClientTypes.ReportSetting?
    let reportPlanTags: [Swift.String:Swift.String]?
    let idempotencyToken: Swift.String?
}

extension CreateReportPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanDescription = "ReportPlanDescription"
        case reportPlanName = "ReportPlanName"
        case reportPlanTags = "ReportPlanTags"
        case reportSetting = "ReportSetting"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanName)
        reportPlanName = reportPlanNameDecoded
        let reportPlanDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanDescription)
        reportPlanDescription = reportPlanDescriptionDecoded
        let reportDeliveryChannelDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportDeliveryChannel.self, forKey: .reportDeliveryChannel)
        reportDeliveryChannel = reportDeliveryChannelDecoded
        let reportSettingDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportSetting.self, forKey: .reportSetting)
        reportSetting = reportSettingDecoded
        let reportPlanTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .reportPlanTags)
        var reportPlanTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let reportPlanTagsContainer = reportPlanTagsContainer {
            reportPlanTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in reportPlanTagsContainer {
                if let string0 = string0 {
                    reportPlanTagsDecoded0?[key0] = string0
                }
            }
        }
        reportPlanTags = reportPlanTagsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateReportPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateReportPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.reportPlanArn = output.reportPlanArn
            self.reportPlanName = output.reportPlanName
        } else {
            self.creationTime = nil
            self.reportPlanArn = nil
            self.reportPlanName = nil
        }
    }
}

public struct CreateReportPlanOutput: Swift.Equatable {
    /// The date and time a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationTime: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var reportPlanArn: Swift.String?
    /// The unique name of the report plan.
    public var reportPlanName: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        reportPlanArn: Swift.String? = nil,
        reportPlanName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.reportPlanArn = reportPlanArn
        self.reportPlanName = reportPlanName
    }
}

struct CreateReportPlanOutputBody: Swift.Equatable {
    let reportPlanName: Swift.String?
    let reportPlanArn: Swift.String?
    let creationTime: ClientRuntime.Date?
}

extension CreateReportPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case reportPlanArn = "ReportPlanArn"
        case reportPlanName = "ReportPlanName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanName)
        reportPlanName = reportPlanNameDecoded
        let reportPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanArn)
        reportPlanArn = reportPlanArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum CreateReportPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BackupClientTypes.DateRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromDate = "FromDate"
        case toDate = "ToDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromDate = self.fromDate {
            try encodeContainer.encodeTimestamp(fromDate, format: .epochSeconds, forKey: .fromDate)
        }
        if let toDate = self.toDate {
            try encodeContainer.encodeTimestamp(toDate, format: .epochSeconds, forKey: .toDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fromDate)
        fromDate = fromDateDecoded
        let toDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .toDate)
        toDate = toDateDecoded
    }
}

extension BackupClientTypes {
    /// This is a resource filter containing FromDate: DateTime and ToDate: DateTime. Both values are required. Future DateTime values are not permitted. The date and time are in Unix format and Coordinated Universal Time (UTC), and it is accurate to milliseconds ((milliseconds are optional). For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public struct DateRange: Swift.Equatable {
        /// This value is the beginning date, inclusive. The date and time are in Unix format and Coordinated Universal Time (UTC), and it is accurate to milliseconds (milliseconds are optional).
        /// This member is required.
        public var fromDate: ClientRuntime.Date?
        /// This value is the end date, inclusive. The date and time are in Unix format and Coordinated Universal Time (UTC), and it is accurate to milliseconds (milliseconds are optional).
        /// This member is required.
        public var toDate: ClientRuntime.Date?

        public init(
            fromDate: ClientRuntime.Date? = nil,
            toDate: ClientRuntime.Date? = nil
        )
        {
            self.fromDate = fromDate
            self.toDate = toDate
        }
    }

}

extension DeleteBackupPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())"
    }
}

public struct DeleteBackupPlanInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
    }
}

struct DeleteBackupPlanInputBody: Swift.Equatable {
}

extension DeleteBackupPlanInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBackupPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.deletionDate = output.deletionDate
            self.versionId = output.versionId
        } else {
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.deletionDate = nil
            self.versionId = nil
        }
    }
}

public struct DeleteBackupPlanOutput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var deletionDate: ClientRuntime.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
    public var versionId: Swift.String?

    public init(
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        deletionDate: ClientRuntime.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.deletionDate = deletionDate
        self.versionId = versionId
    }
}

struct DeleteBackupPlanOutputBody: Swift.Equatable {
    let backupPlanId: Swift.String?
    let backupPlanArn: Swift.String?
    let deletionDate: ClientRuntime.Date?
    let versionId: Swift.String?
}

extension DeleteBackupPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case deletionDate = "DeletionDate"
        case versionId = "VersionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let deletionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

enum DeleteBackupPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBackupSelectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        guard let selectionId = selectionId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections/\(selectionId.urlPercentEncoding())"
    }
}

public struct DeleteBackupSelectionInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    /// This member is required.
    public var selectionId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.selectionId = selectionId
    }
}

struct DeleteBackupSelectionInputBody: Swift.Equatable {
}

extension DeleteBackupSelectionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupSelectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBackupSelectionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBackupSelectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBackupVaultAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/access-policy"
    }
}

public struct DeleteBackupVaultAccessPolicyInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultAccessPolicyInputBody: Swift.Equatable {
}

extension DeleteBackupVaultAccessPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultAccessPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBackupVaultAccessPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBackupVaultAccessPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBackupVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())"
    }
}

public struct DeleteBackupVaultInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultInputBody: Swift.Equatable {
}

extension DeleteBackupVaultInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultLockConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/vault-lock"
    }
}

public struct DeleteBackupVaultLockConfigurationInput: Swift.Equatable {
    /// The name of the backup vault from which to delete Backup Vault Lock.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultLockConfigurationInputBody: Swift.Equatable {
}

extension DeleteBackupVaultLockConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultLockConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBackupVaultLockConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBackupVaultLockConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBackupVaultNotificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/notification-configuration"
    }
}

public struct DeleteBackupVaultNotificationsInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultNotificationsInputBody: Swift.Equatable {
}

extension DeleteBackupVaultNotificationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultNotificationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBackupVaultNotificationsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBackupVaultNotificationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBackupVaultOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBackupVaultOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBackupVaultOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let frameworkName = frameworkName else {
            return nil
        }
        return "/audit/frameworks/\(frameworkName.urlPercentEncoding())"
    }
}

public struct DeleteFrameworkInput: Swift.Equatable {
    /// The unique name of a framework.
    /// This member is required.
    public var frameworkName: Swift.String?

    public init(
        frameworkName: Swift.String? = nil
    )
    {
        self.frameworkName = frameworkName
    }
}

struct DeleteFrameworkInputBody: Swift.Equatable {
}

extension DeleteFrameworkInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFrameworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFrameworkOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFrameworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRecoveryPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())"
    }
}

public struct DeleteRecoveryPointInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct DeleteRecoveryPointInputBody: Swift.Equatable {
}

extension DeleteRecoveryPointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRecoveryPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRecoveryPointOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRecoveryPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteReportPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportPlanName = reportPlanName else {
            return nil
        }
        return "/audit/report-plans/\(reportPlanName.urlPercentEncoding())"
    }
}

public struct DeleteReportPlanInput: Swift.Equatable {
    /// The unique name of a report plan.
    /// This member is required.
    public var reportPlanName: Swift.String?

    public init(
        reportPlanName: Swift.String? = nil
    )
    {
        self.reportPlanName = reportPlanName
    }
}

struct DeleteReportPlanInputBody: Swift.Equatable {
}

extension DeleteReportPlanInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReportPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteReportPlanOutput: Swift.Equatable {

    public init() { }
}

enum DeleteReportPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DependencyFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DependencyFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A dependent Amazon Web Services service or resource returned an error to the Backup service, and the action cannot be completed.
public struct DependencyFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

struct DependencyFailureExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension DependencyFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension DescribeBackupJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupJobId = backupJobId else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())"
    }
}

public struct DescribeBackupJobInput: Swift.Equatable {
    /// Uniquely identifies a request to Backup to back up a resource.
    /// This member is required.
    public var backupJobId: Swift.String?

    public init(
        backupJobId: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
    }
}

struct DescribeBackupJobInputBody: Swift.Equatable {
}

extension DescribeBackupJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBackupJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBackupJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.backupJobId = output.backupJobId
            self.backupOptions = output.backupOptions
            self.backupSizeInBytes = output.backupSizeInBytes
            self.backupType = output.backupType
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.bytesTransferred = output.bytesTransferred
            self.childJobsInState = output.childJobsInState
            self.completionDate = output.completionDate
            self.createdBy = output.createdBy
            self.creationDate = output.creationDate
            self.expectedCompletionDate = output.expectedCompletionDate
            self.iamRoleArn = output.iamRoleArn
            self.isParent = output.isParent
            self.numberOfChildJobs = output.numberOfChildJobs
            self.parentJobId = output.parentJobId
            self.percentDone = output.percentDone
            self.recoveryPointArn = output.recoveryPointArn
            self.resourceArn = output.resourceArn
            self.resourceName = output.resourceName
            self.resourceType = output.resourceType
            self.startBy = output.startBy
            self.state = output.state
            self.statusMessage = output.statusMessage
        } else {
            self.accountId = nil
            self.backupJobId = nil
            self.backupOptions = nil
            self.backupSizeInBytes = nil
            self.backupType = nil
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.bytesTransferred = nil
            self.childJobsInState = nil
            self.completionDate = nil
            self.createdBy = nil
            self.creationDate = nil
            self.expectedCompletionDate = nil
            self.iamRoleArn = nil
            self.isParent = false
            self.numberOfChildJobs = nil
            self.parentJobId = nil
            self.percentDone = nil
            self.recoveryPointArn = nil
            self.resourceArn = nil
            self.resourceName = nil
            self.resourceType = nil
            self.startBy = nil
            self.state = nil
            self.statusMessage = nil
        }
    }
}

public struct DescribeBackupJobOutput: Swift.Equatable {
    /// Returns the account ID that owns the backup job.
    public var accountId: Swift.String?
    /// Uniquely identifies a request to Backup to back up a resource.
    public var backupJobId: Swift.String?
    /// Represents the options specified as part of backup plan or on-demand backup job.
    public var backupOptions: [Swift.String:Swift.String]?
    /// The size, in bytes, of a backup.
    public var backupSizeInBytes: Swift.Int?
    /// Represents the actual backup type selected for a backup job. For example, if a successful Windows Volume Shadow Copy Service (VSS) backup was taken, BackupType returns "WindowsVSS". If BackupType is empty, then the backup type was a regular backup.
    public var backupType: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// The size in bytes transferred to a backup vault at the time that the job status was queried.
    public var bytesTransferred: Swift.Int?
    /// This returns the statistics of the included child (nested) backup jobs.
    public var childJobsInState: [Swift.String:Swift.Int]?
    /// The date and time that a job to create a backup job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var completionDate: ClientRuntime.Date?
    /// Contains identifying information about the creation of a backup job, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan that is used to create it.
    public var createdBy: BackupClientTypes.RecoveryPointCreator?
    /// The date and time that a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// The date and time that a job to back up resources is expected to be completed, in Unix format and Coordinated Universal Time (UTC). The value of ExpectedCompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var expectedCompletionDate: ClientRuntime.Date?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// This returns the boolean value that a backup job is a parent (composite) job.
    public var isParent: Swift.Bool
    /// This returns the number of child (nested) backup jobs.
    public var numberOfChildJobs: Swift.Int?
    /// This returns the parent (composite) resource backup job ID.
    public var parentJobId: Swift.String?
    /// Contains an estimated percentage that is complete of a job at the time the job status was queried.
    public var percentDone: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// An ARN that uniquely identifies a saved resource. The format of the ARN depends on the resource type.
    public var resourceArn: Swift.String?
    /// This is the non-unique name of the resource that belongs to the specified backup.
    public var resourceName: Swift.String?
    /// The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
    public var resourceType: Swift.String?
    /// Specifies the time in Unix format and Coordinated Universal Time (UTC) when a backup job must be started before it is canceled. The value is calculated by adding the start window to the scheduled time. So if the scheduled time were 6:00 PM and the start window is 2 hours, the StartBy time would be 8:00 PM on the date specified. The value of StartBy is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var startBy: ClientRuntime.Date?
    /// The current state of a backup job.
    public var state: BackupClientTypes.BackupJobState?
    /// A detailed message explaining the status of the job to back up a resource.
    public var statusMessage: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        backupJobId: Swift.String? = nil,
        backupOptions: [Swift.String:Swift.String]? = nil,
        backupSizeInBytes: Swift.Int? = nil,
        backupType: Swift.String? = nil,
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        bytesTransferred: Swift.Int? = nil,
        childJobsInState: [Swift.String:Swift.Int]? = nil,
        completionDate: ClientRuntime.Date? = nil,
        createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
        creationDate: ClientRuntime.Date? = nil,
        expectedCompletionDate: ClientRuntime.Date? = nil,
        iamRoleArn: Swift.String? = nil,
        isParent: Swift.Bool = false,
        numberOfChildJobs: Swift.Int? = nil,
        parentJobId: Swift.String? = nil,
        percentDone: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        startBy: ClientRuntime.Date? = nil,
        state: BackupClientTypes.BackupJobState? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.backupJobId = backupJobId
        self.backupOptions = backupOptions
        self.backupSizeInBytes = backupSizeInBytes
        self.backupType = backupType
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.bytesTransferred = bytesTransferred
        self.childJobsInState = childJobsInState
        self.completionDate = completionDate
        self.createdBy = createdBy
        self.creationDate = creationDate
        self.expectedCompletionDate = expectedCompletionDate
        self.iamRoleArn = iamRoleArn
        self.isParent = isParent
        self.numberOfChildJobs = numberOfChildJobs
        self.parentJobId = parentJobId
        self.percentDone = percentDone
        self.recoveryPointArn = recoveryPointArn
        self.resourceArn = resourceArn
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.startBy = startBy
        self.state = state
        self.statusMessage = statusMessage
    }
}

struct DescribeBackupJobOutputBody: Swift.Equatable {
    let accountId: Swift.String?
    let backupJobId: Swift.String?
    let backupVaultName: Swift.String?
    let backupVaultArn: Swift.String?
    let recoveryPointArn: Swift.String?
    let resourceArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let completionDate: ClientRuntime.Date?
    let state: BackupClientTypes.BackupJobState?
    let statusMessage: Swift.String?
    let percentDone: Swift.String?
    let backupSizeInBytes: Swift.Int?
    let iamRoleArn: Swift.String?
    let createdBy: BackupClientTypes.RecoveryPointCreator?
    let resourceType: Swift.String?
    let bytesTransferred: Swift.Int?
    let expectedCompletionDate: ClientRuntime.Date?
    let startBy: ClientRuntime.Date?
    let backupOptions: [Swift.String:Swift.String]?
    let backupType: Swift.String?
    let parentJobId: Swift.String?
    let isParent: Swift.Bool
    let numberOfChildJobs: Swift.Int?
    let childJobsInState: [Swift.String:Swift.Int]?
    let resourceName: Swift.String?
}

extension DescribeBackupJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupJobId = "BackupJobId"
        case backupOptions = "BackupOptions"
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupType = "BackupType"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case bytesTransferred = "BytesTransferred"
        case childJobsInState = "ChildJobsInState"
        case completionDate = "CompletionDate"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case expectedCompletionDate = "ExpectedCompletionDate"
        case iamRoleArn = "IamRoleArn"
        case isParent = "IsParent"
        case numberOfChildJobs = "NumberOfChildJobs"
        case parentJobId = "ParentJobId"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case startBy = "StartBy"
        case state = "State"
        case statusMessage = "StatusMessage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let backupJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupJobId)
        backupJobId = backupJobIdDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDate)
        completionDate = completionDateDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupJobState.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let bytesTransferredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesTransferred)
        bytesTransferred = bytesTransferredDecoded
        let expectedCompletionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expectedCompletionDate)
        expectedCompletionDate = expectedCompletionDateDecoded
        let startByDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startBy)
        startBy = startByDecoded
        let backupOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
        let backupTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupType)
        backupType = backupTypeDecoded
        let parentJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentJobId)
        parentJobId = parentJobIdDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
        let numberOfChildJobsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfChildJobs)
        numberOfChildJobs = numberOfChildJobsDecoded
        let childJobsInStateContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .childJobsInState)
        var childJobsInStateDecoded0: [Swift.String:Swift.Int]? = nil
        if let childJobsInStateContainer = childJobsInStateContainer {
            childJobsInStateDecoded0 = [Swift.String:Swift.Int]()
            for (key0, long0) in childJobsInStateContainer {
                if let long0 = long0 {
                    childJobsInStateDecoded0?[key0] = long0
                }
            }
        }
        childJobsInState = childJobsInStateDecoded0
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

enum DescribeBackupJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyFailureException": return try await DependencyFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBackupVaultInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let backupVaultAccountId = backupVaultAccountId {
                let backupVaultAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "backupVaultAccountId".urlPercentEncoding(), value: Swift.String(backupVaultAccountId).urlPercentEncoding())
                items.append(backupVaultAccountIdQueryItem)
            }
            return items
        }
    }
}

extension DescribeBackupVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())"
    }
}

public struct DescribeBackupVaultInput: Swift.Equatable {
    /// This is the account ID of the specified backup vault.
    public var backupVaultAccountId: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init(
        backupVaultAccountId: Swift.String? = nil,
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultAccountId = backupVaultAccountId
        self.backupVaultName = backupVaultName
    }
}

struct DescribeBackupVaultInputBody: Swift.Equatable {
}

extension DescribeBackupVaultInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBackupVaultOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBackupVaultOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.creationDate = output.creationDate
            self.creatorRequestId = output.creatorRequestId
            self.encryptionKeyArn = output.encryptionKeyArn
            self.lockDate = output.lockDate
            self.locked = output.locked
            self.maxRetentionDays = output.maxRetentionDays
            self.minRetentionDays = output.minRetentionDays
            self.numberOfRecoveryPoints = output.numberOfRecoveryPoints
            self.vaultType = output.vaultType
        } else {
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.creationDate = nil
            self.creatorRequestId = nil
            self.encryptionKeyArn = nil
            self.lockDate = nil
            self.locked = nil
            self.maxRetentionDays = nil
            self.minRetentionDays = nil
            self.numberOfRecoveryPoints = 0
            self.vaultType = nil
        }
    }
}

public struct DescribeBackupVaultOutput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// The date and time that a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
    public var creatorRequestId: Swift.String?
    /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    public var encryptionKeyArn: Swift.String?
    /// The date and time when Backup Vault Lock configuration cannot be changed or deleted. If you applied Vault Lock to your vault without specifying a lock date, you can change any of your Vault Lock settings, or delete Vault Lock from the vault entirely, at any time. This value is in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lockDate: ClientRuntime.Date?
    /// A Boolean that indicates whether Backup Vault Lock is currently protecting the backup vault. True means that Vault Lock causes delete or update operations on the recovery points stored in the vault to fail.
    public var locked: Swift.Bool?
    /// The Backup Vault Lock setting that specifies the maximum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a maximum retention period on the recovery points in the vault (allowing indefinite storage). If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
    public var maxRetentionDays: Swift.Int?
    /// The Backup Vault Lock setting that specifies the minimum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a minimum retention period. If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
    public var minRetentionDays: Swift.Int?
    /// The number of recovery points that are stored in a backup vault.
    public var numberOfRecoveryPoints: Swift.Int
    /// This is the type of vault described.
    public var vaultType: BackupClientTypes.VaultType?

    public init(
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        creatorRequestId: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil,
        lockDate: ClientRuntime.Date? = nil,
        locked: Swift.Bool? = nil,
        maxRetentionDays: Swift.Int? = nil,
        minRetentionDays: Swift.Int? = nil,
        numberOfRecoveryPoints: Swift.Int = 0,
        vaultType: BackupClientTypes.VaultType? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.encryptionKeyArn = encryptionKeyArn
        self.lockDate = lockDate
        self.locked = locked
        self.maxRetentionDays = maxRetentionDays
        self.minRetentionDays = minRetentionDays
        self.numberOfRecoveryPoints = numberOfRecoveryPoints
        self.vaultType = vaultType
    }
}

struct DescribeBackupVaultOutputBody: Swift.Equatable {
    let backupVaultName: Swift.String?
    let backupVaultArn: Swift.String?
    let vaultType: BackupClientTypes.VaultType?
    let encryptionKeyArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let creatorRequestId: Swift.String?
    let numberOfRecoveryPoints: Swift.Int
    let locked: Swift.Bool?
    let minRetentionDays: Swift.Int?
    let maxRetentionDays: Swift.Int?
    let lockDate: ClientRuntime.Date?
}

extension DescribeBackupVaultOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
        case lockDate = "LockDate"
        case locked = "Locked"
        case maxRetentionDays = "MaxRetentionDays"
        case minRetentionDays = "MinRetentionDays"
        case numberOfRecoveryPoints = "NumberOfRecoveryPoints"
        case vaultType = "VaultType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let vaultTypeDecoded = try containerValues.decodeIfPresent(BackupClientTypes.VaultType.self, forKey: .vaultType)
        vaultType = vaultTypeDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let numberOfRecoveryPointsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecoveryPoints) ?? 0
        numberOfRecoveryPoints = numberOfRecoveryPointsDecoded
        let lockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .locked)
        locked = lockedDecoded
        let minRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minRetentionDays)
        minRetentionDays = minRetentionDaysDecoded
        let maxRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetentionDays)
        maxRetentionDays = maxRetentionDaysDecoded
        let lockDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lockDate)
        lockDate = lockDateDecoded
    }
}

enum DescribeBackupVaultOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCopyJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let copyJobId = copyJobId else {
            return nil
        }
        return "/copy-jobs/\(copyJobId.urlPercentEncoding())"
    }
}

public struct DescribeCopyJobInput: Swift.Equatable {
    /// Uniquely identifies a copy job.
    /// This member is required.
    public var copyJobId: Swift.String?

    public init(
        copyJobId: Swift.String? = nil
    )
    {
        self.copyJobId = copyJobId
    }
}

struct DescribeCopyJobInputBody: Swift.Equatable {
}

extension DescribeCopyJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCopyJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCopyJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.copyJob = output.copyJob
        } else {
            self.copyJob = nil
        }
    }
}

public struct DescribeCopyJobOutput: Swift.Equatable {
    /// Contains detailed information about a copy job.
    public var copyJob: BackupClientTypes.CopyJob?

    public init(
        copyJob: BackupClientTypes.CopyJob? = nil
    )
    {
        self.copyJob = copyJob
    }
}

struct DescribeCopyJobOutputBody: Swift.Equatable {
    let copyJob: BackupClientTypes.CopyJob?
}

extension DescribeCopyJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyJob = "CopyJob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyJobDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CopyJob.self, forKey: .copyJob)
        copyJob = copyJobDecoded
    }
}

enum DescribeCopyJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let frameworkName = frameworkName else {
            return nil
        }
        return "/audit/frameworks/\(frameworkName.urlPercentEncoding())"
    }
}

public struct DescribeFrameworkInput: Swift.Equatable {
    /// The unique name of a framework.
    /// This member is required.
    public var frameworkName: Swift.String?

    public init(
        frameworkName: Swift.String? = nil
    )
    {
        self.frameworkName = frameworkName
    }
}

struct DescribeFrameworkInputBody: Swift.Equatable {
}

extension DescribeFrameworkInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFrameworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFrameworkOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.deploymentStatus = output.deploymentStatus
            self.frameworkArn = output.frameworkArn
            self.frameworkControls = output.frameworkControls
            self.frameworkDescription = output.frameworkDescription
            self.frameworkName = output.frameworkName
            self.frameworkStatus = output.frameworkStatus
            self.idempotencyToken = output.idempotencyToken
        } else {
            self.creationTime = nil
            self.deploymentStatus = nil
            self.frameworkArn = nil
            self.frameworkControls = nil
            self.frameworkDescription = nil
            self.frameworkName = nil
            self.frameworkStatus = nil
            self.idempotencyToken = nil
        }
    }
}

public struct DescribeFrameworkOutput: Swift.Equatable {
    /// The date and time that a framework is created, in ISO 8601 representation. The value of CreationTime is accurate to milliseconds. For example, 2020-07-10T15:00:00.000-08:00 represents the 10th of July 2020 at 3:00 PM 8 hours behind UTC.
    public var creationTime: ClientRuntime.Date?
    /// The deployment status of a framework. The statuses are: CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED | FAILED
    public var deploymentStatus: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var frameworkArn: Swift.String?
    /// A list of the controls that make up the framework. Each control in the list has a name, input parameters, and scope.
    public var frameworkControls: [BackupClientTypes.FrameworkControl]?
    /// An optional description of the framework.
    public var frameworkDescription: Swift.String?
    /// The unique name of a framework.
    public var frameworkName: Swift.String?
    /// A framework consists of one or more controls. Each control governs a resource, such as backup plans, backup selections, backup vaults, or recovery points. You can also turn Config recording on or off for each resource. The statuses are:
    ///
    /// * ACTIVE when recording is turned on for all resources governed by the framework.
    ///
    /// * PARTIALLY_ACTIVE when recording is turned off for at least one resource governed by the framework.
    ///
    /// * INACTIVE when recording is turned off for all resources governed by the framework.
    ///
    /// * UNAVAILABLE when Backup is unable to validate recording status at this time.
    public var frameworkStatus: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to DescribeFrameworkOutput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        deploymentStatus: Swift.String? = nil,
        frameworkArn: Swift.String? = nil,
        frameworkControls: [BackupClientTypes.FrameworkControl]? = nil,
        frameworkDescription: Swift.String? = nil,
        frameworkName: Swift.String? = nil,
        frameworkStatus: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.deploymentStatus = deploymentStatus
        self.frameworkArn = frameworkArn
        self.frameworkControls = frameworkControls
        self.frameworkDescription = frameworkDescription
        self.frameworkName = frameworkName
        self.frameworkStatus = frameworkStatus
        self.idempotencyToken = idempotencyToken
    }
}

struct DescribeFrameworkOutputBody: Swift.Equatable {
    let frameworkName: Swift.String?
    let frameworkArn: Swift.String?
    let frameworkDescription: Swift.String?
    let frameworkControls: [BackupClientTypes.FrameworkControl]?
    let creationTime: ClientRuntime.Date?
    let deploymentStatus: Swift.String?
    let frameworkStatus: Swift.String?
    let idempotencyToken: Swift.String?
}

extension DescribeFrameworkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case deploymentStatus = "DeploymentStatus"
        case frameworkArn = "FrameworkArn"
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case frameworkName = "FrameworkName"
        case frameworkStatus = "FrameworkStatus"
        case idempotencyToken = "IdempotencyToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkArn)
        frameworkArn = frameworkArnDecoded
        let frameworkDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkDescription)
        frameworkDescription = frameworkDescriptionDecoded
        let frameworkControlsContainer = try containerValues.decodeIfPresent([BackupClientTypes.FrameworkControl?].self, forKey: .frameworkControls)
        var frameworkControlsDecoded0:[BackupClientTypes.FrameworkControl]? = nil
        if let frameworkControlsContainer = frameworkControlsContainer {
            frameworkControlsDecoded0 = [BackupClientTypes.FrameworkControl]()
            for structure0 in frameworkControlsContainer {
                if let structure0 = structure0 {
                    frameworkControlsDecoded0?.append(structure0)
                }
            }
        }
        frameworkControls = frameworkControlsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let frameworkStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkStatus)
        frameworkStatus = frameworkStatusDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

enum DescribeFrameworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeGlobalSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/global-settings"
    }
}

public struct DescribeGlobalSettingsInput: Swift.Equatable {

    public init() { }
}

struct DescribeGlobalSettingsInputBody: Swift.Equatable {
}

extension DescribeGlobalSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGlobalSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeGlobalSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.globalSettings = output.globalSettings
            self.lastUpdateTime = output.lastUpdateTime
        } else {
            self.globalSettings = nil
            self.lastUpdateTime = nil
        }
    }
}

public struct DescribeGlobalSettingsOutput: Swift.Equatable {
    /// The status of the flag isCrossAccountBackupEnabled.
    public var globalSettings: [Swift.String:Swift.String]?
    /// The date and time that the flag isCrossAccountBackupEnabled was last updated. This update is in Unix format and Coordinated Universal Time (UTC). The value of LastUpdateTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastUpdateTime: ClientRuntime.Date?

    public init(
        globalSettings: [Swift.String:Swift.String]? = nil,
        lastUpdateTime: ClientRuntime.Date? = nil
    )
    {
        self.globalSettings = globalSettings
        self.lastUpdateTime = lastUpdateTime
    }
}

struct DescribeGlobalSettingsOutputBody: Swift.Equatable {
    let globalSettings: [Swift.String:Swift.String]?
    let lastUpdateTime: ClientRuntime.Date?
}

extension DescribeGlobalSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalSettings = "GlobalSettings"
        case lastUpdateTime = "LastUpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalSettingsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .globalSettings)
        var globalSettingsDecoded0: [Swift.String:Swift.String]? = nil
        if let globalSettingsContainer = globalSettingsContainer {
            globalSettingsDecoded0 = [Swift.String:Swift.String]()
            for (key0, globalsettingsvalue0) in globalSettingsContainer {
                if let globalsettingsvalue0 = globalsettingsvalue0 {
                    globalSettingsDecoded0?[key0] = globalsettingsvalue0
                }
            }
        }
        globalSettings = globalSettingsDecoded0
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

enum DescribeGlobalSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProtectedResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())"
    }
}

public struct DescribeProtectedResourceInput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DescribeProtectedResourceInputBody: Swift.Equatable {
}

extension DescribeProtectedResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProtectedResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProtectedResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.lastBackupTime = output.lastBackupTime
            self.resourceArn = output.resourceArn
            self.resourceName = output.resourceName
            self.resourceType = output.resourceType
        } else {
            self.lastBackupTime = nil
            self.resourceArn = nil
            self.resourceName = nil
            self.resourceType = nil
        }
    }
}

public struct DescribeProtectedResourceOutput: Swift.Equatable {
    /// The date and time that a resource was last backed up, in Unix format and Coordinated Universal Time (UTC). The value of LastBackupTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastBackupTime: ClientRuntime.Date?
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var resourceArn: Swift.String?
    /// This is the non-unique name of the resource that belongs to the specified backup.
    public var resourceName: Swift.String?
    /// The type of Amazon Web Services resource saved as a recovery point; for example, an Amazon EBS volume or an Amazon RDS database.
    public var resourceType: Swift.String?

    public init(
        lastBackupTime: ClientRuntime.Date? = nil,
        resourceArn: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.lastBackupTime = lastBackupTime
        self.resourceArn = resourceArn
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

struct DescribeProtectedResourceOutputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let resourceType: Swift.String?
    let lastBackupTime: ClientRuntime.Date?
    let resourceName: Swift.String?
}

extension DescribeProtectedResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastBackupTime = "LastBackupTime"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let lastBackupTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastBackupTime)
        lastBackupTime = lastBackupTimeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

enum DescribeProtectedResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRecoveryPointInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let backupVaultAccountId = backupVaultAccountId {
                let backupVaultAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "backupVaultAccountId".urlPercentEncoding(), value: Swift.String(backupVaultAccountId).urlPercentEncoding())
                items.append(backupVaultAccountIdQueryItem)
            }
            return items
        }
    }
}

extension DescribeRecoveryPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())"
    }
}

public struct DescribeRecoveryPointInput: Swift.Equatable {
    /// This is the account ID of the specified backup vault.
    public var backupVaultAccountId: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultAccountId: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultAccountId = backupVaultAccountId
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct DescribeRecoveryPointInputBody: Swift.Equatable {
}

extension DescribeRecoveryPointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRecoveryPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRecoveryPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupSizeInBytes = output.backupSizeInBytes
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.calculatedLifecycle = output.calculatedLifecycle
            self.completionDate = output.completionDate
            self.compositeMemberIdentifier = output.compositeMemberIdentifier
            self.createdBy = output.createdBy
            self.creationDate = output.creationDate
            self.encryptionKeyArn = output.encryptionKeyArn
            self.iamRoleArn = output.iamRoleArn
            self.isEncrypted = output.isEncrypted
            self.isParent = output.isParent
            self.lastRestoreTime = output.lastRestoreTime
            self.lifecycle = output.lifecycle
            self.parentRecoveryPointArn = output.parentRecoveryPointArn
            self.recoveryPointArn = output.recoveryPointArn
            self.resourceArn = output.resourceArn
            self.resourceName = output.resourceName
            self.resourceType = output.resourceType
            self.sourceBackupVaultArn = output.sourceBackupVaultArn
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.storageClass = output.storageClass
        } else {
            self.backupSizeInBytes = nil
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.calculatedLifecycle = nil
            self.completionDate = nil
            self.compositeMemberIdentifier = nil
            self.createdBy = nil
            self.creationDate = nil
            self.encryptionKeyArn = nil
            self.iamRoleArn = nil
            self.isEncrypted = false
            self.isParent = false
            self.lastRestoreTime = nil
            self.lifecycle = nil
            self.parentRecoveryPointArn = nil
            self.recoveryPointArn = nil
            self.resourceArn = nil
            self.resourceName = nil
            self.resourceType = nil
            self.sourceBackupVaultArn = nil
            self.status = nil
            self.statusMessage = nil
            self.storageClass = nil
        }
    }
}

public struct DescribeRecoveryPointOutput: Swift.Equatable {
    /// The size, in bytes, of a backup.
    public var backupSizeInBytes: Swift.Int?
    /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
    public var calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
    /// The date and time that a job to create a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var completionDate: ClientRuntime.Date?
    /// This is the identifier of a resource within a composite group, such as nested (child) recovery point belonging to a composite (parent) stack. The ID is transferred from the [ logical ID](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html#resources-section-structure-syntax) within a stack.
    public var compositeMemberIdentifier: Swift.String?
    /// Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan used to create it.
    public var createdBy: BackupClientTypes.RecoveryPointCreator?
    /// The date and time that a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// The server-side encryption key used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    public var encryptionKeyArn: Swift.String?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.
    public var isEncrypted: Swift.Bool
    /// This returns the boolean value that a recovery point is a parent (composite) job.
    public var isParent: Swift.Bool
    /// The date and time that a recovery point was last restored, in Unix format and Coordinated Universal Time (UTC). The value of LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastRestoreTime: ClientRuntime.Date?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups that are transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the retention setting must be 90 days greater than the transition to cold after days setting. The transition to cold after days setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// This is an ARN that uniquely identifies a parent (composite) recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var parentRecoveryPointArn: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// An ARN that uniquely identifies a saved resource. The format of the ARN depends on the resource type.
    public var resourceArn: Swift.String?
    /// This is the non-unique name of the resource that belongs to the specified backup.
    public var resourceName: Swift.String?
    /// The type of Amazon Web Services resource to save as a recovery point; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
    public var resourceType: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies the source vault where the resource was originally backed up in; for example, arn:aws:backup:us-east-1:123456789012:vault:BackupVault. If the recovery is restored to the same Amazon Web Services account or Region, this value will be null.
    public var sourceBackupVaultArn: Swift.String?
    /// A status code specifying the state of the recovery point. PARTIAL status indicates Backup could not create the recovery point before the backup window closed. To increase your backup plan window using the API, see [UpdateBackupPlan](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_UpdateBackupPlan.html). You can also increase your backup plan window using the Console by choosing and editing your backup plan. EXPIRED status indicates that the recovery point has exceeded its retention period, but Backup lacks permission or is otherwise unable to delete it. To manually delete these recovery points, see [ Step 3: Delete the recovery points](https://docs.aws.amazon.com/aws-backup/latest/devguide/gs-cleanup-resources.html#cleanup-backups) in the Clean up resources section of Getting started. STOPPED status occurs on a continuous backup where a user has taken some action that causes the continuous backup to be disabled. This can be caused by the removal of permissions, turning off versioning, turning off events being sent to EventBridge, or disabling the EventBridge rules that are put in place by Backup. To resolve STOPPED status, ensure that all requested permissions are in place and that versioning is enabled on the S3 bucket. Once these conditions are met, the next instance of a backup rule running will result in a new continuous recovery point being created. The recovery points with STOPPED status do not need to be deleted. For SAP HANA on Amazon EC2 STOPPED status occurs due to user action, application misconfiguration, or backup failure. To ensure that future continuous backups succeed, refer to the recovery point status and check SAP HANA for details.
    public var status: BackupClientTypes.RecoveryPointStatus?
    /// A status message explaining the status of the recovery point.
    public var statusMessage: Swift.String?
    /// Specifies the storage class of the recovery point. Valid values are WARM or COLD.
    public var storageClass: BackupClientTypes.StorageClass?

    public init(
        backupSizeInBytes: Swift.Int? = nil,
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        calculatedLifecycle: BackupClientTypes.CalculatedLifecycle? = nil,
        completionDate: ClientRuntime.Date? = nil,
        compositeMemberIdentifier: Swift.String? = nil,
        createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
        creationDate: ClientRuntime.Date? = nil,
        encryptionKeyArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        isEncrypted: Swift.Bool = false,
        isParent: Swift.Bool = false,
        lastRestoreTime: ClientRuntime.Date? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        parentRecoveryPointArn: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        sourceBackupVaultArn: Swift.String? = nil,
        status: BackupClientTypes.RecoveryPointStatus? = nil,
        statusMessage: Swift.String? = nil,
        storageClass: BackupClientTypes.StorageClass? = nil
    )
    {
        self.backupSizeInBytes = backupSizeInBytes
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.calculatedLifecycle = calculatedLifecycle
        self.completionDate = completionDate
        self.compositeMemberIdentifier = compositeMemberIdentifier
        self.createdBy = createdBy
        self.creationDate = creationDate
        self.encryptionKeyArn = encryptionKeyArn
        self.iamRoleArn = iamRoleArn
        self.isEncrypted = isEncrypted
        self.isParent = isParent
        self.lastRestoreTime = lastRestoreTime
        self.lifecycle = lifecycle
        self.parentRecoveryPointArn = parentRecoveryPointArn
        self.recoveryPointArn = recoveryPointArn
        self.resourceArn = resourceArn
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.sourceBackupVaultArn = sourceBackupVaultArn
        self.status = status
        self.statusMessage = statusMessage
        self.storageClass = storageClass
    }
}

struct DescribeRecoveryPointOutputBody: Swift.Equatable {
    let recoveryPointArn: Swift.String?
    let backupVaultName: Swift.String?
    let backupVaultArn: Swift.String?
    let sourceBackupVaultArn: Swift.String?
    let resourceArn: Swift.String?
    let resourceType: Swift.String?
    let createdBy: BackupClientTypes.RecoveryPointCreator?
    let iamRoleArn: Swift.String?
    let status: BackupClientTypes.RecoveryPointStatus?
    let statusMessage: Swift.String?
    let creationDate: ClientRuntime.Date?
    let completionDate: ClientRuntime.Date?
    let backupSizeInBytes: Swift.Int?
    let calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
    let lifecycle: BackupClientTypes.Lifecycle?
    let encryptionKeyArn: Swift.String?
    let isEncrypted: Swift.Bool
    let storageClass: BackupClientTypes.StorageClass?
    let lastRestoreTime: ClientRuntime.Date?
    let parentRecoveryPointArn: Swift.String?
    let compositeMemberIdentifier: Swift.String?
    let isParent: Swift.Bool
    let resourceName: Swift.String?
}

extension DescribeRecoveryPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case calculatedLifecycle = "CalculatedLifecycle"
        case completionDate = "CompletionDate"
        case compositeMemberIdentifier = "CompositeMemberIdentifier"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case encryptionKeyArn = "EncryptionKeyArn"
        case iamRoleArn = "IamRoleArn"
        case isEncrypted = "IsEncrypted"
        case isParent = "IsParent"
        case lastRestoreTime = "LastRestoreTime"
        case lifecycle = "Lifecycle"
        case parentRecoveryPointArn = "ParentRecoveryPointArn"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case sourceBackupVaultArn = "SourceBackupVaultArn"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case storageClass = "StorageClass"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let sourceBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupVaultArn)
        sourceBackupVaultArn = sourceBackupVaultArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDate)
        completionDate = completionDateDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let calculatedLifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CalculatedLifecycle.self, forKey: .calculatedLifecycle)
        calculatedLifecycle = calculatedLifecycleDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let isEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEncrypted) ?? false
        isEncrypted = isEncryptedDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(BackupClientTypes.StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let lastRestoreTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastRestoreTime)
        lastRestoreTime = lastRestoreTimeDecoded
        let parentRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentRecoveryPointArn)
        parentRecoveryPointArn = parentRecoveryPointArnDecoded
        let compositeMemberIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .compositeMemberIdentifier)
        compositeMemberIdentifier = compositeMemberIdentifierDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

enum DescribeRecoveryPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRegionSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account-settings"
    }
}

public struct DescribeRegionSettingsInput: Swift.Equatable {

    public init() { }
}

struct DescribeRegionSettingsInputBody: Swift.Equatable {
}

extension DescribeRegionSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRegionSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRegionSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceTypeManagementPreference = output.resourceTypeManagementPreference
            self.resourceTypeOptInPreference = output.resourceTypeOptInPreference
        } else {
            self.resourceTypeManagementPreference = nil
            self.resourceTypeOptInPreference = nil
        }
    }
}

public struct DescribeRegionSettingsOutput: Swift.Equatable {
    /// Returns whether Backup fully manages the backups for a resource type. For the benefits of full Backup management, see [ Full Backup management](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#full-management). For a list of resource types and whether each supports full Backup management, see the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. If "DynamoDB":false, you can enable full Backup management for DynamoDB backup by enabling [ Backup's advanced DynamoDB backup features](https://docs.aws.amazon.com/aws-backup/latest/devguide/advanced-ddb-backup.html#advanced-ddb-backup-enable-cli).
    public var resourceTypeManagementPreference: [Swift.String:Swift.Bool]?
    /// Returns a list of all services along with the opt-in preferences in the Region.
    public var resourceTypeOptInPreference: [Swift.String:Swift.Bool]?

    public init(
        resourceTypeManagementPreference: [Swift.String:Swift.Bool]? = nil,
        resourceTypeOptInPreference: [Swift.String:Swift.Bool]? = nil
    )
    {
        self.resourceTypeManagementPreference = resourceTypeManagementPreference
        self.resourceTypeOptInPreference = resourceTypeOptInPreference
    }
}

struct DescribeRegionSettingsOutputBody: Swift.Equatable {
    let resourceTypeOptInPreference: [Swift.String:Swift.Bool]?
    let resourceTypeManagementPreference: [Swift.String:Swift.Bool]?
}

extension DescribeRegionSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTypeManagementPreference = "ResourceTypeManagementPreference"
        case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeOptInPreferenceContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .resourceTypeOptInPreference)
        var resourceTypeOptInPreferenceDecoded0: [Swift.String:Swift.Bool]? = nil
        if let resourceTypeOptInPreferenceContainer = resourceTypeOptInPreferenceContainer {
            resourceTypeOptInPreferenceDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, isenabled0) in resourceTypeOptInPreferenceContainer {
                if let isenabled0 = isenabled0 {
                    resourceTypeOptInPreferenceDecoded0?[key0] = isenabled0
                }
            }
        }
        resourceTypeOptInPreference = resourceTypeOptInPreferenceDecoded0
        let resourceTypeManagementPreferenceContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .resourceTypeManagementPreference)
        var resourceTypeManagementPreferenceDecoded0: [Swift.String:Swift.Bool]? = nil
        if let resourceTypeManagementPreferenceContainer = resourceTypeManagementPreferenceContainer {
            resourceTypeManagementPreferenceDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, isenabled0) in resourceTypeManagementPreferenceContainer {
                if let isenabled0 = isenabled0 {
                    resourceTypeManagementPreferenceDecoded0?[key0] = isenabled0
                }
            }
        }
        resourceTypeManagementPreference = resourceTypeManagementPreferenceDecoded0
    }
}

enum DescribeRegionSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportJobId = reportJobId else {
            return nil
        }
        return "/audit/report-jobs/\(reportJobId.urlPercentEncoding())"
    }
}

public struct DescribeReportJobInput: Swift.Equatable {
    /// The identifier of the report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. The report job ID cannot be edited.
    /// This member is required.
    public var reportJobId: Swift.String?

    public init(
        reportJobId: Swift.String? = nil
    )
    {
        self.reportJobId = reportJobId
    }
}

struct DescribeReportJobInputBody: Swift.Equatable {
}

extension DescribeReportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeReportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.reportJob = output.reportJob
        } else {
            self.reportJob = nil
        }
    }
}

public struct DescribeReportJobOutput: Swift.Equatable {
    /// A list of information about a report job, including its completion and creation times, report destination, unique report job ID, Amazon Resource Name (ARN), report template, status, and status message.
    public var reportJob: BackupClientTypes.ReportJob?

    public init(
        reportJob: BackupClientTypes.ReportJob? = nil
    )
    {
        self.reportJob = reportJob
    }
}

struct DescribeReportJobOutputBody: Swift.Equatable {
    let reportJob: BackupClientTypes.ReportJob?
}

extension DescribeReportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportJob = "ReportJob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportJobDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportJob.self, forKey: .reportJob)
        reportJob = reportJobDecoded
    }
}

enum DescribeReportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReportPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportPlanName = reportPlanName else {
            return nil
        }
        return "/audit/report-plans/\(reportPlanName.urlPercentEncoding())"
    }
}

public struct DescribeReportPlanInput: Swift.Equatable {
    /// The unique name of a report plan.
    /// This member is required.
    public var reportPlanName: Swift.String?

    public init(
        reportPlanName: Swift.String? = nil
    )
    {
        self.reportPlanName = reportPlanName
    }
}

struct DescribeReportPlanInputBody: Swift.Equatable {
}

extension DescribeReportPlanInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeReportPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReportPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.reportPlan = output.reportPlan
        } else {
            self.reportPlan = nil
        }
    }
}

public struct DescribeReportPlanOutput: Swift.Equatable {
    /// Returns details about the report plan that is specified by its name. These details include the report plan's Amazon Resource Name (ARN), description, settings, delivery channel, deployment status, creation time, and last attempted and successful run times.
    public var reportPlan: BackupClientTypes.ReportPlan?

    public init(
        reportPlan: BackupClientTypes.ReportPlan? = nil
    )
    {
        self.reportPlan = reportPlan
    }
}

struct DescribeReportPlanOutputBody: Swift.Equatable {
    let reportPlan: BackupClientTypes.ReportPlan?
}

extension DescribeReportPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportPlan = "ReportPlan"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportPlan.self, forKey: .reportPlan)
        reportPlan = reportPlanDecoded
    }
}

enum DescribeReportPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRestoreJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restoreJobId = restoreJobId else {
            return nil
        }
        return "/restore-jobs/\(restoreJobId.urlPercentEncoding())"
    }
}

public struct DescribeRestoreJobInput: Swift.Equatable {
    /// Uniquely identifies the job that restores a recovery point.
    /// This member is required.
    public var restoreJobId: Swift.String?

    public init(
        restoreJobId: Swift.String? = nil
    )
    {
        self.restoreJobId = restoreJobId
    }
}

struct DescribeRestoreJobInputBody: Swift.Equatable {
}

extension DescribeRestoreJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRestoreJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRestoreJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.backupSizeInBytes = output.backupSizeInBytes
            self.completionDate = output.completionDate
            self.createdResourceArn = output.createdResourceArn
            self.creationDate = output.creationDate
            self.expectedCompletionTimeMinutes = output.expectedCompletionTimeMinutes
            self.iamRoleArn = output.iamRoleArn
            self.percentDone = output.percentDone
            self.recoveryPointArn = output.recoveryPointArn
            self.resourceType = output.resourceType
            self.restoreJobId = output.restoreJobId
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.accountId = nil
            self.backupSizeInBytes = nil
            self.completionDate = nil
            self.createdResourceArn = nil
            self.creationDate = nil
            self.expectedCompletionTimeMinutes = nil
            self.iamRoleArn = nil
            self.percentDone = nil
            self.recoveryPointArn = nil
            self.resourceType = nil
            self.restoreJobId = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct DescribeRestoreJobOutput: Swift.Equatable {
    /// Returns the account ID that owns the restore job.
    public var accountId: Swift.String?
    /// The size, in bytes, of the restored resource.
    public var backupSizeInBytes: Swift.Int?
    /// The date and time that a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var completionDate: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource whose recovery point is being restored. The format of the ARN depends on the resource type of the backed-up resource.
    public var createdResourceArn: Swift.String?
    /// The date and time that a restore job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// The amount of time in minutes that a job restoring a recovery point is expected to take.
    public var expectedCompletionTimeMinutes: Swift.Int?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// Contains an estimated percentage that is complete of a job at the time the job status was queried.
    public var percentDone: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// Returns metadata associated with a restore job listed by resource type.
    public var resourceType: Swift.String?
    /// Uniquely identifies the job that restores a recovery point.
    public var restoreJobId: Swift.String?
    /// Status code specifying the state of the job that is initiated by Backup to restore a recovery point.
    public var status: BackupClientTypes.RestoreJobStatus?
    /// A message showing the status of a job to restore a recovery point.
    public var statusMessage: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        backupSizeInBytes: Swift.Int? = nil,
        completionDate: ClientRuntime.Date? = nil,
        createdResourceArn: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        expectedCompletionTimeMinutes: Swift.Int? = nil,
        iamRoleArn: Swift.String? = nil,
        percentDone: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        restoreJobId: Swift.String? = nil,
        status: BackupClientTypes.RestoreJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.backupSizeInBytes = backupSizeInBytes
        self.completionDate = completionDate
        self.createdResourceArn = createdResourceArn
        self.creationDate = creationDate
        self.expectedCompletionTimeMinutes = expectedCompletionTimeMinutes
        self.iamRoleArn = iamRoleArn
        self.percentDone = percentDone
        self.recoveryPointArn = recoveryPointArn
        self.resourceType = resourceType
        self.restoreJobId = restoreJobId
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct DescribeRestoreJobOutputBody: Swift.Equatable {
    let accountId: Swift.String?
    let restoreJobId: Swift.String?
    let recoveryPointArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let completionDate: ClientRuntime.Date?
    let status: BackupClientTypes.RestoreJobStatus?
    let statusMessage: Swift.String?
    let percentDone: Swift.String?
    let backupSizeInBytes: Swift.Int?
    let iamRoleArn: Swift.String?
    let expectedCompletionTimeMinutes: Swift.Int?
    let createdResourceArn: Swift.String?
    let resourceType: Swift.String?
}

extension DescribeRestoreJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupSizeInBytes = "BackupSizeInBytes"
        case completionDate = "CompletionDate"
        case createdResourceArn = "CreatedResourceArn"
        case creationDate = "CreationDate"
        case expectedCompletionTimeMinutes = "ExpectedCompletionTimeMinutes"
        case iamRoleArn = "IamRoleArn"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
        case restoreJobId = "RestoreJobId"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let restoreJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreJobId)
        restoreJobId = restoreJobIdDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDate)
        completionDate = completionDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RestoreJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let expectedCompletionTimeMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expectedCompletionTimeMinutes)
        expectedCompletionTimeMinutes = expectedCompletionTimeMinutesDecoded
        let createdResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdResourceArn)
        createdResourceArn = createdResourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

enum DescribeRestoreJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyFailureException": return try await DependencyFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateRecoveryPointFromParentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())/parentAssociation"
    }
}

public struct DisassociateRecoveryPointFromParentInput: Swift.Equatable {
    /// This is the name of a logical container where the child (nested) recovery point is stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// This is the Amazon Resource Name (ARN) that uniquely identifies the child (nested) recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct DisassociateRecoveryPointFromParentInputBody: Swift.Equatable {
}

extension DisassociateRecoveryPointFromParentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateRecoveryPointFromParentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateRecoveryPointFromParentOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateRecoveryPointFromParentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateRecoveryPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())/disassociate"
    }
}

public struct DisassociateRecoveryPointInput: Swift.Equatable {
    /// The unique name of an Backup vault.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies an Backup recovery point.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct DisassociateRecoveryPointInputBody: Swift.Equatable {
}

extension DisassociateRecoveryPointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateRecoveryPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateRecoveryPointOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateRecoveryPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExportBackupPlanTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/toTemplate"
    }
}

public struct ExportBackupPlanTemplateInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
    }
}

struct ExportBackupPlanTemplateInputBody: Swift.Equatable {
}

extension ExportBackupPlanTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ExportBackupPlanTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportBackupPlanTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanTemplateJson = output.backupPlanTemplateJson
        } else {
            self.backupPlanTemplateJson = nil
        }
    }
}

public struct ExportBackupPlanTemplateOutput: Swift.Equatable {
    /// The body of a backup plan template in JSON format. This is a signed JSON document that cannot be modified before being passed to GetBackupPlanFromJSON.
    public var backupPlanTemplateJson: Swift.String?

    public init(
        backupPlanTemplateJson: Swift.String? = nil
    )
    {
        self.backupPlanTemplateJson = backupPlanTemplateJson
    }
}

struct ExportBackupPlanTemplateOutputBody: Swift.Equatable {
    let backupPlanTemplateJson: Swift.String?
}

extension ExportBackupPlanTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplateJson = "BackupPlanTemplateJson"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanTemplateJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanTemplateJson)
        backupPlanTemplateJson = backupPlanTemplateJsonDecoded
    }
}

enum ExportBackupPlanTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BackupClientTypes.Framework: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case deploymentStatus = "DeploymentStatus"
        case frameworkArn = "FrameworkArn"
        case frameworkDescription = "FrameworkDescription"
        case frameworkName = "FrameworkName"
        case numberOfControls = "NumberOfControls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus, forKey: .deploymentStatus)
        }
        if let frameworkArn = self.frameworkArn {
            try encodeContainer.encode(frameworkArn, forKey: .frameworkArn)
        }
        if let frameworkDescription = self.frameworkDescription {
            try encodeContainer.encode(frameworkDescription, forKey: .frameworkDescription)
        }
        if let frameworkName = self.frameworkName {
            try encodeContainer.encode(frameworkName, forKey: .frameworkName)
        }
        if numberOfControls != 0 {
            try encodeContainer.encode(numberOfControls, forKey: .numberOfControls)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkArn)
        frameworkArn = frameworkArnDecoded
        let frameworkDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkDescription)
        frameworkDescription = frameworkDescriptionDecoded
        let numberOfControlsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfControls) ?? 0
        numberOfControls = numberOfControlsDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about a framework. Frameworks contain controls, which evaluate and report on your backup events and resources. Frameworks generate daily compliance results.
    public struct Framework: Swift.Equatable {
        /// The date and time that a framework is created, in ISO 8601 representation. The value of CreationTime is accurate to milliseconds. For example, 2020-07-10T15:00:00.000-08:00 represents the 10th of July 2020 at 3:00 PM 8 hours behind UTC.
        public var creationTime: ClientRuntime.Date?
        /// The deployment status of a framework. The statuses are: CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED | FAILED
        public var deploymentStatus: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var frameworkArn: Swift.String?
        /// An optional description of the framework with a maximum 1,024 characters.
        public var frameworkDescription: Swift.String?
        /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public var frameworkName: Swift.String?
        /// The number of controls contained by the framework.
        public var numberOfControls: Swift.Int

        public init(
            creationTime: ClientRuntime.Date? = nil,
            deploymentStatus: Swift.String? = nil,
            frameworkArn: Swift.String? = nil,
            frameworkDescription: Swift.String? = nil,
            frameworkName: Swift.String? = nil,
            numberOfControls: Swift.Int = 0
        )
        {
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.frameworkArn = frameworkArn
            self.frameworkDescription = frameworkDescription
            self.frameworkName = frameworkName
            self.numberOfControls = numberOfControls
        }
    }

}

extension BackupClientTypes.FrameworkControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlInputParameters = "ControlInputParameters"
        case controlName = "ControlName"
        case controlScope = "ControlScope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlInputParameters = controlInputParameters {
            var controlInputParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlInputParameters)
            for controlinputparameter0 in controlInputParameters {
                try controlInputParametersContainer.encode(controlinputparameter0)
            }
        }
        if let controlName = self.controlName {
            try encodeContainer.encode(controlName, forKey: .controlName)
        }
        if let controlScope = self.controlScope {
            try encodeContainer.encode(controlScope, forKey: .controlScope)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlName)
        controlName = controlNameDecoded
        let controlInputParametersContainer = try containerValues.decodeIfPresent([BackupClientTypes.ControlInputParameter?].self, forKey: .controlInputParameters)
        var controlInputParametersDecoded0:[BackupClientTypes.ControlInputParameter]? = nil
        if let controlInputParametersContainer = controlInputParametersContainer {
            controlInputParametersDecoded0 = [BackupClientTypes.ControlInputParameter]()
            for structure0 in controlInputParametersContainer {
                if let structure0 = structure0 {
                    controlInputParametersDecoded0?.append(structure0)
                }
            }
        }
        controlInputParameters = controlInputParametersDecoded0
        let controlScopeDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ControlScope.self, forKey: .controlScope)
        controlScope = controlScopeDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about all of the controls of a framework. Each framework must contain at least one control.
    public struct FrameworkControl: Swift.Equatable {
        /// A list of ParameterName and ParameterValue pairs.
        public var controlInputParameters: [BackupClientTypes.ControlInputParameter]?
        /// The name of a control. This name is between 1 and 256 characters.
        /// This member is required.
        public var controlName: Swift.String?
        /// The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans.
        public var controlScope: BackupClientTypes.ControlScope?

        public init(
            controlInputParameters: [BackupClientTypes.ControlInputParameter]? = nil,
            controlName: Swift.String? = nil,
            controlScope: BackupClientTypes.ControlScope? = nil
        )
        {
            self.controlInputParameters = controlInputParameters
            self.controlName = controlName
            self.controlScope = controlScope
        }
    }

}

extension GetBackupPlanFromJSONInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplateJson = "BackupPlanTemplateJson"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanTemplateJson = self.backupPlanTemplateJson {
            try encodeContainer.encode(backupPlanTemplateJson, forKey: .backupPlanTemplateJson)
        }
    }
}

extension GetBackupPlanFromJSONInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backup/template/json/toPlan"
    }
}

public struct GetBackupPlanFromJSONInput: Swift.Equatable {
    /// A customer-supplied backup plan document in JSON format.
    /// This member is required.
    public var backupPlanTemplateJson: Swift.String?

    public init(
        backupPlanTemplateJson: Swift.String? = nil
    )
    {
        self.backupPlanTemplateJson = backupPlanTemplateJson
    }
}

struct GetBackupPlanFromJSONInputBody: Swift.Equatable {
    let backupPlanTemplateJson: Swift.String?
}

extension GetBackupPlanFromJSONInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplateJson = "BackupPlanTemplateJson"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanTemplateJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanTemplateJson)
        backupPlanTemplateJson = backupPlanTemplateJsonDecoded
    }
}

extension GetBackupPlanFromJSONOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBackupPlanFromJSONOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupPlan = output.backupPlan
        } else {
            self.backupPlan = nil
        }
    }
}

public struct GetBackupPlanFromJSONOutput: Swift.Equatable {
    /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    public var backupPlan: BackupClientTypes.BackupPlan?

    public init(
        backupPlan: BackupClientTypes.BackupPlan? = nil
    )
    {
        self.backupPlan = backupPlan
    }
}

struct GetBackupPlanFromJSONOutputBody: Swift.Equatable {
    let backupPlan: BackupClientTypes.BackupPlan?
}

extension GetBackupPlanFromJSONOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlan.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
    }
}

enum GetBackupPlanFromJSONOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBackupPlanFromTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanTemplateId = backupPlanTemplateId else {
            return nil
        }
        return "/backup/template/plans/\(backupPlanTemplateId.urlPercentEncoding())/toPlan"
    }
}

public struct GetBackupPlanFromTemplateInput: Swift.Equatable {
    /// Uniquely identifies a stored backup plan template.
    /// This member is required.
    public var backupPlanTemplateId: Swift.String?

    public init(
        backupPlanTemplateId: Swift.String? = nil
    )
    {
        self.backupPlanTemplateId = backupPlanTemplateId
    }
}

struct GetBackupPlanFromTemplateInputBody: Swift.Equatable {
}

extension GetBackupPlanFromTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupPlanFromTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBackupPlanFromTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanDocument = output.backupPlanDocument
        } else {
            self.backupPlanDocument = nil
        }
    }
}

public struct GetBackupPlanFromTemplateOutput: Swift.Equatable {
    /// Returns the body of a backup plan based on the target template, including the name, rules, and backup vault of the plan.
    public var backupPlanDocument: BackupClientTypes.BackupPlan?

    public init(
        backupPlanDocument: BackupClientTypes.BackupPlan? = nil
    )
    {
        self.backupPlanDocument = backupPlanDocument
    }
}

struct GetBackupPlanFromTemplateOutputBody: Swift.Equatable {
    let backupPlanDocument: BackupClientTypes.BackupPlan?
}

extension GetBackupPlanFromTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanDocument = "BackupPlanDocument"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDocumentDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlan.self, forKey: .backupPlanDocument)
        backupPlanDocument = backupPlanDocumentDecoded
    }
}

enum GetBackupPlanFromTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBackupPlanInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let versionId = versionId {
                let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
                items.append(versionIdQueryItem)
            }
            return items
        }
    }
}

extension GetBackupPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())"
    }
}

public struct GetBackupPlanInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
    public var versionId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.versionId = versionId
    }
}

struct GetBackupPlanInputBody: Swift.Equatable {
}

extension GetBackupPlanInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBackupPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.advancedBackupSettings = output.advancedBackupSettings
            self.backupPlan = output.backupPlan
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.creatorRequestId = output.creatorRequestId
            self.deletionDate = output.deletionDate
            self.lastExecutionDate = output.lastExecutionDate
            self.versionId = output.versionId
        } else {
            self.advancedBackupSettings = nil
            self.backupPlan = nil
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.creationDate = nil
            self.creatorRequestId = nil
            self.deletionDate = nil
            self.lastExecutionDate = nil
            self.versionId = nil
        }
    }
}

public struct GetBackupPlanOutput: Swift.Equatable {
    /// Contains a list of BackupOptions for each resource type. The list is populated only if the advanced option is set for the backup plan.
    public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
    /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    public var backupPlan: BackupClientTypes.BackupPlan?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time that a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
    public var creatorRequestId: Swift.String?
    /// The date and time that a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var deletionDate: ClientRuntime.Date?
    /// The last time a job to back up resources was run with this backup plan. A date and time, in Unix format and Coordinated Universal Time (UTC). The value of LastExecutionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastExecutionDate: ClientRuntime.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
    public var versionId: Swift.String?

    public init(
        advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
        backupPlan: BackupClientTypes.BackupPlan? = nil,
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        creatorRequestId: Swift.String? = nil,
        deletionDate: ClientRuntime.Date? = nil,
        lastExecutionDate: ClientRuntime.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlan = backupPlan
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.deletionDate = deletionDate
        self.lastExecutionDate = lastExecutionDate
        self.versionId = versionId
    }
}

struct GetBackupPlanOutputBody: Swift.Equatable {
    let backupPlan: BackupClientTypes.BackupPlan?
    let backupPlanId: Swift.String?
    let backupPlanArn: Swift.String?
    let versionId: Swift.String?
    let creatorRequestId: Swift.String?
    let creationDate: ClientRuntime.Date?
    let deletionDate: ClientRuntime.Date?
    let lastExecutionDate: ClientRuntime.Date?
    let advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
}

extension GetBackupPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlan = "BackupPlan"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case deletionDate = "DeletionDate"
        case lastExecutionDate = "LastExecutionDate"
        case versionId = "VersionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlan.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let deletionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
        let lastExecutionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

enum GetBackupPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBackupSelectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        guard let selectionId = selectionId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections/\(selectionId.urlPercentEncoding())"
    }
}

public struct GetBackupSelectionInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    /// This member is required.
    public var selectionId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.selectionId = selectionId
    }
}

struct GetBackupSelectionInputBody: Swift.Equatable {
}

extension GetBackupSelectionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupSelectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBackupSelectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanId = output.backupPlanId
            self.backupSelection = output.backupSelection
            self.creationDate = output.creationDate
            self.creatorRequestId = output.creatorRequestId
            self.selectionId = output.selectionId
        } else {
            self.backupPlanId = nil
            self.backupSelection = nil
            self.creationDate = nil
            self.creatorRequestId = nil
            self.selectionId = nil
        }
    }
}

public struct GetBackupSelectionOutput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// Specifies the body of a request to assign a set of resources to a backup plan.
    public var backupSelection: BackupClientTypes.BackupSelection?
    /// The date and time a backup selection is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
    public var creatorRequestId: Swift.String?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    public var selectionId: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        backupSelection: BackupClientTypes.BackupSelection? = nil,
        creationDate: ClientRuntime.Date? = nil,
        creatorRequestId: Swift.String? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.backupSelection = backupSelection
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.selectionId = selectionId
    }
}

struct GetBackupSelectionOutputBody: Swift.Equatable {
    let backupSelection: BackupClientTypes.BackupSelection?
    let selectionId: Swift.String?
    let backupPlanId: Swift.String?
    let creationDate: ClientRuntime.Date?
    let creatorRequestId: Swift.String?
}

extension GetBackupSelectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanId = "BackupPlanId"
        case backupSelection = "BackupSelection"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case selectionId = "SelectionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupSelectionDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupSelection.self, forKey: .backupSelection)
        backupSelection = backupSelectionDecoded
        let selectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionId)
        selectionId = selectionIdDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

enum GetBackupSelectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBackupVaultAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/access-policy"
    }
}

public struct GetBackupVaultAccessPolicyInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct GetBackupVaultAccessPolicyInputBody: Swift.Equatable {
}

extension GetBackupVaultAccessPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupVaultAccessPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBackupVaultAccessPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.policy = output.policy
        } else {
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.policy = nil
        }
    }
}

public struct GetBackupVaultAccessPolicyOutput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// The backup vault access policy document in JSON format.
    public var policy: Swift.String?

    public init(
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.policy = policy
    }
}

struct GetBackupVaultAccessPolicyOutputBody: Swift.Equatable {
    let backupVaultName: Swift.String?
    let backupVaultArn: Swift.String?
    let policy: Swift.String?
}

extension GetBackupVaultAccessPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetBackupVaultAccessPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBackupVaultNotificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/notification-configuration"
    }
}

public struct GetBackupVaultNotificationsInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct GetBackupVaultNotificationsInputBody: Swift.Equatable {
}

extension GetBackupVaultNotificationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupVaultNotificationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBackupVaultNotificationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultEvents = output.backupVaultEvents
            self.backupVaultName = output.backupVaultName
            self.snsTopicArn = output.snsTopicArn
        } else {
            self.backupVaultArn = nil
            self.backupVaultEvents = nil
            self.backupVaultName = nil
            self.snsTopicArn = nil
        }
    }
}

public struct GetBackupVaultNotificationsOutput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// An array of events that indicate the status of jobs to back up resources to the backup vault.
    public var backupVaultEvents: [BackupClientTypes.BackupVaultEvent]?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// An ARN that uniquely identifies an Amazon Simple Notification Service (Amazon SNS) topic; for example, arn:aws:sns:us-west-2:111122223333:MyTopic.
    public var snsTopicArn: Swift.String?

    public init(
        backupVaultArn: Swift.String? = nil,
        backupVaultEvents: [BackupClientTypes.BackupVaultEvent]? = nil,
        backupVaultName: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultEvents = backupVaultEvents
        self.backupVaultName = backupVaultName
        self.snsTopicArn = snsTopicArn
    }
}

struct GetBackupVaultNotificationsOutputBody: Swift.Equatable {
    let backupVaultName: Swift.String?
    let backupVaultArn: Swift.String?
    let snsTopicArn: Swift.String?
    let backupVaultEvents: [BackupClientTypes.BackupVaultEvent]?
}

extension GetBackupVaultNotificationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultEvents = "BackupVaultEvents"
        case backupVaultName = "BackupVaultName"
        case snsTopicArn = "SNSTopicArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let backupVaultEventsContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupVaultEvent?].self, forKey: .backupVaultEvents)
        var backupVaultEventsDecoded0:[BackupClientTypes.BackupVaultEvent]? = nil
        if let backupVaultEventsContainer = backupVaultEventsContainer {
            backupVaultEventsDecoded0 = [BackupClientTypes.BackupVaultEvent]()
            for enum0 in backupVaultEventsContainer {
                if let enum0 = enum0 {
                    backupVaultEventsDecoded0?.append(enum0)
                }
            }
        }
        backupVaultEvents = backupVaultEventsDecoded0
    }
}

enum GetBackupVaultNotificationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLegalHoldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let legalHoldId = legalHoldId else {
            return nil
        }
        return "/legal-holds/\(legalHoldId.urlPercentEncoding())"
    }
}

public struct GetLegalHoldInput: Swift.Equatable {
    /// This is the ID required to use GetLegalHold. This unique ID is associated with a specific legal hold.
    /// This member is required.
    public var legalHoldId: Swift.String?

    public init(
        legalHoldId: Swift.String? = nil
    )
    {
        self.legalHoldId = legalHoldId
    }
}

struct GetLegalHoldInputBody: Swift.Equatable {
}

extension GetLegalHoldInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLegalHoldOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLegalHoldOutputBody = try responseDecoder.decode(responseBody: data)
            self.cancelDescription = output.cancelDescription
            self.cancellationDate = output.cancellationDate
            self.creationDate = output.creationDate
            self.description = output.description
            self.legalHoldArn = output.legalHoldArn
            self.legalHoldId = output.legalHoldId
            self.recoveryPointSelection = output.recoveryPointSelection
            self.retainRecordUntil = output.retainRecordUntil
            self.status = output.status
            self.title = output.title
        } else {
            self.cancelDescription = nil
            self.cancellationDate = nil
            self.creationDate = nil
            self.description = nil
            self.legalHoldArn = nil
            self.legalHoldId = nil
            self.recoveryPointSelection = nil
            self.retainRecordUntil = nil
            self.status = nil
            self.title = nil
        }
    }
}

public struct GetLegalHoldOutput: Swift.Equatable {
    /// String describing the reason for removing the legal hold.
    public var cancelDescription: Swift.String?
    /// Time in number when legal hold was cancelled.
    public var cancellationDate: ClientRuntime.Date?
    /// Time in number format when legal hold was created.
    public var creationDate: ClientRuntime.Date?
    /// This is the returned string description of the legal hold.
    public var description: Swift.String?
    /// This is the returned framework ARN for the specified legal hold. An Amazon Resource Name (ARN) uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var legalHoldArn: Swift.String?
    /// This is the returned ID associated with a specified legal hold.
    public var legalHoldId: Swift.String?
    /// This specifies criteria to assign a set of resources, such as resource types or backup vaults.
    public var recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
    /// This is the date and time until which the legal hold record will be retained.
    public var retainRecordUntil: ClientRuntime.Date?
    /// This is the status of the legal hold. Statuses can be ACTIVE, CREATING, CANCELED, and CANCELING.
    public var status: BackupClientTypes.LegalHoldStatus?
    /// This is the string title of the legal hold.
    public var title: Swift.String?

    public init(
        cancelDescription: Swift.String? = nil,
        cancellationDate: ClientRuntime.Date? = nil,
        creationDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        legalHoldArn: Swift.String? = nil,
        legalHoldId: Swift.String? = nil,
        recoveryPointSelection: BackupClientTypes.RecoveryPointSelection? = nil,
        retainRecordUntil: ClientRuntime.Date? = nil,
        status: BackupClientTypes.LegalHoldStatus? = nil,
        title: Swift.String? = nil
    )
    {
        self.cancelDescription = cancelDescription
        self.cancellationDate = cancellationDate
        self.creationDate = creationDate
        self.description = description
        self.legalHoldArn = legalHoldArn
        self.legalHoldId = legalHoldId
        self.recoveryPointSelection = recoveryPointSelection
        self.retainRecordUntil = retainRecordUntil
        self.status = status
        self.title = title
    }
}

struct GetLegalHoldOutputBody: Swift.Equatable {
    let title: Swift.String?
    let status: BackupClientTypes.LegalHoldStatus?
    let description: Swift.String?
    let cancelDescription: Swift.String?
    let legalHoldId: Swift.String?
    let legalHoldArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let cancellationDate: ClientRuntime.Date?
    let retainRecordUntil: ClientRuntime.Date?
    let recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
}

extension GetLegalHoldOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancelDescription = "CancelDescription"
        case cancellationDate = "CancellationDate"
        case creationDate = "CreationDate"
        case description = "Description"
        case legalHoldArn = "LegalHoldArn"
        case legalHoldId = "LegalHoldId"
        case recoveryPointSelection = "RecoveryPointSelection"
        case retainRecordUntil = "RetainRecordUntil"
        case status = "Status"
        case title = "Title"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.LegalHoldStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cancelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cancelDescription)
        cancelDescription = cancelDescriptionDecoded
        let legalHoldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .legalHoldId)
        legalHoldId = legalHoldIdDecoded
        let legalHoldArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .legalHoldArn)
        legalHoldArn = legalHoldArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let cancellationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .cancellationDate)
        cancellationDate = cancellationDateDecoded
        let retainRecordUntilDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .retainRecordUntil)
        retainRecordUntil = retainRecordUntilDecoded
        let recoveryPointSelectionDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointSelection.self, forKey: .recoveryPointSelection)
        recoveryPointSelection = recoveryPointSelectionDecoded
    }
}

enum GetLegalHoldOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRecoveryPointRestoreMetadataInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let backupVaultAccountId = backupVaultAccountId {
                let backupVaultAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "backupVaultAccountId".urlPercentEncoding(), value: Swift.String(backupVaultAccountId).urlPercentEncoding())
                items.append(backupVaultAccountIdQueryItem)
            }
            return items
        }
    }
}

extension GetRecoveryPointRestoreMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())/restore-metadata"
    }
}

public struct GetRecoveryPointRestoreMetadataInput: Swift.Equatable {
    /// This is the account ID of the specified backup vault.
    public var backupVaultAccountId: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultAccountId: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultAccountId = backupVaultAccountId
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct GetRecoveryPointRestoreMetadataInputBody: Swift.Equatable {
}

extension GetRecoveryPointRestoreMetadataInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRecoveryPointRestoreMetadataOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecoveryPointRestoreMetadataOutput(backupVaultArn: \(Swift.String(describing: backupVaultArn)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), restoreMetadata: \"CONTENT_REDACTED\")"}
}

extension GetRecoveryPointRestoreMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRecoveryPointRestoreMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.recoveryPointArn = output.recoveryPointArn
            self.restoreMetadata = output.restoreMetadata
        } else {
            self.backupVaultArn = nil
            self.recoveryPointArn = nil
            self.restoreMetadata = nil
        }
    }
}

public struct GetRecoveryPointRestoreMetadataOutput: Swift.Equatable {
    /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// The set of metadata key-value pairs that describe the original configuration of the backed-up resource. These values vary depending on the service that is being restored.
    public var restoreMetadata: [Swift.String:Swift.String]?

    public init(
        backupVaultArn: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        restoreMetadata: [Swift.String:Swift.String]? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.recoveryPointArn = recoveryPointArn
        self.restoreMetadata = restoreMetadata
    }
}

struct GetRecoveryPointRestoreMetadataOutputBody: Swift.Equatable {
    let backupVaultArn: Swift.String?
    let recoveryPointArn: Swift.String?
    let restoreMetadata: [Swift.String:Swift.String]?
}

extension GetRecoveryPointRestoreMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case recoveryPointArn = "RecoveryPointArn"
        case restoreMetadata = "RestoreMetadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let restoreMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .restoreMetadata)
        var restoreMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let restoreMetadataContainer = restoreMetadataContainer {
            restoreMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, metadatavalue0) in restoreMetadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    restoreMetadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        restoreMetadata = restoreMetadataDecoded0
    }
}

enum GetRecoveryPointRestoreMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSupportedResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/supported-resource-types"
    }
}

public struct GetSupportedResourceTypesInput: Swift.Equatable {

    public init() { }
}

struct GetSupportedResourceTypesInputBody: Swift.Equatable {
}

extension GetSupportedResourceTypesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSupportedResourceTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSupportedResourceTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceTypes = output.resourceTypes
        } else {
            self.resourceTypes = nil
        }
    }
}

public struct GetSupportedResourceTypesOutput: Swift.Equatable {
    /// Contains a string with the supported Amazon Web Services resource types:
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * FSX for Amazon FSx
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Storage Gateway for Storage Gateway
    ///
    /// * DocDB for Amazon DocumentDB (with MongoDB compatibility)
    ///
    /// * Neptune for Amazon Neptune
    public var resourceTypes: [Swift.String]?

    public init(
        resourceTypes: [Swift.String]? = nil
    )
    {
        self.resourceTypes = resourceTypes
    }
}

struct GetSupportedResourceTypesOutputBody: Swift.Equatable {
    let resourceTypes: [Swift.String]?
}

extension GetSupportedResourceTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTypes = "ResourceTypes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
    }
}

enum GetSupportedResourceTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InvalidParameterValueException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that something is wrong with a parameter's value. For example, the value is out of range.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValueException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that something is wrong with the input to the request. For example, a parameter is of the wrong type.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension InvalidResourceStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Backup is already performing an action on this recovery point. It can't perform the action you requested until the first action finishes. Try again later.
public struct InvalidResourceStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

struct InvalidResourceStateExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension InvalidResourceStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes.LegalHold: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancellationDate = "CancellationDate"
        case creationDate = "CreationDate"
        case description = "Description"
        case legalHoldArn = "LegalHoldArn"
        case legalHoldId = "LegalHoldId"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cancellationDate = self.cancellationDate {
            try encodeContainer.encodeTimestamp(cancellationDate, format: .epochSeconds, forKey: .cancellationDate)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let legalHoldArn = self.legalHoldArn {
            try encodeContainer.encode(legalHoldArn, forKey: .legalHoldArn)
        }
        if let legalHoldId = self.legalHoldId {
            try encodeContainer.encode(legalHoldId, forKey: .legalHoldId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.LegalHoldStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let legalHoldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .legalHoldId)
        legalHoldId = legalHoldIdDecoded
        let legalHoldArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .legalHoldArn)
        legalHoldArn = legalHoldArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let cancellationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .cancellationDate)
        cancellationDate = cancellationDateDecoded
    }
}

extension BackupClientTypes {
    /// A legal hold is an administrative tool that helps prevent backups from being deleted while under a hold. While the hold is in place, backups under a hold cannot be deleted and lifecycle policies that would alter the backup status (such as transition to cold storage) are delayed until the legal hold is removed. A backup can have more than one legal hold. Legal holds are applied to one or more backups (also known as recovery points). These backups can be filtered by resource types and by resource IDs.
    public struct LegalHold: Swift.Equatable {
        /// This is the time in number format when legal hold was cancelled.
        public var cancellationDate: ClientRuntime.Date?
        /// This is the time in number format when legal hold was created.
        public var creationDate: ClientRuntime.Date?
        /// This is the description of a legal hold.
        public var description: Swift.String?
        /// This is an Amazon Resource Number (ARN) that uniquely identifies the legal hold; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var legalHoldArn: Swift.String?
        /// ID of specific legal hold on one or more recovery points.
        public var legalHoldId: Swift.String?
        /// This is the status of the legal hold. Statuses can be ACTIVE, CREATING, CANCELED, and CANCELING.
        public var status: BackupClientTypes.LegalHoldStatus?
        /// This is the title of a legal hold.
        public var title: Swift.String?

        public init(
            cancellationDate: ClientRuntime.Date? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            legalHoldArn: Swift.String? = nil,
            legalHoldId: Swift.String? = nil,
            status: BackupClientTypes.LegalHoldStatus? = nil,
            title: Swift.String? = nil
        )
        {
            self.cancellationDate = cancellationDate
            self.creationDate = creationDate
            self.description = description
            self.legalHoldArn = legalHoldArn
            self.legalHoldId = legalHoldId
            self.status = status
            self.title = title
        }
    }

}

extension BackupClientTypes {
    public enum LegalHoldStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case canceled
        case canceling
        case creating
        case sdkUnknown(Swift.String)

        public static var allCases: [LegalHoldStatus] {
            return [
                .active,
                .canceled,
                .canceling,
                .creating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .canceling: return "CANCELING"
            case .creating: return "CREATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LegalHoldStatus(rawValue: rawValue) ?? LegalHoldStatus.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.Lifecycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAfterDays = "DeleteAfterDays"
        case moveToColdStorageAfterDays = "MoveToColdStorageAfterDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteAfterDays = self.deleteAfterDays {
            try encodeContainer.encode(deleteAfterDays, forKey: .deleteAfterDays)
        }
        if let moveToColdStorageAfterDays = self.moveToColdStorageAfterDays {
            try encodeContainer.encode(moveToColdStorageAfterDays, forKey: .moveToColdStorageAfterDays)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moveToColdStorageAfterDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .moveToColdStorageAfterDays)
        moveToColdStorageAfterDays = moveToColdStorageAfterDaysDecoded
        let deleteAfterDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deleteAfterDays)
        deleteAfterDays = deleteAfterDaysDecoded
    }
}

extension BackupClientTypes {
    /// Contains an array of Transition objects specifying how long in days before a recovery point transitions to cold storage or is deleted. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the retention setting must be 90 days greater than the transition to cold after days setting. The transition to cold after days setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
    public struct Lifecycle: Swift.Equatable {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater than 90 days plus MoveToColdStorageAfterDays.
        public var deleteAfterDays: Swift.Int?
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public var moveToColdStorageAfterDays: Swift.Int?

        public init(
            deleteAfterDays: Swift.Int? = nil,
            moveToColdStorageAfterDays: Swift.Int? = nil
        )
        {
            self.deleteAfterDays = deleteAfterDays
            self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A limit in the request has been exceeded; for example, a maximum number of items allowed in a request.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension ListBackupJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let byCreatedBefore = byCreatedBefore {
                let byCreatedBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedBefore)).urlPercentEncoding())
                items.append(byCreatedBeforeQueryItem)
            }
            if let byResourceType = byResourceType {
                let byResourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(byResourceType).urlPercentEncoding())
                items.append(byResourceTypeQueryItem)
            }
            if let byBackupVaultName = byBackupVaultName {
                let byBackupVaultNameQueryItem = ClientRuntime.URLQueryItem(name: "backupVaultName".urlPercentEncoding(), value: Swift.String(byBackupVaultName).urlPercentEncoding())
                items.append(byBackupVaultNameQueryItem)
            }
            if let byCompleteAfter = byCompleteAfter {
                let byCompleteAfterQueryItem = ClientRuntime.URLQueryItem(name: "completeAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCompleteAfter)).urlPercentEncoding())
                items.append(byCompleteAfterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let byResourceArn = byResourceArn {
                let byResourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(byResourceArn).urlPercentEncoding())
                items.append(byResourceArnQueryItem)
            }
            if let byParentJobId = byParentJobId {
                let byParentJobIdQueryItem = ClientRuntime.URLQueryItem(name: "parentJobId".urlPercentEncoding(), value: Swift.String(byParentJobId).urlPercentEncoding())
                items.append(byParentJobIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let byState = byState {
                let byStateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(byState.rawValue).urlPercentEncoding())
                items.append(byStateQueryItem)
            }
            if let byAccountId = byAccountId {
                let byAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(byAccountId).urlPercentEncoding())
                items.append(byAccountIdQueryItem)
            }
            if let byCompleteBefore = byCompleteBefore {
                let byCompleteBeforeQueryItem = ClientRuntime.URLQueryItem(name: "completeBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCompleteBefore)).urlPercentEncoding())
                items.append(byCompleteBeforeQueryItem)
            }
            if let byCreatedAfter = byCreatedAfter {
                let byCreatedAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedAfter)).urlPercentEncoding())
                items.append(byCreatedAfterQueryItem)
            }
            return items
        }
    }
}

extension ListBackupJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backup-jobs"
    }
}

public struct ListBackupJobsInput: Swift.Equatable {
    /// The account ID to list the jobs from. Returns only backup jobs associated with the specified account ID. If used from an Organizations management account, passing * returns all jobs across the organization.
    public var byAccountId: Swift.String?
    /// Returns only backup jobs that will be stored in the specified backup vault. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var byBackupVaultName: Swift.String?
    /// Returns only backup jobs completed after a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteAfter: ClientRuntime.Date?
    /// Returns only backup jobs completed before a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteBefore: ClientRuntime.Date?
    /// Returns only backup jobs that were created after the specified date.
    public var byCreatedAfter: ClientRuntime.Date?
    /// Returns only backup jobs that were created before the specified date.
    public var byCreatedBefore: ClientRuntime.Date?
    /// This is a filter to list child (nested) jobs based on parent job ID.
    public var byParentJobId: Swift.String?
    /// Returns only backup jobs that match the specified resource Amazon Resource Name (ARN).
    public var byResourceArn: Swift.String?
    /// Returns only backup jobs for the specified resources:
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * DocumentDB for Amazon DocumentDB (with MongoDB compatibility)
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * FSx for Amazon FSx
    ///
    /// * Neptune for Amazon Neptune
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Storage Gateway for Storage Gateway
    ///
    /// * S3 for Amazon S3
    ///
    /// * VirtualMachine for virtual machines
    public var byResourceType: Swift.String?
    /// Returns only backup jobs that are in the specified state.
    public var byState: BackupClientTypes.BackupJobState?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        byAccountId: Swift.String? = nil,
        byBackupVaultName: Swift.String? = nil,
        byCompleteAfter: ClientRuntime.Date? = nil,
        byCompleteBefore: ClientRuntime.Date? = nil,
        byCreatedAfter: ClientRuntime.Date? = nil,
        byCreatedBefore: ClientRuntime.Date? = nil,
        byParentJobId: Swift.String? = nil,
        byResourceArn: Swift.String? = nil,
        byResourceType: Swift.String? = nil,
        byState: BackupClientTypes.BackupJobState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byBackupVaultName = byBackupVaultName
        self.byCompleteAfter = byCompleteAfter
        self.byCompleteBefore = byCompleteBefore
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byParentJobId = byParentJobId
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.byState = byState
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupJobsInputBody: Swift.Equatable {
}

extension ListBackupJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBackupJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupJobs = output.backupJobs
            self.nextToken = output.nextToken
        } else {
            self.backupJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupJobsOutput: Swift.Equatable {
    /// An array of structures containing metadata about your backup jobs returned in JSON format.
    public var backupJobs: [BackupClientTypes.BackupJob]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupJobs: [BackupClientTypes.BackupJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupJobs = backupJobs
        self.nextToken = nextToken
    }
}

struct ListBackupJobsOutputBody: Swift.Equatable {
    let backupJobs: [BackupClientTypes.BackupJob]?
    let nextToken: Swift.String?
}

extension ListBackupJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupJobs = "BackupJobs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupJobsContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupJob?].self, forKey: .backupJobs)
        var backupJobsDecoded0:[BackupClientTypes.BackupJob]? = nil
        if let backupJobsContainer = backupJobsContainer {
            backupJobsDecoded0 = [BackupClientTypes.BackupJob]()
            for structure0 in backupJobsContainer {
                if let structure0 = structure0 {
                    backupJobsDecoded0?.append(structure0)
                }
            }
        }
        backupJobs = backupJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBackupJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBackupPlanTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBackupPlanTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backup/template/plans"
    }
}

public struct ListBackupPlanTemplatesInput: Swift.Equatable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupPlanTemplatesInputBody: Swift.Equatable {
}

extension ListBackupPlanTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupPlanTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBackupPlanTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanTemplatesList = output.backupPlanTemplatesList
            self.nextToken = output.nextToken
        } else {
            self.backupPlanTemplatesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupPlanTemplatesOutput: Swift.Equatable {
    /// An array of template list items containing metadata about your saved templates.
    public var backupPlanTemplatesList: [BackupClientTypes.BackupPlanTemplatesListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupPlanTemplatesList: [BackupClientTypes.BackupPlanTemplatesListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanTemplatesList = backupPlanTemplatesList
        self.nextToken = nextToken
    }
}

struct ListBackupPlanTemplatesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let backupPlanTemplatesList: [BackupClientTypes.BackupPlanTemplatesListMember]?
}

extension ListBackupPlanTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplatesList = "BackupPlanTemplatesList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupPlanTemplatesListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupPlanTemplatesListMember?].self, forKey: .backupPlanTemplatesList)
        var backupPlanTemplatesListDecoded0:[BackupClientTypes.BackupPlanTemplatesListMember]? = nil
        if let backupPlanTemplatesListContainer = backupPlanTemplatesListContainer {
            backupPlanTemplatesListDecoded0 = [BackupClientTypes.BackupPlanTemplatesListMember]()
            for structure0 in backupPlanTemplatesListContainer {
                if let structure0 = structure0 {
                    backupPlanTemplatesListDecoded0?.append(structure0)
                }
            }
        }
        backupPlanTemplatesList = backupPlanTemplatesListDecoded0
    }
}

enum ListBackupPlanTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBackupPlanVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBackupPlanVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/versions"
    }
}

public struct ListBackupPlanVersionsInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupPlanVersionsInputBody: Swift.Equatable {
}

extension ListBackupPlanVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupPlanVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBackupPlanVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanVersionsList = output.backupPlanVersionsList
            self.nextToken = output.nextToken
        } else {
            self.backupPlanVersionsList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupPlanVersionsOutput: Swift.Equatable {
    /// An array of version list items containing metadata about your backup plans.
    public var backupPlanVersionsList: [BackupClientTypes.BackupPlansListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupPlanVersionsList: [BackupClientTypes.BackupPlansListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanVersionsList = backupPlanVersionsList
        self.nextToken = nextToken
    }
}

struct ListBackupPlanVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let backupPlanVersionsList: [BackupClientTypes.BackupPlansListMember]?
}

extension ListBackupPlanVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanVersionsList = "BackupPlanVersionsList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupPlanVersionsListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupPlansListMember?].self, forKey: .backupPlanVersionsList)
        var backupPlanVersionsListDecoded0:[BackupClientTypes.BackupPlansListMember]? = nil
        if let backupPlanVersionsListContainer = backupPlanVersionsListContainer {
            backupPlanVersionsListDecoded0 = [BackupClientTypes.BackupPlansListMember]()
            for structure0 in backupPlanVersionsListContainer {
                if let structure0 = structure0 {
                    backupPlanVersionsListDecoded0?.append(structure0)
                }
            }
        }
        backupPlanVersionsList = backupPlanVersionsListDecoded0
    }
}

enum ListBackupPlanVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBackupPlansInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let includeDeleted = includeDeleted {
                let includeDeletedQueryItem = ClientRuntime.URLQueryItem(name: "includeDeleted".urlPercentEncoding(), value: Swift.String(includeDeleted).urlPercentEncoding())
                items.append(includeDeletedQueryItem)
            }
            return items
        }
    }
}

extension ListBackupPlansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backup/plans"
    }
}

public struct ListBackupPlansInput: Swift.Equatable {
    /// A Boolean value with a default value of FALSE that returns deleted backup plans when set to TRUE.
    public var includeDeleted: Swift.Bool?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        includeDeleted: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.includeDeleted = includeDeleted
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupPlansInputBody: Swift.Equatable {
}

extension ListBackupPlansInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupPlansOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBackupPlansOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupPlansList = output.backupPlansList
            self.nextToken = output.nextToken
        } else {
            self.backupPlansList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupPlansOutput: Swift.Equatable {
    /// An array of backup plan list items containing metadata about your saved backup plans.
    public var backupPlansList: [BackupClientTypes.BackupPlansListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupPlansList: [BackupClientTypes.BackupPlansListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlansList = backupPlansList
        self.nextToken = nextToken
    }
}

struct ListBackupPlansOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let backupPlansList: [BackupClientTypes.BackupPlansListMember]?
}

extension ListBackupPlansOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlansList = "BackupPlansList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupPlansListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupPlansListMember?].self, forKey: .backupPlansList)
        var backupPlansListDecoded0:[BackupClientTypes.BackupPlansListMember]? = nil
        if let backupPlansListContainer = backupPlansListContainer {
            backupPlansListDecoded0 = [BackupClientTypes.BackupPlansListMember]()
            for structure0 in backupPlansListContainer {
                if let structure0 = structure0 {
                    backupPlansListDecoded0?.append(structure0)
                }
            }
        }
        backupPlansList = backupPlansListDecoded0
    }
}

enum ListBackupPlansOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBackupSelectionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBackupSelectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections"
    }
}

public struct ListBackupSelectionsInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupPlanId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupSelectionsInputBody: Swift.Equatable {
}

extension ListBackupSelectionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupSelectionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBackupSelectionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupSelectionsList = output.backupSelectionsList
            self.nextToken = output.nextToken
        } else {
            self.backupSelectionsList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupSelectionsOutput: Swift.Equatable {
    /// An array of backup selection list items containing metadata about each resource in the list.
    public var backupSelectionsList: [BackupClientTypes.BackupSelectionsListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupSelectionsList: [BackupClientTypes.BackupSelectionsListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupSelectionsList = backupSelectionsList
        self.nextToken = nextToken
    }
}

struct ListBackupSelectionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let backupSelectionsList: [BackupClientTypes.BackupSelectionsListMember]?
}

extension ListBackupSelectionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSelectionsList = "BackupSelectionsList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupSelectionsListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupSelectionsListMember?].self, forKey: .backupSelectionsList)
        var backupSelectionsListDecoded0:[BackupClientTypes.BackupSelectionsListMember]? = nil
        if let backupSelectionsListContainer = backupSelectionsListContainer {
            backupSelectionsListDecoded0 = [BackupClientTypes.BackupSelectionsListMember]()
            for structure0 in backupSelectionsListContainer {
                if let structure0 = structure0 {
                    backupSelectionsListDecoded0?.append(structure0)
                }
            }
        }
        backupSelectionsList = backupSelectionsListDecoded0
    }
}

enum ListBackupSelectionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBackupVaultsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let byShared = byShared {
                let bySharedQueryItem = ClientRuntime.URLQueryItem(name: "shared".urlPercentEncoding(), value: Swift.String(byShared).urlPercentEncoding())
                items.append(bySharedQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let byVaultType = byVaultType {
                let byVaultTypeQueryItem = ClientRuntime.URLQueryItem(name: "vaultType".urlPercentEncoding(), value: Swift.String(byVaultType.rawValue).urlPercentEncoding())
                items.append(byVaultTypeQueryItem)
            }
            return items
        }
    }
}

extension ListBackupVaultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backup-vaults"
    }
}

public struct ListBackupVaultsInput: Swift.Equatable {
    /// This parameter will sort the list of vaults by shared vaults.
    public var byShared: Swift.Bool?
    /// This parameter will sort the list of vaults by vault type.
    public var byVaultType: BackupClientTypes.VaultType?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        byShared: Swift.Bool? = nil,
        byVaultType: BackupClientTypes.VaultType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byShared = byShared
        self.byVaultType = byVaultType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupVaultsInputBody: Swift.Equatable {
}

extension ListBackupVaultsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupVaultsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBackupVaultsOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultList = output.backupVaultList
            self.nextToken = output.nextToken
        } else {
            self.backupVaultList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupVaultsOutput: Swift.Equatable {
    /// An array of backup vault list members containing vault metadata, including Amazon Resource Name (ARN), display name, creation date, number of saved recovery points, and encryption information if the resources saved in the backup vault are encrypted.
    public var backupVaultList: [BackupClientTypes.BackupVaultListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupVaultList: [BackupClientTypes.BackupVaultListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupVaultList = backupVaultList
        self.nextToken = nextToken
    }
}

struct ListBackupVaultsOutputBody: Swift.Equatable {
    let backupVaultList: [BackupClientTypes.BackupVaultListMember]?
    let nextToken: Swift.String?
}

extension ListBackupVaultsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultList = "BackupVaultList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupVaultListMember?].self, forKey: .backupVaultList)
        var backupVaultListDecoded0:[BackupClientTypes.BackupVaultListMember]? = nil
        if let backupVaultListContainer = backupVaultListContainer {
            backupVaultListDecoded0 = [BackupClientTypes.BackupVaultListMember]()
            for structure0 in backupVaultListContainer {
                if let structure0 = structure0 {
                    backupVaultListDecoded0?.append(structure0)
                }
            }
        }
        backupVaultList = backupVaultListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBackupVaultsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCopyJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let byCreatedBefore = byCreatedBefore {
                let byCreatedBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedBefore)).urlPercentEncoding())
                items.append(byCreatedBeforeQueryItem)
            }
            if let byResourceType = byResourceType {
                let byResourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(byResourceType).urlPercentEncoding())
                items.append(byResourceTypeQueryItem)
            }
            if let byCompleteAfter = byCompleteAfter {
                let byCompleteAfterQueryItem = ClientRuntime.URLQueryItem(name: "completeAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCompleteAfter)).urlPercentEncoding())
                items.append(byCompleteAfterQueryItem)
            }
            if let byDestinationVaultArn = byDestinationVaultArn {
                let byDestinationVaultArnQueryItem = ClientRuntime.URLQueryItem(name: "destinationVaultArn".urlPercentEncoding(), value: Swift.String(byDestinationVaultArn).urlPercentEncoding())
                items.append(byDestinationVaultArnQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let byResourceArn = byResourceArn {
                let byResourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(byResourceArn).urlPercentEncoding())
                items.append(byResourceArnQueryItem)
            }
            if let byParentJobId = byParentJobId {
                let byParentJobIdQueryItem = ClientRuntime.URLQueryItem(name: "parentJobId".urlPercentEncoding(), value: Swift.String(byParentJobId).urlPercentEncoding())
                items.append(byParentJobIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let byState = byState {
                let byStateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(byState.rawValue).urlPercentEncoding())
                items.append(byStateQueryItem)
            }
            if let byAccountId = byAccountId {
                let byAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(byAccountId).urlPercentEncoding())
                items.append(byAccountIdQueryItem)
            }
            if let byCompleteBefore = byCompleteBefore {
                let byCompleteBeforeQueryItem = ClientRuntime.URLQueryItem(name: "completeBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCompleteBefore)).urlPercentEncoding())
                items.append(byCompleteBeforeQueryItem)
            }
            if let byCreatedAfter = byCreatedAfter {
                let byCreatedAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedAfter)).urlPercentEncoding())
                items.append(byCreatedAfterQueryItem)
            }
            return items
        }
    }
}

extension ListCopyJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/copy-jobs"
    }
}

public struct ListCopyJobsInput: Swift.Equatable {
    /// The account ID to list the jobs from. Returns only copy jobs associated with the specified account ID.
    public var byAccountId: Swift.String?
    /// Returns only copy jobs completed after a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteAfter: ClientRuntime.Date?
    /// Returns only copy jobs completed before a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteBefore: ClientRuntime.Date?
    /// Returns only copy jobs that were created after the specified date.
    public var byCreatedAfter: ClientRuntime.Date?
    /// Returns only copy jobs that were created before the specified date.
    public var byCreatedBefore: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a source backup vault to copy from; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var byDestinationVaultArn: Swift.String?
    /// This is a filter to list child (nested) jobs based on parent job ID.
    public var byParentJobId: Swift.String?
    /// Returns only copy jobs that match the specified resource Amazon Resource Name (ARN).
    public var byResourceArn: Swift.String?
    /// Returns only backup jobs for the specified resources:
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * DocumentDB for Amazon DocumentDB (with MongoDB compatibility)
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * FSx for Amazon FSx
    ///
    /// * Neptune for Amazon Neptune
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Storage Gateway for Storage Gateway
    ///
    /// * S3 for Amazon S3
    ///
    /// * VirtualMachine for virtual machines
    public var byResourceType: Swift.String?
    /// Returns only copy jobs that are in the specified state.
    public var byState: BackupClientTypes.CopyJobState?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        byAccountId: Swift.String? = nil,
        byCompleteAfter: ClientRuntime.Date? = nil,
        byCompleteBefore: ClientRuntime.Date? = nil,
        byCreatedAfter: ClientRuntime.Date? = nil,
        byCreatedBefore: ClientRuntime.Date? = nil,
        byDestinationVaultArn: Swift.String? = nil,
        byParentJobId: Swift.String? = nil,
        byResourceArn: Swift.String? = nil,
        byResourceType: Swift.String? = nil,
        byState: BackupClientTypes.CopyJobState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byCompleteAfter = byCompleteAfter
        self.byCompleteBefore = byCompleteBefore
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byDestinationVaultArn = byDestinationVaultArn
        self.byParentJobId = byParentJobId
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.byState = byState
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCopyJobsInputBody: Swift.Equatable {
}

extension ListCopyJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCopyJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCopyJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.copyJobs = output.copyJobs
            self.nextToken = output.nextToken
        } else {
            self.copyJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListCopyJobsOutput: Swift.Equatable {
    /// An array of structures containing metadata about your copy jobs returned in JSON format.
    public var copyJobs: [BackupClientTypes.CopyJob]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        copyJobs: [BackupClientTypes.CopyJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.copyJobs = copyJobs
        self.nextToken = nextToken
    }
}

struct ListCopyJobsOutputBody: Swift.Equatable {
    let copyJobs: [BackupClientTypes.CopyJob]?
    let nextToken: Swift.String?
}

extension ListCopyJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyJobs = "CopyJobs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyJobsContainer = try containerValues.decodeIfPresent([BackupClientTypes.CopyJob?].self, forKey: .copyJobs)
        var copyJobsDecoded0:[BackupClientTypes.CopyJob]? = nil
        if let copyJobsContainer = copyJobsContainer {
            copyJobsDecoded0 = [BackupClientTypes.CopyJob]()
            for structure0 in copyJobsContainer {
                if let structure0 = structure0 {
                    copyJobsDecoded0?.append(structure0)
                }
            }
        }
        copyJobs = copyJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCopyJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFrameworksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFrameworksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/frameworks"
    }
}

public struct ListFrameworksInput: Swift.Equatable {
    /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFrameworksInputBody: Swift.Equatable {
}

extension ListFrameworksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFrameworksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFrameworksOutputBody = try responseDecoder.decode(responseBody: data)
            self.frameworks = output.frameworks
            self.nextToken = output.nextToken
        } else {
            self.frameworks = nil
            self.nextToken = nil
        }
    }
}

public struct ListFrameworksOutput: Swift.Equatable {
    /// A list of frameworks with details for each framework, including the framework name, Amazon Resource Name (ARN), description, number of controls, creation time, and deployment status.
    public var frameworks: [BackupClientTypes.Framework]?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        frameworks: [BackupClientTypes.Framework]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.frameworks = frameworks
        self.nextToken = nextToken
    }
}

struct ListFrameworksOutputBody: Swift.Equatable {
    let frameworks: [BackupClientTypes.Framework]?
    let nextToken: Swift.String?
}

extension ListFrameworksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworks = "Frameworks"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworksContainer = try containerValues.decodeIfPresent([BackupClientTypes.Framework?].self, forKey: .frameworks)
        var frameworksDecoded0:[BackupClientTypes.Framework]? = nil
        if let frameworksContainer = frameworksContainer {
            frameworksDecoded0 = [BackupClientTypes.Framework]()
            for structure0 in frameworksContainer {
                if let structure0 = structure0 {
                    frameworksDecoded0?.append(structure0)
                }
            }
        }
        frameworks = frameworksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFrameworksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLegalHoldsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListLegalHoldsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/legal-holds"
    }
}

public struct ListLegalHoldsInput: Swift.Equatable {
    /// The maximum number of resource list items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLegalHoldsInputBody: Swift.Equatable {
}

extension ListLegalHoldsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLegalHoldsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLegalHoldsOutputBody = try responseDecoder.decode(responseBody: data)
            self.legalHolds = output.legalHolds
            self.nextToken = output.nextToken
        } else {
            self.legalHolds = nil
            self.nextToken = nil
        }
    }
}

public struct ListLegalHoldsOutput: Swift.Equatable {
    /// This is an array of returned legal holds, both active and previous.
    public var legalHolds: [BackupClientTypes.LegalHold]?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        legalHolds: [BackupClientTypes.LegalHold]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.legalHolds = legalHolds
        self.nextToken = nextToken
    }
}

struct ListLegalHoldsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let legalHolds: [BackupClientTypes.LegalHold]?
}

extension ListLegalHoldsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case legalHolds = "LegalHolds"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let legalHoldsContainer = try containerValues.decodeIfPresent([BackupClientTypes.LegalHold?].self, forKey: .legalHolds)
        var legalHoldsDecoded0:[BackupClientTypes.LegalHold]? = nil
        if let legalHoldsContainer = legalHoldsContainer {
            legalHoldsDecoded0 = [BackupClientTypes.LegalHold]()
            for structure0 in legalHoldsContainer {
                if let structure0 = structure0 {
                    legalHoldsDecoded0?.append(structure0)
                }
            }
        }
        legalHolds = legalHoldsDecoded0
    }
}

enum ListLegalHoldsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProtectedResourcesByBackupVaultInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let backupVaultAccountId = backupVaultAccountId {
                let backupVaultAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "backupVaultAccountId".urlPercentEncoding(), value: Swift.String(backupVaultAccountId).urlPercentEncoding())
                items.append(backupVaultAccountIdQueryItem)
            }
            return items
        }
    }
}

extension ListProtectedResourcesByBackupVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/resources"
    }
}

public struct ListProtectedResourcesByBackupVaultInput: Swift.Equatable {
    /// This is the list of protected resources by backup vault within the vault(s) you specify by account ID.
    public var backupVaultAccountId: Swift.String?
    /// This is the list of protected resources by backup vault within the vault(s) you specify by name.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupVaultAccountId: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupVaultAccountId = backupVaultAccountId
        self.backupVaultName = backupVaultName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProtectedResourcesByBackupVaultInputBody: Swift.Equatable {
}

extension ListProtectedResourcesByBackupVaultInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProtectedResourcesByBackupVaultOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProtectedResourcesByBackupVaultOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.results = output.results
        } else {
            self.nextToken = nil
            self.results = nil
        }
    }
}

public struct ListProtectedResourcesByBackupVaultOutput: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// These are the results returned for the request ListProtectedResourcesByBackupVault.
    public var results: [BackupClientTypes.ProtectedResource]?

    public init(
        nextToken: Swift.String? = nil,
        results: [BackupClientTypes.ProtectedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

struct ListProtectedResourcesByBackupVaultOutputBody: Swift.Equatable {
    let results: [BackupClientTypes.ProtectedResource]?
    let nextToken: Swift.String?
}

extension ListProtectedResourcesByBackupVaultOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case results = "Results"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([BackupClientTypes.ProtectedResource?].self, forKey: .results)
        var resultsDecoded0:[BackupClientTypes.ProtectedResource]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [BackupClientTypes.ProtectedResource]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProtectedResourcesByBackupVaultOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProtectedResourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListProtectedResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resources"
    }
}

public struct ListProtectedResourcesInput: Swift.Equatable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProtectedResourcesInputBody: Swift.Equatable {
}

extension ListProtectedResourcesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProtectedResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProtectedResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.results = output.results
        } else {
            self.nextToken = nil
            self.results = nil
        }
    }
}

public struct ListProtectedResourcesOutput: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of resources successfully backed up by Backup including the time the resource was saved, an Amazon Resource Name (ARN) of the resource, and a resource type.
    public var results: [BackupClientTypes.ProtectedResource]?

    public init(
        nextToken: Swift.String? = nil,
        results: [BackupClientTypes.ProtectedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

struct ListProtectedResourcesOutputBody: Swift.Equatable {
    let results: [BackupClientTypes.ProtectedResource]?
    let nextToken: Swift.String?
}

extension ListProtectedResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case results = "Results"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([BackupClientTypes.ProtectedResource?].self, forKey: .results)
        var resultsDecoded0:[BackupClientTypes.ProtectedResource]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [BackupClientTypes.ProtectedResource]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProtectedResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecoveryPointsByBackupVaultInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let byResourceType = byResourceType {
                let byResourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(byResourceType).urlPercentEncoding())
                items.append(byResourceTypeQueryItem)
            }
            if let byCreatedBefore = byCreatedBefore {
                let byCreatedBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedBefore)).urlPercentEncoding())
                items.append(byCreatedBeforeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let byResourceArn = byResourceArn {
                let byResourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(byResourceArn).urlPercentEncoding())
                items.append(byResourceArnQueryItem)
            }
            if let byBackupPlanId = byBackupPlanId {
                let byBackupPlanIdQueryItem = ClientRuntime.URLQueryItem(name: "backupPlanId".urlPercentEncoding(), value: Swift.String(byBackupPlanId).urlPercentEncoding())
                items.append(byBackupPlanIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let byParentRecoveryPointArn = byParentRecoveryPointArn {
                let byParentRecoveryPointArnQueryItem = ClientRuntime.URLQueryItem(name: "parentRecoveryPointArn".urlPercentEncoding(), value: Swift.String(byParentRecoveryPointArn).urlPercentEncoding())
                items.append(byParentRecoveryPointArnQueryItem)
            }
            if let backupVaultAccountId = backupVaultAccountId {
                let backupVaultAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "backupVaultAccountId".urlPercentEncoding(), value: Swift.String(backupVaultAccountId).urlPercentEncoding())
                items.append(backupVaultAccountIdQueryItem)
            }
            if let byCreatedAfter = byCreatedAfter {
                let byCreatedAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedAfter)).urlPercentEncoding())
                items.append(byCreatedAfterQueryItem)
            }
            return items
        }
    }
}

extension ListRecoveryPointsByBackupVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points"
    }
}

public struct ListRecoveryPointsByBackupVaultInput: Swift.Equatable {
    /// This parameter will sort the list of recovery points by account ID.
    public var backupVaultAccountId: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens. Backup vault name might not be available when a supported service creates the backup.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// Returns only recovery points that match the specified backup plan ID.
    public var byBackupPlanId: Swift.String?
    /// Returns only recovery points that were created after the specified timestamp.
    public var byCreatedAfter: ClientRuntime.Date?
    /// Returns only recovery points that were created before the specified timestamp.
    public var byCreatedBefore: ClientRuntime.Date?
    /// This returns only recovery points that match the specified parent (composite) recovery point Amazon Resource Name (ARN).
    public var byParentRecoveryPointArn: Swift.String?
    /// Returns only recovery points that match the specified resource Amazon Resource Name (ARN).
    public var byResourceArn: Swift.String?
    /// Returns only recovery points that match the specified resource type.
    public var byResourceType: Swift.String?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        backupVaultAccountId: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        byBackupPlanId: Swift.String? = nil,
        byCreatedAfter: ClientRuntime.Date? = nil,
        byCreatedBefore: ClientRuntime.Date? = nil,
        byParentRecoveryPointArn: Swift.String? = nil,
        byResourceArn: Swift.String? = nil,
        byResourceType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupVaultAccountId = backupVaultAccountId
        self.backupVaultName = backupVaultName
        self.byBackupPlanId = byBackupPlanId
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byParentRecoveryPointArn = byParentRecoveryPointArn
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecoveryPointsByBackupVaultInputBody: Swift.Equatable {
}

extension ListRecoveryPointsByBackupVaultInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRecoveryPointsByBackupVaultOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecoveryPointsByBackupVaultOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recoveryPoints = output.recoveryPoints
        } else {
            self.nextToken = nil
            self.recoveryPoints = nil
        }
    }
}

public struct ListRecoveryPointsByBackupVaultOutput: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of objects that contain detailed information about recovery points saved in a backup vault.
    public var recoveryPoints: [BackupClientTypes.RecoveryPointByBackupVault]?

    public init(
        nextToken: Swift.String? = nil,
        recoveryPoints: [BackupClientTypes.RecoveryPointByBackupVault]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

struct ListRecoveryPointsByBackupVaultOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let recoveryPoints: [BackupClientTypes.RecoveryPointByBackupVault]?
}

extension ListRecoveryPointsByBackupVaultOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recoveryPoints = "RecoveryPoints"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recoveryPointsContainer = try containerValues.decodeIfPresent([BackupClientTypes.RecoveryPointByBackupVault?].self, forKey: .recoveryPoints)
        var recoveryPointsDecoded0:[BackupClientTypes.RecoveryPointByBackupVault]? = nil
        if let recoveryPointsContainer = recoveryPointsContainer {
            recoveryPointsDecoded0 = [BackupClientTypes.RecoveryPointByBackupVault]()
            for structure0 in recoveryPointsContainer {
                if let structure0 = structure0 {
                    recoveryPointsDecoded0?.append(structure0)
                }
            }
        }
        recoveryPoints = recoveryPointsDecoded0
    }
}

enum ListRecoveryPointsByBackupVaultOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecoveryPointsByLegalHoldInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRecoveryPointsByLegalHoldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let legalHoldId = legalHoldId else {
            return nil
        }
        return "/legal-holds/\(legalHoldId.urlPercentEncoding())/recovery-points"
    }
}

public struct ListRecoveryPointsByLegalHoldInput: Swift.Equatable {
    /// This is the ID of the legal hold.
    /// This member is required.
    public var legalHoldId: Swift.String?
    /// This is the maximum number of resource list items to be returned.
    public var maxResults: Swift.Int?
    /// This is the next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        legalHoldId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.legalHoldId = legalHoldId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecoveryPointsByLegalHoldInputBody: Swift.Equatable {
}

extension ListRecoveryPointsByLegalHoldInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRecoveryPointsByLegalHoldOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecoveryPointsByLegalHoldOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recoveryPoints = output.recoveryPoints
        } else {
            self.nextToken = nil
            self.recoveryPoints = nil
        }
    }
}

public struct ListRecoveryPointsByLegalHoldOutput: Swift.Equatable {
    /// This return is the next item following a partial list of returned resources.
    public var nextToken: Swift.String?
    /// This is a list of the recovery points returned by ListRecoveryPointsByLegalHold.
    public var recoveryPoints: [BackupClientTypes.RecoveryPointMember]?

    public init(
        nextToken: Swift.String? = nil,
        recoveryPoints: [BackupClientTypes.RecoveryPointMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

struct ListRecoveryPointsByLegalHoldOutputBody: Swift.Equatable {
    let recoveryPoints: [BackupClientTypes.RecoveryPointMember]?
    let nextToken: Swift.String?
}

extension ListRecoveryPointsByLegalHoldOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recoveryPoints = "RecoveryPoints"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointsContainer = try containerValues.decodeIfPresent([BackupClientTypes.RecoveryPointMember?].self, forKey: .recoveryPoints)
        var recoveryPointsDecoded0:[BackupClientTypes.RecoveryPointMember]? = nil
        if let recoveryPointsContainer = recoveryPointsContainer {
            recoveryPointsDecoded0 = [BackupClientTypes.RecoveryPointMember]()
            for structure0 in recoveryPointsContainer {
                if let structure0 = structure0 {
                    recoveryPointsDecoded0?.append(structure0)
                }
            }
        }
        recoveryPoints = recoveryPointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRecoveryPointsByLegalHoldOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecoveryPointsByResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRecoveryPointsByResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())/recovery-points"
    }
}

public struct ListRecoveryPointsByResourceInput: Swift.Equatable {
    /// The maximum number of items to be returned. Amazon RDS requires a value of at least 20.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListRecoveryPointsByResourceInputBody: Swift.Equatable {
}

extension ListRecoveryPointsByResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRecoveryPointsByResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecoveryPointsByResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recoveryPoints = output.recoveryPoints
        } else {
            self.nextToken = nil
            self.recoveryPoints = nil
        }
    }
}

public struct ListRecoveryPointsByResourceOutput: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of objects that contain detailed information about recovery points of the specified resource type. Only Amazon EFS and Amazon EC2 recovery points return BackupVaultName.
    public var recoveryPoints: [BackupClientTypes.RecoveryPointByResource]?

    public init(
        nextToken: Swift.String? = nil,
        recoveryPoints: [BackupClientTypes.RecoveryPointByResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

struct ListRecoveryPointsByResourceOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let recoveryPoints: [BackupClientTypes.RecoveryPointByResource]?
}

extension ListRecoveryPointsByResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recoveryPoints = "RecoveryPoints"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recoveryPointsContainer = try containerValues.decodeIfPresent([BackupClientTypes.RecoveryPointByResource?].self, forKey: .recoveryPoints)
        var recoveryPointsDecoded0:[BackupClientTypes.RecoveryPointByResource]? = nil
        if let recoveryPointsContainer = recoveryPointsContainer {
            recoveryPointsDecoded0 = [BackupClientTypes.RecoveryPointByResource]()
            for structure0 in recoveryPointsContainer {
                if let structure0 = structure0 {
                    recoveryPointsDecoded0?.append(structure0)
                }
            }
        }
        recoveryPoints = recoveryPointsDecoded0
    }
}

enum ListRecoveryPointsByResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let byReportPlanName = byReportPlanName {
                let byReportPlanNameQueryItem = ClientRuntime.URLQueryItem(name: "ReportPlanName".urlPercentEncoding(), value: Swift.String(byReportPlanName).urlPercentEncoding())
                items.append(byReportPlanNameQueryItem)
            }
            if let byCreationAfter = byCreationAfter {
                let byCreationAfterQueryItem = ClientRuntime.URLQueryItem(name: "CreationAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreationAfter)).urlPercentEncoding())
                items.append(byCreationAfterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let byStatus = byStatus {
                let byStatusQueryItem = ClientRuntime.URLQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(byStatus).urlPercentEncoding())
                items.append(byStatusQueryItem)
            }
            if let byCreationBefore = byCreationBefore {
                let byCreationBeforeQueryItem = ClientRuntime.URLQueryItem(name: "CreationBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreationBefore)).urlPercentEncoding())
                items.append(byCreationBeforeQueryItem)
            }
            return items
        }
    }
}

extension ListReportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/report-jobs"
    }
}

public struct ListReportJobsInput: Swift.Equatable {
    /// Returns only report jobs that were created after the date and time specified in Unix format and Coordinated Universal Time (UTC). For example, the value 1516925490 represents Friday, January 26, 2018 12:11:30 AM.
    public var byCreationAfter: ClientRuntime.Date?
    /// Returns only report jobs that were created before the date and time specified in Unix format and Coordinated Universal Time (UTC). For example, the value 1516925490 represents Friday, January 26, 2018 12:11:30 AM.
    public var byCreationBefore: ClientRuntime.Date?
    /// Returns only report jobs with the specified report plan name.
    public var byReportPlanName: Swift.String?
    /// Returns only report jobs that are in the specified status. The statuses are: CREATED | RUNNING | COMPLETED | FAILED
    public var byStatus: Swift.String?
    /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        byCreationAfter: ClientRuntime.Date? = nil,
        byCreationBefore: ClientRuntime.Date? = nil,
        byReportPlanName: Swift.String? = nil,
        byStatus: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byCreationAfter = byCreationAfter
        self.byCreationBefore = byCreationBefore
        self.byReportPlanName = byReportPlanName
        self.byStatus = byStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReportJobsInputBody: Swift.Equatable {
}

extension ListReportJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListReportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportJobs = output.reportJobs
        } else {
            self.nextToken = nil
            self.reportJobs = nil
        }
    }
}

public struct ListReportJobsOutput: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Details about your report jobs in JSON format.
    public var reportJobs: [BackupClientTypes.ReportJob]?

    public init(
        nextToken: Swift.String? = nil,
        reportJobs: [BackupClientTypes.ReportJob]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportJobs = reportJobs
    }
}

struct ListReportJobsOutputBody: Swift.Equatable {
    let reportJobs: [BackupClientTypes.ReportJob]?
    let nextToken: Swift.String?
}

extension ListReportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reportJobs = "ReportJobs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportJobsContainer = try containerValues.decodeIfPresent([BackupClientTypes.ReportJob?].self, forKey: .reportJobs)
        var reportJobsDecoded0:[BackupClientTypes.ReportJob]? = nil
        if let reportJobsContainer = reportJobsContainer {
            reportJobsDecoded0 = [BackupClientTypes.ReportJob]()
            for structure0 in reportJobsContainer {
                if let structure0 = structure0 {
                    reportJobsDecoded0?.append(structure0)
                }
            }
        }
        reportJobs = reportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListReportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReportPlansInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListReportPlansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/report-plans"
    }
}

public struct ListReportPlansInput: Swift.Equatable {
    /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReportPlansInputBody: Swift.Equatable {
}

extension ListReportPlansInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListReportPlansOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReportPlansOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportPlans = output.reportPlans
        } else {
            self.nextToken = nil
            self.reportPlans = nil
        }
    }
}

public struct ListReportPlansOutput: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// A list of your report plans with detailed information for each plan. This information includes the Amazon Resource Name (ARN), report plan name, description, settings, delivery channel, deployment status, creation time, and last times the report plan attempted to and successfully ran.
    public var reportPlans: [BackupClientTypes.ReportPlan]?

    public init(
        nextToken: Swift.String? = nil,
        reportPlans: [BackupClientTypes.ReportPlan]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportPlans = reportPlans
    }
}

struct ListReportPlansOutputBody: Swift.Equatable {
    let reportPlans: [BackupClientTypes.ReportPlan]?
    let nextToken: Swift.String?
}

extension ListReportPlansOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reportPlans = "ReportPlans"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlansContainer = try containerValues.decodeIfPresent([BackupClientTypes.ReportPlan?].self, forKey: .reportPlans)
        var reportPlansDecoded0:[BackupClientTypes.ReportPlan]? = nil
        if let reportPlansContainer = reportPlansContainer {
            reportPlansDecoded0 = [BackupClientTypes.ReportPlan]()
            for structure0 in reportPlansContainer {
                if let structure0 = structure0 {
                    reportPlansDecoded0?.append(structure0)
                }
            }
        }
        reportPlans = reportPlansDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListReportPlansOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRestoreJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let byCreatedBefore = byCreatedBefore {
                let byCreatedBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedBefore)).urlPercentEncoding())
                items.append(byCreatedBeforeQueryItem)
            }
            if let byCompleteAfter = byCompleteAfter {
                let byCompleteAfterQueryItem = ClientRuntime.URLQueryItem(name: "completeAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCompleteAfter)).urlPercentEncoding())
                items.append(byCompleteAfterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let byAccountId = byAccountId {
                let byAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(byAccountId).urlPercentEncoding())
                items.append(byAccountIdQueryItem)
            }
            if let byCompleteBefore = byCompleteBefore {
                let byCompleteBeforeQueryItem = ClientRuntime.URLQueryItem(name: "completeBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCompleteBefore)).urlPercentEncoding())
                items.append(byCompleteBeforeQueryItem)
            }
            if let byCreatedAfter = byCreatedAfter {
                let byCreatedAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedAfter)).urlPercentEncoding())
                items.append(byCreatedAfterQueryItem)
            }
            if let byStatus = byStatus {
                let byStatusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(byStatus.rawValue).urlPercentEncoding())
                items.append(byStatusQueryItem)
            }
            return items
        }
    }
}

extension ListRestoreJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/restore-jobs"
    }
}

public struct ListRestoreJobsInput: Swift.Equatable {
    /// The account ID to list the jobs from. Returns only restore jobs associated with the specified account ID.
    public var byAccountId: Swift.String?
    /// Returns only copy jobs completed after a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteAfter: ClientRuntime.Date?
    /// Returns only copy jobs completed before a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteBefore: ClientRuntime.Date?
    /// Returns only restore jobs that were created after the specified date.
    public var byCreatedAfter: ClientRuntime.Date?
    /// Returns only restore jobs that were created before the specified date.
    public var byCreatedBefore: ClientRuntime.Date?
    /// Returns only restore jobs associated with the specified job status.
    public var byStatus: BackupClientTypes.RestoreJobStatus?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        byAccountId: Swift.String? = nil,
        byCompleteAfter: ClientRuntime.Date? = nil,
        byCompleteBefore: ClientRuntime.Date? = nil,
        byCreatedAfter: ClientRuntime.Date? = nil,
        byCreatedBefore: ClientRuntime.Date? = nil,
        byStatus: BackupClientTypes.RestoreJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byCompleteAfter = byCompleteAfter
        self.byCompleteBefore = byCompleteBefore
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byStatus = byStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRestoreJobsInputBody: Swift.Equatable {
}

extension ListRestoreJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRestoreJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRestoreJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.restoreJobs = output.restoreJobs
        } else {
            self.nextToken = nil
            self.restoreJobs = nil
        }
    }
}

public struct ListRestoreJobsOutput: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of objects that contain detailed information about jobs to restore saved resources.
    public var restoreJobs: [BackupClientTypes.RestoreJobsListMember]?

    public init(
        nextToken: Swift.String? = nil,
        restoreJobs: [BackupClientTypes.RestoreJobsListMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.restoreJobs = restoreJobs
    }
}

struct ListRestoreJobsOutputBody: Swift.Equatable {
    let restoreJobs: [BackupClientTypes.RestoreJobsListMember]?
    let nextToken: Swift.String?
}

extension ListRestoreJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case restoreJobs = "RestoreJobs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restoreJobsContainer = try containerValues.decodeIfPresent([BackupClientTypes.RestoreJobsListMember?].self, forKey: .restoreJobs)
        var restoreJobsDecoded0:[BackupClientTypes.RestoreJobsListMember]? = nil
        if let restoreJobsContainer = restoreJobsContainer {
            restoreJobsDecoded0 = [BackupClientTypes.RestoreJobsListMember]()
            for structure0 in restoreJobsContainer {
                if let structure0 = structure0 {
                    restoreJobsDecoded0?.append(structure0)
                }
            }
        }
        restoreJobs = restoreJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRestoreJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsInput: Swift.Equatable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the type of resource. Valid targets for ListTags are recovery points, backup plans, and backup vaults.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsInputBody: Swift.Equatable {
}

extension ListTagsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsOutput(nextToken: \(Swift.String(describing: nextToken)), tags: \"CONTENT_REDACTED\")"}
}

extension ListTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsOutput: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// To help organize your resources, you can assign your own metadata to the resources you create. Each tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MissingParameterValueException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MissingParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a required parameter is missing.
public struct MissingParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MissingParameterValueException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

struct MissingParameterValueExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension MissingParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes.ProtectedResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastBackupTime = "LastBackupTime"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastBackupTime = self.lastBackupTime {
            try encodeContainer.encodeTimestamp(lastBackupTime, format: .epochSeconds, forKey: .lastBackupTime)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let lastBackupTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastBackupTime)
        lastBackupTime = lastBackupTimeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension BackupClientTypes {
    /// A structure that contains information about a backed-up resource.
    public struct ProtectedResource: Swift.Equatable {
        /// The date and time a resource was last backed up, in Unix format and Coordinated Universal Time (UTC). The value of LastBackupTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastBackupTime: ClientRuntime.Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var resourceArn: Swift.String?
        /// This is the non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?

        public init(
            lastBackupTime: ClientRuntime.Date? = nil,
            resourceArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.lastBackupTime = lastBackupTime
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
        }
    }

}

extension PutBackupVaultAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutBackupVaultAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/access-policy"
    }
}

public struct PutBackupVaultAccessPolicyInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The backup vault access policy document in JSON format.
    public var policy: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.policy = policy
    }
}

struct PutBackupVaultAccessPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutBackupVaultAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutBackupVaultAccessPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutBackupVaultAccessPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutBackupVaultAccessPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutBackupVaultLockConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeableForDays = "ChangeableForDays"
        case maxRetentionDays = "MaxRetentionDays"
        case minRetentionDays = "MinRetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeableForDays = self.changeableForDays {
            try encodeContainer.encode(changeableForDays, forKey: .changeableForDays)
        }
        if let maxRetentionDays = self.maxRetentionDays {
            try encodeContainer.encode(maxRetentionDays, forKey: .maxRetentionDays)
        }
        if let minRetentionDays = self.minRetentionDays {
            try encodeContainer.encode(minRetentionDays, forKey: .minRetentionDays)
        }
    }
}

extension PutBackupVaultLockConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/vault-lock"
    }
}

public struct PutBackupVaultLockConfigurationInput: Swift.Equatable {
    /// The Backup Vault Lock configuration that specifies the name of the backup vault it protects.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The Backup Vault Lock configuration that specifies the number of days before the lock date. For example, setting ChangeableForDays to 30 on Jan. 1, 2022 at 8pm UTC will set the lock date to Jan. 31, 2022 at 8pm UTC. Backup enforces a 72-hour cooling-off period before Vault Lock takes effect and becomes immutable. Therefore, you must set ChangeableForDays to 3 or greater. Before the lock date, you can delete Vault Lock from the vault using DeleteBackupVaultLockConfiguration or change the Vault Lock configuration using PutBackupVaultLockConfiguration. On and after the lock date, the Vault Lock becomes immutable and cannot be changed or deleted. If this parameter is not specified, you can delete Vault Lock from the vault using DeleteBackupVaultLockConfiguration or change the Vault Lock configuration using PutBackupVaultLockConfiguration at any time.
    public var changeableForDays: Swift.Int?
    /// The Backup Vault Lock configuration that specifies the maximum retention period that the vault retains its recovery points. This setting can be useful if, for example, your organization's policies require you to destroy certain data after retaining it for four years (1460 days). If this parameter is not included, Vault Lock does not enforce a maximum retention period on the recovery points in the vault. If this parameter is included without a value, Vault Lock will not enforce a maximum retention period. If this parameter is specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. The longest maximum retention period you can specify is 36500 days (approximately 100 years). Recovery points already saved in the vault prior to Vault Lock are not affected.
    public var maxRetentionDays: Swift.Int?
    /// The Backup Vault Lock configuration that specifies the minimum retention period that the vault retains its recovery points. This setting can be useful if, for example, your organization's policies require you to retain certain data for at least seven years (2555 days). If this parameter is not specified, Vault Lock will not enforce a minimum retention period. If this parameter is specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails that backup or copy job, and you should either modify your lifecycle settings or use a different vault. The shortest minimum retention period you can specify is 1 day. Recovery points already saved in the vault prior to Vault Lock are not affected.
    public var minRetentionDays: Swift.Int?

    public init(
        backupVaultName: Swift.String? = nil,
        changeableForDays: Swift.Int? = nil,
        maxRetentionDays: Swift.Int? = nil,
        minRetentionDays: Swift.Int? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.changeableForDays = changeableForDays
        self.maxRetentionDays = maxRetentionDays
        self.minRetentionDays = minRetentionDays
    }
}

struct PutBackupVaultLockConfigurationInputBody: Swift.Equatable {
    let minRetentionDays: Swift.Int?
    let maxRetentionDays: Swift.Int?
    let changeableForDays: Swift.Int?
}

extension PutBackupVaultLockConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeableForDays = "ChangeableForDays"
        case maxRetentionDays = "MaxRetentionDays"
        case minRetentionDays = "MinRetentionDays"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minRetentionDays)
        minRetentionDays = minRetentionDaysDecoded
        let maxRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetentionDays)
        maxRetentionDays = maxRetentionDaysDecoded
        let changeableForDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .changeableForDays)
        changeableForDays = changeableForDaysDecoded
    }
}

extension PutBackupVaultLockConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutBackupVaultLockConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutBackupVaultLockConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutBackupVaultNotificationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultEvents = "BackupVaultEvents"
        case snsTopicArn = "SNSTopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultEvents = backupVaultEvents {
            var backupVaultEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .backupVaultEvents)
            for backupvaultevent0 in backupVaultEvents {
                try backupVaultEventsContainer.encode(backupvaultevent0.rawValue)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }
}

extension PutBackupVaultNotificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/notification-configuration"
    }
}

public struct PutBackupVaultNotificationsInput: Swift.Equatable {
    /// An array of events that indicate the status of jobs to back up resources to the backup vault. For common use cases and code samples, see [Using Amazon SNS to track Backup events](https://docs.aws.amazon.com/aws-backup/latest/devguide/sns-notifications.html). The following events are supported:
    ///
    /// * BACKUP_JOB_STARTED | BACKUP_JOB_COMPLETED
    ///
    /// * COPY_JOB_STARTED | COPY_JOB_SUCCESSFUL | COPY_JOB_FAILED
    ///
    /// * RESTORE_JOB_STARTED | RESTORE_JOB_COMPLETED | RECOVERY_POINT_MODIFIED
    ///
    /// * S3_BACKUP_OBJECT_FAILED | S3_RESTORE_OBJECT_FAILED
    ///
    ///
    /// The list below shows items that are deprecated events (for reference) and are no longer in use. They are no longer supported and will not return statuses or notifications. Refer to the list above for current supported events.
    /// This member is required.
    public var backupVaultEvents: [BackupClientTypes.BackupVaultEvent]?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The Amazon Resource Name (ARN) that specifies the topic for a backup vaults events; for example, arn:aws:sns:us-west-2:111122223333:MyVaultTopic.
    /// This member is required.
    public var snsTopicArn: Swift.String?

    public init(
        backupVaultEvents: [BackupClientTypes.BackupVaultEvent]? = nil,
        backupVaultName: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.backupVaultEvents = backupVaultEvents
        self.backupVaultName = backupVaultName
        self.snsTopicArn = snsTopicArn
    }
}

struct PutBackupVaultNotificationsInputBody: Swift.Equatable {
    let snsTopicArn: Swift.String?
    let backupVaultEvents: [BackupClientTypes.BackupVaultEvent]?
}

extension PutBackupVaultNotificationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultEvents = "BackupVaultEvents"
        case snsTopicArn = "SNSTopicArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let backupVaultEventsContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupVaultEvent?].self, forKey: .backupVaultEvents)
        var backupVaultEventsDecoded0:[BackupClientTypes.BackupVaultEvent]? = nil
        if let backupVaultEventsContainer = backupVaultEventsContainer {
            backupVaultEventsDecoded0 = [BackupClientTypes.BackupVaultEvent]()
            for enum0 in backupVaultEventsContainer {
                if let enum0 = enum0 {
                    backupVaultEventsDecoded0?.append(enum0)
                }
            }
        }
        backupVaultEvents = backupVaultEventsDecoded0
    }
}

extension PutBackupVaultNotificationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutBackupVaultNotificationsOutput: Swift.Equatable {

    public init() { }
}

enum PutBackupVaultNotificationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BackupClientTypes.RecoveryPointByBackupVault: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case calculatedLifecycle = "CalculatedLifecycle"
        case completionDate = "CompletionDate"
        case compositeMemberIdentifier = "CompositeMemberIdentifier"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case encryptionKeyArn = "EncryptionKeyArn"
        case iamRoleArn = "IamRoleArn"
        case isEncrypted = "IsEncrypted"
        case isParent = "IsParent"
        case lastRestoreTime = "LastRestoreTime"
        case lifecycle = "Lifecycle"
        case parentRecoveryPointArn = "ParentRecoveryPointArn"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case sourceBackupVaultArn = "SourceBackupVaultArn"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupSizeInBytes = self.backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let backupVaultArn = self.backupVaultArn {
            try encodeContainer.encode(backupVaultArn, forKey: .backupVaultArn)
        }
        if let backupVaultName = self.backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let calculatedLifecycle = self.calculatedLifecycle {
            try encodeContainer.encode(calculatedLifecycle, forKey: .calculatedLifecycle)
        }
        if let completionDate = self.completionDate {
            try encodeContainer.encodeTimestamp(completionDate, format: .epochSeconds, forKey: .completionDate)
        }
        if let compositeMemberIdentifier = self.compositeMemberIdentifier {
            try encodeContainer.encode(compositeMemberIdentifier, forKey: .compositeMemberIdentifier)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if isEncrypted != false {
            try encodeContainer.encode(isEncrypted, forKey: .isEncrypted)
        }
        if isParent != false {
            try encodeContainer.encode(isParent, forKey: .isParent)
        }
        if let lastRestoreTime = self.lastRestoreTime {
            try encodeContainer.encodeTimestamp(lastRestoreTime, format: .epochSeconds, forKey: .lastRestoreTime)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let parentRecoveryPointArn = self.parentRecoveryPointArn {
            try encodeContainer.encode(parentRecoveryPointArn, forKey: .parentRecoveryPointArn)
        }
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let sourceBackupVaultArn = self.sourceBackupVaultArn {
            try encodeContainer.encode(sourceBackupVaultArn, forKey: .sourceBackupVaultArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let sourceBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupVaultArn)
        sourceBackupVaultArn = sourceBackupVaultArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDate)
        completionDate = completionDateDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let calculatedLifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CalculatedLifecycle.self, forKey: .calculatedLifecycle)
        calculatedLifecycle = calculatedLifecycleDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let isEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEncrypted) ?? false
        isEncrypted = isEncryptedDecoded
        let lastRestoreTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastRestoreTime)
        lastRestoreTime = lastRestoreTimeDecoded
        let parentRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentRecoveryPointArn)
        parentRecoveryPointArn = parentRecoveryPointArnDecoded
        let compositeMemberIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .compositeMemberIdentifier)
        compositeMemberIdentifier = compositeMemberIdentifierDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about the recovery points stored in a backup vault.
    public struct RecoveryPointByBackupVault: Swift.Equatable {
        /// The size, in bytes, of a backup.
        public var backupSizeInBytes: Swift.Int?
        /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
        public var calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
        /// The date and time a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: ClientRuntime.Date?
        /// This is the identifier of a resource within a composite group, such as nested (child) recovery point belonging to a composite (parent) stack. The ID is transferred from the [ logical ID](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html#resources-section-structure-syntax) within a stack.
        public var compositeMemberIdentifier: Swift.String?
        /// Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan that is used to create it.
        public var createdBy: BackupClientTypes.RecoveryPointCreator?
        /// The date and time a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public var encryptionKeyArn: Swift.String?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.
        public var isEncrypted: Swift.Bool
        /// This is a boolean value indicating this is a parent (composite) recovery point.
        public var isParent: Swift.Bool
        /// The date and time a recovery point was last restored, in Unix format and Coordinated Universal Time (UTC). The value of LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastRestoreTime: ClientRuntime.Date?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the retention setting must be 90 days greater than the transition to cold after days setting. The transition to cold after days setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
        public var lifecycle: BackupClientTypes.Lifecycle?
        /// This is the Amazon Resource Name (ARN) of the parent (composite) recovery point.
        public var parentRecoveryPointArn: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var resourceArn: Swift.String?
        /// This is the non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource saved as a recovery point; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?
        /// The backup vault where the recovery point was originally copied from. If the recovery point is restored to the same account this value will be null.
        public var sourceBackupVaultArn: Swift.String?
        /// A status code specifying the state of the recovery point.
        public var status: BackupClientTypes.RecoveryPointStatus?
        /// A message explaining the reason of the recovery point deletion failure.
        public var statusMessage: Swift.String?

        public init(
            backupSizeInBytes: Swift.Int? = nil,
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            calculatedLifecycle: BackupClientTypes.CalculatedLifecycle? = nil,
            completionDate: ClientRuntime.Date? = nil,
            compositeMemberIdentifier: Swift.String? = nil,
            createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
            creationDate: ClientRuntime.Date? = nil,
            encryptionKeyArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            isEncrypted: Swift.Bool = false,
            isParent: Swift.Bool = false,
            lastRestoreTime: ClientRuntime.Date? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil,
            parentRecoveryPointArn: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            sourceBackupVaultArn: Swift.String? = nil,
            status: BackupClientTypes.RecoveryPointStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.backupSizeInBytes = backupSizeInBytes
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.calculatedLifecycle = calculatedLifecycle
            self.completionDate = completionDate
            self.compositeMemberIdentifier = compositeMemberIdentifier
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.iamRoleArn = iamRoleArn
            self.isEncrypted = isEncrypted
            self.isParent = isParent
            self.lastRestoreTime = lastRestoreTime
            self.lifecycle = lifecycle
            self.parentRecoveryPointArn = parentRecoveryPointArn
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes.RecoveryPointByResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSizeBytes = "BackupSizeBytes"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
        case encryptionKeyArn = "EncryptionKeyArn"
        case isParent = "IsParent"
        case parentRecoveryPointArn = "ParentRecoveryPointArn"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceName = "ResourceName"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupSizeBytes = self.backupSizeBytes {
            try encodeContainer.encode(backupSizeBytes, forKey: .backupSizeBytes)
        }
        if let backupVaultName = self.backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if isParent != false {
            try encodeContainer.encode(isParent, forKey: .isParent)
        }
        if let parentRecoveryPointArn = self.parentRecoveryPointArn {
            try encodeContainer.encode(parentRecoveryPointArn, forKey: .parentRecoveryPointArn)
        }
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let backupSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeBytes)
        backupSizeBytes = backupSizeBytesDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
        let parentRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentRecoveryPointArn)
        parentRecoveryPointArn = parentRecoveryPointArnDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about a saved recovery point.
    public struct RecoveryPointByResource: Swift.Equatable {
        /// The size, in bytes, of a backup.
        public var backupSizeBytes: Swift.Int?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// The date and time a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public var encryptionKeyArn: Swift.String?
        /// This is a boolean value indicating this is a parent (composite) recovery point.
        public var isParent: Swift.Bool
        /// This is the Amazon Resource Name (ARN) of the parent (composite) recovery point.
        public var parentRecoveryPointArn: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// This is the non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// A status code specifying the state of the recovery point.
        public var status: BackupClientTypes.RecoveryPointStatus?
        /// A message explaining the reason of the recovery point deletion failure.
        public var statusMessage: Swift.String?

        public init(
            backupSizeBytes: Swift.Int? = nil,
            backupVaultName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            encryptionKeyArn: Swift.String? = nil,
            isParent: Swift.Bool = false,
            parentRecoveryPointArn: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            status: BackupClientTypes.RecoveryPointStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.backupSizeBytes = backupSizeBytes
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.isParent = isParent
            self.parentRecoveryPointArn = parentRecoveryPointArn
            self.recoveryPointArn = recoveryPointArn
            self.resourceName = resourceName
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes.RecoveryPointCreator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case backupPlanVersion = "BackupPlanVersion"
        case backupRuleId = "BackupRuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanArn = self.backupPlanArn {
            try encodeContainer.encode(backupPlanArn, forKey: .backupPlanArn)
        }
        if let backupPlanId = self.backupPlanId {
            try encodeContainer.encode(backupPlanId, forKey: .backupPlanId)
        }
        if let backupPlanVersion = self.backupPlanVersion {
            try encodeContainer.encode(backupPlanVersion, forKey: .backupPlanVersion)
        }
        if let backupRuleId = self.backupRuleId {
            try encodeContainer.encode(backupRuleId, forKey: .backupRuleId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let backupPlanVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanVersion)
        backupPlanVersion = backupPlanVersionDecoded
        let backupRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupRuleId)
        backupRuleId = backupRuleIdDecoded
    }
}

extension BackupClientTypes {
    /// Contains information about the backup plan and rule that Backup used to initiate the recovery point backup.
    public struct RecoveryPointCreator: Swift.Equatable {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public var backupPlanArn: Swift.String?
        /// Uniquely identifies a backup plan.
        public var backupPlanId: Swift.String?
        /// Version IDs are unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. They cannot be edited.
        public var backupPlanVersion: Swift.String?
        /// Uniquely identifies a rule used to schedule the backup of a selection of resources.
        public var backupRuleId: Swift.String?

        public init(
            backupPlanArn: Swift.String? = nil,
            backupPlanId: Swift.String? = nil,
            backupPlanVersion: Swift.String? = nil,
            backupRuleId: Swift.String? = nil
        )
        {
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanVersion = backupPlanVersion
            self.backupRuleId = backupRuleId
        }
    }

}

extension BackupClientTypes.RecoveryPointMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultName = "BackupVaultName"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultName = self.backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
    }
}

extension BackupClientTypes {
    /// This is a recovery point which is a child (nested) recovery point of a parent (composite) recovery point. These recovery points can be disassociated from their parent (composite) recovery point, in which case they will no longer be a member.
    public struct RecoveryPointMember: Swift.Equatable {
        /// This is the name of the backup vault (the logical container in which backups are stored).
        public var backupVaultName: Swift.String?
        /// This is the Amazon Resource Name (ARN) of the parent (composite) recovery point.
        public var recoveryPointArn: Swift.String?
        /// This is the Amazon Resource Name (ARN) that uniquely identifies a saved resource.
        public var resourceArn: Swift.String?
        /// This is the Amazon Web Services resource type that is saved as a recovery point.
        public var resourceType: Swift.String?

        public init(
            backupVaultName: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.backupVaultName = backupVaultName
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }
    }

}

extension BackupClientTypes.RecoveryPointSelection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateRange = "DateRange"
        case resourceIdentifiers = "ResourceIdentifiers"
        case vaultNames = "VaultNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRange = self.dateRange {
            try encodeContainer.encode(dateRange, forKey: .dateRange)
        }
        if let resourceIdentifiers = resourceIdentifiers {
            var resourceIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIdentifiers)
            for string0 in resourceIdentifiers {
                try resourceIdentifiersContainer.encode(string0)
            }
        }
        if let vaultNames = vaultNames {
            var vaultNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vaultNames)
            for string0 in vaultNames {
                try vaultNamesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vaultNames)
        var vaultNamesDecoded0:[Swift.String]? = nil
        if let vaultNamesContainer = vaultNamesContainer {
            vaultNamesDecoded0 = [Swift.String]()
            for string0 in vaultNamesContainer {
                if let string0 = string0 {
                    vaultNamesDecoded0?.append(string0)
                }
            }
        }
        vaultNames = vaultNamesDecoded0
        let resourceIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIdentifiers)
        var resourceIdentifiersDecoded0:[Swift.String]? = nil
        if let resourceIdentifiersContainer = resourceIdentifiersContainer {
            resourceIdentifiersDecoded0 = [Swift.String]()
            for string0 in resourceIdentifiersContainer {
                if let string0 = string0 {
                    resourceIdentifiersDecoded0?.append(string0)
                }
            }
        }
        resourceIdentifiers = resourceIdentifiersDecoded0
        let dateRangeDecoded = try containerValues.decodeIfPresent(BackupClientTypes.DateRange.self, forKey: .dateRange)
        dateRange = dateRangeDecoded
    }
}

extension BackupClientTypes {
    /// This specifies criteria to assign a set of resources, such as resource types or backup vaults.
    public struct RecoveryPointSelection: Swift.Equatable {
        /// This is a resource filter containing FromDate: DateTime and ToDate: DateTime. Both values are required. Future DateTime values are not permitted. The date and time are in Unix format and Coordinated Universal Time (UTC), and it is accurate to milliseconds ((milliseconds are optional). For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var dateRange: BackupClientTypes.DateRange?
        /// These are the resources included in the resource selection (including type of resources and vaults).
        public var resourceIdentifiers: [Swift.String]?
        /// These are the names of the vaults in which the selected recovery points are contained.
        public var vaultNames: [Swift.String]?

        public init(
            dateRange: BackupClientTypes.DateRange? = nil,
            resourceIdentifiers: [Swift.String]? = nil,
            vaultNames: [Swift.String]? = nil
        )
        {
            self.dateRange = dateRange
            self.resourceIdentifiers = resourceIdentifiers
            self.vaultNames = vaultNames
        }
    }

}

extension BackupClientTypes {
    public enum RecoveryPointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case deleting
        case expired
        case partial
        case sdkUnknown(Swift.String)

        public static var allCases: [RecoveryPointStatus] {
            return [
                .completed,
                .deleting,
                .expired,
                .partial,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .deleting: return "DELETING"
            case .expired: return "EXPIRED"
            case .partial: return "PARTIAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecoveryPointStatus(rawValue: rawValue) ?? RecoveryPointStatus.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.ReportDeliveryChannel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formats = "Formats"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formats = formats {
            var formatsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .formats)
            for string0 in formats {
                try formatsContainer.encode(string0)
            }
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let formatsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .formats)
        var formatsDecoded0:[Swift.String]? = nil
        if let formatsContainer = formatsContainer {
            formatsDecoded0 = [Swift.String]()
            for string0 in formatsContainer {
                if let string0 = string0 {
                    formatsDecoded0?.append(string0)
                }
            }
        }
        formats = formatsDecoded0
    }
}

extension BackupClientTypes {
    /// Contains information from your report plan about where to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
    public struct ReportDeliveryChannel: Swift.Equatable {
        /// A list of the format of your reports: CSV, JSON, or both. If not specified, the default format is CSV.
        public var formats: [Swift.String]?
        /// The unique name of the S3 bucket that receives your reports.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// The prefix for where Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name. If not specified, there is no prefix.
        public var s3KeyPrefix: Swift.String?

        public init(
            formats: [Swift.String]? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil
        )
        {
            self.formats = formats
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }
    }

}

extension BackupClientTypes.ReportDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName = "S3BucketName"
        case s3Keys = "S3Keys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3Keys = s3Keys {
            var s3KeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Keys)
            for string0 in s3Keys {
                try s3KeysContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Keys)
        var s3KeysDecoded0:[Swift.String]? = nil
        if let s3KeysContainer = s3KeysContainer {
            s3KeysDecoded0 = [Swift.String]()
            for string0 in s3KeysContainer {
                if let string0 = string0 {
                    s3KeysDecoded0?.append(string0)
                }
            }
        }
        s3Keys = s3KeysDecoded0
    }
}

extension BackupClientTypes {
    /// Contains information from your report job about your report destination.
    public struct ReportDestination: Swift.Equatable {
        /// The unique name of the Amazon S3 bucket that receives your reports.
        public var s3BucketName: Swift.String?
        /// The object key that uniquely identifies your reports in your S3 bucket.
        public var s3Keys: [Swift.String]?

        public init(
            s3BucketName: Swift.String? = nil,
            s3Keys: [Swift.String]? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3Keys = s3Keys
        }
    }

}

extension BackupClientTypes.ReportJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime = "CompletionTime"
        case creationTime = "CreationTime"
        case reportDestination = "ReportDestination"
        case reportJobId = "ReportJobId"
        case reportPlanArn = "ReportPlanArn"
        case reportTemplate = "ReportTemplate"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .epochSeconds, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let reportDestination = self.reportDestination {
            try encodeContainer.encode(reportDestination, forKey: .reportDestination)
        }
        if let reportJobId = self.reportJobId {
            try encodeContainer.encode(reportJobId, forKey: .reportJobId)
        }
        if let reportPlanArn = self.reportPlanArn {
            try encodeContainer.encode(reportPlanArn, forKey: .reportPlanArn)
        }
        if let reportTemplate = self.reportTemplate {
            try encodeContainer.encode(reportTemplate, forKey: .reportTemplate)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportJobId)
        reportJobId = reportJobIdDecoded
        let reportPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanArn)
        reportPlanArn = reportPlanArnDecoded
        let reportTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportTemplate)
        reportTemplate = reportTemplateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let reportDestinationDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportDestination.self, forKey: .reportDestination)
        reportDestination = reportDestinationDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about a report job. A report job compiles a report based on a report plan and publishes it to Amazon S3.
    public struct ReportJob: Swift.Equatable {
        /// The date and time that a report job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionTime: ClientRuntime.Date?
        /// The date and time that a report job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationTime: ClientRuntime.Date?
        /// The S3 bucket name and S3 keys for the destination where the report job publishes the report.
        public var reportDestination: BackupClientTypes.ReportDestination?
        /// The identifier for a report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. Report job IDs cannot be edited.
        public var reportJobId: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var reportPlanArn: Swift.String?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        public var reportTemplate: Swift.String?
        /// The status of a report job. The statuses are: CREATED | RUNNING | COMPLETED | FAILEDCOMPLETED means that the report is available for your review at your designated destination. If the status is FAILED, review the StatusMessage for the reason.
        public var status: Swift.String?
        /// A message explaining the status of the report job.
        public var statusMessage: Swift.String?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            reportDestination: BackupClientTypes.ReportDestination? = nil,
            reportJobId: Swift.String? = nil,
            reportPlanArn: Swift.String? = nil,
            reportTemplate: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.reportDestination = reportDestination
            self.reportJobId = reportJobId
            self.reportPlanArn = reportPlanArn
            self.reportTemplate = reportTemplate
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes.ReportPlan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case deploymentStatus = "DeploymentStatus"
        case lastAttemptedExecutionTime = "LastAttemptedExecutionTime"
        case lastSuccessfulExecutionTime = "LastSuccessfulExecutionTime"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanArn = "ReportPlanArn"
        case reportPlanDescription = "ReportPlanDescription"
        case reportPlanName = "ReportPlanName"
        case reportSetting = "ReportSetting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus, forKey: .deploymentStatus)
        }
        if let lastAttemptedExecutionTime = self.lastAttemptedExecutionTime {
            try encodeContainer.encodeTimestamp(lastAttemptedExecutionTime, format: .epochSeconds, forKey: .lastAttemptedExecutionTime)
        }
        if let lastSuccessfulExecutionTime = self.lastSuccessfulExecutionTime {
            try encodeContainer.encodeTimestamp(lastSuccessfulExecutionTime, format: .epochSeconds, forKey: .lastSuccessfulExecutionTime)
        }
        if let reportDeliveryChannel = self.reportDeliveryChannel {
            try encodeContainer.encode(reportDeliveryChannel, forKey: .reportDeliveryChannel)
        }
        if let reportPlanArn = self.reportPlanArn {
            try encodeContainer.encode(reportPlanArn, forKey: .reportPlanArn)
        }
        if let reportPlanDescription = self.reportPlanDescription {
            try encodeContainer.encode(reportPlanDescription, forKey: .reportPlanDescription)
        }
        if let reportPlanName = self.reportPlanName {
            try encodeContainer.encode(reportPlanName, forKey: .reportPlanName)
        }
        if let reportSetting = self.reportSetting {
            try encodeContainer.encode(reportSetting, forKey: .reportSetting)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanArn)
        reportPlanArn = reportPlanArnDecoded
        let reportPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanName)
        reportPlanName = reportPlanNameDecoded
        let reportPlanDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanDescription)
        reportPlanDescription = reportPlanDescriptionDecoded
        let reportSettingDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportSetting.self, forKey: .reportSetting)
        reportSetting = reportSettingDecoded
        let reportDeliveryChannelDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportDeliveryChannel.self, forKey: .reportDeliveryChannel)
        reportDeliveryChannel = reportDeliveryChannelDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastAttemptedExecutionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAttemptedExecutionTime)
        lastAttemptedExecutionTime = lastAttemptedExecutionTimeDecoded
        let lastSuccessfulExecutionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSuccessfulExecutionTime)
        lastSuccessfulExecutionTime = lastSuccessfulExecutionTimeDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about a report plan.
    public struct ReportPlan: Swift.Equatable {
        /// The date and time that a report plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationTime: ClientRuntime.Date?
        /// The deployment status of a report plan. The statuses are: CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED
        public var deploymentStatus: Swift.String?
        /// The date and time that a report job associated with this report plan last attempted to run, in Unix format and Coordinated Universal Time (UTC). The value of LastAttemptedExecutionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastAttemptedExecutionTime: ClientRuntime.Date?
        /// The date and time that a report job associated with this report plan last successfully ran, in Unix format and Coordinated Universal Time (UTC). The value of LastSuccessfulExecutionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastSuccessfulExecutionTime: ClientRuntime.Date?
        /// Contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
        public var reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var reportPlanArn: Swift.String?
        /// An optional description of the report plan with a maximum 1,024 characters.
        public var reportPlanDescription: Swift.String?
        /// The unique name of the report plan. This name is between 1 and 256 characters starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public var reportPlanName: Swift.String?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
        public var reportSetting: BackupClientTypes.ReportSetting?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            deploymentStatus: Swift.String? = nil,
            lastAttemptedExecutionTime: ClientRuntime.Date? = nil,
            lastSuccessfulExecutionTime: ClientRuntime.Date? = nil,
            reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel? = nil,
            reportPlanArn: Swift.String? = nil,
            reportPlanDescription: Swift.String? = nil,
            reportPlanName: Swift.String? = nil,
            reportSetting: BackupClientTypes.ReportSetting? = nil
        )
        {
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.lastAttemptedExecutionTime = lastAttemptedExecutionTime
            self.lastSuccessfulExecutionTime = lastSuccessfulExecutionTime
            self.reportDeliveryChannel = reportDeliveryChannel
            self.reportPlanArn = reportPlanArn
            self.reportPlanDescription = reportPlanDescription
            self.reportPlanName = reportPlanName
            self.reportSetting = reportSetting
        }
    }

}

extension BackupClientTypes.ReportSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts = "Accounts"
        case frameworkArns = "FrameworkArns"
        case numberOfFrameworks = "NumberOfFrameworks"
        case organizationUnits = "OrganizationUnits"
        case regions = "Regions"
        case reportTemplate = "ReportTemplate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for string0 in accounts {
                try accountsContainer.encode(string0)
            }
        }
        if let frameworkArns = frameworkArns {
            var frameworkArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .frameworkArns)
            for string0 in frameworkArns {
                try frameworkArnsContainer.encode(string0)
            }
        }
        if numberOfFrameworks != 0 {
            try encodeContainer.encode(numberOfFrameworks, forKey: .numberOfFrameworks)
        }
        if let organizationUnits = organizationUnits {
            var organizationUnitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationUnits)
            for string0 in organizationUnits {
                try organizationUnitsContainer.encode(string0)
            }
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for string0 in regions {
                try regionsContainer.encode(string0)
            }
        }
        if let reportTemplate = self.reportTemplate {
            try encodeContainer.encode(reportTemplate, forKey: .reportTemplate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportTemplate)
        reportTemplate = reportTemplateDecoded
        let frameworkArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .frameworkArns)
        var frameworkArnsDecoded0:[Swift.String]? = nil
        if let frameworkArnsContainer = frameworkArnsContainer {
            frameworkArnsDecoded0 = [Swift.String]()
            for string0 in frameworkArnsContainer {
                if let string0 = string0 {
                    frameworkArnsDecoded0?.append(string0)
                }
            }
        }
        frameworkArns = frameworkArnsDecoded0
        let numberOfFrameworksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfFrameworks) ?? 0
        numberOfFrameworks = numberOfFrameworksDecoded
        let accountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accounts)
        var accountsDecoded0:[Swift.String]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Swift.String]()
            for string0 in accountsContainer {
                if let string0 = string0 {
                    accountsDecoded0?.append(string0)
                }
            }
        }
        accounts = accountsDecoded0
        let organizationUnitsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationUnits)
        var organizationUnitsDecoded0:[Swift.String]? = nil
        if let organizationUnitsContainer = organizationUnitsContainer {
            organizationUnitsDecoded0 = [Swift.String]()
            for string0 in organizationUnitsContainer {
                if let string0 = string0 {
                    organizationUnitsDecoded0?.append(string0)
                }
            }
        }
        organizationUnits = organizationUnitsDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
    }
}

extension BackupClientTypes {
    /// Contains detailed information about a report setting.
    public struct ReportSetting: Swift.Equatable {
        /// These are the accounts to be included in the report.
        public var accounts: [Swift.String]?
        /// The Amazon Resource Names (ARNs) of the frameworks a report covers.
        public var frameworkArns: [Swift.String]?
        /// The number of frameworks a report covers.
        public var numberOfFrameworks: Swift.Int
        /// These are the Organizational Units to be included in the report.
        public var organizationUnits: [Swift.String]?
        /// These are the Regions to be included in the report.
        public var regions: [Swift.String]?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        /// This member is required.
        public var reportTemplate: Swift.String?

        public init(
            accounts: [Swift.String]? = nil,
            frameworkArns: [Swift.String]? = nil,
            numberOfFrameworks: Swift.Int = 0,
            organizationUnits: [Swift.String]? = nil,
            regions: [Swift.String]? = nil,
            reportTemplate: Swift.String? = nil
        )
        {
            self.accounts = accounts
            self.frameworkArns = frameworkArns
            self.numberOfFrameworks = numberOfFrameworks
            self.organizationUnits = organizationUnits
            self.regions = regions
            self.reportTemplate = reportTemplate
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource that is required for the action doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes {
    public enum RestoreJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case completed
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [RestoreJobStatus] {
            return [
                .aborted,
                .completed,
                .failed,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RestoreJobStatus(rawValue: rawValue) ?? RestoreJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.RestoreJobsListMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupSizeInBytes = "BackupSizeInBytes"
        case completionDate = "CompletionDate"
        case createdResourceArn = "CreatedResourceArn"
        case creationDate = "CreationDate"
        case expectedCompletionTimeMinutes = "ExpectedCompletionTimeMinutes"
        case iamRoleArn = "IamRoleArn"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
        case restoreJobId = "RestoreJobId"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let backupSizeInBytes = self.backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let completionDate = self.completionDate {
            try encodeContainer.encodeTimestamp(completionDate, format: .epochSeconds, forKey: .completionDate)
        }
        if let createdResourceArn = self.createdResourceArn {
            try encodeContainer.encode(createdResourceArn, forKey: .createdResourceArn)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let expectedCompletionTimeMinutes = self.expectedCompletionTimeMinutes {
            try encodeContainer.encode(expectedCompletionTimeMinutes, forKey: .expectedCompletionTimeMinutes)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let percentDone = self.percentDone {
            try encodeContainer.encode(percentDone, forKey: .percentDone)
        }
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let restoreJobId = self.restoreJobId {
            try encodeContainer.encode(restoreJobId, forKey: .restoreJobId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let restoreJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreJobId)
        restoreJobId = restoreJobIdDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDate)
        completionDate = completionDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RestoreJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let expectedCompletionTimeMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expectedCompletionTimeMinutes)
        expectedCompletionTimeMinutes = expectedCompletionTimeMinutesDecoded
        let createdResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdResourceArn)
        createdResourceArn = createdResourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension BackupClientTypes {
    /// Contains metadata about a restore job.
    public struct RestoreJobsListMember: Swift.Equatable {
        /// The account ID that owns the restore job.
        public var accountId: Swift.String?
        /// The size, in bytes, of the restored resource.
        public var backupSizeInBytes: Swift.Int?
        /// The date and time a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: ClientRuntime.Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var createdResourceArn: Swift.String?
        /// The date and time a restore job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// The amount of time in minutes that a job restoring a recovery point is expected to take.
        public var expectedCompletionTimeMinutes: Swift.Int?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// Contains an estimated percentage complete of a job at the time the job status was queried.
        public var percentDone: Swift.String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// The resource type of the listed restore jobs; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?
        /// Uniquely identifies the job that restores a recovery point.
        public var restoreJobId: Swift.String?
        /// A status code specifying the state of the job initiated by Backup to restore a recovery point.
        public var status: BackupClientTypes.RestoreJobStatus?
        /// A detailed message explaining the status of the job to restore a recovery point.
        public var statusMessage: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            backupSizeInBytes: Swift.Int? = nil,
            completionDate: ClientRuntime.Date? = nil,
            createdResourceArn: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            expectedCompletionTimeMinutes: Swift.Int? = nil,
            iamRoleArn: Swift.String? = nil,
            percentDone: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            restoreJobId: Swift.String? = nil,
            status: BackupClientTypes.RestoreJobStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.backupSizeInBytes = backupSizeInBytes
            self.completionDate = completionDate
            self.createdResourceArn = createdResourceArn
            self.creationDate = creationDate
            self.expectedCompletionTimeMinutes = expectedCompletionTimeMinutes
            self.iamRoleArn = iamRoleArn
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.resourceType = resourceType
            self.restoreJobId = restoreJobId
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed due to a temporary failure of the server.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        ///
        public internal(set) var context: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
        self.properties.type = type
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension StartBackupJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartBackupJobInput(backupOptions: \(Swift.String(describing: backupOptions)), backupVaultName: \(Swift.String(describing: backupVaultName)), completeWindowMinutes: \(Swift.String(describing: completeWindowMinutes)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), lifecycle: \(Swift.String(describing: lifecycle)), resourceArn: \(Swift.String(describing: resourceArn)), startWindowMinutes: \(Swift.String(describing: startWindowMinutes)), recoveryPointTags: \"CONTENT_REDACTED\")"}
}

extension StartBackupJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupOptions = "BackupOptions"
        case backupVaultName = "BackupVaultName"
        case completeWindowMinutes = "CompleteWindowMinutes"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case resourceArn = "ResourceArn"
        case startWindowMinutes = "StartWindowMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupOptions = backupOptions {
            var backupOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupOptions)
            for (dictKey0, backupOptions0) in backupOptions {
                try backupOptionsContainer.encode(backupOptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let backupVaultName = self.backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let completeWindowMinutes = self.completeWindowMinutes {
            try encodeContainer.encode(completeWindowMinutes, forKey: .completeWindowMinutes)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointTags = recoveryPointTags {
            var recoveryPointTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .recoveryPointTags)
            for (dictKey0, tags0) in recoveryPointTags {
                try recoveryPointTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let startWindowMinutes = self.startWindowMinutes {
            try encodeContainer.encode(startWindowMinutes, forKey: .startWindowMinutes)
        }
    }
}

extension StartBackupJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backup-jobs"
    }
}

public struct StartBackupJobInput: Swift.Equatable {
    /// Specifies the backup option for a selected resource. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS""disabled" to create a regular backup. The WindowsVSS option is not enabled by default.
    public var backupOptions: [Swift.String:Swift.String]?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// A value in minutes during which a successfully started backup must complete, or else Backup will cancel the job. This value is optional. This value begins counting down from when the backup was scheduled. It does not add additional time for StartWindowMinutes, or if the backup started later than scheduled. Like StartWindowMinutes, this parameter has a maximum value of 100 years (52,560,000 minutes).
    public var completeWindowMinutes: Swift.Int?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartBackupJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup will transition and expire backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the retention setting must be 90 days greater than the transition to cold after days setting. The transition to cold after days setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types. This parameter has a maximum value of 100 years (36,500 days).
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair.
    public var recoveryPointTags: [Swift.String:Swift.String]?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional, and the default is 8 hours. If this value is included, it must be at least 60 minutes to avoid errors. This parameter has a maximum value of 100 years (52,560,000 minutes). During the start window, the backup job status remains in CREATED status until it has successfully begun or until the start window time has run out. If within the start window time Backup receives an error that allows the job to be retried, Backup will automatically retry to begin the job at least every 10 minutes until the backup successfully begins (the job status changes to RUNNING) or until the job status changes to EXPIRED (which is expected to occur when the start window time is over).
    public var startWindowMinutes: Swift.Int?

    public init(
        backupOptions: [Swift.String:Swift.String]? = nil,
        backupVaultName: Swift.String? = nil,
        completeWindowMinutes: Swift.Int? = nil,
        iamRoleArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointTags: [Swift.String:Swift.String]? = nil,
        resourceArn: Swift.String? = nil,
        startWindowMinutes: Swift.Int? = nil
    )
    {
        self.backupOptions = backupOptions
        self.backupVaultName = backupVaultName
        self.completeWindowMinutes = completeWindowMinutes
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.lifecycle = lifecycle
        self.recoveryPointTags = recoveryPointTags
        self.resourceArn = resourceArn
        self.startWindowMinutes = startWindowMinutes
    }
}

struct StartBackupJobInputBody: Swift.Equatable {
    let backupVaultName: Swift.String?
    let resourceArn: Swift.String?
    let iamRoleArn: Swift.String?
    let idempotencyToken: Swift.String?
    let startWindowMinutes: Swift.Int?
    let completeWindowMinutes: Swift.Int?
    let lifecycle: BackupClientTypes.Lifecycle?
    let recoveryPointTags: [Swift.String:Swift.String]?
    let backupOptions: [Swift.String:Swift.String]?
}

extension StartBackupJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupOptions = "BackupOptions"
        case backupVaultName = "BackupVaultName"
        case completeWindowMinutes = "CompleteWindowMinutes"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case resourceArn = "ResourceArn"
        case startWindowMinutes = "StartWindowMinutes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let startWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startWindowMinutes)
        startWindowMinutes = startWindowMinutesDecoded
        let completeWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completeWindowMinutes)
        completeWindowMinutes = completeWindowMinutesDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let recoveryPointTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .recoveryPointTags)
        var recoveryPointTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let recoveryPointTagsContainer = recoveryPointTagsContainer {
            recoveryPointTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in recoveryPointTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    recoveryPointTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        recoveryPointTags = recoveryPointTagsDecoded0
        let backupOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
    }
}

extension StartBackupJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartBackupJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupJobId = output.backupJobId
            self.creationDate = output.creationDate
            self.isParent = output.isParent
            self.recoveryPointArn = output.recoveryPointArn
        } else {
            self.backupJobId = nil
            self.creationDate = nil
            self.isParent = false
            self.recoveryPointArn = nil
        }
    }
}

public struct StartBackupJobOutput: Swift.Equatable {
    /// Uniquely identifies a request to Backup to back up a resource.
    public var backupJobId: Swift.String?
    /// The date and time that a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// This is a returned boolean value indicating this is a parent (composite) backup job.
    public var isParent: Swift.Bool
    /// Note: This field is only returned for Amazon EFS and Advanced DynamoDB resources. An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?

    public init(
        backupJobId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        isParent: Swift.Bool = false,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
        self.creationDate = creationDate
        self.isParent = isParent
        self.recoveryPointArn = recoveryPointArn
    }
}

struct StartBackupJobOutputBody: Swift.Equatable {
    let backupJobId: Swift.String?
    let recoveryPointArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let isParent: Swift.Bool
}

extension StartBackupJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupJobId = "BackupJobId"
        case creationDate = "CreationDate"
        case isParent = "IsParent"
        case recoveryPointArn = "RecoveryPointArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupJobId)
        backupJobId = backupJobIdDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
    }
}

enum StartBackupJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartCopyJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
        case sourceBackupVaultName = "SourceBackupVaultName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationBackupVaultArn = self.destinationBackupVaultArn {
            try encodeContainer.encode(destinationBackupVaultArn, forKey: .destinationBackupVaultArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let sourceBackupVaultName = self.sourceBackupVaultName {
            try encodeContainer.encode(sourceBackupVaultName, forKey: .sourceBackupVaultName)
        }
    }
}

extension StartCopyJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/copy-jobs"
    }
}

public struct StartCopyJobInput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a destination backup vault to copy to; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    /// This member is required.
    public var destinationBackupVaultArn: Swift.String?
    /// Specifies the IAM role ARN used to copy the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartCopyJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// Contains an array of Transition objects specifying how long in days before a recovery point transitions to cold storage or is deleted. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the retention setting must be 90 days greater than the transition to cold after days setting. The transition to cold after days setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// An ARN that uniquely identifies a recovery point to use for the copy job; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?
    /// The name of a logical source container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var sourceBackupVaultName: Swift.String?

    public init(
        destinationBackupVaultArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointArn: Swift.String? = nil,
        sourceBackupVaultName: Swift.String? = nil
    )
    {
        self.destinationBackupVaultArn = destinationBackupVaultArn
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
        self.sourceBackupVaultName = sourceBackupVaultName
    }
}

struct StartCopyJobInputBody: Swift.Equatable {
    let recoveryPointArn: Swift.String?
    let sourceBackupVaultName: Swift.String?
    let destinationBackupVaultArn: Swift.String?
    let iamRoleArn: Swift.String?
    let idempotencyToken: Swift.String?
    let lifecycle: BackupClientTypes.Lifecycle?
}

extension StartCopyJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
        case sourceBackupVaultName = "SourceBackupVaultName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let sourceBackupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupVaultName)
        sourceBackupVaultName = sourceBackupVaultNameDecoded
        let destinationBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationBackupVaultArn)
        destinationBackupVaultArn = destinationBackupVaultArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

extension StartCopyJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartCopyJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.copyJobId = output.copyJobId
            self.creationDate = output.creationDate
            self.isParent = output.isParent
        } else {
            self.copyJobId = nil
            self.creationDate = nil
            self.isParent = false
        }
    }
}

public struct StartCopyJobOutput: Swift.Equatable {
    /// Uniquely identifies a copy job.
    public var copyJobId: Swift.String?
    /// The date and time that a copy job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// This is a returned boolean value indicating this is a parent (composite) copy job.
    public var isParent: Swift.Bool

    public init(
        copyJobId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        isParent: Swift.Bool = false
    )
    {
        self.copyJobId = copyJobId
        self.creationDate = creationDate
        self.isParent = isParent
    }
}

struct StartCopyJobOutputBody: Swift.Equatable {
    let copyJobId: Swift.String?
    let creationDate: ClientRuntime.Date?
    let isParent: Swift.Bool
}

extension StartCopyJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyJobId = "CopyJobId"
        case creationDate = "CreationDate"
        case isParent = "IsParent"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .copyJobId)
        copyJobId = copyJobIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
    }
}

enum StartCopyJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartReportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
    }
}

extension StartReportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportPlanName = reportPlanName else {
            return nil
        }
        return "/audit/report-jobs/\(reportPlanName.urlPercentEncoding())"
    }
}

public struct StartReportJobInput: Swift.Equatable {
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartReportJobInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// The unique name of a report plan.
    /// This member is required.
    public var reportPlanName: Swift.String?

    public init(
        idempotencyToken: Swift.String? = nil,
        reportPlanName: Swift.String? = nil
    )
    {
        self.idempotencyToken = idempotencyToken
        self.reportPlanName = reportPlanName
    }
}

struct StartReportJobInputBody: Swift.Equatable {
    let idempotencyToken: Swift.String?
}

extension StartReportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension StartReportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartReportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.reportJobId = output.reportJobId
        } else {
            self.reportJobId = nil
        }
    }
}

public struct StartReportJobOutput: Swift.Equatable {
    /// The identifier of the report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. The report job ID cannot be edited.
    public var reportJobId: Swift.String?

    public init(
        reportJobId: Swift.String? = nil
    )
    {
        self.reportJobId = reportJobId
    }
}

struct StartReportJobOutputBody: Swift.Equatable {
    let reportJobId: Swift.String?
}

extension StartReportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportJobId = "ReportJobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportJobId)
        reportJobId = reportJobIdDecoded
    }
}

enum StartReportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartRestoreJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartRestoreJobInput(copySourceTagsToRestoredResource: \(Swift.String(describing: copySourceTagsToRestoredResource)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), resourceType: \(Swift.String(describing: resourceType)), metadata: \"CONTENT_REDACTED\")"}
}

extension StartRestoreJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copySourceTagsToRestoredResource = "CopySourceTagsToRestoredResource"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case metadata = "Metadata"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copySourceTagsToRestoredResource = self.copySourceTagsToRestoredResource {
            try encodeContainer.encode(copySourceTagsToRestoredResource, forKey: .copySourceTagsToRestoredResource)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, metadata0) in metadata {
                try metadataContainer.encode(metadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension StartRestoreJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/restore-jobs"
    }
}

public struct StartRestoreJobInput: Swift.Equatable {
    /// This is an optional parameter. If this equals True, tags included in the backup will be copied to the restored resource. This can only be applied to backups created through Backup.
    public var copySourceTagsToRestoredResource: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role that Backup uses to create the target resource; for example: arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartRestoreJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// A set of metadata key-value pairs. Contains information, such as a resource name, required to restore a recovery point. You can get configuration metadata about a resource at the time it was backed up by calling GetRecoveryPointRestoreMetadata. However, values in addition to those provided by GetRecoveryPointRestoreMetadata might be required to restore a resource. For example, you might need to provide a new resource name if the original already exists. You need to specify specific metadata to restore an Amazon Elastic File System (Amazon EFS) instance:
    ///
    /// * file-system-id: The ID of the Amazon EFS file system that is backed up by Backup. Returned in GetRecoveryPointRestoreMetadata.
    ///
    /// * Encrypted: A Boolean value that, if true, specifies that the file system is encrypted. If KmsKeyId is specified, Encrypted must be set to true.
    ///
    /// * KmsKeyId: Specifies the Amazon Web Services KMS key that is used to encrypt the restored file system. You can specify a key from another Amazon Web Services account provided that key it is properly shared with your account via Amazon Web Services KMS.
    ///
    /// * PerformanceMode: Specifies the throughput mode of the file system.
    ///
    /// * CreationToken: A user-supplied value that ensures the uniqueness (idempotency) of the request.
    ///
    /// * newFileSystem: A Boolean value that, if true, specifies that the recovery point is restored to a new Amazon EFS file system.
    ///
    /// * ItemsToRestore: An array of one to five strings where each string is a file path. Use ItemsToRestore to restore specific files or directories rather than the entire file system. This parameter is optional. For example, "itemsToRestore":"[\"/my.test\"]".
    /// This member is required.
    public var metadata: [Swift.String:Swift.String]?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?
    /// Starts a job to restore a recovery point for one of the following resources:
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * DocumentDB for Amazon DocumentDB (with MongoDB compatibility)
    ///
    /// * CloudFormation for CloudFormation
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * FSx for Amazon FSx
    ///
    /// * Neptune for Amazon Neptune
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Redshift for Amazon Redshift
    ///
    /// * Storage Gateway for Storage Gateway
    ///
    /// * S3 for Amazon S3
    ///
    /// * Timestream for Amazon Timestream
    ///
    /// * VirtualMachine for virtual machines
    public var resourceType: Swift.String?

    public init(
        copySourceTagsToRestoredResource: Swift.Bool? = nil,
        iamRoleArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.copySourceTagsToRestoredResource = copySourceTagsToRestoredResource
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.metadata = metadata
        self.recoveryPointArn = recoveryPointArn
        self.resourceType = resourceType
    }
}

struct StartRestoreJobInputBody: Swift.Equatable {
    let recoveryPointArn: Swift.String?
    let metadata: [Swift.String:Swift.String]?
    let iamRoleArn: Swift.String?
    let idempotencyToken: Swift.String?
    let resourceType: Swift.String?
    let copySourceTagsToRestoredResource: Swift.Bool?
}

extension StartRestoreJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copySourceTagsToRestoredResource = "CopySourceTagsToRestoredResource"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case metadata = "Metadata"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, metadatavalue0) in metadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    metadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        metadata = metadataDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let copySourceTagsToRestoredResourceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copySourceTagsToRestoredResource)
        copySourceTagsToRestoredResource = copySourceTagsToRestoredResourceDecoded
    }
}

extension StartRestoreJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartRestoreJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.restoreJobId = output.restoreJobId
        } else {
            self.restoreJobId = nil
        }
    }
}

public struct StartRestoreJobOutput: Swift.Equatable {
    /// Uniquely identifies the job that restores a recovery point.
    public var restoreJobId: Swift.String?

    public init(
        restoreJobId: Swift.String? = nil
    )
    {
        self.restoreJobId = restoreJobId
    }
}

struct StartRestoreJobOutputBody: Swift.Equatable {
    let restoreJobId: Swift.String?
}

extension StartRestoreJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case restoreJobId = "RestoreJobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restoreJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreJobId)
        restoreJobId = restoreJobIdDecoded
    }
}

enum StartRestoreJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopBackupJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupJobId = backupJobId else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())"
    }
}

public struct StopBackupJobInput: Swift.Equatable {
    /// Uniquely identifies a request to Backup to back up a resource.
    /// This member is required.
    public var backupJobId: Swift.String?

    public init(
        backupJobId: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
    }
}

struct StopBackupJobInputBody: Swift.Equatable {
}

extension StopBackupJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopBackupJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopBackupJobOutput: Swift.Equatable {

    public init() { }
}

enum StopBackupJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BackupClientTypes {
    public enum StorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cold
        case deleted
        case warm
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageClass] {
            return [
                .cold,
                .deleted,
                .warm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cold: return "COLD"
            case .deleted: return "DELETED"
            case .warm: return "WARM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the type of the tagged resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Key-value pairs that are used to help organize your resources. You can assign your own metadata to the resources you create. For clarity, this is the structure to assign tags: [{"Key":"string","Value":"string"}].
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeyList: \"CONTENT_REDACTED\")"}
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for string0 in tagKeyList {
                try tagKeyListContainer.encode(string0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/untag/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the type of the tagged resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys to identify which key-value tags to remove from a resource.
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeyList = tagKeyList
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let tagKeyList: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeyList = "TagKeyList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[Swift.String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [Swift.String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBackupPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlan = self.backupPlan {
            try encodeContainer.encode(backupPlan, forKey: .backupPlan)
        }
    }
}

extension UpdateBackupPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())"
    }
}

public struct UpdateBackupPlanInput: Swift.Equatable {
    /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    /// This member is required.
    public var backupPlan: BackupClientTypes.BackupPlanInput?
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?

    public init(
        backupPlan: BackupClientTypes.BackupPlanInput? = nil,
        backupPlanId: Swift.String? = nil
    )
    {
        self.backupPlan = backupPlan
        self.backupPlanId = backupPlanId
    }
}

struct UpdateBackupPlanInputBody: Swift.Equatable {
    let backupPlan: BackupClientTypes.BackupPlanInput?
}

extension UpdateBackupPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlanInput.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
    }
}

extension UpdateBackupPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBackupPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.advancedBackupSettings = output.advancedBackupSettings
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.versionId = output.versionId
        } else {
            self.advancedBackupSettings = nil
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.creationDate = nil
            self.versionId = nil
        }
    }
}

public struct UpdateBackupPlanOutput: Swift.Equatable {
    /// Contains a list of BackupOptions for each resource type.
    public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version Ids cannot be edited.
    public var versionId: Swift.String?

    public init(
        advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.versionId = versionId
    }
}

struct UpdateBackupPlanOutputBody: Swift.Equatable {
    let backupPlanId: Swift.String?
    let backupPlanArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let versionId: Swift.String?
    let advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
}

extension UpdateBackupPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case versionId = "VersionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

enum UpdateBackupPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFrameworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case idempotencyToken = "IdempotencyToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameworkControls = frameworkControls {
            var frameworkControlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .frameworkControls)
            for frameworkcontrol0 in frameworkControls {
                try frameworkControlsContainer.encode(frameworkcontrol0)
            }
        }
        if let frameworkDescription = self.frameworkDescription {
            try encodeContainer.encode(frameworkDescription, forKey: .frameworkDescription)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
    }
}

extension UpdateFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let frameworkName = frameworkName else {
            return nil
        }
        return "/audit/frameworks/\(frameworkName.urlPercentEncoding())"
    }
}

public struct UpdateFrameworkInput: Swift.Equatable {
    /// A list of the controls that make up the framework. Each control in the list has a name, input parameters, and scope.
    public var frameworkControls: [BackupClientTypes.FrameworkControl]?
    /// An optional description of the framework with a maximum 1,024 characters.
    public var frameworkDescription: Swift.String?
    /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var frameworkName: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to UpdateFrameworkInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?

    public init(
        frameworkControls: [BackupClientTypes.FrameworkControl]? = nil,
        frameworkDescription: Swift.String? = nil,
        frameworkName: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil
    )
    {
        self.frameworkControls = frameworkControls
        self.frameworkDescription = frameworkDescription
        self.frameworkName = frameworkName
        self.idempotencyToken = idempotencyToken
    }
}

struct UpdateFrameworkInputBody: Swift.Equatable {
    let frameworkDescription: Swift.String?
    let frameworkControls: [BackupClientTypes.FrameworkControl]?
    let idempotencyToken: Swift.String?
}

extension UpdateFrameworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case idempotencyToken = "IdempotencyToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkDescription)
        frameworkDescription = frameworkDescriptionDecoded
        let frameworkControlsContainer = try containerValues.decodeIfPresent([BackupClientTypes.FrameworkControl?].self, forKey: .frameworkControls)
        var frameworkControlsDecoded0:[BackupClientTypes.FrameworkControl]? = nil
        if let frameworkControlsContainer = frameworkControlsContainer {
            frameworkControlsDecoded0 = [BackupClientTypes.FrameworkControl]()
            for structure0 in frameworkControlsContainer {
                if let structure0 = structure0 {
                    frameworkControlsDecoded0?.append(structure0)
                }
            }
        }
        frameworkControls = frameworkControlsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension UpdateFrameworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFrameworkOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.frameworkArn = output.frameworkArn
            self.frameworkName = output.frameworkName
        } else {
            self.creationTime = nil
            self.frameworkArn = nil
            self.frameworkName = nil
        }
    }
}

public struct UpdateFrameworkOutput: Swift.Equatable {
    /// The date and time that a framework is created, in ISO 8601 representation. The value of CreationTime is accurate to milliseconds. For example, 2020-07-10T15:00:00.000-08:00 represents the 10th of July 2020 at 3:00 PM 8 hours behind UTC.
    public var creationTime: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var frameworkArn: Swift.String?
    /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    public var frameworkName: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        frameworkArn: Swift.String? = nil,
        frameworkName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.frameworkArn = frameworkArn
        self.frameworkName = frameworkName
    }
}

struct UpdateFrameworkOutputBody: Swift.Equatable {
    let frameworkName: Swift.String?
    let frameworkArn: Swift.String?
    let creationTime: ClientRuntime.Date?
}

extension UpdateFrameworkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case frameworkArn = "FrameworkArn"
        case frameworkName = "FrameworkName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkArn)
        frameworkArn = frameworkArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum UpdateFrameworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGlobalSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalSettings = "GlobalSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let globalSettings = globalSettings {
            var globalSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .globalSettings)
            for (dictKey0, globalSettings0) in globalSettings {
                try globalSettingsContainer.encode(globalSettings0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateGlobalSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/global-settings"
    }
}

public struct UpdateGlobalSettingsInput: Swift.Equatable {
    /// A value for isCrossAccountBackupEnabled and a Region. Example: update-global-settings --global-settings isCrossAccountBackupEnabled=false --region us-west-2.
    public var globalSettings: [Swift.String:Swift.String]?

    public init(
        globalSettings: [Swift.String:Swift.String]? = nil
    )
    {
        self.globalSettings = globalSettings
    }
}

struct UpdateGlobalSettingsInputBody: Swift.Equatable {
    let globalSettings: [Swift.String:Swift.String]?
}

extension UpdateGlobalSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalSettings = "GlobalSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalSettingsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .globalSettings)
        var globalSettingsDecoded0: [Swift.String:Swift.String]? = nil
        if let globalSettingsContainer = globalSettingsContainer {
            globalSettingsDecoded0 = [Swift.String:Swift.String]()
            for (key0, globalsettingsvalue0) in globalSettingsContainer {
                if let globalsettingsvalue0 = globalsettingsvalue0 {
                    globalSettingsDecoded0?[key0] = globalsettingsvalue0
                }
            }
        }
        globalSettings = globalSettingsDecoded0
    }
}

extension UpdateGlobalSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateGlobalSettingsOutput: Swift.Equatable {

    public init() { }
}

enum UpdateGlobalSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRecoveryPointLifecycleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycle = "Lifecycle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
    }
}

extension UpdateRecoveryPointLifecycleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())"
    }
}

public struct UpdateRecoveryPointLifecycleInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the retention setting must be 90 days greater than the transition to cold after days setting. The transition to cold after days setting cannot be changed after a backup has been transitioned to cold.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultName: Swift.String? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
    }
}

struct UpdateRecoveryPointLifecycleInputBody: Swift.Equatable {
    let lifecycle: BackupClientTypes.Lifecycle?
}

extension UpdateRecoveryPointLifecycleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycle = "Lifecycle"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

extension UpdateRecoveryPointLifecycleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRecoveryPointLifecycleOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.calculatedLifecycle = output.calculatedLifecycle
            self.lifecycle = output.lifecycle
            self.recoveryPointArn = output.recoveryPointArn
        } else {
            self.backupVaultArn = nil
            self.calculatedLifecycle = nil
            self.lifecycle = nil
            self.recoveryPointArn = nil
        }
    }
}

public struct UpdateRecoveryPointLifecycleOutput: Swift.Equatable {
    /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
    public var calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the retention setting must be 90 days greater than the transition to cold after days setting. The transition to cold after days setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?

    public init(
        backupVaultArn: Swift.String? = nil,
        calculatedLifecycle: BackupClientTypes.CalculatedLifecycle? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.calculatedLifecycle = calculatedLifecycle
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
    }
}

struct UpdateRecoveryPointLifecycleOutputBody: Swift.Equatable {
    let backupVaultArn: Swift.String?
    let recoveryPointArn: Swift.String?
    let lifecycle: BackupClientTypes.Lifecycle?
    let calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
}

extension UpdateRecoveryPointLifecycleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case calculatedLifecycle = "CalculatedLifecycle"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let calculatedLifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CalculatedLifecycle.self, forKey: .calculatedLifecycle)
        calculatedLifecycle = calculatedLifecycleDecoded
    }
}

enum UpdateRecoveryPointLifecycleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRegionSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTypeManagementPreference = "ResourceTypeManagementPreference"
        case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceTypeManagementPreference = resourceTypeManagementPreference {
            var resourceTypeManagementPreferenceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTypeManagementPreference)
            for (dictKey0, resourceTypeManagementPreference0) in resourceTypeManagementPreference {
                try resourceTypeManagementPreferenceContainer.encode(resourceTypeManagementPreference0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceTypeOptInPreference = resourceTypeOptInPreference {
            var resourceTypeOptInPreferenceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTypeOptInPreference)
            for (dictKey0, resourceTypeOptInPreference0) in resourceTypeOptInPreference {
                try resourceTypeOptInPreferenceContainer.encode(resourceTypeOptInPreference0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateRegionSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account-settings"
    }
}

public struct UpdateRegionSettingsInput: Swift.Equatable {
    /// Enables or disables full Backup management of backups for a resource type. To enable full Backup management for DynamoDB along with [ Backup's advanced DynamoDB backup features](https://docs.aws.amazon.com/aws-backup/latest/devguide/advanced-ddb-backup.html), follow the procedure to [ enable advanced DynamoDB backup programmatically](https://docs.aws.amazon.com/aws-backup/latest/devguide/advanced-ddb-backup.html#advanced-ddb-backup-enable-cli).
    public var resourceTypeManagementPreference: [Swift.String:Swift.Bool]?
    /// Updates the list of services along with the opt-in preferences for the Region.
    public var resourceTypeOptInPreference: [Swift.String:Swift.Bool]?

    public init(
        resourceTypeManagementPreference: [Swift.String:Swift.Bool]? = nil,
        resourceTypeOptInPreference: [Swift.String:Swift.Bool]? = nil
    )
    {
        self.resourceTypeManagementPreference = resourceTypeManagementPreference
        self.resourceTypeOptInPreference = resourceTypeOptInPreference
    }
}

struct UpdateRegionSettingsInputBody: Swift.Equatable {
    let resourceTypeOptInPreference: [Swift.String:Swift.Bool]?
    let resourceTypeManagementPreference: [Swift.String:Swift.Bool]?
}

extension UpdateRegionSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTypeManagementPreference = "ResourceTypeManagementPreference"
        case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeOptInPreferenceContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .resourceTypeOptInPreference)
        var resourceTypeOptInPreferenceDecoded0: [Swift.String:Swift.Bool]? = nil
        if let resourceTypeOptInPreferenceContainer = resourceTypeOptInPreferenceContainer {
            resourceTypeOptInPreferenceDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, isenabled0) in resourceTypeOptInPreferenceContainer {
                if let isenabled0 = isenabled0 {
                    resourceTypeOptInPreferenceDecoded0?[key0] = isenabled0
                }
            }
        }
        resourceTypeOptInPreference = resourceTypeOptInPreferenceDecoded0
        let resourceTypeManagementPreferenceContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .resourceTypeManagementPreference)
        var resourceTypeManagementPreferenceDecoded0: [Swift.String:Swift.Bool]? = nil
        if let resourceTypeManagementPreferenceContainer = resourceTypeManagementPreferenceContainer {
            resourceTypeManagementPreferenceDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, isenabled0) in resourceTypeManagementPreferenceContainer {
                if let isenabled0 = isenabled0 {
                    resourceTypeManagementPreferenceDecoded0?[key0] = isenabled0
                }
            }
        }
        resourceTypeManagementPreference = resourceTypeManagementPreferenceDecoded0
    }
}

extension UpdateRegionSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRegionSettingsOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRegionSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateReportPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanDescription = "ReportPlanDescription"
        case reportSetting = "ReportSetting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let reportDeliveryChannel = self.reportDeliveryChannel {
            try encodeContainer.encode(reportDeliveryChannel, forKey: .reportDeliveryChannel)
        }
        if let reportPlanDescription = self.reportPlanDescription {
            try encodeContainer.encode(reportPlanDescription, forKey: .reportPlanDescription)
        }
        if let reportSetting = self.reportSetting {
            try encodeContainer.encode(reportSetting, forKey: .reportSetting)
        }
    }
}

extension UpdateReportPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportPlanName = reportPlanName else {
            return nil
        }
        return "/audit/report-plans/\(reportPlanName.urlPercentEncoding())"
    }
}

public struct UpdateReportPlanInput: Swift.Equatable {
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to UpdateReportPlanInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// A structure that contains information about where to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
    public var reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
    /// An optional description of the report plan with a maximum 1,024 characters.
    public var reportPlanDescription: Swift.String?
    /// The unique name of the report plan. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var reportPlanName: Swift.String?
    /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
    public var reportSetting: BackupClientTypes.ReportSetting?

    public init(
        idempotencyToken: Swift.String? = nil,
        reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel? = nil,
        reportPlanDescription: Swift.String? = nil,
        reportPlanName: Swift.String? = nil,
        reportSetting: BackupClientTypes.ReportSetting? = nil
    )
    {
        self.idempotencyToken = idempotencyToken
        self.reportDeliveryChannel = reportDeliveryChannel
        self.reportPlanDescription = reportPlanDescription
        self.reportPlanName = reportPlanName
        self.reportSetting = reportSetting
    }
}

struct UpdateReportPlanInputBody: Swift.Equatable {
    let reportPlanDescription: Swift.String?
    let reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
    let reportSetting: BackupClientTypes.ReportSetting?
    let idempotencyToken: Swift.String?
}

extension UpdateReportPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanDescription = "ReportPlanDescription"
        case reportSetting = "ReportSetting"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanDescription)
        reportPlanDescription = reportPlanDescriptionDecoded
        let reportDeliveryChannelDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportDeliveryChannel.self, forKey: .reportDeliveryChannel)
        reportDeliveryChannel = reportDeliveryChannelDecoded
        let reportSettingDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportSetting.self, forKey: .reportSetting)
        reportSetting = reportSettingDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension UpdateReportPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateReportPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.reportPlanArn = output.reportPlanArn
            self.reportPlanName = output.reportPlanName
        } else {
            self.creationTime = nil
            self.reportPlanArn = nil
            self.reportPlanName = nil
        }
    }
}

public struct UpdateReportPlanOutput: Swift.Equatable {
    /// The date and time that a report plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationTime: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var reportPlanArn: Swift.String?
    /// The unique name of the report plan.
    public var reportPlanName: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        reportPlanArn: Swift.String? = nil,
        reportPlanName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.reportPlanArn = reportPlanArn
        self.reportPlanName = reportPlanName
    }
}

struct UpdateReportPlanOutputBody: Swift.Equatable {
    let reportPlanName: Swift.String?
    let reportPlanArn: Swift.String?
    let creationTime: ClientRuntime.Date?
}

extension UpdateReportPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case reportPlanArn = "ReportPlanArn"
        case reportPlanName = "ReportPlanName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanName)
        reportPlanName = reportPlanNameDecoded
        let reportPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanArn)
        reportPlanArn = reportPlanArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum UpdateReportPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterValueException": return try await MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BackupClientTypes {
    public enum VaultState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [VaultState] {
            return [
                .available,
                .creating,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VaultState(rawValue: rawValue) ?? VaultState.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes {
    public enum VaultType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backupVault
        case logicallyAirGappedBackupVault
        case sdkUnknown(Swift.String)

        public static var allCases: [VaultType] {
            return [
                .backupVault,
                .logicallyAirGappedBackupVault,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backupVault: return "BACKUP_VAULT"
            case .logicallyAirGappedBackupVault: return "LOGICALLY_AIR_GAPPED_BACKUP_VAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VaultType(rawValue: rawValue) ?? VaultType.sdkUnknown(rawValue)
        }
    }
}
