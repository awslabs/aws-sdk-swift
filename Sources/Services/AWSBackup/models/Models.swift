// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BackupClientTypes.AdvancedBackupSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupOptions = "BackupOptions"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupOptions = backupOptions {
            var backupOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupOptions)
            for (dictKey0, backupOptions0) in backupOptions {
                try backupOptionsContainer.encode(backupOptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let backupOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
    }
}

extension BackupClientTypes {
    /// A list of backup options for each resource type.
    public struct AdvancedBackupSetting: Swift.Equatable {
        /// Specifies the backup option for a selected resource. This option is only available for Windows VSS backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS":"disabled" to create a regular backup. The WindowsVSS option is not enabled by default. If you specify an invalid option, you get an InvalidParameterValueException exception. For more information about Windows VSS backups, see [Creating a VSS-Enabled Windows Backup](https://docs.aws.amazon.com/aws-backup/latest/devguide/windows-backups.html).
        public var backupOptions: [Swift.String:Swift.String]?
        /// Specifies an object containing resource type and backup options. The only supported resource type is Amazon EC2 instances with Windows Volume Shadow Copy Service (VSS). For a CloudFormation example, see the [sample CloudFormation template to enable Windows VSS](https://docs.aws.amazon.com/aws-backup/latest/devguide/integrate-cloudformation-with-aws-backup.html) in the Backup User Guide. Valid values: EC2.
        public var resourceType: Swift.String?

        public init (
            backupOptions: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.backupOptions = backupOptions
            self.resourceType = resourceType
        }
    }

}

extension AlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.code = output.code
            self.context = output.context
            self.creatorRequestId = output.creatorRequestId
            self.message = output.message
            self.type = output.type
        } else {
            self.arn = nil
            self.code = nil
            self.context = nil
            self.creatorRequestId = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The required resource already exists.
public struct AlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var arn: Swift.String?
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    ///
    public var creatorRequestId: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        arn: Swift.String? = nil,
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        creatorRequestId: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.arn = arn
        self.code = code
        self.context = context
        self.creatorRequestId = creatorRequestId
        self.message = message
        self.type = type
    }
}

struct AlreadyExistsExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let creatorRequestId: Swift.String?
    let arn: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension AlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case code = "Code"
        case context = "Context"
        case creatorRequestId = "CreatorRequestId"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes.BackupJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupJobId = "BackupJobId"
        case backupOptions = "BackupOptions"
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupType = "BackupType"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case bytesTransferred = "BytesTransferred"
        case completionDate = "CompletionDate"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case expectedCompletionDate = "ExpectedCompletionDate"
        case iamRoleArn = "IamRoleArn"
        case isParent = "IsParent"
        case parentJobId = "ParentJobId"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case startBy = "StartBy"
        case state = "State"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let backupJobId = self.backupJobId {
            try encodeContainer.encode(backupJobId, forKey: .backupJobId)
        }
        if let backupOptions = backupOptions {
            var backupOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupOptions)
            for (dictKey0, backupOptions0) in backupOptions {
                try backupOptionsContainer.encode(backupOptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let backupSizeInBytes = self.backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let backupType = self.backupType {
            try encodeContainer.encode(backupType, forKey: .backupType)
        }
        if let backupVaultArn = self.backupVaultArn {
            try encodeContainer.encode(backupVaultArn, forKey: .backupVaultArn)
        }
        if let backupVaultName = self.backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let bytesTransferred = self.bytesTransferred {
            try encodeContainer.encode(bytesTransferred, forKey: .bytesTransferred)
        }
        if let completionDate = self.completionDate {
            try encodeContainer.encodeTimestamp(completionDate, format: .epochSeconds, forKey: .completionDate)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let expectedCompletionDate = self.expectedCompletionDate {
            try encodeContainer.encodeTimestamp(expectedCompletionDate, format: .epochSeconds, forKey: .expectedCompletionDate)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if isParent != false {
            try encodeContainer.encode(isParent, forKey: .isParent)
        }
        if let parentJobId = self.parentJobId {
            try encodeContainer.encode(parentJobId, forKey: .parentJobId)
        }
        if let percentDone = self.percentDone {
            try encodeContainer.encode(percentDone, forKey: .percentDone)
        }
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let startBy = self.startBy {
            try encodeContainer.encodeTimestamp(startBy, format: .epochSeconds, forKey: .startBy)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let backupJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupJobId)
        backupJobId = backupJobIdDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDate)
        completionDate = completionDateDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupJobState.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let expectedCompletionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expectedCompletionDate)
        expectedCompletionDate = expectedCompletionDateDecoded
        let startByDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startBy)
        startBy = startByDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let bytesTransferredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesTransferred)
        bytesTransferred = bytesTransferredDecoded
        let backupOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
        let backupTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupType)
        backupType = backupTypeDecoded
        let parentJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentJobId)
        parentJobId = parentJobIdDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about a backup job.
    public struct BackupJob: Swift.Equatable {
        /// The account ID that owns the backup job.
        public var accountId: Swift.String?
        /// Uniquely identifies a request to Backup to back up a resource.
        public var backupJobId: Swift.String?
        /// Specifies the backup option for a selected resource. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS":"disabled" to create a regular backup. If you specify an invalid option, you get an InvalidParameterValueException exception.
        public var backupOptions: [Swift.String:Swift.String]?
        /// The size, in bytes, of a backup.
        public var backupSizeInBytes: Swift.Int?
        /// Represents the type of backup for a backup job.
        public var backupType: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// The size in bytes transferred to a backup vault at the time that the job status was queried.
        public var bytesTransferred: Swift.Int?
        /// The date and time a job to create a backup job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: ClientRuntime.Date?
        /// Contains identifying information about the creation of a backup job, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan used to create it.
        public var createdBy: BackupClientTypes.RecoveryPointCreator?
        /// The date and time a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// The date and time a job to back up resources is expected to be completed, in Unix format and Coordinated Universal Time (UTC). The value of ExpectedCompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var expectedCompletionDate: ClientRuntime.Date?
        /// Specifies the IAM role ARN used to create the target recovery point. IAM roles other than the default role must include either AWSBackup or AwsBackup in the role name. For example, arn:aws:iam::123456789012:role/AWSBackupRDSAccess. Role names without those strings lack permissions to perform backup jobs.
        public var iamRoleArn: Swift.String?
        /// This is a boolean value indicating this is a parent (composite) backup job.
        public var isParent: Swift.Bool
        /// This uniquely identifies a request to Backup to back up a resource. The return will be the parent (composite) job ID.
        public var parentJobId: Swift.String?
        /// Contains an estimated percentage complete of a job at the time the job status was queried.
        public var percentDone: Swift.String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var resourceArn: Swift.String?
        /// This is the non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?
        /// Specifies the time in Unix format and Coordinated Universal Time (UTC) when a backup job must be started before it is canceled. The value is calculated by adding the start window to the scheduled time. So if the scheduled time were 6:00 PM and the start window is 2 hours, the StartBy time would be 8:00 PM on the date specified. The value of StartBy is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var startBy: ClientRuntime.Date?
        /// The current state of a resource recovery point.
        public var state: BackupClientTypes.BackupJobState?
        /// A detailed message explaining the status of the job to back up a resource.
        public var statusMessage: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            backupJobId: Swift.String? = nil,
            backupOptions: [Swift.String:Swift.String]? = nil,
            backupSizeInBytes: Swift.Int? = nil,
            backupType: Swift.String? = nil,
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            bytesTransferred: Swift.Int? = nil,
            completionDate: ClientRuntime.Date? = nil,
            createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
            creationDate: ClientRuntime.Date? = nil,
            expectedCompletionDate: ClientRuntime.Date? = nil,
            iamRoleArn: Swift.String? = nil,
            isParent: Swift.Bool = false,
            parentJobId: Swift.String? = nil,
            percentDone: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            startBy: ClientRuntime.Date? = nil,
            state: BackupClientTypes.BackupJobState? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.backupJobId = backupJobId
            self.backupOptions = backupOptions
            self.backupSizeInBytes = backupSizeInBytes
            self.backupType = backupType
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.bytesTransferred = bytesTransferred
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.expectedCompletionDate = expectedCompletionDate
            self.iamRoleArn = iamRoleArn
            self.isParent = isParent
            self.parentJobId = parentJobId
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.startBy = startBy
            self.state = state
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes {
    public enum BackupJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case aborting
        case completed
        case created
        case expired
        case failed
        case partial
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupJobState] {
            return [
                .aborted,
                .aborting,
                .completed,
                .created,
                .expired,
                .failed,
                .partial,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .aborting: return "ABORTING"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .expired: return "EXPIRED"
            case .failed: return "FAILED"
            case .partial: return "PARTIAL"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupJobState(rawValue: rawValue) ?? BackupJobState.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.BackupPlan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanName = "BackupPlanName"
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedBackupSettings = advancedBackupSettings {
            var advancedBackupSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedBackupSettings)
            for advancedbackupsetting0 in advancedBackupSettings {
                try advancedBackupSettingsContainer.encode(advancedbackupsetting0)
            }
        }
        if let backupPlanName = self.backupPlanName {
            try encodeContainer.encode(backupPlanName, forKey: .backupPlanName)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for backuprule0 in rules {
                try rulesContainer.encode(backuprule0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanName)
        backupPlanName = backupPlanNameDecoded
        let rulesContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupRule?].self, forKey: .rules)
        var rulesDecoded0:[BackupClientTypes.BackupRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [BackupClientTypes.BackupRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension BackupClientTypes {
    /// Contains an optional backup plan display name and an array of BackupRule objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task and can back up a different selection of Amazon Web Services resources.
    public struct BackupPlan: Swift.Equatable {
        /// Contains a list of BackupOptions for each resource type.
        public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
        /// The display name of a backup plan. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var backupPlanName: Swift.String?
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        /// This member is required.
        public var rules: [BackupClientTypes.BackupRule]?

        public init (
            advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
            backupPlanName: Swift.String? = nil,
            rules: [BackupClientTypes.BackupRule]? = nil
        )
        {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.rules = rules
        }
    }

}

extension BackupClientTypes.BackupPlanInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanName = "BackupPlanName"
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedBackupSettings = advancedBackupSettings {
            var advancedBackupSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedBackupSettings)
            for advancedbackupsetting0 in advancedBackupSettings {
                try advancedBackupSettingsContainer.encode(advancedbackupsetting0)
            }
        }
        if let backupPlanName = self.backupPlanName {
            try encodeContainer.encode(backupPlanName, forKey: .backupPlanName)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for backupruleinput0 in rules {
                try rulesContainer.encode(backupruleinput0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanName)
        backupPlanName = backupPlanNameDecoded
        let rulesContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupRuleInput?].self, forKey: .rules)
        var rulesDecoded0:[BackupClientTypes.BackupRuleInput]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [BackupClientTypes.BackupRuleInput]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension BackupClientTypes {
    /// Contains an optional backup plan display name and an array of BackupRule objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task.
    public struct BackupPlanInput: Swift.Equatable {
        /// Specifies a list of BackupOptions for each resource type. These settings are only available for Windows Volume Shadow Copy Service (VSS) backup jobs.
        public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
        /// The display name of a backup plan. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var backupPlanName: Swift.String?
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        /// This member is required.
        public var rules: [BackupClientTypes.BackupRuleInput]?

        public init (
            advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
            backupPlanName: Swift.String? = nil,
            rules: [BackupClientTypes.BackupRuleInput]? = nil
        )
        {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.rules = rules
        }
    }

}

extension BackupClientTypes.BackupPlanTemplatesListMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplateId = "BackupPlanTemplateId"
        case backupPlanTemplateName = "BackupPlanTemplateName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanTemplateId = self.backupPlanTemplateId {
            try encodeContainer.encode(backupPlanTemplateId, forKey: .backupPlanTemplateId)
        }
        if let backupPlanTemplateName = self.backupPlanTemplateName {
            try encodeContainer.encode(backupPlanTemplateName, forKey: .backupPlanTemplateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanTemplateId)
        backupPlanTemplateId = backupPlanTemplateIdDecoded
        let backupPlanTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanTemplateName)
        backupPlanTemplateName = backupPlanTemplateNameDecoded
    }
}

extension BackupClientTypes {
    /// An object specifying metadata associated with a backup plan template.
    public struct BackupPlanTemplatesListMember: Swift.Equatable {
        /// Uniquely identifies a stored backup plan template.
        public var backupPlanTemplateId: Swift.String?
        /// The optional display name of a backup plan template.
        public var backupPlanTemplateName: Swift.String?

        public init (
            backupPlanTemplateId: Swift.String? = nil,
            backupPlanTemplateName: Swift.String? = nil
        )
        {
            self.backupPlanTemplateId = backupPlanTemplateId
            self.backupPlanTemplateName = backupPlanTemplateName
        }
    }

}

extension BackupClientTypes.BackupPlansListMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case backupPlanName = "BackupPlanName"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case deletionDate = "DeletionDate"
        case lastExecutionDate = "LastExecutionDate"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedBackupSettings = advancedBackupSettings {
            var advancedBackupSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedBackupSettings)
            for advancedbackupsetting0 in advancedBackupSettings {
                try advancedBackupSettingsContainer.encode(advancedbackupsetting0)
            }
        }
        if let backupPlanArn = self.backupPlanArn {
            try encodeContainer.encode(backupPlanArn, forKey: .backupPlanArn)
        }
        if let backupPlanId = self.backupPlanId {
            try encodeContainer.encode(backupPlanId, forKey: .backupPlanId)
        }
        if let backupPlanName = self.backupPlanName {
            try encodeContainer.encode(backupPlanName, forKey: .backupPlanName)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let deletionDate = self.deletionDate {
            try encodeContainer.encodeTimestamp(deletionDate, format: .epochSeconds, forKey: .deletionDate)
        }
        if let lastExecutionDate = self.lastExecutionDate {
            try encodeContainer.encodeTimestamp(lastExecutionDate, format: .epochSeconds, forKey: .lastExecutionDate)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let deletionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let backupPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanName)
        backupPlanName = backupPlanNameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let lastExecutionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension BackupClientTypes {
    /// Contains metadata about a backup plan.
    public struct BackupPlansListMember: Swift.Equatable {
        /// Contains a list of BackupOptions for a resource type.
        public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public var backupPlanArn: Swift.String?
        /// Uniquely identifies a backup plan.
        public var backupPlanId: Swift.String?
        /// The display name of a saved backup plan.
        public var backupPlanName: Swift.String?
        /// The date and time a resource backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public var creatorRequestId: Swift.String?
        /// The date and time a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var deletionDate: ClientRuntime.Date?
        /// The last time a job to back up resources was run with this rule. A date and time, in Unix format and Coordinated Universal Time (UTC). The value of LastExecutionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastExecutionDate: ClientRuntime.Date?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
        public var versionId: Swift.String?

        public init (
            advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
            backupPlanArn: Swift.String? = nil,
            backupPlanId: Swift.String? = nil,
            backupPlanName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            deletionDate: ClientRuntime.Date? = nil,
            lastExecutionDate: ClientRuntime.Date? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanName = backupPlanName
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.deletionDate = deletionDate
            self.lastExecutionDate = lastExecutionDate
            self.versionId = versionId
        }
    }

}

extension BackupClientTypes.BackupRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionWindowMinutes = "CompletionWindowMinutes"
        case copyActions = "CopyActions"
        case enableContinuousBackup = "EnableContinuousBackup"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case ruleId = "RuleId"
        case ruleName = "RuleName"
        case scheduleExpression = "ScheduleExpression"
        case startWindowMinutes = "StartWindowMinutes"
        case targetBackupVaultName = "TargetBackupVaultName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionWindowMinutes = self.completionWindowMinutes {
            try encodeContainer.encode(completionWindowMinutes, forKey: .completionWindowMinutes)
        }
        if let copyActions = copyActions {
            var copyActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .copyActions)
            for copyaction0 in copyActions {
                try copyActionsContainer.encode(copyaction0)
            }
        }
        if let enableContinuousBackup = self.enableContinuousBackup {
            try encodeContainer.encode(enableContinuousBackup, forKey: .enableContinuousBackup)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointTags = recoveryPointTags {
            var recoveryPointTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .recoveryPointTags)
            for (dictKey0, tags0) in recoveryPointTags {
                try recoveryPointTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let startWindowMinutes = self.startWindowMinutes {
            try encodeContainer.encode(startWindowMinutes, forKey: .startWindowMinutes)
        }
        if let targetBackupVaultName = self.targetBackupVaultName {
            try encodeContainer.encode(targetBackupVaultName, forKey: .targetBackupVaultName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let targetBackupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBackupVaultName)
        targetBackupVaultName = targetBackupVaultNameDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let startWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startWindowMinutes)
        startWindowMinutes = startWindowMinutesDecoded
        let completionWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completionWindowMinutes)
        completionWindowMinutes = completionWindowMinutesDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let recoveryPointTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .recoveryPointTags)
        var recoveryPointTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let recoveryPointTagsContainer = recoveryPointTagsContainer {
            recoveryPointTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in recoveryPointTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    recoveryPointTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        recoveryPointTags = recoveryPointTagsDecoded0
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let copyActionsContainer = try containerValues.decodeIfPresent([BackupClientTypes.CopyAction?].self, forKey: .copyActions)
        var copyActionsDecoded0:[BackupClientTypes.CopyAction]? = nil
        if let copyActionsContainer = copyActionsContainer {
            copyActionsDecoded0 = [BackupClientTypes.CopyAction]()
            for structure0 in copyActionsContainer {
                if let structure0 = structure0 {
                    copyActionsDecoded0?.append(structure0)
                }
            }
        }
        copyActions = copyActionsDecoded0
        let enableContinuousBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableContinuousBackup)
        enableContinuousBackup = enableContinuousBackupDecoded
    }
}

extension BackupClientTypes.BackupRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupRule(completionWindowMinutes: \(Swift.String(describing: completionWindowMinutes)), copyActions: \(Swift.String(describing: copyActions)), enableContinuousBackup: \(Swift.String(describing: enableContinuousBackup)), lifecycle: \(Swift.String(describing: lifecycle)), ruleId: \(Swift.String(describing: ruleId)), ruleName: \(Swift.String(describing: ruleName)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), startWindowMinutes: \(Swift.String(describing: startWindowMinutes)), targetBackupVaultName: \(Swift.String(describing: targetBackupVaultName)), recoveryPointTags: \"CONTENT_REDACTED\")"}
}

extension BackupClientTypes {
    /// Specifies a scheduled task used to back up a selection of resources.
    public struct BackupRule: Swift.Equatable {
        /// A value in minutes after a backup job is successfully started before it must be completed or it will be canceled by Backup. This value is optional.
        public var completionWindowMinutes: Swift.Int?
        /// An array of CopyAction objects, which contains the details of the copy operation.
        public var copyActions: [BackupClientTypes.CopyAction]?
        /// Specifies whether Backup creates continuous backups. True causes Backup to create continuous backups capable of point-in-time restore (PITR). False (or not specified) causes Backup to create snapshot backups.
        public var enableContinuousBackup: Swift.Bool?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
        public var lifecycle: BackupClientTypes.Lifecycle?
        /// An array of key-value pair strings that are assigned to resources that are associated with this rule when restored from backup.
        public var recoveryPointTags: [Swift.String:Swift.String]?
        /// Uniquely identifies a rule that is used to schedule the backup of a selection of resources.
        public var ruleId: Swift.String?
        /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var ruleName: Swift.String?
        /// A cron expression in UTC specifying when Backup initiates a backup job. For more information about Amazon Web Services cron expressions, see [Schedule Expressions for Rules](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html) in the Amazon CloudWatch Events User Guide.. Two examples of Amazon Web Services cron expressions are  15 * ? * * * (take a backup every hour at 15 minutes past the hour) and 0 12 * * ? * (take a backup every day at 12 noon UTC). For a table of examples, click the preceding link and scroll down the page.
        public var scheduleExpression: Swift.String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional. If this value is included, it must be at least 60 minutes to avoid errors.
        public var startWindowMinutes: Swift.Int?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        /// This member is required.
        public var targetBackupVaultName: Swift.String?

        public init (
            completionWindowMinutes: Swift.Int? = nil,
            copyActions: [BackupClientTypes.CopyAction]? = nil,
            enableContinuousBackup: Swift.Bool? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil,
            recoveryPointTags: [Swift.String:Swift.String]? = nil,
            ruleId: Swift.String? = nil,
            ruleName: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            startWindowMinutes: Swift.Int? = nil,
            targetBackupVaultName: Swift.String? = nil
        )
        {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.lifecycle = lifecycle
            self.recoveryPointTags = recoveryPointTags
            self.ruleId = ruleId
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVaultName = targetBackupVaultName
        }
    }

}

extension BackupClientTypes.BackupRuleInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionWindowMinutes = "CompletionWindowMinutes"
        case copyActions = "CopyActions"
        case enableContinuousBackup = "EnableContinuousBackup"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case ruleName = "RuleName"
        case scheduleExpression = "ScheduleExpression"
        case startWindowMinutes = "StartWindowMinutes"
        case targetBackupVaultName = "TargetBackupVaultName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionWindowMinutes = self.completionWindowMinutes {
            try encodeContainer.encode(completionWindowMinutes, forKey: .completionWindowMinutes)
        }
        if let copyActions = copyActions {
            var copyActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .copyActions)
            for copyaction0 in copyActions {
                try copyActionsContainer.encode(copyaction0)
            }
        }
        if let enableContinuousBackup = self.enableContinuousBackup {
            try encodeContainer.encode(enableContinuousBackup, forKey: .enableContinuousBackup)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointTags = recoveryPointTags {
            var recoveryPointTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .recoveryPointTags)
            for (dictKey0, tags0) in recoveryPointTags {
                try recoveryPointTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let startWindowMinutes = self.startWindowMinutes {
            try encodeContainer.encode(startWindowMinutes, forKey: .startWindowMinutes)
        }
        if let targetBackupVaultName = self.targetBackupVaultName {
            try encodeContainer.encode(targetBackupVaultName, forKey: .targetBackupVaultName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let targetBackupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBackupVaultName)
        targetBackupVaultName = targetBackupVaultNameDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let startWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startWindowMinutes)
        startWindowMinutes = startWindowMinutesDecoded
        let completionWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completionWindowMinutes)
        completionWindowMinutes = completionWindowMinutesDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let recoveryPointTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .recoveryPointTags)
        var recoveryPointTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let recoveryPointTagsContainer = recoveryPointTagsContainer {
            recoveryPointTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in recoveryPointTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    recoveryPointTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        recoveryPointTags = recoveryPointTagsDecoded0
        let copyActionsContainer = try containerValues.decodeIfPresent([BackupClientTypes.CopyAction?].self, forKey: .copyActions)
        var copyActionsDecoded0:[BackupClientTypes.CopyAction]? = nil
        if let copyActionsContainer = copyActionsContainer {
            copyActionsDecoded0 = [BackupClientTypes.CopyAction]()
            for structure0 in copyActionsContainer {
                if let structure0 = structure0 {
                    copyActionsDecoded0?.append(structure0)
                }
            }
        }
        copyActions = copyActionsDecoded0
        let enableContinuousBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableContinuousBackup)
        enableContinuousBackup = enableContinuousBackupDecoded
    }
}

extension BackupClientTypes.BackupRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupRuleInput(completionWindowMinutes: \(Swift.String(describing: completionWindowMinutes)), copyActions: \(Swift.String(describing: copyActions)), enableContinuousBackup: \(Swift.String(describing: enableContinuousBackup)), lifecycle: \(Swift.String(describing: lifecycle)), ruleName: \(Swift.String(describing: ruleName)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), startWindowMinutes: \(Swift.String(describing: startWindowMinutes)), targetBackupVaultName: \(Swift.String(describing: targetBackupVaultName)), recoveryPointTags: \"CONTENT_REDACTED\")"}
}

extension BackupClientTypes {
    /// Specifies a scheduled task used to back up a selection of resources.
    public struct BackupRuleInput: Swift.Equatable {
        /// A value in minutes after a backup job is successfully started before it must be completed or it will be canceled by Backup. This value is optional.
        public var completionWindowMinutes: Swift.Int?
        /// An array of CopyAction objects, which contains the details of the copy operation.
        public var copyActions: [BackupClientTypes.CopyAction]?
        /// Specifies whether Backup creates continuous backups. True causes Backup to create continuous backups capable of point-in-time restore (PITR). False (or not specified) causes Backup to create snapshot backups.
        public var enableContinuousBackup: Swift.Bool?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup will transition and expire backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
        public var lifecycle: BackupClientTypes.Lifecycle?
        /// To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair.
        public var recoveryPointTags: [Swift.String:Swift.String]?
        /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var ruleName: Swift.String?
        /// A CRON expression in UTC specifying when Backup initiates a backup job.
        public var scheduleExpression: Swift.String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional. If this value is included, it must be at least 60 minutes to avoid errors.
        public var startWindowMinutes: Swift.Int?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        /// This member is required.
        public var targetBackupVaultName: Swift.String?

        public init (
            completionWindowMinutes: Swift.Int? = nil,
            copyActions: [BackupClientTypes.CopyAction]? = nil,
            enableContinuousBackup: Swift.Bool? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil,
            recoveryPointTags: [Swift.String:Swift.String]? = nil,
            ruleName: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            startWindowMinutes: Swift.Int? = nil,
            targetBackupVaultName: Swift.String? = nil
        )
        {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.lifecycle = lifecycle
            self.recoveryPointTags = recoveryPointTags
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVaultName = targetBackupVaultName
        }
    }

}

extension BackupClientTypes.BackupSelection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditions = "Conditions"
        case iamRoleArn = "IamRoleArn"
        case listOfTags = "ListOfTags"
        case notResources = "NotResources"
        case resources = "Resources"
        case selectionName = "SelectionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditions = self.conditions {
            try encodeContainer.encode(conditions, forKey: .conditions)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let listOfTags = listOfTags {
            var listOfTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listOfTags)
            for condition0 in listOfTags {
                try listOfTagsContainer.encode(condition0)
            }
        }
        if let notResources = notResources {
            var notResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notResources)
            for arn0 in notResources {
                try notResourcesContainer.encode(arn0)
            }
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for arn0 in resources {
                try resourcesContainer.encode(arn0)
            }
        }
        if let selectionName = self.selectionName {
            try encodeContainer.encode(selectionName, forKey: .selectionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionName)
        selectionName = selectionNameDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resources)
        var resourcesDecoded0:[Swift.String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Swift.String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
        let listOfTagsContainer = try containerValues.decodeIfPresent([BackupClientTypes.Condition?].self, forKey: .listOfTags)
        var listOfTagsDecoded0:[BackupClientTypes.Condition]? = nil
        if let listOfTagsContainer = listOfTagsContainer {
            listOfTagsDecoded0 = [BackupClientTypes.Condition]()
            for structure0 in listOfTagsContainer {
                if let structure0 = structure0 {
                    listOfTagsDecoded0?.append(structure0)
                }
            }
        }
        listOfTags = listOfTagsDecoded0
        let notResourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notResources)
        var notResourcesDecoded0:[Swift.String]? = nil
        if let notResourcesContainer = notResourcesContainer {
            notResourcesDecoded0 = [Swift.String]()
            for string0 in notResourcesContainer {
                if let string0 = string0 {
                    notResourcesDecoded0?.append(string0)
                }
            }
        }
        notResources = notResourcesDecoded0
        let conditionsDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Conditions.self, forKey: .conditions)
        conditions = conditionsDecoded
    }
}

extension BackupClientTypes {
    /// Used to specify a set of resources to a backup plan. Specifying your desired Conditions, ListOfTags, NotResources, and/or Resources is recommended. If none of these are specified, Backup will attempt to select all supported and opted-in storage resources, which could have unintended cost implications.
    public struct BackupSelection: Swift.Equatable {
        /// A list of conditions that you define to assign resources to your backup plans using tags. For example, "StringEquals": { "ConditionKey": "aws:ResourceTag/CreatedByCryo", "ConditionValue": "true" },. Condition operators are case sensitive. Conditions differs from ListOfTags as follows:
        ///
        /// * When you specify more than one condition, you only assign the resources that match ALL conditions (using AND logic).
        ///
        /// * Conditions supports StringEquals, StringLike, StringNotEquals, and StringNotLike. ListOfTags only supports StringEquals.
        public var conditions: BackupClientTypes.Conditions?
        /// The ARN of the IAM role that Backup uses to authenticate when backing up the target resource; for example, arn:aws:iam::123456789012:role/S3Access.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// A list of conditions that you define to assign resources to your backup plans using tags. For example, "StringEquals": { "ConditionKey": "aws:ResourceTag/CreatedByCryo", "ConditionValue": "true" },. Condition operators are case sensitive. ListOfTags differs from Conditions as follows:
        ///
        /// * When you specify more than one condition, you assign all resources that match AT LEAST ONE condition (using OR logic).
        ///
        /// * ListOfTags only supports StringEquals. Conditions supports StringEquals, StringLike, StringNotEquals, and StringNotLike.
        public var listOfTags: [BackupClientTypes.Condition]?
        /// A list of Amazon Resource Names (ARNs) to exclude from a backup plan. The maximum number of ARNs is 500 without wildcards, or 30 ARNs with wildcards. If you need to exclude many resources from a backup plan, consider a different resource selection strategy, such as assigning only one or a few resource types or refining your resource selection using tags.
        public var notResources: [Swift.String]?
        /// A list of Amazon Resource Names (ARNs) to assign to a backup plan. The maximum number of ARNs is 500 without wildcards, or 30 ARNs with wildcards. If you need to assign many resources to a backup plan, consider a different resource selection strategy, such as assigning all resources of a resource type or refining your resource selection using tags.
        public var resources: [Swift.String]?
        /// The display name of a resource selection document. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var selectionName: Swift.String?

        public init (
            conditions: BackupClientTypes.Conditions? = nil,
            iamRoleArn: Swift.String? = nil,
            listOfTags: [BackupClientTypes.Condition]? = nil,
            notResources: [Swift.String]? = nil,
            resources: [Swift.String]? = nil,
            selectionName: Swift.String? = nil
        )
        {
            self.conditions = conditions
            self.iamRoleArn = iamRoleArn
            self.listOfTags = listOfTags
            self.notResources = notResources
            self.resources = resources
            self.selectionName = selectionName
        }
    }

}

extension BackupClientTypes.BackupSelectionsListMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case iamRoleArn = "IamRoleArn"
        case selectionId = "SelectionId"
        case selectionName = "SelectionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanId = self.backupPlanId {
            try encodeContainer.encode(backupPlanId, forKey: .backupPlanId)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let selectionId = self.selectionId {
            try encodeContainer.encode(selectionId, forKey: .selectionId)
        }
        if let selectionName = self.selectionName {
            try encodeContainer.encode(selectionName, forKey: .selectionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionId)
        selectionId = selectionIdDecoded
        let selectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionName)
        selectionName = selectionNameDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

extension BackupClientTypes {
    /// Contains metadata about a BackupSelection object.
    public struct BackupSelectionsListMember: Swift.Equatable {
        /// Uniquely identifies a backup plan.
        public var backupPlanId: Swift.String?
        /// The date and time a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public var creatorRequestId: Swift.String?
        /// Specifies the IAM role Amazon Resource Name (ARN) to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// Uniquely identifies a request to assign a set of resources to a backup plan.
        public var selectionId: Swift.String?
        /// The display name of a resource selection document.
        public var selectionName: Swift.String?

        public init (
            backupPlanId: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            selectionId: Swift.String? = nil,
            selectionName: Swift.String? = nil
        )
        {
            self.backupPlanId = backupPlanId
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.iamRoleArn = iamRoleArn
            self.selectionId = selectionId
            self.selectionName = selectionName
        }
    }

}

extension BackupClientTypes {
    public enum BackupVaultEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backupJobCompleted
        case backupJobExpired
        case backupJobFailed
        case backupJobStarted
        case backupJobSuccessful
        case backupPlanCreated
        case backupPlanModified
        case copyJobFailed
        case copyJobStarted
        case copyJobSuccessful
        case recoveryPointModified
        case restoreJobCompleted
        case restoreJobFailed
        case restoreJobStarted
        case restoreJobSuccessful
        case s3BackupObjectFailed
        case s3RestoreObjectFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupVaultEvent] {
            return [
                .backupJobCompleted,
                .backupJobExpired,
                .backupJobFailed,
                .backupJobStarted,
                .backupJobSuccessful,
                .backupPlanCreated,
                .backupPlanModified,
                .copyJobFailed,
                .copyJobStarted,
                .copyJobSuccessful,
                .recoveryPointModified,
                .restoreJobCompleted,
                .restoreJobFailed,
                .restoreJobStarted,
                .restoreJobSuccessful,
                .s3BackupObjectFailed,
                .s3RestoreObjectFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backupJobCompleted: return "BACKUP_JOB_COMPLETED"
            case .backupJobExpired: return "BACKUP_JOB_EXPIRED"
            case .backupJobFailed: return "BACKUP_JOB_FAILED"
            case .backupJobStarted: return "BACKUP_JOB_STARTED"
            case .backupJobSuccessful: return "BACKUP_JOB_SUCCESSFUL"
            case .backupPlanCreated: return "BACKUP_PLAN_CREATED"
            case .backupPlanModified: return "BACKUP_PLAN_MODIFIED"
            case .copyJobFailed: return "COPY_JOB_FAILED"
            case .copyJobStarted: return "COPY_JOB_STARTED"
            case .copyJobSuccessful: return "COPY_JOB_SUCCESSFUL"
            case .recoveryPointModified: return "RECOVERY_POINT_MODIFIED"
            case .restoreJobCompleted: return "RESTORE_JOB_COMPLETED"
            case .restoreJobFailed: return "RESTORE_JOB_FAILED"
            case .restoreJobStarted: return "RESTORE_JOB_STARTED"
            case .restoreJobSuccessful: return "RESTORE_JOB_SUCCESSFUL"
            case .s3BackupObjectFailed: return "S3_BACKUP_OBJECT_FAILED"
            case .s3RestoreObjectFailed: return "S3_RESTORE_OBJECT_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupVaultEvent(rawValue: rawValue) ?? BackupVaultEvent.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.BackupVaultListMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
        case lockDate = "LockDate"
        case locked = "Locked"
        case maxRetentionDays = "MaxRetentionDays"
        case minRetentionDays = "MinRetentionDays"
        case numberOfRecoveryPoints = "NumberOfRecoveryPoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultArn = self.backupVaultArn {
            try encodeContainer.encode(backupVaultArn, forKey: .backupVaultArn)
        }
        if let backupVaultName = self.backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let lockDate = self.lockDate {
            try encodeContainer.encodeTimestamp(lockDate, format: .epochSeconds, forKey: .lockDate)
        }
        if let locked = self.locked {
            try encodeContainer.encode(locked, forKey: .locked)
        }
        if let maxRetentionDays = self.maxRetentionDays {
            try encodeContainer.encode(maxRetentionDays, forKey: .maxRetentionDays)
        }
        if let minRetentionDays = self.minRetentionDays {
            try encodeContainer.encode(minRetentionDays, forKey: .minRetentionDays)
        }
        if numberOfRecoveryPoints != 0 {
            try encodeContainer.encode(numberOfRecoveryPoints, forKey: .numberOfRecoveryPoints)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let numberOfRecoveryPointsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecoveryPoints) ?? 0
        numberOfRecoveryPoints = numberOfRecoveryPointsDecoded
        let lockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .locked)
        locked = lockedDecoded
        let minRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minRetentionDays)
        minRetentionDays = minRetentionDaysDecoded
        let maxRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetentionDays)
        maxRetentionDays = maxRetentionDaysDecoded
        let lockDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lockDate)
        lockDate = lockDateDecoded
    }
}

extension BackupClientTypes {
    /// Contains metadata about a backup vault.
    public struct BackupVaultListMember: Swift.Equatable {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// The date and time a resource backup is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public var creatorRequestId: Swift.String?
        /// A server-side encryption key you can specify to encrypt your backups from services that support full Backup management; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab. If you specify a key, you must specify its ARN, not its alias. If you do not specify a key, Backup creates a KMS key for you by default. To learn which Backup services support full Backup management and how Backup handles encryption for backups from services that do not yet support full Backup, see [ Encryption for backups in Backup](https://docs.aws.amazon.com/aws-backup/latest/devguide/encryption.html)
        public var encryptionKeyArn: Swift.String?
        /// The date and time when Backup Vault Lock configuration becomes immutable, meaning it cannot be changed or deleted. If you applied Vault Lock to your vault without specifying a lock date, you can change your Vault Lock settings, or delete Vault Lock from the vault entirely, at any time. This value is in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lockDate: ClientRuntime.Date?
        /// A Boolean value that indicates whether Backup Vault Lock applies to the selected backup vault. If true, Vault Lock prevents delete and update operations on the recovery points in the selected vault.
        public var locked: Swift.Bool?
        /// The Backup Vault Lock setting that specifies the maximum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a maximum retention period on the recovery points in the vault (allowing indefinite storage). If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
        public var maxRetentionDays: Swift.Int?
        /// The Backup Vault Lock setting that specifies the minimum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a minimum retention period. If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
        public var minRetentionDays: Swift.Int?
        /// The number of recovery points that are stored in a backup vault.
        public var numberOfRecoveryPoints: Swift.Int

        public init (
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            encryptionKeyArn: Swift.String? = nil,
            lockDate: ClientRuntime.Date? = nil,
            locked: Swift.Bool? = nil,
            maxRetentionDays: Swift.Int? = nil,
            minRetentionDays: Swift.Int? = nil,
            numberOfRecoveryPoints: Swift.Int = 0
        )
        {
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.encryptionKeyArn = encryptionKeyArn
            self.lockDate = lockDate
            self.locked = locked
            self.maxRetentionDays = maxRetentionDays
            self.minRetentionDays = minRetentionDays
            self.numberOfRecoveryPoints = numberOfRecoveryPoints
        }
    }

}

extension BackupClientTypes.CalculatedLifecycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAt = "DeleteAt"
        case moveToColdStorageAt = "MoveToColdStorageAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteAt = self.deleteAt {
            try encodeContainer.encodeTimestamp(deleteAt, format: .epochSeconds, forKey: .deleteAt)
        }
        if let moveToColdStorageAt = self.moveToColdStorageAt {
            try encodeContainer.encodeTimestamp(moveToColdStorageAt, format: .epochSeconds, forKey: .moveToColdStorageAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moveToColdStorageAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .moveToColdStorageAt)
        moveToColdStorageAt = moveToColdStorageAtDecoded
        let deleteAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deleteAt)
        deleteAt = deleteAtDecoded
    }
}

extension BackupClientTypes {
    /// Contains DeleteAt and MoveToColdStorageAt timestamps, which are used to specify a lifecycle for a recovery point. The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
    public struct CalculatedLifecycle: Swift.Equatable {
        /// A timestamp that specifies when to delete a recovery point.
        public var deleteAt: ClientRuntime.Date?
        /// A timestamp that specifies when to transition a recovery point to cold storage.
        public var moveToColdStorageAt: ClientRuntime.Date?

        public init (
            deleteAt: ClientRuntime.Date? = nil,
            moveToColdStorageAt: ClientRuntime.Date? = nil
        )
        {
            self.deleteAt = deleteAt
            self.moveToColdStorageAt = moveToColdStorageAt
        }
    }

}

extension CancelLegalHoldInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let cancelDescription = cancelDescription else {
                let message = "Creating a URL Query Item failed. cancelDescription is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let cancelDescriptionQueryItem = ClientRuntime.URLQueryItem(name: "cancelDescription".urlPercentEncoding(), value: Swift.String(cancelDescription).urlPercentEncoding())
            items.append(cancelDescriptionQueryItem)
            if let retainRecordInDays = retainRecordInDays {
                let retainRecordInDaysQueryItem = ClientRuntime.URLQueryItem(name: "retainRecordInDays".urlPercentEncoding(), value: Swift.String(retainRecordInDays).urlPercentEncoding())
                items.append(retainRecordInDaysQueryItem)
            }
            return items
        }
    }
}

extension CancelLegalHoldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let legalHoldId = legalHoldId else {
            return nil
        }
        return "/legal-holds/\(legalHoldId.urlPercentEncoding())"
    }
}

public struct CancelLegalHoldInput: Swift.Equatable {
    /// String describing the reason for removing the legal hold.
    /// This member is required.
    public var cancelDescription: Swift.String?
    /// Legal hold ID required to remove the specified legal hold on a recovery point.
    /// This member is required.
    public var legalHoldId: Swift.String?
    /// The integer amount in days specifying amount of days after this API operation to remove legal hold.
    public var retainRecordInDays: Swift.Int?

    public init (
        cancelDescription: Swift.String? = nil,
        legalHoldId: Swift.String? = nil,
        retainRecordInDays: Swift.Int? = nil
    )
    {
        self.cancelDescription = cancelDescription
        self.legalHoldId = legalHoldId
        self.retainRecordInDays = retainRecordInDays
    }
}

struct CancelLegalHoldInputBody: Swift.Equatable {
}

extension CancelLegalHoldInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelLegalHoldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelLegalHoldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelLegalHoldOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidResourceStateException(InvalidResourceStateException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelLegalHoldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelLegalHoldOutputResponse: Swift.Equatable {

    public init () { }
}

extension BackupClientTypes.Condition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionKey = "ConditionKey"
        case conditionType = "ConditionType"
        case conditionValue = "ConditionValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionKey = self.conditionKey {
            try encodeContainer.encode(conditionKey, forKey: .conditionKey)
        }
        if let conditionType = self.conditionType {
            try encodeContainer.encode(conditionType.rawValue, forKey: .conditionType)
        }
        if let conditionValue = self.conditionValue {
            try encodeContainer.encode(conditionValue, forKey: .conditionValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionTypeDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ConditionType.self, forKey: .conditionType)
        conditionType = conditionTypeDecoded
        let conditionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionKey)
        conditionKey = conditionKeyDecoded
        let conditionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionValue)
        conditionValue = conditionValueDecoded
    }
}

extension BackupClientTypes {
    /// Contains an array of triplets made up of a condition type (such as StringEquals), a key, and a value. Used to filter resources using their tags and assign them to a backup plan. Case sensitive.
    public struct Condition: Swift.Equatable {
        /// The key in a key-value pair. For example, in the tag Department: Accounting, Department is the key.
        /// This member is required.
        public var conditionKey: Swift.String?
        /// An operation applied to a key-value pair used to assign resources to your backup plan. Condition only supports StringEquals. For more flexible assignment options, including StringLike and the ability to exclude resources from your backup plan, use Conditions (with an "s" on the end) for your [BackupSelection](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BackupSelection.html).
        /// This member is required.
        public var conditionType: BackupClientTypes.ConditionType?
        /// The value in a key-value pair. For example, in the tag Department: Accounting, Accounting is the value.
        /// This member is required.
        public var conditionValue: Swift.String?

        public init (
            conditionKey: Swift.String? = nil,
            conditionType: BackupClientTypes.ConditionType? = nil,
            conditionValue: Swift.String? = nil
        )
        {
            self.conditionKey = conditionKey
            self.conditionType = conditionType
            self.conditionValue = conditionValue
        }
    }

}

extension BackupClientTypes.ConditionParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionKey = "ConditionKey"
        case conditionValue = "ConditionValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionKey = self.conditionKey {
            try encodeContainer.encode(conditionKey, forKey: .conditionKey)
        }
        if let conditionValue = self.conditionValue {
            try encodeContainer.encode(conditionValue, forKey: .conditionValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionKey)
        conditionKey = conditionKeyDecoded
        let conditionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionValue)
        conditionValue = conditionValueDecoded
    }
}

extension BackupClientTypes {
    /// Includes information about tags you define to assign tagged resources to a backup plan.
    public struct ConditionParameter: Swift.Equatable {
        /// The key in a key-value pair. For example, in the tag Department: Accounting, Department is the key.
        public var conditionKey: Swift.String?
        /// The value in a key-value pair. For example, in the tag Department: Accounting, Accounting is the value.
        public var conditionValue: Swift.String?

        public init (
            conditionKey: Swift.String? = nil,
            conditionValue: Swift.String? = nil
        )
        {
            self.conditionKey = conditionKey
            self.conditionValue = conditionValue
        }
    }

}

extension BackupClientTypes {
    public enum ConditionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stringequals
        case sdkUnknown(Swift.String)

        public static var allCases: [ConditionType] {
            return [
                .stringequals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stringequals: return "STRINGEQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConditionType(rawValue: rawValue) ?? ConditionType.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.Conditions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stringEquals = "StringEquals"
        case stringLike = "StringLike"
        case stringNotEquals = "StringNotEquals"
        case stringNotLike = "StringNotLike"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stringEquals = stringEquals {
            var stringEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringEquals)
            for conditionparameter0 in stringEquals {
                try stringEqualsContainer.encode(conditionparameter0)
            }
        }
        if let stringLike = stringLike {
            var stringLikeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringLike)
            for conditionparameter0 in stringLike {
                try stringLikeContainer.encode(conditionparameter0)
            }
        }
        if let stringNotEquals = stringNotEquals {
            var stringNotEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringNotEquals)
            for conditionparameter0 in stringNotEquals {
                try stringNotEqualsContainer.encode(conditionparameter0)
            }
        }
        if let stringNotLike = stringNotLike {
            var stringNotLikeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringNotLike)
            for conditionparameter0 in stringNotLike {
                try stringNotLikeContainer.encode(conditionparameter0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringEqualsContainer = try containerValues.decodeIfPresent([BackupClientTypes.ConditionParameter?].self, forKey: .stringEquals)
        var stringEqualsDecoded0:[BackupClientTypes.ConditionParameter]? = nil
        if let stringEqualsContainer = stringEqualsContainer {
            stringEqualsDecoded0 = [BackupClientTypes.ConditionParameter]()
            for structure0 in stringEqualsContainer {
                if let structure0 = structure0 {
                    stringEqualsDecoded0?.append(structure0)
                }
            }
        }
        stringEquals = stringEqualsDecoded0
        let stringNotEqualsContainer = try containerValues.decodeIfPresent([BackupClientTypes.ConditionParameter?].self, forKey: .stringNotEquals)
        var stringNotEqualsDecoded0:[BackupClientTypes.ConditionParameter]? = nil
        if let stringNotEqualsContainer = stringNotEqualsContainer {
            stringNotEqualsDecoded0 = [BackupClientTypes.ConditionParameter]()
            for structure0 in stringNotEqualsContainer {
                if let structure0 = structure0 {
                    stringNotEqualsDecoded0?.append(structure0)
                }
            }
        }
        stringNotEquals = stringNotEqualsDecoded0
        let stringLikeContainer = try containerValues.decodeIfPresent([BackupClientTypes.ConditionParameter?].self, forKey: .stringLike)
        var stringLikeDecoded0:[BackupClientTypes.ConditionParameter]? = nil
        if let stringLikeContainer = stringLikeContainer {
            stringLikeDecoded0 = [BackupClientTypes.ConditionParameter]()
            for structure0 in stringLikeContainer {
                if let structure0 = structure0 {
                    stringLikeDecoded0?.append(structure0)
                }
            }
        }
        stringLike = stringLikeDecoded0
        let stringNotLikeContainer = try containerValues.decodeIfPresent([BackupClientTypes.ConditionParameter?].self, forKey: .stringNotLike)
        var stringNotLikeDecoded0:[BackupClientTypes.ConditionParameter]? = nil
        if let stringNotLikeContainer = stringNotLikeContainer {
            stringNotLikeDecoded0 = [BackupClientTypes.ConditionParameter]()
            for structure0 in stringNotLikeContainer {
                if let structure0 = structure0 {
                    stringNotLikeDecoded0?.append(structure0)
                }
            }
        }
        stringNotLike = stringNotLikeDecoded0
    }
}

extension BackupClientTypes {
    /// Contains information about which resources to include or exclude from a backup plan using their tags. Conditions are case sensitive.
    public struct Conditions: Swift.Equatable {
        /// Filters the values of your tagged resources for only those resources that you tagged with the same value. Also called "exact matching."
        public var stringEquals: [BackupClientTypes.ConditionParameter]?
        /// Filters the values of your tagged resources for matching tag values with the use of a wildcard character (*) anywhere in the string. For example, "prod*" or "*rod*" matches the tag value "production".
        public var stringLike: [BackupClientTypes.ConditionParameter]?
        /// Filters the values of your tagged resources for only those resources that you tagged that do not have the same value. Also called "negated matching."
        public var stringNotEquals: [BackupClientTypes.ConditionParameter]?
        /// Filters the values of your tagged resources for non-matching tag values with the use of a wildcard character (*) anywhere in the string.
        public var stringNotLike: [BackupClientTypes.ConditionParameter]?

        public init (
            stringEquals: [BackupClientTypes.ConditionParameter]? = nil,
            stringLike: [BackupClientTypes.ConditionParameter]? = nil,
            stringNotEquals: [BackupClientTypes.ConditionParameter]? = nil,
            stringNotLike: [BackupClientTypes.ConditionParameter]? = nil
        )
        {
            self.stringEquals = stringEquals
            self.stringLike = stringLike
            self.stringNotEquals = stringNotEquals
            self.stringNotLike = stringNotLike
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Backup can't perform the action that you requested until it finishes performing a previous action. Try again later.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes.ControlInputParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterValue = self.parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension BackupClientTypes {
    /// A list of parameters for a control. A control can have zero, one, or more than one parameter. An example of a control with two parameters is: "backup plan frequency is at least daily and the retention period is at least 1 year". The first parameter is daily. The second parameter is 1 year.
    public struct ControlInputParameter: Swift.Equatable {
        /// The name of a parameter, for example, BackupPlanFrequency.
        public var parameterName: Swift.String?
        /// The value of parameter, for example, hourly.
        public var parameterValue: Swift.String?

        public init (
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }
    }

}

extension BackupClientTypes.ControlScope: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceResourceIds = "ComplianceResourceIds"
        case complianceResourceTypes = "ComplianceResourceTypes"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceResourceIds = complianceResourceIds {
            var complianceResourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceResourceIds)
            for string0 in complianceResourceIds {
                try complianceResourceIdsContainer.encode(string0)
            }
        }
        if let complianceResourceTypes = complianceResourceTypes {
            var complianceResourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceResourceTypes)
            for arn0 in complianceResourceTypes {
                try complianceResourceTypesContainer.encode(arn0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, stringMap0) in tags {
                try tagsContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceResourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .complianceResourceIds)
        var complianceResourceIdsDecoded0:[Swift.String]? = nil
        if let complianceResourceIdsContainer = complianceResourceIdsContainer {
            complianceResourceIdsDecoded0 = [Swift.String]()
            for string0 in complianceResourceIdsContainer {
                if let string0 = string0 {
                    complianceResourceIdsDecoded0?.append(string0)
                }
            }
        }
        complianceResourceIds = complianceResourceIdsDecoded0
        let complianceResourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .complianceResourceTypes)
        var complianceResourceTypesDecoded0:[Swift.String]? = nil
        if let complianceResourceTypesContainer = complianceResourceTypesContainer {
            complianceResourceTypesDecoded0 = [Swift.String]()
            for string0 in complianceResourceTypesContainer {
                if let string0 = string0 {
                    complianceResourceTypesDecoded0?.append(string0)
                }
            }
        }
        complianceResourceTypes = complianceResourceTypesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension BackupClientTypes {
    /// A framework consists of one or more controls. Each control has its own control scope. The control scope can include one or more resource types, a combination of a tag key and value, or a combination of one resource type and one resource ID. If no scope is specified, evaluations for the rule are triggered when any resource in your recording group changes in configuration. To set a control scope that includes all of a particular resource, leave the ControlScope empty or do not pass it when calling CreateFramework.
    public struct ControlScope: Swift.Equatable {
        /// The ID of the only Amazon Web Services resource that you want your control scope to contain.
        public var complianceResourceIds: [Swift.String]?
        /// Describes whether the control scope includes one or more types of resources, such as EFS or RDS.
        public var complianceResourceTypes: [Swift.String]?
        /// The tag key-value pair applied to those Amazon Web Services resources that you want to trigger an evaluation for a rule. A maximum of one key-value pair can be provided. The tag value is optional, but it cannot be an empty string. The structure to assign a tag is: [{"Key":"string","Value":"string"}].
        public var tags: [Swift.String:Swift.String]?

        public init (
            complianceResourceIds: [Swift.String]? = nil,
            complianceResourceTypes: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.complianceResourceIds = complianceResourceIds
            self.complianceResourceTypes = complianceResourceTypes
            self.tags = tags
        }
    }

}

extension BackupClientTypes.CopyAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case lifecycle = "Lifecycle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationBackupVaultArn = self.destinationBackupVaultArn {
            try encodeContainer.encode(destinationBackupVaultArn, forKey: .destinationBackupVaultArn)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let destinationBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationBackupVaultArn)
        destinationBackupVaultArn = destinationBackupVaultArnDecoded
    }
}

extension BackupClientTypes {
    /// The details of the copy operation.
    public struct CopyAction: Swift.Equatable {
        /// An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup. For example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        /// This member is required.
        public var destinationBackupVaultArn: Swift.String?
        /// Contains an array of Transition objects specifying how long in days before a recovery point transitions to cold storage or is deleted. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
        public var lifecycle: BackupClientTypes.Lifecycle?

        public init (
            destinationBackupVaultArn: Swift.String? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil
        )
        {
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.lifecycle = lifecycle
        }
    }

}

extension BackupClientTypes.CopyJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupSizeInBytes = "BackupSizeInBytes"
        case childJobsInState = "ChildJobsInState"
        case completionDate = "CompletionDate"
        case compositeMemberIdentifier = "CompositeMemberIdentifier"
        case copyJobId = "CopyJobId"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case destinationRecoveryPointArn = "DestinationRecoveryPointArn"
        case iamRoleArn = "IamRoleArn"
        case isParent = "IsParent"
        case numberOfChildJobs = "NumberOfChildJobs"
        case parentJobId = "ParentJobId"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case sourceBackupVaultArn = "SourceBackupVaultArn"
        case sourceRecoveryPointArn = "SourceRecoveryPointArn"
        case state = "State"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let backupSizeInBytes = self.backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let childJobsInState = childJobsInState {
            var childJobsInStateContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .childJobsInState)
            for (dictKey0, copyJobChildJobsInState0) in childJobsInState {
                try childJobsInStateContainer.encode(copyJobChildJobsInState0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let completionDate = self.completionDate {
            try encodeContainer.encodeTimestamp(completionDate, format: .epochSeconds, forKey: .completionDate)
        }
        if let compositeMemberIdentifier = self.compositeMemberIdentifier {
            try encodeContainer.encode(compositeMemberIdentifier, forKey: .compositeMemberIdentifier)
        }
        if let copyJobId = self.copyJobId {
            try encodeContainer.encode(copyJobId, forKey: .copyJobId)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let destinationBackupVaultArn = self.destinationBackupVaultArn {
            try encodeContainer.encode(destinationBackupVaultArn, forKey: .destinationBackupVaultArn)
        }
        if let destinationRecoveryPointArn = self.destinationRecoveryPointArn {
            try encodeContainer.encode(destinationRecoveryPointArn, forKey: .destinationRecoveryPointArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if isParent != false {
            try encodeContainer.encode(isParent, forKey: .isParent)
        }
        if let numberOfChildJobs = self.numberOfChildJobs {
            try encodeContainer.encode(numberOfChildJobs, forKey: .numberOfChildJobs)
        }
        if let parentJobId = self.parentJobId {
            try encodeContainer.encode(parentJobId, forKey: .parentJobId)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let sourceBackupVaultArn = self.sourceBackupVaultArn {
            try encodeContainer.encode(sourceBackupVaultArn, forKey: .sourceBackupVaultArn)
        }
        if let sourceRecoveryPointArn = self.sourceRecoveryPointArn {
            try encodeContainer.encode(sourceRecoveryPointArn, forKey: .sourceRecoveryPointArn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let copyJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .copyJobId)
        copyJobId = copyJobIdDecoded
        let sourceBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupVaultArn)
        sourceBackupVaultArn = sourceBackupVaultArnDecoded
        let sourceRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRecoveryPointArn)
        sourceRecoveryPointArn = sourceRecoveryPointArnDecoded
        let destinationBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationBackupVaultArn)
        destinationBackupVaultArn = destinationBackupVaultArnDecoded
        let destinationRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRecoveryPointArn)
        destinationRecoveryPointArn = destinationRecoveryPointArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDate)
        completionDate = completionDateDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CopyJobState.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let parentJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentJobId)
        parentJobId = parentJobIdDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
        let compositeMemberIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .compositeMemberIdentifier)
        compositeMemberIdentifier = compositeMemberIdentifierDecoded
        let numberOfChildJobsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfChildJobs)
        numberOfChildJobs = numberOfChildJobsDecoded
        let childJobsInStateContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .childJobsInState)
        var childJobsInStateDecoded0: [Swift.String:Swift.Int]? = nil
        if let childJobsInStateContainer = childJobsInStateContainer {
            childJobsInStateDecoded0 = [Swift.String:Swift.Int]()
            for (key0, long0) in childJobsInStateContainer {
                if let long0 = long0 {
                    childJobsInStateDecoded0?[key0] = long0
                }
            }
        }
        childJobsInState = childJobsInStateDecoded0
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about a copy job.
    public struct CopyJob: Swift.Equatable {
        /// The account ID that owns the copy job.
        public var accountId: Swift.String?
        /// The size, in bytes, of a copy job.
        public var backupSizeInBytes: Swift.Int?
        /// This returns the statistics of the included child (nested) copy jobs.
        public var childJobsInState: [Swift.String:Swift.Int]?
        /// The date and time a copy job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: ClientRuntime.Date?
        /// This is the identifier of a resource within a composite group, such as nested (child) recovery point belonging to a composite (parent) stack. The ID is transferred from the [ logical ID](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html#resources-section-structure-syntax) within a stack.
        public var compositeMemberIdentifier: Swift.String?
        /// Uniquely identifies a copy job.
        public var copyJobId: Swift.String?
        /// Contains information about the backup plan and rule that Backup used to initiate the recovery point backup.
        public var createdBy: BackupClientTypes.RecoveryPointCreator?
        /// The date and time a copy job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a destination copy vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var destinationBackupVaultArn: Swift.String?
        /// An ARN that uniquely identifies a destination recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var destinationRecoveryPointArn: Swift.String?
        /// Specifies the IAM role ARN used to copy the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// This is a boolean value indicating this is a parent (composite) copy job.
        public var isParent: Swift.Bool
        /// This is the number of child (nested) copy jobs.
        public var numberOfChildJobs: Swift.Int?
        /// This uniquely identifies a request to Backup to copy a resource. The return will be the parent (composite) job ID.
        public var parentJobId: Swift.String?
        /// The Amazon Web Services resource to be copied; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public var resourceArn: Swift.String?
        /// This is the non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource to be copied; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public var resourceType: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a source copy vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var sourceBackupVaultArn: Swift.String?
        /// An ARN that uniquely identifies a source recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var sourceRecoveryPointArn: Swift.String?
        /// The current state of a copy job.
        public var state: BackupClientTypes.CopyJobState?
        /// A detailed message explaining the status of the job to copy a resource.
        public var statusMessage: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            backupSizeInBytes: Swift.Int? = nil,
            childJobsInState: [Swift.String:Swift.Int]? = nil,
            completionDate: ClientRuntime.Date? = nil,
            compositeMemberIdentifier: Swift.String? = nil,
            copyJobId: Swift.String? = nil,
            createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
            creationDate: ClientRuntime.Date? = nil,
            destinationBackupVaultArn: Swift.String? = nil,
            destinationRecoveryPointArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            isParent: Swift.Bool = false,
            numberOfChildJobs: Swift.Int? = nil,
            parentJobId: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            sourceBackupVaultArn: Swift.String? = nil,
            sourceRecoveryPointArn: Swift.String? = nil,
            state: BackupClientTypes.CopyJobState? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.backupSizeInBytes = backupSizeInBytes
            self.childJobsInState = childJobsInState
            self.completionDate = completionDate
            self.compositeMemberIdentifier = compositeMemberIdentifier
            self.copyJobId = copyJobId
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.destinationRecoveryPointArn = destinationRecoveryPointArn
            self.iamRoleArn = iamRoleArn
            self.isParent = isParent
            self.numberOfChildJobs = numberOfChildJobs
            self.parentJobId = parentJobId
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.sourceRecoveryPointArn = sourceRecoveryPointArn
            self.state = state
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes {
    public enum CopyJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case created
        case failed
        case partial
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [CopyJobState] {
            return [
                .completed,
                .created,
                .failed,
                .partial,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .partial: return "PARTIAL"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CopyJobState(rawValue: rawValue) ?? CopyJobState.sdkUnknown(rawValue)
        }
    }
}

extension CreateBackupPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupPlanInput(backupPlan: \(Swift.String(describing: backupPlan)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), backupPlanTags: \"CONTENT_REDACTED\")"}
}

extension CreateBackupPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
        case backupPlanTags = "BackupPlanTags"
        case creatorRequestId = "CreatorRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlan = self.backupPlan {
            try encodeContainer.encode(backupPlan, forKey: .backupPlan)
        }
        if let backupPlanTags = backupPlanTags {
            var backupPlanTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupPlanTags)
            for (dictKey0, tags0) in backupPlanTags {
                try backupPlanTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
    }
}

extension CreateBackupPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backup/plans"
    }
}

public struct CreateBackupPlanInput: Swift.Equatable {
    /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    /// This member is required.
    public var backupPlan: BackupClientTypes.BackupPlanInput?
    /// To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair. The specified tags are assigned to all backups created with this plan.
    public var backupPlanTags: [Swift.String:Swift.String]?
    /// Identifies the request and allows failed requests to be retried without the risk of running the operation twice. If the request includes a CreatorRequestId that matches an existing backup plan, that plan is returned. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?

    public init (
        backupPlan: BackupClientTypes.BackupPlanInput? = nil,
        backupPlanTags: [Swift.String:Swift.String]? = nil,
        creatorRequestId: Swift.String? = nil
    )
    {
        self.backupPlan = backupPlan
        self.backupPlanTags = backupPlanTags
        self.creatorRequestId = creatorRequestId
    }
}

struct CreateBackupPlanInputBody: Swift.Equatable {
    let backupPlan: BackupClientTypes.BackupPlanInput?
    let backupPlanTags: [Swift.String:Swift.String]?
    let creatorRequestId: Swift.String?
}

extension CreateBackupPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
        case backupPlanTags = "BackupPlanTags"
        case creatorRequestId = "CreatorRequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlanInput.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
        let backupPlanTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupPlanTags)
        var backupPlanTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupPlanTagsContainer = backupPlanTagsContainer {
            backupPlanTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in backupPlanTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    backupPlanTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        backupPlanTags = backupPlanTagsDecoded0
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension CreateBackupPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackupPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBackupPlanOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackupPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBackupPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedBackupSettings = output.advancedBackupSettings
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.versionId = output.versionId
        } else {
            self.advancedBackupSettings = nil
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.creationDate = nil
            self.versionId = nil
        }
    }
}

public struct CreateBackupPlanOutputResponse: Swift.Equatable {
    /// A list of BackupOptions settings for a resource type. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs.
    public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time that a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. They cannot be edited.
    public var versionId: Swift.String?

    public init (
        advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.versionId = versionId
    }
}

struct CreateBackupPlanOutputResponseBody: Swift.Equatable {
    let backupPlanId: Swift.String?
    let backupPlanArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let versionId: Swift.String?
    let advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
}

extension CreateBackupPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension CreateBackupSelectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSelection = "BackupSelection"
        case creatorRequestId = "CreatorRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupSelection = self.backupSelection {
            try encodeContainer.encode(backupSelection, forKey: .backupSelection)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
    }
}

extension CreateBackupSelectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections"
    }
}

public struct CreateBackupSelectionInput: Swift.Equatable {
    /// Uniquely identifies the backup plan to be associated with the selection of resources.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Specifies the body of a request to assign a set of resources to a backup plan.
    /// This member is required.
    public var backupSelection: BackupClientTypes.BackupSelection?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        backupSelection: BackupClientTypes.BackupSelection? = nil,
        creatorRequestId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.backupSelection = backupSelection
        self.creatorRequestId = creatorRequestId
    }
}

struct CreateBackupSelectionInputBody: Swift.Equatable {
    let backupSelection: BackupClientTypes.BackupSelection?
    let creatorRequestId: Swift.String?
}

extension CreateBackupSelectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSelection = "BackupSelection"
        case creatorRequestId = "CreatorRequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupSelectionDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupSelection.self, forKey: .backupSelection)
        backupSelection = backupSelectionDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension CreateBackupSelectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackupSelectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBackupSelectionOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackupSelectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBackupSelectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.selectionId = output.selectionId
        } else {
            self.backupPlanId = nil
            self.creationDate = nil
            self.selectionId = nil
        }
    }
}

public struct CreateBackupSelectionOutputResponse: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time a backup selection is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    public var selectionId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.selectionId = selectionId
    }
}

struct CreateBackupSelectionOutputResponseBody: Swift.Equatable {
    let selectionId: Swift.String?
    let backupPlanId: Swift.String?
    let creationDate: ClientRuntime.Date?
}

extension CreateBackupSelectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case selectionId = "SelectionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionId)
        selectionId = selectionIdDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension CreateBackupVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupVaultInput(backupVaultName: \(Swift.String(describing: backupVaultName)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), encryptionKeyArn: \(Swift.String(describing: encryptionKeyArn)), backupVaultTags: \"CONTENT_REDACTED\")"}
}

extension CreateBackupVaultInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultTags = "BackupVaultTags"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultTags = backupVaultTags {
            var backupVaultTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupVaultTags)
            for (dictKey0, tags0) in backupVaultTags {
                try backupVaultTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
    }
}

extension CreateBackupVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())"
    }
}

public struct CreateBackupVaultInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// Metadata that you can assign to help organize the resources that you create. Each tag is a key-value pair.
    public var backupVaultTags: [Swift.String:Swift.String]?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?
    /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    public var encryptionKeyArn: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        backupVaultTags: [Swift.String:Swift.String]? = nil,
        creatorRequestId: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.backupVaultTags = backupVaultTags
        self.creatorRequestId = creatorRequestId
        self.encryptionKeyArn = encryptionKeyArn
    }
}

struct CreateBackupVaultInputBody: Swift.Equatable {
    let backupVaultTags: [Swift.String:Swift.String]?
    let encryptionKeyArn: Swift.String?
    let creatorRequestId: Swift.String?
}

extension CreateBackupVaultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultTags = "BackupVaultTags"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupVaultTags)
        var backupVaultTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupVaultTagsContainer = backupVaultTagsContainer {
            backupVaultTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in backupVaultTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    backupVaultTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        backupVaultTags = backupVaultTagsDecoded0
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension CreateBackupVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackupVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBackupVaultOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackupVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBackupVaultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.creationDate = output.creationDate
        } else {
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.creationDate = nil
        }
    }
}

public struct CreateBackupVaultOutputResponse: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// The date and time a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?

    public init (
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.creationDate = creationDate
    }
}

struct CreateBackupVaultOutputResponseBody: Swift.Equatable {
    let backupVaultName: Swift.String?
    let backupVaultArn: Swift.String?
    let creationDate: ClientRuntime.Date?
}

extension CreateBackupVaultOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension CreateFrameworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case frameworkName = "FrameworkName"
        case frameworkTags = "FrameworkTags"
        case idempotencyToken = "IdempotencyToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameworkControls = frameworkControls {
            var frameworkControlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .frameworkControls)
            for frameworkcontrol0 in frameworkControls {
                try frameworkControlsContainer.encode(frameworkcontrol0)
            }
        }
        if let frameworkDescription = self.frameworkDescription {
            try encodeContainer.encode(frameworkDescription, forKey: .frameworkDescription)
        }
        if let frameworkName = self.frameworkName {
            try encodeContainer.encode(frameworkName, forKey: .frameworkName)
        }
        if let frameworkTags = frameworkTags {
            var frameworkTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .frameworkTags)
            for (dictKey0, stringMap0) in frameworkTags {
                try frameworkTagsContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
    }
}

extension CreateFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/frameworks"
    }
}

public struct CreateFrameworkInput: Swift.Equatable {
    /// A list of the controls that make up the framework. Each control in the list has a name, input parameters, and scope.
    /// This member is required.
    public var frameworkControls: [BackupClientTypes.FrameworkControl]?
    /// An optional description of the framework with a maximum of 1,024 characters.
    public var frameworkDescription: Swift.String?
    /// The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var frameworkName: Swift.String?
    /// Metadata that you can assign to help organize the frameworks that you create. Each tag is a key-value pair.
    public var frameworkTags: [Swift.String:Swift.String]?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to CreateFrameworkInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?

    public init (
        frameworkControls: [BackupClientTypes.FrameworkControl]? = nil,
        frameworkDescription: Swift.String? = nil,
        frameworkName: Swift.String? = nil,
        frameworkTags: [Swift.String:Swift.String]? = nil,
        idempotencyToken: Swift.String? = nil
    )
    {
        self.frameworkControls = frameworkControls
        self.frameworkDescription = frameworkDescription
        self.frameworkName = frameworkName
        self.frameworkTags = frameworkTags
        self.idempotencyToken = idempotencyToken
    }
}

struct CreateFrameworkInputBody: Swift.Equatable {
    let frameworkName: Swift.String?
    let frameworkDescription: Swift.String?
    let frameworkControls: [BackupClientTypes.FrameworkControl]?
    let idempotencyToken: Swift.String?
    let frameworkTags: [Swift.String:Swift.String]?
}

extension CreateFrameworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case frameworkName = "FrameworkName"
        case frameworkTags = "FrameworkTags"
        case idempotencyToken = "IdempotencyToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkDescription)
        frameworkDescription = frameworkDescriptionDecoded
        let frameworkControlsContainer = try containerValues.decodeIfPresent([BackupClientTypes.FrameworkControl?].self, forKey: .frameworkControls)
        var frameworkControlsDecoded0:[BackupClientTypes.FrameworkControl]? = nil
        if let frameworkControlsContainer = frameworkControlsContainer {
            frameworkControlsDecoded0 = [BackupClientTypes.FrameworkControl]()
            for structure0 in frameworkControlsContainer {
                if let structure0 = structure0 {
                    frameworkControlsDecoded0?.append(structure0)
                }
            }
        }
        frameworkControls = frameworkControlsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let frameworkTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .frameworkTags)
        var frameworkTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let frameworkTagsContainer = frameworkTagsContainer {
            frameworkTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in frameworkTagsContainer {
                if let string0 = string0 {
                    frameworkTagsDecoded0?[key0] = string0
                }
            }
        }
        frameworkTags = frameworkTagsDecoded0
    }
}

extension CreateFrameworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFrameworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFrameworkOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFrameworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFrameworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.frameworkArn = output.frameworkArn
            self.frameworkName = output.frameworkName
        } else {
            self.frameworkArn = nil
            self.frameworkName = nil
        }
    }
}

public struct CreateFrameworkOutputResponse: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var frameworkArn: Swift.String?
    /// The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    public var frameworkName: Swift.String?

    public init (
        frameworkArn: Swift.String? = nil,
        frameworkName: Swift.String? = nil
    )
    {
        self.frameworkArn = frameworkArn
        self.frameworkName = frameworkName
    }
}

struct CreateFrameworkOutputResponseBody: Swift.Equatable {
    let frameworkName: Swift.String?
    let frameworkArn: Swift.String?
}

extension CreateFrameworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkArn = "FrameworkArn"
        case frameworkName = "FrameworkName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkArn)
        frameworkArn = frameworkArnDecoded
    }
}

extension CreateLegalHoldInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLegalHoldInput(description: \(Swift.String(describing: description)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), recoveryPointSelection: \(Swift.String(describing: recoveryPointSelection)), title: \(Swift.String(describing: title)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateLegalHoldInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case recoveryPointSelection = "RecoveryPointSelection"
        case tags = "Tags"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let recoveryPointSelection = self.recoveryPointSelection {
            try encodeContainer.encode(recoveryPointSelection, forKey: .recoveryPointSelection)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

extension CreateLegalHoldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/legal-holds"
    }
}

public struct CreateLegalHoldInput: Swift.Equatable {
    /// This is the string description of the legal hold.
    /// This member is required.
    public var description: Swift.String?
    /// This is a user-chosen string used to distinguish between otherwise identical calls. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// This specifies criteria to assign a set of resources, such as resource types or backup vaults.
    public var recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
    /// Optional tags to include. A tag is a key-value pair you can use to manage, filter, and search for your resources. Allowed characters include UTF-8 letters, numbers, spaces, and the following characters: + - = . _ : /.
    public var tags: [Swift.String:Swift.String]?
    /// This is the string title of the legal hold.
    /// This member is required.
    public var title: Swift.String?

    public init (
        description: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        recoveryPointSelection: BackupClientTypes.RecoveryPointSelection? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        title: Swift.String? = nil
    )
    {
        self.description = description
        self.idempotencyToken = idempotencyToken
        self.recoveryPointSelection = recoveryPointSelection
        self.tags = tags
        self.title = title
    }
}

struct CreateLegalHoldInputBody: Swift.Equatable {
    let title: Swift.String?
    let description: Swift.String?
    let idempotencyToken: Swift.String?
    let recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLegalHoldInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case recoveryPointSelection = "RecoveryPointSelection"
        case tags = "Tags"
        case title = "Title"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let recoveryPointSelectionDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointSelection.self, forKey: .recoveryPointSelection)
        recoveryPointSelection = recoveryPointSelectionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLegalHoldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLegalHoldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLegalHoldOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLegalHoldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateLegalHoldOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.description = output.description
            self.legalHoldArn = output.legalHoldArn
            self.legalHoldId = output.legalHoldId
            self.recoveryPointSelection = output.recoveryPointSelection
            self.status = output.status
            self.title = output.title
        } else {
            self.creationDate = nil
            self.description = nil
            self.legalHoldArn = nil
            self.legalHoldId = nil
            self.recoveryPointSelection = nil
            self.status = nil
            self.title = nil
        }
    }
}

public struct CreateLegalHoldOutputResponse: Swift.Equatable {
    /// Time in number format when legal hold was created.
    public var creationDate: ClientRuntime.Date?
    /// This is the returned string description of the legal hold.
    public var description: Swift.String?
    /// This is the ARN (Amazon Resource Number) of the created legal hold.
    public var legalHoldArn: Swift.String?
    /// Legal hold ID returned for the specified legal hold on a recovery point.
    public var legalHoldId: Swift.String?
    /// This specifies criteria to assign a set of resources, such as resource types or backup vaults.
    public var recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
    /// This displays the status of the legal hold returned after creating the legal hold. Statuses can be ACTIVE, PENDING, CANCELED, CANCELING, or FAILED.
    public var status: BackupClientTypes.LegalHoldStatus?
    /// This is the string title of the legal hold returned after creating the legal hold.
    public var title: Swift.String?

    public init (
        creationDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        legalHoldArn: Swift.String? = nil,
        legalHoldId: Swift.String? = nil,
        recoveryPointSelection: BackupClientTypes.RecoveryPointSelection? = nil,
        status: BackupClientTypes.LegalHoldStatus? = nil,
        title: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.description = description
        self.legalHoldArn = legalHoldArn
        self.legalHoldId = legalHoldId
        self.recoveryPointSelection = recoveryPointSelection
        self.status = status
        self.title = title
    }
}

struct CreateLegalHoldOutputResponseBody: Swift.Equatable {
    let title: Swift.String?
    let status: BackupClientTypes.LegalHoldStatus?
    let description: Swift.String?
    let legalHoldId: Swift.String?
    let legalHoldArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
}

extension CreateLegalHoldOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case description = "Description"
        case legalHoldArn = "LegalHoldArn"
        case legalHoldId = "LegalHoldId"
        case recoveryPointSelection = "RecoveryPointSelection"
        case status = "Status"
        case title = "Title"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.LegalHoldStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let legalHoldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .legalHoldId)
        legalHoldId = legalHoldIdDecoded
        let legalHoldArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .legalHoldArn)
        legalHoldArn = legalHoldArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let recoveryPointSelectionDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointSelection.self, forKey: .recoveryPointSelection)
        recoveryPointSelection = recoveryPointSelectionDecoded
    }
}

extension CreateReportPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanDescription = "ReportPlanDescription"
        case reportPlanName = "ReportPlanName"
        case reportPlanTags = "ReportPlanTags"
        case reportSetting = "ReportSetting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let reportDeliveryChannel = self.reportDeliveryChannel {
            try encodeContainer.encode(reportDeliveryChannel, forKey: .reportDeliveryChannel)
        }
        if let reportPlanDescription = self.reportPlanDescription {
            try encodeContainer.encode(reportPlanDescription, forKey: .reportPlanDescription)
        }
        if let reportPlanName = self.reportPlanName {
            try encodeContainer.encode(reportPlanName, forKey: .reportPlanName)
        }
        if let reportPlanTags = reportPlanTags {
            var reportPlanTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .reportPlanTags)
            for (dictKey0, stringMap0) in reportPlanTags {
                try reportPlanTagsContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let reportSetting = self.reportSetting {
            try encodeContainer.encode(reportSetting, forKey: .reportSetting)
        }
    }
}

extension CreateReportPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/report-plans"
    }
}

public struct CreateReportPlanInput: Swift.Equatable {
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to CreateReportPlanInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// A structure that contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
    /// This member is required.
    public var reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
    /// An optional description of the report plan with a maximum of 1,024 characters.
    public var reportPlanDescription: Swift.String?
    /// The unique name of the report plan. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var reportPlanName: Swift.String?
    /// Metadata that you can assign to help organize the report plans that you create. Each tag is a key-value pair.
    public var reportPlanTags: [Swift.String:Swift.String]?
    /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
    /// This member is required.
    public var reportSetting: BackupClientTypes.ReportSetting?

    public init (
        idempotencyToken: Swift.String? = nil,
        reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel? = nil,
        reportPlanDescription: Swift.String? = nil,
        reportPlanName: Swift.String? = nil,
        reportPlanTags: [Swift.String:Swift.String]? = nil,
        reportSetting: BackupClientTypes.ReportSetting? = nil
    )
    {
        self.idempotencyToken = idempotencyToken
        self.reportDeliveryChannel = reportDeliveryChannel
        self.reportPlanDescription = reportPlanDescription
        self.reportPlanName = reportPlanName
        self.reportPlanTags = reportPlanTags
        self.reportSetting = reportSetting
    }
}

struct CreateReportPlanInputBody: Swift.Equatable {
    let reportPlanName: Swift.String?
    let reportPlanDescription: Swift.String?
    let reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
    let reportSetting: BackupClientTypes.ReportSetting?
    let reportPlanTags: [Swift.String:Swift.String]?
    let idempotencyToken: Swift.String?
}

extension CreateReportPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanDescription = "ReportPlanDescription"
        case reportPlanName = "ReportPlanName"
        case reportPlanTags = "ReportPlanTags"
        case reportSetting = "ReportSetting"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanName)
        reportPlanName = reportPlanNameDecoded
        let reportPlanDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanDescription)
        reportPlanDescription = reportPlanDescriptionDecoded
        let reportDeliveryChannelDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportDeliveryChannel.self, forKey: .reportDeliveryChannel)
        reportDeliveryChannel = reportDeliveryChannelDecoded
        let reportSettingDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportSetting.self, forKey: .reportSetting)
        reportSetting = reportSettingDecoded
        let reportPlanTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .reportPlanTags)
        var reportPlanTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let reportPlanTagsContainer = reportPlanTagsContainer {
            reportPlanTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in reportPlanTagsContainer {
                if let string0 = string0 {
                    reportPlanTagsDecoded0?[key0] = string0
                }
            }
        }
        reportPlanTags = reportPlanTagsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateReportPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReportPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateReportPlanOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReportPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateReportPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.reportPlanArn = output.reportPlanArn
            self.reportPlanName = output.reportPlanName
        } else {
            self.creationTime = nil
            self.reportPlanArn = nil
            self.reportPlanName = nil
        }
    }
}

public struct CreateReportPlanOutputResponse: Swift.Equatable {
    /// The date and time a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationTime: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var reportPlanArn: Swift.String?
    /// The unique name of the report plan.
    public var reportPlanName: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        reportPlanArn: Swift.String? = nil,
        reportPlanName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.reportPlanArn = reportPlanArn
        self.reportPlanName = reportPlanName
    }
}

struct CreateReportPlanOutputResponseBody: Swift.Equatable {
    let reportPlanName: Swift.String?
    let reportPlanArn: Swift.String?
    let creationTime: ClientRuntime.Date?
}

extension CreateReportPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case reportPlanArn = "ReportPlanArn"
        case reportPlanName = "ReportPlanName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanName)
        reportPlanName = reportPlanNameDecoded
        let reportPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanArn)
        reportPlanArn = reportPlanArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension BackupClientTypes.DateRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromDate = "FromDate"
        case toDate = "ToDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromDate = self.fromDate {
            try encodeContainer.encodeTimestamp(fromDate, format: .epochSeconds, forKey: .fromDate)
        }
        if let toDate = self.toDate {
            try encodeContainer.encodeTimestamp(toDate, format: .epochSeconds, forKey: .toDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fromDate)
        fromDate = fromDateDecoded
        let toDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .toDate)
        toDate = toDateDecoded
    }
}

extension BackupClientTypes {
    /// This is a resource filter containing FromDate: DateTime and ToDate: DateTime. Both values are required. Future DateTime values are not permitted. The date and time are in Unix format and Coordinated Universal Time (UTC), and it is accurate to milliseconds ((milliseconds are optional). For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public struct DateRange: Swift.Equatable {
        /// This value is the beginning date, inclusive. The date and time are in Unix format and Coordinated Universal Time (UTC), and it is accurate to milliseconds (milliseconds are optional).
        /// This member is required.
        public var fromDate: ClientRuntime.Date?
        /// This value is the end date, inclusive. The date and time are in Unix format and Coordinated Universal Time (UTC), and it is accurate to milliseconds (milliseconds are optional).
        /// This member is required.
        public var toDate: ClientRuntime.Date?

        public init (
            fromDate: ClientRuntime.Date? = nil,
            toDate: ClientRuntime.Date? = nil
        )
        {
            self.fromDate = fromDate
            self.toDate = toDate
        }
    }

}

extension DeleteBackupPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())"
    }
}

public struct DeleteBackupPlanInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
    }
}

struct DeleteBackupPlanInputBody: Swift.Equatable {
}

extension DeleteBackupPlanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBackupPlanOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteBackupPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.deletionDate = output.deletionDate
            self.versionId = output.versionId
        } else {
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.deletionDate = nil
            self.versionId = nil
        }
    }
}

public struct DeleteBackupPlanOutputResponse: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var deletionDate: ClientRuntime.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
    public var versionId: Swift.String?

    public init (
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        deletionDate: ClientRuntime.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.deletionDate = deletionDate
        self.versionId = versionId
    }
}

struct DeleteBackupPlanOutputResponseBody: Swift.Equatable {
    let backupPlanId: Swift.String?
    let backupPlanArn: Swift.String?
    let deletionDate: ClientRuntime.Date?
    let versionId: Swift.String?
}

extension DeleteBackupPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case deletionDate = "DeletionDate"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let deletionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension DeleteBackupSelectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        guard let selectionId = selectionId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections/\(selectionId.urlPercentEncoding())"
    }
}

public struct DeleteBackupSelectionInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    /// This member is required.
    public var selectionId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.selectionId = selectionId
    }
}

struct DeleteBackupSelectionInputBody: Swift.Equatable {
}

extension DeleteBackupSelectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupSelectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupSelectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBackupSelectionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupSelectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupSelectionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteBackupVaultAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/access-policy"
    }
}

public struct DeleteBackupVaultAccessPolicyInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultAccessPolicyInputBody: Swift.Equatable {
}

extension DeleteBackupVaultAccessPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupVaultAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBackupVaultAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupVaultAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupVaultAccessPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteBackupVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())"
    }
}

public struct DeleteBackupVaultInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultInputBody: Swift.Equatable {
}

extension DeleteBackupVaultInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultLockConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/vault-lock"
    }
}

public struct DeleteBackupVaultLockConfigurationInput: Swift.Equatable {
    /// The name of the backup vault from which to delete Backup Vault Lock.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultLockConfigurationInputBody: Swift.Equatable {
}

extension DeleteBackupVaultLockConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultLockConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupVaultLockConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBackupVaultLockConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupVaultLockConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupVaultLockConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteBackupVaultNotificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/notification-configuration"
    }
}

public struct DeleteBackupVaultNotificationsInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultNotificationsInputBody: Swift.Equatable {
}

extension DeleteBackupVaultNotificationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupVaultNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBackupVaultNotificationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupVaultNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupVaultNotificationsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteBackupVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBackupVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupVaultOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let frameworkName = frameworkName else {
            return nil
        }
        return "/audit/frameworks/\(frameworkName.urlPercentEncoding())"
    }
}

public struct DeleteFrameworkInput: Swift.Equatable {
    /// The unique name of a framework.
    /// This member is required.
    public var frameworkName: Swift.String?

    public init (
        frameworkName: Swift.String? = nil
    )
    {
        self.frameworkName = frameworkName
    }
}

struct DeleteFrameworkInputBody: Swift.Equatable {
}

extension DeleteFrameworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFrameworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFrameworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFrameworkOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFrameworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFrameworkOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRecoveryPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())"
    }
}

public struct DeleteRecoveryPointInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct DeleteRecoveryPointInputBody: Swift.Equatable {
}

extension DeleteRecoveryPointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRecoveryPointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecoveryPointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRecoveryPointOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case invalidResourceStateException(InvalidResourceStateException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecoveryPointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRecoveryPointOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteReportPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportPlanName = reportPlanName else {
            return nil
        }
        return "/audit/report-plans/\(reportPlanName.urlPercentEncoding())"
    }
}

public struct DeleteReportPlanInput: Swift.Equatable {
    /// The unique name of a report plan.
    /// This member is required.
    public var reportPlanName: Swift.String?

    public init (
        reportPlanName: Swift.String? = nil
    )
    {
        self.reportPlanName = reportPlanName
    }
}

struct DeleteReportPlanInputBody: Swift.Equatable {
}

extension DeleteReportPlanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReportPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReportPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteReportPlanOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReportPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReportPlanOutputResponse: Swift.Equatable {

    public init () { }
}

extension DependencyFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DependencyFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A dependent Amazon Web Services service or resource returned an error to the Backup service, and the action cannot be completed.
public struct DependencyFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct DependencyFailureExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension DependencyFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension DescribeBackupJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupJobId = backupJobId else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())"
    }
}

public struct DescribeBackupJobInput: Swift.Equatable {
    /// Uniquely identifies a request to Backup to back up a resource.
    /// This member is required.
    public var backupJobId: Swift.String?

    public init (
        backupJobId: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
    }
}

struct DescribeBackupJobInputBody: Swift.Equatable {
}

extension DescribeBackupJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBackupJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBackupJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyFailureException" : self = .dependencyFailureException(try DependencyFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBackupJobOutputError: Swift.Error, Swift.Equatable {
    case dependencyFailureException(DependencyFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBackupJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBackupJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.backupJobId = output.backupJobId
            self.backupOptions = output.backupOptions
            self.backupSizeInBytes = output.backupSizeInBytes
            self.backupType = output.backupType
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.bytesTransferred = output.bytesTransferred
            self.childJobsInState = output.childJobsInState
            self.completionDate = output.completionDate
            self.createdBy = output.createdBy
            self.creationDate = output.creationDate
            self.expectedCompletionDate = output.expectedCompletionDate
            self.iamRoleArn = output.iamRoleArn
            self.isParent = output.isParent
            self.numberOfChildJobs = output.numberOfChildJobs
            self.parentJobId = output.parentJobId
            self.percentDone = output.percentDone
            self.recoveryPointArn = output.recoveryPointArn
            self.resourceArn = output.resourceArn
            self.resourceName = output.resourceName
            self.resourceType = output.resourceType
            self.startBy = output.startBy
            self.state = output.state
            self.statusMessage = output.statusMessage
        } else {
            self.accountId = nil
            self.backupJobId = nil
            self.backupOptions = nil
            self.backupSizeInBytes = nil
            self.backupType = nil
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.bytesTransferred = nil
            self.childJobsInState = nil
            self.completionDate = nil
            self.createdBy = nil
            self.creationDate = nil
            self.expectedCompletionDate = nil
            self.iamRoleArn = nil
            self.isParent = false
            self.numberOfChildJobs = nil
            self.parentJobId = nil
            self.percentDone = nil
            self.recoveryPointArn = nil
            self.resourceArn = nil
            self.resourceName = nil
            self.resourceType = nil
            self.startBy = nil
            self.state = nil
            self.statusMessage = nil
        }
    }
}

public struct DescribeBackupJobOutputResponse: Swift.Equatable {
    /// Returns the account ID that owns the backup job.
    public var accountId: Swift.String?
    /// Uniquely identifies a request to Backup to back up a resource.
    public var backupJobId: Swift.String?
    /// Represents the options specified as part of backup plan or on-demand backup job.
    public var backupOptions: [Swift.String:Swift.String]?
    /// The size, in bytes, of a backup.
    public var backupSizeInBytes: Swift.Int?
    /// Represents the actual backup type selected for a backup job. For example, if a successful Windows Volume Shadow Copy Service (VSS) backup was taken, BackupType returns "WindowsVSS". If BackupType is empty, then the backup type was a regular backup.
    public var backupType: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// The size in bytes transferred to a backup vault at the time that the job status was queried.
    public var bytesTransferred: Swift.Int?
    /// This returns the statistics of the included child (nested) backup jobs.
    public var childJobsInState: [Swift.String:Swift.Int]?
    /// The date and time that a job to create a backup job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var completionDate: ClientRuntime.Date?
    /// Contains identifying information about the creation of a backup job, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan that is used to create it.
    public var createdBy: BackupClientTypes.RecoveryPointCreator?
    /// The date and time that a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// The date and time that a job to back up resources is expected to be completed, in Unix format and Coordinated Universal Time (UTC). The value of ExpectedCompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var expectedCompletionDate: ClientRuntime.Date?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// This returns the boolean value that a backup job is a parent (composite) job.
    public var isParent: Swift.Bool
    /// This returns the number of child (nested) backup jobs.
    public var numberOfChildJobs: Swift.Int?
    /// This returns the parent (composite) resource backup job ID.
    public var parentJobId: Swift.String?
    /// Contains an estimated percentage that is complete of a job at the time the job status was queried.
    public var percentDone: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// An ARN that uniquely identifies a saved resource. The format of the ARN depends on the resource type.
    public var resourceArn: Swift.String?
    /// This is the non-unique name of the resource that belongs to the specified backup.
    public var resourceName: Swift.String?
    /// The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
    public var resourceType: Swift.String?
    /// Specifies the time in Unix format and Coordinated Universal Time (UTC) when a backup job must be started before it is canceled. The value is calculated by adding the start window to the scheduled time. So if the scheduled time were 6:00 PM and the start window is 2 hours, the StartBy time would be 8:00 PM on the date specified. The value of StartBy is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var startBy: ClientRuntime.Date?
    /// The current state of a resource recovery point.
    public var state: BackupClientTypes.BackupJobState?
    /// A detailed message explaining the status of the job to back up a resource.
    public var statusMessage: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        backupJobId: Swift.String? = nil,
        backupOptions: [Swift.String:Swift.String]? = nil,
        backupSizeInBytes: Swift.Int? = nil,
        backupType: Swift.String? = nil,
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        bytesTransferred: Swift.Int? = nil,
        childJobsInState: [Swift.String:Swift.Int]? = nil,
        completionDate: ClientRuntime.Date? = nil,
        createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
        creationDate: ClientRuntime.Date? = nil,
        expectedCompletionDate: ClientRuntime.Date? = nil,
        iamRoleArn: Swift.String? = nil,
        isParent: Swift.Bool = false,
        numberOfChildJobs: Swift.Int? = nil,
        parentJobId: Swift.String? = nil,
        percentDone: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        startBy: ClientRuntime.Date? = nil,
        state: BackupClientTypes.BackupJobState? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.backupJobId = backupJobId
        self.backupOptions = backupOptions
        self.backupSizeInBytes = backupSizeInBytes
        self.backupType = backupType
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.bytesTransferred = bytesTransferred
        self.childJobsInState = childJobsInState
        self.completionDate = completionDate
        self.createdBy = createdBy
        self.creationDate = creationDate
        self.expectedCompletionDate = expectedCompletionDate
        self.iamRoleArn = iamRoleArn
        self.isParent = isParent
        self.numberOfChildJobs = numberOfChildJobs
        self.parentJobId = parentJobId
        self.percentDone = percentDone
        self.recoveryPointArn = recoveryPointArn
        self.resourceArn = resourceArn
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.startBy = startBy
        self.state = state
        self.statusMessage = statusMessage
    }
}

struct DescribeBackupJobOutputResponseBody: Swift.Equatable {
    let accountId: Swift.String?
    let backupJobId: Swift.String?
    let backupVaultName: Swift.String?
    let backupVaultArn: Swift.String?
    let recoveryPointArn: Swift.String?
    let resourceArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let completionDate: ClientRuntime.Date?
    let state: BackupClientTypes.BackupJobState?
    let statusMessage: Swift.String?
    let percentDone: Swift.String?
    let backupSizeInBytes: Swift.Int?
    let iamRoleArn: Swift.String?
    let createdBy: BackupClientTypes.RecoveryPointCreator?
    let resourceType: Swift.String?
    let bytesTransferred: Swift.Int?
    let expectedCompletionDate: ClientRuntime.Date?
    let startBy: ClientRuntime.Date?
    let backupOptions: [Swift.String:Swift.String]?
    let backupType: Swift.String?
    let parentJobId: Swift.String?
    let isParent: Swift.Bool
    let numberOfChildJobs: Swift.Int?
    let childJobsInState: [Swift.String:Swift.Int]?
    let resourceName: Swift.String?
}

extension DescribeBackupJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupJobId = "BackupJobId"
        case backupOptions = "BackupOptions"
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupType = "BackupType"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case bytesTransferred = "BytesTransferred"
        case childJobsInState = "ChildJobsInState"
        case completionDate = "CompletionDate"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case expectedCompletionDate = "ExpectedCompletionDate"
        case iamRoleArn = "IamRoleArn"
        case isParent = "IsParent"
        case numberOfChildJobs = "NumberOfChildJobs"
        case parentJobId = "ParentJobId"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case startBy = "StartBy"
        case state = "State"
        case statusMessage = "StatusMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let backupJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupJobId)
        backupJobId = backupJobIdDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDate)
        completionDate = completionDateDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupJobState.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let bytesTransferredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesTransferred)
        bytesTransferred = bytesTransferredDecoded
        let expectedCompletionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expectedCompletionDate)
        expectedCompletionDate = expectedCompletionDateDecoded
        let startByDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startBy)
        startBy = startByDecoded
        let backupOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
        let backupTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupType)
        backupType = backupTypeDecoded
        let parentJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentJobId)
        parentJobId = parentJobIdDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
        let numberOfChildJobsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfChildJobs)
        numberOfChildJobs = numberOfChildJobsDecoded
        let childJobsInStateContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .childJobsInState)
        var childJobsInStateDecoded0: [Swift.String:Swift.Int]? = nil
        if let childJobsInStateContainer = childJobsInStateContainer {
            childJobsInStateDecoded0 = [Swift.String:Swift.Int]()
            for (key0, long0) in childJobsInStateContainer {
                if let long0 = long0 {
                    childJobsInStateDecoded0?[key0] = long0
                }
            }
        }
        childJobsInState = childJobsInStateDecoded0
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension DescribeBackupVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())"
    }
}

public struct DescribeBackupVaultInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DescribeBackupVaultInputBody: Swift.Equatable {
}

extension DescribeBackupVaultInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBackupVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBackupVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBackupVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBackupVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBackupVaultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.creationDate = output.creationDate
            self.creatorRequestId = output.creatorRequestId
            self.encryptionKeyArn = output.encryptionKeyArn
            self.lockDate = output.lockDate
            self.locked = output.locked
            self.maxRetentionDays = output.maxRetentionDays
            self.minRetentionDays = output.minRetentionDays
            self.numberOfRecoveryPoints = output.numberOfRecoveryPoints
        } else {
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.creationDate = nil
            self.creatorRequestId = nil
            self.encryptionKeyArn = nil
            self.lockDate = nil
            self.locked = nil
            self.maxRetentionDays = nil
            self.minRetentionDays = nil
            self.numberOfRecoveryPoints = 0
        }
    }
}

public struct DescribeBackupVaultOutputResponse: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// The date and time that a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
    public var creatorRequestId: Swift.String?
    /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    public var encryptionKeyArn: Swift.String?
    /// The date and time when Backup Vault Lock configuration cannot be changed or deleted. If you applied Vault Lock to your vault without specifying a lock date, you can change any of your Vault Lock settings, or delete Vault Lock from the vault entirely, at any time. This value is in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lockDate: ClientRuntime.Date?
    /// A Boolean that indicates whether Backup Vault Lock is currently protecting the backup vault. True means that Vault Lock causes delete or update operations on the recovery points stored in the vault to fail.
    public var locked: Swift.Bool?
    /// The Backup Vault Lock setting that specifies the maximum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a maximum retention period on the recovery points in the vault (allowing indefinite storage). If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
    public var maxRetentionDays: Swift.Int?
    /// The Backup Vault Lock setting that specifies the minimum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a minimum retention period. If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
    public var minRetentionDays: Swift.Int?
    /// The number of recovery points that are stored in a backup vault.
    public var numberOfRecoveryPoints: Swift.Int

    public init (
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        creatorRequestId: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil,
        lockDate: ClientRuntime.Date? = nil,
        locked: Swift.Bool? = nil,
        maxRetentionDays: Swift.Int? = nil,
        minRetentionDays: Swift.Int? = nil,
        numberOfRecoveryPoints: Swift.Int = 0
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.encryptionKeyArn = encryptionKeyArn
        self.lockDate = lockDate
        self.locked = locked
        self.maxRetentionDays = maxRetentionDays
        self.minRetentionDays = minRetentionDays
        self.numberOfRecoveryPoints = numberOfRecoveryPoints
    }
}

struct DescribeBackupVaultOutputResponseBody: Swift.Equatable {
    let backupVaultName: Swift.String?
    let backupVaultArn: Swift.String?
    let encryptionKeyArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let creatorRequestId: Swift.String?
    let numberOfRecoveryPoints: Swift.Int
    let locked: Swift.Bool?
    let minRetentionDays: Swift.Int?
    let maxRetentionDays: Swift.Int?
    let lockDate: ClientRuntime.Date?
}

extension DescribeBackupVaultOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
        case lockDate = "LockDate"
        case locked = "Locked"
        case maxRetentionDays = "MaxRetentionDays"
        case minRetentionDays = "MinRetentionDays"
        case numberOfRecoveryPoints = "NumberOfRecoveryPoints"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let numberOfRecoveryPointsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecoveryPoints) ?? 0
        numberOfRecoveryPoints = numberOfRecoveryPointsDecoded
        let lockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .locked)
        locked = lockedDecoded
        let minRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minRetentionDays)
        minRetentionDays = minRetentionDaysDecoded
        let maxRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetentionDays)
        maxRetentionDays = maxRetentionDaysDecoded
        let lockDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lockDate)
        lockDate = lockDateDecoded
    }
}

extension DescribeCopyJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let copyJobId = copyJobId else {
            return nil
        }
        return "/copy-jobs/\(copyJobId.urlPercentEncoding())"
    }
}

public struct DescribeCopyJobInput: Swift.Equatable {
    /// Uniquely identifies a copy job.
    /// This member is required.
    public var copyJobId: Swift.String?

    public init (
        copyJobId: Swift.String? = nil
    )
    {
        self.copyJobId = copyJobId
    }
}

struct DescribeCopyJobInputBody: Swift.Equatable {
}

extension DescribeCopyJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCopyJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCopyJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeCopyJobOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCopyJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCopyJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.copyJob = output.copyJob
        } else {
            self.copyJob = nil
        }
    }
}

public struct DescribeCopyJobOutputResponse: Swift.Equatable {
    /// Contains detailed information about a copy job.
    public var copyJob: BackupClientTypes.CopyJob?

    public init (
        copyJob: BackupClientTypes.CopyJob? = nil
    )
    {
        self.copyJob = copyJob
    }
}

struct DescribeCopyJobOutputResponseBody: Swift.Equatable {
    let copyJob: BackupClientTypes.CopyJob?
}

extension DescribeCopyJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyJob = "CopyJob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyJobDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CopyJob.self, forKey: .copyJob)
        copyJob = copyJobDecoded
    }
}

extension DescribeFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let frameworkName = frameworkName else {
            return nil
        }
        return "/audit/frameworks/\(frameworkName.urlPercentEncoding())"
    }
}

public struct DescribeFrameworkInput: Swift.Equatable {
    /// The unique name of a framework.
    /// This member is required.
    public var frameworkName: Swift.String?

    public init (
        frameworkName: Swift.String? = nil
    )
    {
        self.frameworkName = frameworkName
    }
}

struct DescribeFrameworkInputBody: Swift.Equatable {
}

extension DescribeFrameworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFrameworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFrameworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFrameworkOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFrameworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFrameworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.deploymentStatus = output.deploymentStatus
            self.frameworkArn = output.frameworkArn
            self.frameworkControls = output.frameworkControls
            self.frameworkDescription = output.frameworkDescription
            self.frameworkName = output.frameworkName
            self.frameworkStatus = output.frameworkStatus
            self.idempotencyToken = output.idempotencyToken
        } else {
            self.creationTime = nil
            self.deploymentStatus = nil
            self.frameworkArn = nil
            self.frameworkControls = nil
            self.frameworkDescription = nil
            self.frameworkName = nil
            self.frameworkStatus = nil
            self.idempotencyToken = nil
        }
    }
}

public struct DescribeFrameworkOutputResponse: Swift.Equatable {
    /// The date and time that a framework is created, in ISO 8601 representation. The value of CreationTime is accurate to milliseconds. For example, 2020-07-10T15:00:00.000-08:00 represents the 10th of July 2020 at 3:00 PM 8 hours behind UTC.
    public var creationTime: ClientRuntime.Date?
    /// The deployment status of a framework. The statuses are: CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED | FAILED
    public var deploymentStatus: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var frameworkArn: Swift.String?
    /// A list of the controls that make up the framework. Each control in the list has a name, input parameters, and scope.
    public var frameworkControls: [BackupClientTypes.FrameworkControl]?
    /// An optional description of the framework.
    public var frameworkDescription: Swift.String?
    /// The unique name of a framework.
    public var frameworkName: Swift.String?
    /// A framework consists of one or more controls. Each control governs a resource, such as backup plans, backup selections, backup vaults, or recovery points. You can also turn Config recording on or off for each resource. The statuses are:
    ///
    /// * ACTIVE when recording is turned on for all resources governed by the framework.
    ///
    /// * PARTIALLY_ACTIVE when recording is turned off for at least one resource governed by the framework.
    ///
    /// * INACTIVE when recording is turned off for all resources governed by the framework.
    ///
    /// * UNAVAILABLE when Backup is unable to validate recording status at this time.
    public var frameworkStatus: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to DescribeFrameworkOutput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        deploymentStatus: Swift.String? = nil,
        frameworkArn: Swift.String? = nil,
        frameworkControls: [BackupClientTypes.FrameworkControl]? = nil,
        frameworkDescription: Swift.String? = nil,
        frameworkName: Swift.String? = nil,
        frameworkStatus: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.deploymentStatus = deploymentStatus
        self.frameworkArn = frameworkArn
        self.frameworkControls = frameworkControls
        self.frameworkDescription = frameworkDescription
        self.frameworkName = frameworkName
        self.frameworkStatus = frameworkStatus
        self.idempotencyToken = idempotencyToken
    }
}

struct DescribeFrameworkOutputResponseBody: Swift.Equatable {
    let frameworkName: Swift.String?
    let frameworkArn: Swift.String?
    let frameworkDescription: Swift.String?
    let frameworkControls: [BackupClientTypes.FrameworkControl]?
    let creationTime: ClientRuntime.Date?
    let deploymentStatus: Swift.String?
    let frameworkStatus: Swift.String?
    let idempotencyToken: Swift.String?
}

extension DescribeFrameworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case deploymentStatus = "DeploymentStatus"
        case frameworkArn = "FrameworkArn"
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case frameworkName = "FrameworkName"
        case frameworkStatus = "FrameworkStatus"
        case idempotencyToken = "IdempotencyToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkArn)
        frameworkArn = frameworkArnDecoded
        let frameworkDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkDescription)
        frameworkDescription = frameworkDescriptionDecoded
        let frameworkControlsContainer = try containerValues.decodeIfPresent([BackupClientTypes.FrameworkControl?].self, forKey: .frameworkControls)
        var frameworkControlsDecoded0:[BackupClientTypes.FrameworkControl]? = nil
        if let frameworkControlsContainer = frameworkControlsContainer {
            frameworkControlsDecoded0 = [BackupClientTypes.FrameworkControl]()
            for structure0 in frameworkControlsContainer {
                if let structure0 = structure0 {
                    frameworkControlsDecoded0?.append(structure0)
                }
            }
        }
        frameworkControls = frameworkControlsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let frameworkStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkStatus)
        frameworkStatus = frameworkStatusDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension DescribeGlobalSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/global-settings"
    }
}

public struct DescribeGlobalSettingsInput: Swift.Equatable {

    public init () { }
}

struct DescribeGlobalSettingsInputBody: Swift.Equatable {
}

extension DescribeGlobalSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGlobalSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGlobalSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeGlobalSettingsOutputError: Swift.Error, Swift.Equatable {
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGlobalSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeGlobalSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalSettings = output.globalSettings
            self.lastUpdateTime = output.lastUpdateTime
        } else {
            self.globalSettings = nil
            self.lastUpdateTime = nil
        }
    }
}

public struct DescribeGlobalSettingsOutputResponse: Swift.Equatable {
    /// The status of the flag isCrossAccountBackupEnabled.
    public var globalSettings: [Swift.String:Swift.String]?
    /// The date and time that the flag isCrossAccountBackupEnabled was last updated. This update is in Unix format and Coordinated Universal Time (UTC). The value of LastUpdateTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastUpdateTime: ClientRuntime.Date?

    public init (
        globalSettings: [Swift.String:Swift.String]? = nil,
        lastUpdateTime: ClientRuntime.Date? = nil
    )
    {
        self.globalSettings = globalSettings
        self.lastUpdateTime = lastUpdateTime
    }
}

struct DescribeGlobalSettingsOutputResponseBody: Swift.Equatable {
    let globalSettings: [Swift.String:Swift.String]?
    let lastUpdateTime: ClientRuntime.Date?
}

extension DescribeGlobalSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalSettings = "GlobalSettings"
        case lastUpdateTime = "LastUpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalSettingsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .globalSettings)
        var globalSettingsDecoded0: [Swift.String:Swift.String]? = nil
        if let globalSettingsContainer = globalSettingsContainer {
            globalSettingsDecoded0 = [Swift.String:Swift.String]()
            for (key0, globalsettingsvalue0) in globalSettingsContainer {
                if let globalsettingsvalue0 = globalsettingsvalue0 {
                    globalSettingsDecoded0?[key0] = globalsettingsvalue0
                }
            }
        }
        globalSettings = globalSettingsDecoded0
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension DescribeProtectedResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())"
    }
}

public struct DescribeProtectedResourceInput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DescribeProtectedResourceInputBody: Swift.Equatable {
}

extension DescribeProtectedResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProtectedResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProtectedResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeProtectedResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProtectedResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeProtectedResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastBackupTime = output.lastBackupTime
            self.resourceArn = output.resourceArn
            self.resourceName = output.resourceName
            self.resourceType = output.resourceType
        } else {
            self.lastBackupTime = nil
            self.resourceArn = nil
            self.resourceName = nil
            self.resourceType = nil
        }
    }
}

public struct DescribeProtectedResourceOutputResponse: Swift.Equatable {
    /// The date and time that a resource was last backed up, in Unix format and Coordinated Universal Time (UTC). The value of LastBackupTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastBackupTime: ClientRuntime.Date?
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var resourceArn: Swift.String?
    /// This is the non-unique name of the resource that belongs to the specified backup.
    public var resourceName: Swift.String?
    /// The type of Amazon Web Services resource saved as a recovery point; for example, an Amazon EBS volume or an Amazon RDS database.
    public var resourceType: Swift.String?

    public init (
        lastBackupTime: ClientRuntime.Date? = nil,
        resourceArn: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.lastBackupTime = lastBackupTime
        self.resourceArn = resourceArn
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

struct DescribeProtectedResourceOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let resourceType: Swift.String?
    let lastBackupTime: ClientRuntime.Date?
    let resourceName: Swift.String?
}

extension DescribeProtectedResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastBackupTime = "LastBackupTime"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let lastBackupTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastBackupTime)
        lastBackupTime = lastBackupTimeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension DescribeRecoveryPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())"
    }
}

public struct DescribeRecoveryPointInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct DescribeRecoveryPointInputBody: Swift.Equatable {
}

extension DescribeRecoveryPointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRecoveryPointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecoveryPointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRecoveryPointOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecoveryPointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRecoveryPointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupSizeInBytes = output.backupSizeInBytes
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.calculatedLifecycle = output.calculatedLifecycle
            self.completionDate = output.completionDate
            self.compositeMemberIdentifier = output.compositeMemberIdentifier
            self.createdBy = output.createdBy
            self.creationDate = output.creationDate
            self.encryptionKeyArn = output.encryptionKeyArn
            self.iamRoleArn = output.iamRoleArn
            self.isEncrypted = output.isEncrypted
            self.isParent = output.isParent
            self.lastRestoreTime = output.lastRestoreTime
            self.lifecycle = output.lifecycle
            self.parentRecoveryPointArn = output.parentRecoveryPointArn
            self.recoveryPointArn = output.recoveryPointArn
            self.resourceArn = output.resourceArn
            self.resourceName = output.resourceName
            self.resourceType = output.resourceType
            self.sourceBackupVaultArn = output.sourceBackupVaultArn
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.storageClass = output.storageClass
        } else {
            self.backupSizeInBytes = nil
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.calculatedLifecycle = nil
            self.completionDate = nil
            self.compositeMemberIdentifier = nil
            self.createdBy = nil
            self.creationDate = nil
            self.encryptionKeyArn = nil
            self.iamRoleArn = nil
            self.isEncrypted = false
            self.isParent = false
            self.lastRestoreTime = nil
            self.lifecycle = nil
            self.parentRecoveryPointArn = nil
            self.recoveryPointArn = nil
            self.resourceArn = nil
            self.resourceName = nil
            self.resourceType = nil
            self.sourceBackupVaultArn = nil
            self.status = nil
            self.statusMessage = nil
            self.storageClass = nil
        }
    }
}

public struct DescribeRecoveryPointOutputResponse: Swift.Equatable {
    /// The size, in bytes, of a backup.
    public var backupSizeInBytes: Swift.Int?
    /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
    public var calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
    /// The date and time that a job to create a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var completionDate: ClientRuntime.Date?
    /// This is the identifier of a resource within a composite group, such as nested (child) recovery point belonging to a composite (parent) stack. The ID is transferred from the [ logical ID](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html#resources-section-structure-syntax) within a stack.
    public var compositeMemberIdentifier: Swift.String?
    /// Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan used to create it.
    public var createdBy: BackupClientTypes.RecoveryPointCreator?
    /// The date and time that a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// The server-side encryption key used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    public var encryptionKeyArn: Swift.String?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.
    public var isEncrypted: Swift.Bool
    /// This returns the boolean value that a recovery point is a parent (composite) job.
    public var isParent: Swift.Bool
    /// The date and time that a recovery point was last restored, in Unix format and Coordinated Universal Time (UTC). The value of LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastRestoreTime: ClientRuntime.Date?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups that are transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// This is an ARN that uniquely identifies a parent (composite) recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var parentRecoveryPointArn: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// An ARN that uniquely identifies a saved resource. The format of the ARN depends on the resource type.
    public var resourceArn: Swift.String?
    /// This is the non-unique name of the resource that belongs to the specified backup.
    public var resourceName: Swift.String?
    /// The type of Amazon Web Services resource to save as a recovery point; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
    public var resourceType: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies the source vault where the resource was originally backed up in; for example, arn:aws:backup:us-east-1:123456789012:vault:BackupVault. If the recovery is restored to the same Amazon Web Services account or Region, this value will be null.
    public var sourceBackupVaultArn: Swift.String?
    /// A status code specifying the state of the recovery point. PARTIAL status indicates Backup could not create the recovery point before the backup window closed. To increase your backup plan window using the API, see [UpdateBackupPlan](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_UpdateBackupPlan.html). You can also increase your backup plan window using the Console by choosing and editing your backup plan. EXPIRED status indicates that the recovery point has exceeded its retention period, but Backup lacks permission or is otherwise unable to delete it. To manually delete these recovery points, see [ Step 3: Delete the recovery points](https://docs.aws.amazon.com/aws-backup/latest/devguide/gs-cleanup-resources.html#cleanup-backups) in the Clean up resources section of Getting started. STOPPED status occurs on a continuous backup where a user has taken some action that causes the continuous backup to be disabled. This can be caused by the removal of permissions, turning off versioning, turning off events being sent to EventBridge, or disabling the EventBridge rules that are put in place by Backup. To resolve STOPPED status, ensure that all requested permissions are in place and that versioning is enabled on the S3 bucket. Once these conditions are met, the next instance of a backup rule running will result in a new continuous recovery point being created. The recovery points with STOPPED status do not need to be deleted.
    public var status: BackupClientTypes.RecoveryPointStatus?
    /// A status message explaining the reason for the recovery point deletion failure.
    public var statusMessage: Swift.String?
    /// Specifies the storage class of the recovery point. Valid values are WARM or COLD.
    public var storageClass: BackupClientTypes.StorageClass?

    public init (
        backupSizeInBytes: Swift.Int? = nil,
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        calculatedLifecycle: BackupClientTypes.CalculatedLifecycle? = nil,
        completionDate: ClientRuntime.Date? = nil,
        compositeMemberIdentifier: Swift.String? = nil,
        createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
        creationDate: ClientRuntime.Date? = nil,
        encryptionKeyArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        isEncrypted: Swift.Bool = false,
        isParent: Swift.Bool = false,
        lastRestoreTime: ClientRuntime.Date? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        parentRecoveryPointArn: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        sourceBackupVaultArn: Swift.String? = nil,
        status: BackupClientTypes.RecoveryPointStatus? = nil,
        statusMessage: Swift.String? = nil,
        storageClass: BackupClientTypes.StorageClass? = nil
    )
    {
        self.backupSizeInBytes = backupSizeInBytes
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.calculatedLifecycle = calculatedLifecycle
        self.completionDate = completionDate
        self.compositeMemberIdentifier = compositeMemberIdentifier
        self.createdBy = createdBy
        self.creationDate = creationDate
        self.encryptionKeyArn = encryptionKeyArn
        self.iamRoleArn = iamRoleArn
        self.isEncrypted = isEncrypted
        self.isParent = isParent
        self.lastRestoreTime = lastRestoreTime
        self.lifecycle = lifecycle
        self.parentRecoveryPointArn = parentRecoveryPointArn
        self.recoveryPointArn = recoveryPointArn
        self.resourceArn = resourceArn
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.sourceBackupVaultArn = sourceBackupVaultArn
        self.status = status
        self.statusMessage = statusMessage
        self.storageClass = storageClass
    }
}

struct DescribeRecoveryPointOutputResponseBody: Swift.Equatable {
    let recoveryPointArn: Swift.String?
    let backupVaultName: Swift.String?
    let backupVaultArn: Swift.String?
    let sourceBackupVaultArn: Swift.String?
    let resourceArn: Swift.String?
    let resourceType: Swift.String?
    let createdBy: BackupClientTypes.RecoveryPointCreator?
    let iamRoleArn: Swift.String?
    let status: BackupClientTypes.RecoveryPointStatus?
    let statusMessage: Swift.String?
    let creationDate: ClientRuntime.Date?
    let completionDate: ClientRuntime.Date?
    let backupSizeInBytes: Swift.Int?
    let calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
    let lifecycle: BackupClientTypes.Lifecycle?
    let encryptionKeyArn: Swift.String?
    let isEncrypted: Swift.Bool
    let storageClass: BackupClientTypes.StorageClass?
    let lastRestoreTime: ClientRuntime.Date?
    let parentRecoveryPointArn: Swift.String?
    let compositeMemberIdentifier: Swift.String?
    let isParent: Swift.Bool
    let resourceName: Swift.String?
}

extension DescribeRecoveryPointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case calculatedLifecycle = "CalculatedLifecycle"
        case completionDate = "CompletionDate"
        case compositeMemberIdentifier = "CompositeMemberIdentifier"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case encryptionKeyArn = "EncryptionKeyArn"
        case iamRoleArn = "IamRoleArn"
        case isEncrypted = "IsEncrypted"
        case isParent = "IsParent"
        case lastRestoreTime = "LastRestoreTime"
        case lifecycle = "Lifecycle"
        case parentRecoveryPointArn = "ParentRecoveryPointArn"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case sourceBackupVaultArn = "SourceBackupVaultArn"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case storageClass = "StorageClass"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let sourceBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupVaultArn)
        sourceBackupVaultArn = sourceBackupVaultArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDate)
        completionDate = completionDateDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let calculatedLifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CalculatedLifecycle.self, forKey: .calculatedLifecycle)
        calculatedLifecycle = calculatedLifecycleDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let isEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEncrypted) ?? false
        isEncrypted = isEncryptedDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(BackupClientTypes.StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let lastRestoreTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastRestoreTime)
        lastRestoreTime = lastRestoreTimeDecoded
        let parentRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentRecoveryPointArn)
        parentRecoveryPointArn = parentRecoveryPointArnDecoded
        let compositeMemberIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .compositeMemberIdentifier)
        compositeMemberIdentifier = compositeMemberIdentifierDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension DescribeRegionSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account-settings"
    }
}

public struct DescribeRegionSettingsInput: Swift.Equatable {

    public init () { }
}

struct DescribeRegionSettingsInputBody: Swift.Equatable {
}

extension DescribeRegionSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRegionSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRegionSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRegionSettingsOutputError: Swift.Error, Swift.Equatable {
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRegionSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRegionSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceTypeManagementPreference = output.resourceTypeManagementPreference
            self.resourceTypeOptInPreference = output.resourceTypeOptInPreference
        } else {
            self.resourceTypeManagementPreference = nil
            self.resourceTypeOptInPreference = nil
        }
    }
}

public struct DescribeRegionSettingsOutputResponse: Swift.Equatable {
    /// Returns whether Backup fully manages the backups for a resource type. For the benefits of full Backup management, see [ Full Backup management](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#full-management). For a list of resource types and whether each supports full Backup management, see the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. If "DynamoDB":false, you can enable full Backup management for DynamoDB backup by enabling [ Backup's advanced DynamoDB backup features](https://docs.aws.amazon.com/aws-backup/latest/devguide/advanced-ddb-backup.html#advanced-ddb-backup-enable-cli).
    public var resourceTypeManagementPreference: [Swift.String:Swift.Bool]?
    /// Returns a list of all services along with the opt-in preferences in the Region.
    public var resourceTypeOptInPreference: [Swift.String:Swift.Bool]?

    public init (
        resourceTypeManagementPreference: [Swift.String:Swift.Bool]? = nil,
        resourceTypeOptInPreference: [Swift.String:Swift.Bool]? = nil
    )
    {
        self.resourceTypeManagementPreference = resourceTypeManagementPreference
        self.resourceTypeOptInPreference = resourceTypeOptInPreference
    }
}

struct DescribeRegionSettingsOutputResponseBody: Swift.Equatable {
    let resourceTypeOptInPreference: [Swift.String:Swift.Bool]?
    let resourceTypeManagementPreference: [Swift.String:Swift.Bool]?
}

extension DescribeRegionSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTypeManagementPreference = "ResourceTypeManagementPreference"
        case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeOptInPreferenceContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .resourceTypeOptInPreference)
        var resourceTypeOptInPreferenceDecoded0: [Swift.String:Swift.Bool]? = nil
        if let resourceTypeOptInPreferenceContainer = resourceTypeOptInPreferenceContainer {
            resourceTypeOptInPreferenceDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, isenabled0) in resourceTypeOptInPreferenceContainer {
                if let isenabled0 = isenabled0 {
                    resourceTypeOptInPreferenceDecoded0?[key0] = isenabled0
                }
            }
        }
        resourceTypeOptInPreference = resourceTypeOptInPreferenceDecoded0
        let resourceTypeManagementPreferenceContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .resourceTypeManagementPreference)
        var resourceTypeManagementPreferenceDecoded0: [Swift.String:Swift.Bool]? = nil
        if let resourceTypeManagementPreferenceContainer = resourceTypeManagementPreferenceContainer {
            resourceTypeManagementPreferenceDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, isenabled0) in resourceTypeManagementPreferenceContainer {
                if let isenabled0 = isenabled0 {
                    resourceTypeManagementPreferenceDecoded0?[key0] = isenabled0
                }
            }
        }
        resourceTypeManagementPreference = resourceTypeManagementPreferenceDecoded0
    }
}

extension DescribeReportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportJobId = reportJobId else {
            return nil
        }
        return "/audit/report-jobs/\(reportJobId.urlPercentEncoding())"
    }
}

public struct DescribeReportJobInput: Swift.Equatable {
    /// The identifier of the report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. The report job ID cannot be edited.
    /// This member is required.
    public var reportJobId: Swift.String?

    public init (
        reportJobId: Swift.String? = nil
    )
    {
        self.reportJobId = reportJobId
    }
}

struct DescribeReportJobInputBody: Swift.Equatable {
}

extension DescribeReportJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeReportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeReportJobOutputError: Swift.Error, Swift.Equatable {
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeReportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportJob = output.reportJob
        } else {
            self.reportJob = nil
        }
    }
}

public struct DescribeReportJobOutputResponse: Swift.Equatable {
    /// A list of information about a report job, including its completion and creation times, report destination, unique report job ID, Amazon Resource Name (ARN), report template, status, and status message.
    public var reportJob: BackupClientTypes.ReportJob?

    public init (
        reportJob: BackupClientTypes.ReportJob? = nil
    )
    {
        self.reportJob = reportJob
    }
}

struct DescribeReportJobOutputResponseBody: Swift.Equatable {
    let reportJob: BackupClientTypes.ReportJob?
}

extension DescribeReportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportJob = "ReportJob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportJobDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportJob.self, forKey: .reportJob)
        reportJob = reportJobDecoded
    }
}

extension DescribeReportPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportPlanName = reportPlanName else {
            return nil
        }
        return "/audit/report-plans/\(reportPlanName.urlPercentEncoding())"
    }
}

public struct DescribeReportPlanInput: Swift.Equatable {
    /// The unique name of a report plan.
    /// This member is required.
    public var reportPlanName: Swift.String?

    public init (
        reportPlanName: Swift.String? = nil
    )
    {
        self.reportPlanName = reportPlanName
    }
}

struct DescribeReportPlanInputBody: Swift.Equatable {
}

extension DescribeReportPlanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeReportPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReportPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeReportPlanOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReportPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeReportPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportPlan = output.reportPlan
        } else {
            self.reportPlan = nil
        }
    }
}

public struct DescribeReportPlanOutputResponse: Swift.Equatable {
    /// Returns details about the report plan that is specified by its name. These details include the report plan's Amazon Resource Name (ARN), description, settings, delivery channel, deployment status, creation time, and last attempted and successful run times.
    public var reportPlan: BackupClientTypes.ReportPlan?

    public init (
        reportPlan: BackupClientTypes.ReportPlan? = nil
    )
    {
        self.reportPlan = reportPlan
    }
}

struct DescribeReportPlanOutputResponseBody: Swift.Equatable {
    let reportPlan: BackupClientTypes.ReportPlan?
}

extension DescribeReportPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportPlan = "ReportPlan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportPlan.self, forKey: .reportPlan)
        reportPlan = reportPlanDecoded
    }
}

extension DescribeRestoreJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restoreJobId = restoreJobId else {
            return nil
        }
        return "/restore-jobs/\(restoreJobId.urlPercentEncoding())"
    }
}

public struct DescribeRestoreJobInput: Swift.Equatable {
    /// Uniquely identifies the job that restores a recovery point.
    /// This member is required.
    public var restoreJobId: Swift.String?

    public init (
        restoreJobId: Swift.String? = nil
    )
    {
        self.restoreJobId = restoreJobId
    }
}

struct DescribeRestoreJobInputBody: Swift.Equatable {
}

extension DescribeRestoreJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRestoreJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRestoreJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyFailureException" : self = .dependencyFailureException(try DependencyFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRestoreJobOutputError: Swift.Error, Swift.Equatable {
    case dependencyFailureException(DependencyFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRestoreJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRestoreJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.backupSizeInBytes = output.backupSizeInBytes
            self.completionDate = output.completionDate
            self.createdResourceArn = output.createdResourceArn
            self.creationDate = output.creationDate
            self.expectedCompletionTimeMinutes = output.expectedCompletionTimeMinutes
            self.iamRoleArn = output.iamRoleArn
            self.percentDone = output.percentDone
            self.recoveryPointArn = output.recoveryPointArn
            self.resourceType = output.resourceType
            self.restoreJobId = output.restoreJobId
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.accountId = nil
            self.backupSizeInBytes = nil
            self.completionDate = nil
            self.createdResourceArn = nil
            self.creationDate = nil
            self.expectedCompletionTimeMinutes = nil
            self.iamRoleArn = nil
            self.percentDone = nil
            self.recoveryPointArn = nil
            self.resourceType = nil
            self.restoreJobId = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct DescribeRestoreJobOutputResponse: Swift.Equatable {
    /// Returns the account ID that owns the restore job.
    public var accountId: Swift.String?
    /// The size, in bytes, of the restored resource.
    public var backupSizeInBytes: Swift.Int?
    /// The date and time that a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var completionDate: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource whose recovery point is being restored. The format of the ARN depends on the resource type of the backed-up resource.
    public var createdResourceArn: Swift.String?
    /// The date and time that a restore job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// The amount of time in minutes that a job restoring a recovery point is expected to take.
    public var expectedCompletionTimeMinutes: Swift.Int?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// Contains an estimated percentage that is complete of a job at the time the job status was queried.
    public var percentDone: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// Returns metadata associated with a restore job listed by resource type.
    public var resourceType: Swift.String?
    /// Uniquely identifies the job that restores a recovery point.
    public var restoreJobId: Swift.String?
    /// Status code specifying the state of the job that is initiated by Backup to restore a recovery point.
    public var status: BackupClientTypes.RestoreJobStatus?
    /// A message showing the status of a job to restore a recovery point.
    public var statusMessage: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        backupSizeInBytes: Swift.Int? = nil,
        completionDate: ClientRuntime.Date? = nil,
        createdResourceArn: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        expectedCompletionTimeMinutes: Swift.Int? = nil,
        iamRoleArn: Swift.String? = nil,
        percentDone: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        restoreJobId: Swift.String? = nil,
        status: BackupClientTypes.RestoreJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.backupSizeInBytes = backupSizeInBytes
        self.completionDate = completionDate
        self.createdResourceArn = createdResourceArn
        self.creationDate = creationDate
        self.expectedCompletionTimeMinutes = expectedCompletionTimeMinutes
        self.iamRoleArn = iamRoleArn
        self.percentDone = percentDone
        self.recoveryPointArn = recoveryPointArn
        self.resourceType = resourceType
        self.restoreJobId = restoreJobId
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct DescribeRestoreJobOutputResponseBody: Swift.Equatable {
    let accountId: Swift.String?
    let restoreJobId: Swift.String?
    let recoveryPointArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let completionDate: ClientRuntime.Date?
    let status: BackupClientTypes.RestoreJobStatus?
    let statusMessage: Swift.String?
    let percentDone: Swift.String?
    let backupSizeInBytes: Swift.Int?
    let iamRoleArn: Swift.String?
    let expectedCompletionTimeMinutes: Swift.Int?
    let createdResourceArn: Swift.String?
    let resourceType: Swift.String?
}

extension DescribeRestoreJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupSizeInBytes = "BackupSizeInBytes"
        case completionDate = "CompletionDate"
        case createdResourceArn = "CreatedResourceArn"
        case creationDate = "CreationDate"
        case expectedCompletionTimeMinutes = "ExpectedCompletionTimeMinutes"
        case iamRoleArn = "IamRoleArn"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
        case restoreJobId = "RestoreJobId"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let restoreJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreJobId)
        restoreJobId = restoreJobIdDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDate)
        completionDate = completionDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RestoreJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let expectedCompletionTimeMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expectedCompletionTimeMinutes)
        expectedCompletionTimeMinutes = expectedCompletionTimeMinutesDecoded
        let createdResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdResourceArn)
        createdResourceArn = createdResourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension DisassociateRecoveryPointFromParentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())/parentAssociation"
    }
}

public struct DisassociateRecoveryPointFromParentInput: Swift.Equatable {
    /// This is the name of a logical container where the child (nested) recovery point is stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// This is the Amazon Resource Name (ARN) that uniquely identifies the child (nested) recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct DisassociateRecoveryPointFromParentInputBody: Swift.Equatable {
}

extension DisassociateRecoveryPointFromParentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateRecoveryPointFromParentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateRecoveryPointFromParentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateRecoveryPointFromParentOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateRecoveryPointFromParentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateRecoveryPointFromParentOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateRecoveryPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())/disassociate"
    }
}

public struct DisassociateRecoveryPointInput: Swift.Equatable {
    /// The unique name of an Backup vault.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies an Backup recovery point.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct DisassociateRecoveryPointInputBody: Swift.Equatable {
}

extension DisassociateRecoveryPointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateRecoveryPointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateRecoveryPointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateRecoveryPointOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case invalidResourceStateException(InvalidResourceStateException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateRecoveryPointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateRecoveryPointOutputResponse: Swift.Equatable {

    public init () { }
}

extension ExportBackupPlanTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/toTemplate"
    }
}

public struct ExportBackupPlanTemplateInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
    }
}

struct ExportBackupPlanTemplateInputBody: Swift.Equatable {
}

extension ExportBackupPlanTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportBackupPlanTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportBackupPlanTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExportBackupPlanTemplateOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportBackupPlanTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExportBackupPlanTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanTemplateJson = output.backupPlanTemplateJson
        } else {
            self.backupPlanTemplateJson = nil
        }
    }
}

public struct ExportBackupPlanTemplateOutputResponse: Swift.Equatable {
    /// The body of a backup plan template in JSON format. This is a signed JSON document that cannot be modified before being passed to GetBackupPlanFromJSON.
    public var backupPlanTemplateJson: Swift.String?

    public init (
        backupPlanTemplateJson: Swift.String? = nil
    )
    {
        self.backupPlanTemplateJson = backupPlanTemplateJson
    }
}

struct ExportBackupPlanTemplateOutputResponseBody: Swift.Equatable {
    let backupPlanTemplateJson: Swift.String?
}

extension ExportBackupPlanTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplateJson = "BackupPlanTemplateJson"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanTemplateJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanTemplateJson)
        backupPlanTemplateJson = backupPlanTemplateJsonDecoded
    }
}

extension BackupClientTypes.Framework: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case deploymentStatus = "DeploymentStatus"
        case frameworkArn = "FrameworkArn"
        case frameworkDescription = "FrameworkDescription"
        case frameworkName = "FrameworkName"
        case numberOfControls = "NumberOfControls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus, forKey: .deploymentStatus)
        }
        if let frameworkArn = self.frameworkArn {
            try encodeContainer.encode(frameworkArn, forKey: .frameworkArn)
        }
        if let frameworkDescription = self.frameworkDescription {
            try encodeContainer.encode(frameworkDescription, forKey: .frameworkDescription)
        }
        if let frameworkName = self.frameworkName {
            try encodeContainer.encode(frameworkName, forKey: .frameworkName)
        }
        if numberOfControls != 0 {
            try encodeContainer.encode(numberOfControls, forKey: .numberOfControls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkArn)
        frameworkArn = frameworkArnDecoded
        let frameworkDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkDescription)
        frameworkDescription = frameworkDescriptionDecoded
        let numberOfControlsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfControls) ?? 0
        numberOfControls = numberOfControlsDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about a framework. Frameworks contain controls, which evaluate and report on your backup events and resources. Frameworks generate daily compliance results.
    public struct Framework: Swift.Equatable {
        /// The date and time that a framework is created, in ISO 8601 representation. The value of CreationTime is accurate to milliseconds. For example, 2020-07-10T15:00:00.000-08:00 represents the 10th of July 2020 at 3:00 PM 8 hours behind UTC.
        public var creationTime: ClientRuntime.Date?
        /// The deployment status of a framework. The statuses are: CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED | FAILED
        public var deploymentStatus: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var frameworkArn: Swift.String?
        /// An optional description of the framework with a maximum 1,024 characters.
        public var frameworkDescription: Swift.String?
        /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public var frameworkName: Swift.String?
        /// The number of controls contained by the framework.
        public var numberOfControls: Swift.Int

        public init (
            creationTime: ClientRuntime.Date? = nil,
            deploymentStatus: Swift.String? = nil,
            frameworkArn: Swift.String? = nil,
            frameworkDescription: Swift.String? = nil,
            frameworkName: Swift.String? = nil,
            numberOfControls: Swift.Int = 0
        )
        {
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.frameworkArn = frameworkArn
            self.frameworkDescription = frameworkDescription
            self.frameworkName = frameworkName
            self.numberOfControls = numberOfControls
        }
    }

}

extension BackupClientTypes.FrameworkControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlInputParameters = "ControlInputParameters"
        case controlName = "ControlName"
        case controlScope = "ControlScope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlInputParameters = controlInputParameters {
            var controlInputParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlInputParameters)
            for controlinputparameter0 in controlInputParameters {
                try controlInputParametersContainer.encode(controlinputparameter0)
            }
        }
        if let controlName = self.controlName {
            try encodeContainer.encode(controlName, forKey: .controlName)
        }
        if let controlScope = self.controlScope {
            try encodeContainer.encode(controlScope, forKey: .controlScope)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlName)
        controlName = controlNameDecoded
        let controlInputParametersContainer = try containerValues.decodeIfPresent([BackupClientTypes.ControlInputParameter?].self, forKey: .controlInputParameters)
        var controlInputParametersDecoded0:[BackupClientTypes.ControlInputParameter]? = nil
        if let controlInputParametersContainer = controlInputParametersContainer {
            controlInputParametersDecoded0 = [BackupClientTypes.ControlInputParameter]()
            for structure0 in controlInputParametersContainer {
                if let structure0 = structure0 {
                    controlInputParametersDecoded0?.append(structure0)
                }
            }
        }
        controlInputParameters = controlInputParametersDecoded0
        let controlScopeDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ControlScope.self, forKey: .controlScope)
        controlScope = controlScopeDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about all of the controls of a framework. Each framework must contain at least one control.
    public struct FrameworkControl: Swift.Equatable {
        /// A list of ParameterName and ParameterValue pairs.
        public var controlInputParameters: [BackupClientTypes.ControlInputParameter]?
        /// The name of a control. This name is between 1 and 256 characters.
        /// This member is required.
        public var controlName: Swift.String?
        /// The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans. For more information, see [ControlScope].
        public var controlScope: BackupClientTypes.ControlScope?

        public init (
            controlInputParameters: [BackupClientTypes.ControlInputParameter]? = nil,
            controlName: Swift.String? = nil,
            controlScope: BackupClientTypes.ControlScope? = nil
        )
        {
            self.controlInputParameters = controlInputParameters
            self.controlName = controlName
            self.controlScope = controlScope
        }
    }

}

extension GetBackupPlanFromJSONInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplateJson = "BackupPlanTemplateJson"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanTemplateJson = self.backupPlanTemplateJson {
            try encodeContainer.encode(backupPlanTemplateJson, forKey: .backupPlanTemplateJson)
        }
    }
}

extension GetBackupPlanFromJSONInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backup/template/json/toPlan"
    }
}

public struct GetBackupPlanFromJSONInput: Swift.Equatable {
    /// A customer-supplied backup plan document in JSON format.
    /// This member is required.
    public var backupPlanTemplateJson: Swift.String?

    public init (
        backupPlanTemplateJson: Swift.String? = nil
    )
    {
        self.backupPlanTemplateJson = backupPlanTemplateJson
    }
}

struct GetBackupPlanFromJSONInputBody: Swift.Equatable {
    let backupPlanTemplateJson: Swift.String?
}

extension GetBackupPlanFromJSONInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplateJson = "BackupPlanTemplateJson"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanTemplateJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanTemplateJson)
        backupPlanTemplateJson = backupPlanTemplateJsonDecoded
    }
}

extension GetBackupPlanFromJSONOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupPlanFromJSONOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBackupPlanFromJSONOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupPlanFromJSONOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBackupPlanFromJSONOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlan = output.backupPlan
        } else {
            self.backupPlan = nil
        }
    }
}

public struct GetBackupPlanFromJSONOutputResponse: Swift.Equatable {
    /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    public var backupPlan: BackupClientTypes.BackupPlan?

    public init (
        backupPlan: BackupClientTypes.BackupPlan? = nil
    )
    {
        self.backupPlan = backupPlan
    }
}

struct GetBackupPlanFromJSONOutputResponseBody: Swift.Equatable {
    let backupPlan: BackupClientTypes.BackupPlan?
}

extension GetBackupPlanFromJSONOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlan.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
    }
}

extension GetBackupPlanFromTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanTemplateId = backupPlanTemplateId else {
            return nil
        }
        return "/backup/template/plans/\(backupPlanTemplateId.urlPercentEncoding())/toPlan"
    }
}

public struct GetBackupPlanFromTemplateInput: Swift.Equatable {
    /// Uniquely identifies a stored backup plan template.
    /// This member is required.
    public var backupPlanTemplateId: Swift.String?

    public init (
        backupPlanTemplateId: Swift.String? = nil
    )
    {
        self.backupPlanTemplateId = backupPlanTemplateId
    }
}

struct GetBackupPlanFromTemplateInputBody: Swift.Equatable {
}

extension GetBackupPlanFromTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupPlanFromTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupPlanFromTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBackupPlanFromTemplateOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupPlanFromTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBackupPlanFromTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanDocument = output.backupPlanDocument
        } else {
            self.backupPlanDocument = nil
        }
    }
}

public struct GetBackupPlanFromTemplateOutputResponse: Swift.Equatable {
    /// Returns the body of a backup plan based on the target template, including the name, rules, and backup vault of the plan.
    public var backupPlanDocument: BackupClientTypes.BackupPlan?

    public init (
        backupPlanDocument: BackupClientTypes.BackupPlan? = nil
    )
    {
        self.backupPlanDocument = backupPlanDocument
    }
}

struct GetBackupPlanFromTemplateOutputResponseBody: Swift.Equatable {
    let backupPlanDocument: BackupClientTypes.BackupPlan?
}

extension GetBackupPlanFromTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanDocument = "BackupPlanDocument"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDocumentDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlan.self, forKey: .backupPlanDocument)
        backupPlanDocument = backupPlanDocumentDecoded
    }
}

extension GetBackupPlanInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let versionId = versionId {
                let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
                items.append(versionIdQueryItem)
            }
            return items
        }
    }
}

extension GetBackupPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())"
    }
}

public struct GetBackupPlanInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
    public var versionId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.versionId = versionId
    }
}

struct GetBackupPlanInputBody: Swift.Equatable {
}

extension GetBackupPlanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBackupPlanOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBackupPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedBackupSettings = output.advancedBackupSettings
            self.backupPlan = output.backupPlan
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.creatorRequestId = output.creatorRequestId
            self.deletionDate = output.deletionDate
            self.lastExecutionDate = output.lastExecutionDate
            self.versionId = output.versionId
        } else {
            self.advancedBackupSettings = nil
            self.backupPlan = nil
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.creationDate = nil
            self.creatorRequestId = nil
            self.deletionDate = nil
            self.lastExecutionDate = nil
            self.versionId = nil
        }
    }
}

public struct GetBackupPlanOutputResponse: Swift.Equatable {
    /// Contains a list of BackupOptions for each resource type. The list is populated only if the advanced option is set for the backup plan.
    public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
    /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    public var backupPlan: BackupClientTypes.BackupPlan?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time that a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
    public var creatorRequestId: Swift.String?
    /// The date and time that a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var deletionDate: ClientRuntime.Date?
    /// The last time a job to back up resources was run with this backup plan. A date and time, in Unix format and Coordinated Universal Time (UTC). The value of LastExecutionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastExecutionDate: ClientRuntime.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
    public var versionId: Swift.String?

    public init (
        advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
        backupPlan: BackupClientTypes.BackupPlan? = nil,
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        creatorRequestId: Swift.String? = nil,
        deletionDate: ClientRuntime.Date? = nil,
        lastExecutionDate: ClientRuntime.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlan = backupPlan
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.deletionDate = deletionDate
        self.lastExecutionDate = lastExecutionDate
        self.versionId = versionId
    }
}

struct GetBackupPlanOutputResponseBody: Swift.Equatable {
    let backupPlan: BackupClientTypes.BackupPlan?
    let backupPlanId: Swift.String?
    let backupPlanArn: Swift.String?
    let versionId: Swift.String?
    let creatorRequestId: Swift.String?
    let creationDate: ClientRuntime.Date?
    let deletionDate: ClientRuntime.Date?
    let lastExecutionDate: ClientRuntime.Date?
    let advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
}

extension GetBackupPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlan = "BackupPlan"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case deletionDate = "DeletionDate"
        case lastExecutionDate = "LastExecutionDate"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlan.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let deletionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
        let lastExecutionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension GetBackupSelectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        guard let selectionId = selectionId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections/\(selectionId.urlPercentEncoding())"
    }
}

public struct GetBackupSelectionInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    /// This member is required.
    public var selectionId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.selectionId = selectionId
    }
}

struct GetBackupSelectionInputBody: Swift.Equatable {
}

extension GetBackupSelectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupSelectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupSelectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBackupSelectionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupSelectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBackupSelectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanId = output.backupPlanId
            self.backupSelection = output.backupSelection
            self.creationDate = output.creationDate
            self.creatorRequestId = output.creatorRequestId
            self.selectionId = output.selectionId
        } else {
            self.backupPlanId = nil
            self.backupSelection = nil
            self.creationDate = nil
            self.creatorRequestId = nil
            self.selectionId = nil
        }
    }
}

public struct GetBackupSelectionOutputResponse: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// Specifies the body of a request to assign a set of resources to a backup plan.
    public var backupSelection: BackupClientTypes.BackupSelection?
    /// The date and time a backup selection is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
    public var creatorRequestId: Swift.String?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    public var selectionId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        backupSelection: BackupClientTypes.BackupSelection? = nil,
        creationDate: ClientRuntime.Date? = nil,
        creatorRequestId: Swift.String? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.backupSelection = backupSelection
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.selectionId = selectionId
    }
}

struct GetBackupSelectionOutputResponseBody: Swift.Equatable {
    let backupSelection: BackupClientTypes.BackupSelection?
    let selectionId: Swift.String?
    let backupPlanId: Swift.String?
    let creationDate: ClientRuntime.Date?
    let creatorRequestId: Swift.String?
}

extension GetBackupSelectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanId = "BackupPlanId"
        case backupSelection = "BackupSelection"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case selectionId = "SelectionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupSelectionDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupSelection.self, forKey: .backupSelection)
        backupSelection = backupSelectionDecoded
        let selectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionId)
        selectionId = selectionIdDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension GetBackupVaultAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/access-policy"
    }
}

public struct GetBackupVaultAccessPolicyInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct GetBackupVaultAccessPolicyInputBody: Swift.Equatable {
}

extension GetBackupVaultAccessPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupVaultAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupVaultAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBackupVaultAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupVaultAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBackupVaultAccessPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.policy = output.policy
        } else {
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.policy = nil
        }
    }
}

public struct GetBackupVaultAccessPolicyOutputResponse: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// The backup vault access policy document in JSON format.
    public var policy: Swift.String?

    public init (
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.policy = policy
    }
}

struct GetBackupVaultAccessPolicyOutputResponseBody: Swift.Equatable {
    let backupVaultName: Swift.String?
    let backupVaultArn: Swift.String?
    let policy: Swift.String?
}

extension GetBackupVaultAccessPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetBackupVaultNotificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/notification-configuration"
    }
}

public struct GetBackupVaultNotificationsInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct GetBackupVaultNotificationsInputBody: Swift.Equatable {
}

extension GetBackupVaultNotificationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupVaultNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupVaultNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBackupVaultNotificationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupVaultNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBackupVaultNotificationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultEvents = output.backupVaultEvents
            self.backupVaultName = output.backupVaultName
            self.snsTopicArn = output.snsTopicArn
        } else {
            self.backupVaultArn = nil
            self.backupVaultEvents = nil
            self.backupVaultName = nil
            self.snsTopicArn = nil
        }
    }
}

public struct GetBackupVaultNotificationsOutputResponse: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// An array of events that indicate the status of jobs to back up resources to the backup vault.
    public var backupVaultEvents: [BackupClientTypes.BackupVaultEvent]?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// An ARN that uniquely identifies an Amazon Simple Notification Service (Amazon SNS) topic; for example, arn:aws:sns:us-west-2:111122223333:MyTopic.
    public var snsTopicArn: Swift.String?

    public init (
        backupVaultArn: Swift.String? = nil,
        backupVaultEvents: [BackupClientTypes.BackupVaultEvent]? = nil,
        backupVaultName: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultEvents = backupVaultEvents
        self.backupVaultName = backupVaultName
        self.snsTopicArn = snsTopicArn
    }
}

struct GetBackupVaultNotificationsOutputResponseBody: Swift.Equatable {
    let backupVaultName: Swift.String?
    let backupVaultArn: Swift.String?
    let snsTopicArn: Swift.String?
    let backupVaultEvents: [BackupClientTypes.BackupVaultEvent]?
}

extension GetBackupVaultNotificationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultEvents = "BackupVaultEvents"
        case backupVaultName = "BackupVaultName"
        case snsTopicArn = "SNSTopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let backupVaultEventsContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupVaultEvent?].self, forKey: .backupVaultEvents)
        var backupVaultEventsDecoded0:[BackupClientTypes.BackupVaultEvent]? = nil
        if let backupVaultEventsContainer = backupVaultEventsContainer {
            backupVaultEventsDecoded0 = [BackupClientTypes.BackupVaultEvent]()
            for enum0 in backupVaultEventsContainer {
                if let enum0 = enum0 {
                    backupVaultEventsDecoded0?.append(enum0)
                }
            }
        }
        backupVaultEvents = backupVaultEventsDecoded0
    }
}

extension GetLegalHoldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let legalHoldId = legalHoldId else {
            return nil
        }
        return "/legal-holds/\(legalHoldId.urlPercentEncoding())"
    }
}

public struct GetLegalHoldInput: Swift.Equatable {
    /// This is the ID required to use GetLegalHold. This unique ID is associated with a specific legal hold.
    /// This member is required.
    public var legalHoldId: Swift.String?

    public init (
        legalHoldId: Swift.String? = nil
    )
    {
        self.legalHoldId = legalHoldId
    }
}

struct GetLegalHoldInputBody: Swift.Equatable {
}

extension GetLegalHoldInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLegalHoldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLegalHoldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetLegalHoldOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLegalHoldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetLegalHoldOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cancelDescription = output.cancelDescription
            self.cancellationDate = output.cancellationDate
            self.creationDate = output.creationDate
            self.description = output.description
            self.legalHoldArn = output.legalHoldArn
            self.legalHoldId = output.legalHoldId
            self.recoveryPointSelection = output.recoveryPointSelection
            self.retainRecordUntil = output.retainRecordUntil
            self.status = output.status
            self.title = output.title
        } else {
            self.cancelDescription = nil
            self.cancellationDate = nil
            self.creationDate = nil
            self.description = nil
            self.legalHoldArn = nil
            self.legalHoldId = nil
            self.recoveryPointSelection = nil
            self.retainRecordUntil = nil
            self.status = nil
            self.title = nil
        }
    }
}

public struct GetLegalHoldOutputResponse: Swift.Equatable {
    /// String describing the reason for removing the legal hold.
    public var cancelDescription: Swift.String?
    /// Time in number when legal hold was cancelled.
    public var cancellationDate: ClientRuntime.Date?
    /// Time in number format when legal hold was created.
    public var creationDate: ClientRuntime.Date?
    /// This is the returned string description of the legal hold.
    public var description: Swift.String?
    /// This is the returned framework ARN for the specified legal hold. An Amazon Resource Name (ARN) uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var legalHoldArn: Swift.String?
    /// This is the returned ID associated with a specified legal hold.
    public var legalHoldId: Swift.String?
    /// This specifies criteria to assign a set of resources, such as resource types or backup vaults.
    public var recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
    /// This is the date and time until which the legal hold record will be retained.
    public var retainRecordUntil: ClientRuntime.Date?
    /// This is the status of the legal hold. Statuses can be ACTIVE, CREATING, CANCELED, and CANCELING.
    public var status: BackupClientTypes.LegalHoldStatus?
    /// This is the string title of the legal hold.
    public var title: Swift.String?

    public init (
        cancelDescription: Swift.String? = nil,
        cancellationDate: ClientRuntime.Date? = nil,
        creationDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        legalHoldArn: Swift.String? = nil,
        legalHoldId: Swift.String? = nil,
        recoveryPointSelection: BackupClientTypes.RecoveryPointSelection? = nil,
        retainRecordUntil: ClientRuntime.Date? = nil,
        status: BackupClientTypes.LegalHoldStatus? = nil,
        title: Swift.String? = nil
    )
    {
        self.cancelDescription = cancelDescription
        self.cancellationDate = cancellationDate
        self.creationDate = creationDate
        self.description = description
        self.legalHoldArn = legalHoldArn
        self.legalHoldId = legalHoldId
        self.recoveryPointSelection = recoveryPointSelection
        self.retainRecordUntil = retainRecordUntil
        self.status = status
        self.title = title
    }
}

struct GetLegalHoldOutputResponseBody: Swift.Equatable {
    let title: Swift.String?
    let status: BackupClientTypes.LegalHoldStatus?
    let description: Swift.String?
    let cancelDescription: Swift.String?
    let legalHoldId: Swift.String?
    let legalHoldArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let cancellationDate: ClientRuntime.Date?
    let retainRecordUntil: ClientRuntime.Date?
    let recoveryPointSelection: BackupClientTypes.RecoveryPointSelection?
}

extension GetLegalHoldOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancelDescription = "CancelDescription"
        case cancellationDate = "CancellationDate"
        case creationDate = "CreationDate"
        case description = "Description"
        case legalHoldArn = "LegalHoldArn"
        case legalHoldId = "LegalHoldId"
        case recoveryPointSelection = "RecoveryPointSelection"
        case retainRecordUntil = "RetainRecordUntil"
        case status = "Status"
        case title = "Title"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.LegalHoldStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cancelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cancelDescription)
        cancelDescription = cancelDescriptionDecoded
        let legalHoldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .legalHoldId)
        legalHoldId = legalHoldIdDecoded
        let legalHoldArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .legalHoldArn)
        legalHoldArn = legalHoldArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let cancellationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .cancellationDate)
        cancellationDate = cancellationDateDecoded
        let retainRecordUntilDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .retainRecordUntil)
        retainRecordUntil = retainRecordUntilDecoded
        let recoveryPointSelectionDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointSelection.self, forKey: .recoveryPointSelection)
        recoveryPointSelection = recoveryPointSelectionDecoded
    }
}

extension GetRecoveryPointRestoreMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())/restore-metadata"
    }
}

public struct GetRecoveryPointRestoreMetadataInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct GetRecoveryPointRestoreMetadataInputBody: Swift.Equatable {
}

extension GetRecoveryPointRestoreMetadataInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRecoveryPointRestoreMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecoveryPointRestoreMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRecoveryPointRestoreMetadataOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecoveryPointRestoreMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecoveryPointRestoreMetadataOutputResponse(backupVaultArn: \(Swift.String(describing: backupVaultArn)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), restoreMetadata: \"CONTENT_REDACTED\")"}
}

extension GetRecoveryPointRestoreMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRecoveryPointRestoreMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.recoveryPointArn = output.recoveryPointArn
            self.restoreMetadata = output.restoreMetadata
        } else {
            self.backupVaultArn = nil
            self.recoveryPointArn = nil
            self.restoreMetadata = nil
        }
    }
}

public struct GetRecoveryPointRestoreMetadataOutputResponse: Swift.Equatable {
    /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// The set of metadata key-value pairs that describe the original configuration of the backed-up resource. These values vary depending on the service that is being restored.
    public var restoreMetadata: [Swift.String:Swift.String]?

    public init (
        backupVaultArn: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        restoreMetadata: [Swift.String:Swift.String]? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.recoveryPointArn = recoveryPointArn
        self.restoreMetadata = restoreMetadata
    }
}

struct GetRecoveryPointRestoreMetadataOutputResponseBody: Swift.Equatable {
    let backupVaultArn: Swift.String?
    let recoveryPointArn: Swift.String?
    let restoreMetadata: [Swift.String:Swift.String]?
}

extension GetRecoveryPointRestoreMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case recoveryPointArn = "RecoveryPointArn"
        case restoreMetadata = "RestoreMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let restoreMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .restoreMetadata)
        var restoreMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let restoreMetadataContainer = restoreMetadataContainer {
            restoreMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, metadatavalue0) in restoreMetadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    restoreMetadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        restoreMetadata = restoreMetadataDecoded0
    }
}

extension GetSupportedResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/supported-resource-types"
    }
}

public struct GetSupportedResourceTypesInput: Swift.Equatable {

    public init () { }
}

struct GetSupportedResourceTypesInputBody: Swift.Equatable {
}

extension GetSupportedResourceTypesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSupportedResourceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSupportedResourceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSupportedResourceTypesOutputError: Swift.Error, Swift.Equatable {
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSupportedResourceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSupportedResourceTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceTypes = output.resourceTypes
        } else {
            self.resourceTypes = nil
        }
    }
}

public struct GetSupportedResourceTypesOutputResponse: Swift.Equatable {
    /// Contains a string with the supported Amazon Web Services resource types:
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * FSX for Amazon FSx
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Storage Gateway for Storage Gateway
    ///
    /// * DocDB for Amazon DocumentDB (with MongoDB compatibility)
    ///
    /// * Neptune for Amazon Neptune
    public var resourceTypes: [Swift.String]?

    public init (
        resourceTypes: [Swift.String]? = nil
    )
    {
        self.resourceTypes = resourceTypes
    }
}

struct GetSupportedResourceTypesOutputResponseBody: Swift.Equatable {
    let resourceTypes: [Swift.String]?
}

extension GetSupportedResourceTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTypes = "ResourceTypes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
    }
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that something is wrong with a parameter's value. For example, the value is out of range.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that something is wrong with the input to the request. For example, a parameter is of the wrong type.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension InvalidResourceStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Backup is already performing an action on this recovery point. It can't perform the action you requested until the first action finishes. Try again later.
public struct InvalidResourceStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct InvalidResourceStateExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension InvalidResourceStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes.LegalHold: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancellationDate = "CancellationDate"
        case creationDate = "CreationDate"
        case description = "Description"
        case legalHoldArn = "LegalHoldArn"
        case legalHoldId = "LegalHoldId"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cancellationDate = self.cancellationDate {
            try encodeContainer.encodeTimestamp(cancellationDate, format: .epochSeconds, forKey: .cancellationDate)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let legalHoldArn = self.legalHoldArn {
            try encodeContainer.encode(legalHoldArn, forKey: .legalHoldArn)
        }
        if let legalHoldId = self.legalHoldId {
            try encodeContainer.encode(legalHoldId, forKey: .legalHoldId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.LegalHoldStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let legalHoldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .legalHoldId)
        legalHoldId = legalHoldIdDecoded
        let legalHoldArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .legalHoldArn)
        legalHoldArn = legalHoldArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let cancellationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .cancellationDate)
        cancellationDate = cancellationDateDecoded
    }
}

extension BackupClientTypes {
    /// A legal hold is an administrative tool that helps prevent backups from being deleted while under a hold. While the hold is in place, backups under a hold cannot be deleted and lifecycle policies that would alter the backup status (such as transition to cold storage) are delayed until the legal hold is removed. A backup can have more than one legal hold. Legal holds are applied to one or more backups (also known as recovery points). These backups can be filtered by resource types and by resource IDs.
    public struct LegalHold: Swift.Equatable {
        /// This is the time in number format when legal hold was cancelled.
        public var cancellationDate: ClientRuntime.Date?
        /// This is the time in number format when legal hold was created.
        public var creationDate: ClientRuntime.Date?
        /// This is the description of a legal hold.
        public var description: Swift.String?
        /// This is an Amazon Resource Number (ARN) that uniquely identifies the legal hold; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var legalHoldArn: Swift.String?
        /// ID of specific legal hold on one or more recovery points.
        public var legalHoldId: Swift.String?
        /// This is the status of the legal hold. Statuses can be ACTIVE, CREATING, CANCELED, and CANCELING.
        public var status: BackupClientTypes.LegalHoldStatus?
        /// This is the title of a legal hold.
        public var title: Swift.String?

        public init (
            cancellationDate: ClientRuntime.Date? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            legalHoldArn: Swift.String? = nil,
            legalHoldId: Swift.String? = nil,
            status: BackupClientTypes.LegalHoldStatus? = nil,
            title: Swift.String? = nil
        )
        {
            self.cancellationDate = cancellationDate
            self.creationDate = creationDate
            self.description = description
            self.legalHoldArn = legalHoldArn
            self.legalHoldId = legalHoldId
            self.status = status
            self.title = title
        }
    }

}

extension BackupClientTypes {
    public enum LegalHoldStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case canceled
        case canceling
        case creating
        case sdkUnknown(Swift.String)

        public static var allCases: [LegalHoldStatus] {
            return [
                .active,
                .canceled,
                .canceling,
                .creating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .canceling: return "CANCELING"
            case .creating: return "CREATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LegalHoldStatus(rawValue: rawValue) ?? LegalHoldStatus.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.Lifecycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAfterDays = "DeleteAfterDays"
        case moveToColdStorageAfterDays = "MoveToColdStorageAfterDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteAfterDays = self.deleteAfterDays {
            try encodeContainer.encode(deleteAfterDays, forKey: .deleteAfterDays)
        }
        if let moveToColdStorageAfterDays = self.moveToColdStorageAfterDays {
            try encodeContainer.encode(moveToColdStorageAfterDays, forKey: .moveToColdStorageAfterDays)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moveToColdStorageAfterDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .moveToColdStorageAfterDays)
        moveToColdStorageAfterDays = moveToColdStorageAfterDaysDecoded
        let deleteAfterDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deleteAfterDays)
        deleteAfterDays = deleteAfterDaysDecoded
    }
}

extension BackupClientTypes {
    /// Contains an array of Transition objects specifying how long in days before a recovery point transitions to cold storage or is deleted. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
    public struct Lifecycle: Swift.Equatable {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater than 90 days plus MoveToColdStorageAfterDays.
        public var deleteAfterDays: Swift.Int?
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public var moveToColdStorageAfterDays: Swift.Int?

        public init (
            deleteAfterDays: Swift.Int? = nil,
            moveToColdStorageAfterDays: Swift.Int? = nil
        )
        {
            self.deleteAfterDays = deleteAfterDays
            self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A limit in the request has been exceeded; for example, a maximum number of items allowed in a request.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension ListBackupJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let byCreatedBefore = byCreatedBefore {
                let byCreatedBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedBefore)).urlPercentEncoding())
                items.append(byCreatedBeforeQueryItem)
            }
            if let byResourceType = byResourceType {
                let byResourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(byResourceType).urlPercentEncoding())
                items.append(byResourceTypeQueryItem)
            }
            if let byBackupVaultName = byBackupVaultName {
                let byBackupVaultNameQueryItem = ClientRuntime.URLQueryItem(name: "backupVaultName".urlPercentEncoding(), value: Swift.String(byBackupVaultName).urlPercentEncoding())
                items.append(byBackupVaultNameQueryItem)
            }
            if let byCompleteAfter = byCompleteAfter {
                let byCompleteAfterQueryItem = ClientRuntime.URLQueryItem(name: "completeAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCompleteAfter)).urlPercentEncoding())
                items.append(byCompleteAfterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let byResourceArn = byResourceArn {
                let byResourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(byResourceArn).urlPercentEncoding())
                items.append(byResourceArnQueryItem)
            }
            if let byParentJobId = byParentJobId {
                let byParentJobIdQueryItem = ClientRuntime.URLQueryItem(name: "parentJobId".urlPercentEncoding(), value: Swift.String(byParentJobId).urlPercentEncoding())
                items.append(byParentJobIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let byState = byState {
                let byStateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(byState.rawValue).urlPercentEncoding())
                items.append(byStateQueryItem)
            }
            if let byAccountId = byAccountId {
                let byAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(byAccountId).urlPercentEncoding())
                items.append(byAccountIdQueryItem)
            }
            if let byCompleteBefore = byCompleteBefore {
                let byCompleteBeforeQueryItem = ClientRuntime.URLQueryItem(name: "completeBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCompleteBefore)).urlPercentEncoding())
                items.append(byCompleteBeforeQueryItem)
            }
            if let byCreatedAfter = byCreatedAfter {
                let byCreatedAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedAfter)).urlPercentEncoding())
                items.append(byCreatedAfterQueryItem)
            }
            return items
        }
    }
}

extension ListBackupJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backup-jobs"
    }
}

public struct ListBackupJobsInput: Swift.Equatable {
    /// The account ID to list the jobs from. Returns only backup jobs associated with the specified account ID. If used from an Organizations management account, passing * returns all jobs across the organization.
    public var byAccountId: Swift.String?
    /// Returns only backup jobs that will be stored in the specified backup vault. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var byBackupVaultName: Swift.String?
    /// Returns only backup jobs completed after a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteAfter: ClientRuntime.Date?
    /// Returns only backup jobs completed before a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteBefore: ClientRuntime.Date?
    /// Returns only backup jobs that were created after the specified date.
    public var byCreatedAfter: ClientRuntime.Date?
    /// Returns only backup jobs that were created before the specified date.
    public var byCreatedBefore: ClientRuntime.Date?
    /// This is a filter to list child (nested) jobs based on parent job ID.
    public var byParentJobId: Swift.String?
    /// Returns only backup jobs that match the specified resource Amazon Resource Name (ARN).
    public var byResourceArn: Swift.String?
    /// Returns only backup jobs for the specified resources:
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * DocumentDB for Amazon DocumentDB (with MongoDB compatibility)
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * FSx for Amazon FSx
    ///
    /// * Neptune for Amazon Neptune
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Storage Gateway for Storage Gateway
    ///
    /// * S3 for Amazon S3
    ///
    /// * VirtualMachine for virtual machines
    public var byResourceType: Swift.String?
    /// Returns only backup jobs that are in the specified state.
    public var byState: BackupClientTypes.BackupJobState?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        byAccountId: Swift.String? = nil,
        byBackupVaultName: Swift.String? = nil,
        byCompleteAfter: ClientRuntime.Date? = nil,
        byCompleteBefore: ClientRuntime.Date? = nil,
        byCreatedAfter: ClientRuntime.Date? = nil,
        byCreatedBefore: ClientRuntime.Date? = nil,
        byParentJobId: Swift.String? = nil,
        byResourceArn: Swift.String? = nil,
        byResourceType: Swift.String? = nil,
        byState: BackupClientTypes.BackupJobState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byBackupVaultName = byBackupVaultName
        self.byCompleteAfter = byCompleteAfter
        self.byCompleteBefore = byCompleteBefore
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byParentJobId = byParentJobId
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.byState = byState
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupJobsInputBody: Swift.Equatable {
}

extension ListBackupJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBackupJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBackupJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupJobs = output.backupJobs
            self.nextToken = output.nextToken
        } else {
            self.backupJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupJobsOutputResponse: Swift.Equatable {
    /// An array of structures containing metadata about your backup jobs returned in JSON format.
    public var backupJobs: [BackupClientTypes.BackupJob]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupJobs: [BackupClientTypes.BackupJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupJobs = backupJobs
        self.nextToken = nextToken
    }
}

struct ListBackupJobsOutputResponseBody: Swift.Equatable {
    let backupJobs: [BackupClientTypes.BackupJob]?
    let nextToken: Swift.String?
}

extension ListBackupJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupJobs = "BackupJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupJobsContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupJob?].self, forKey: .backupJobs)
        var backupJobsDecoded0:[BackupClientTypes.BackupJob]? = nil
        if let backupJobsContainer = backupJobsContainer {
            backupJobsDecoded0 = [BackupClientTypes.BackupJob]()
            for structure0 in backupJobsContainer {
                if let structure0 = structure0 {
                    backupJobsDecoded0?.append(structure0)
                }
            }
        }
        backupJobs = backupJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBackupPlanTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBackupPlanTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backup/template/plans"
    }
}

public struct ListBackupPlanTemplatesInput: Swift.Equatable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupPlanTemplatesInputBody: Swift.Equatable {
}

extension ListBackupPlanTemplatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupPlanTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupPlanTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBackupPlanTemplatesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupPlanTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBackupPlanTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanTemplatesList = output.backupPlanTemplatesList
            self.nextToken = output.nextToken
        } else {
            self.backupPlanTemplatesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupPlanTemplatesOutputResponse: Swift.Equatable {
    /// An array of template list items containing metadata about your saved templates.
    public var backupPlanTemplatesList: [BackupClientTypes.BackupPlanTemplatesListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupPlanTemplatesList: [BackupClientTypes.BackupPlanTemplatesListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanTemplatesList = backupPlanTemplatesList
        self.nextToken = nextToken
    }
}

struct ListBackupPlanTemplatesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let backupPlanTemplatesList: [BackupClientTypes.BackupPlanTemplatesListMember]?
}

extension ListBackupPlanTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplatesList = "BackupPlanTemplatesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupPlanTemplatesListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupPlanTemplatesListMember?].self, forKey: .backupPlanTemplatesList)
        var backupPlanTemplatesListDecoded0:[BackupClientTypes.BackupPlanTemplatesListMember]? = nil
        if let backupPlanTemplatesListContainer = backupPlanTemplatesListContainer {
            backupPlanTemplatesListDecoded0 = [BackupClientTypes.BackupPlanTemplatesListMember]()
            for structure0 in backupPlanTemplatesListContainer {
                if let structure0 = structure0 {
                    backupPlanTemplatesListDecoded0?.append(structure0)
                }
            }
        }
        backupPlanTemplatesList = backupPlanTemplatesListDecoded0
    }
}

extension ListBackupPlanVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBackupPlanVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/versions"
    }
}

public struct ListBackupPlanVersionsInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupPlanVersionsInputBody: Swift.Equatable {
}

extension ListBackupPlanVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupPlanVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupPlanVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBackupPlanVersionsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupPlanVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBackupPlanVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanVersionsList = output.backupPlanVersionsList
            self.nextToken = output.nextToken
        } else {
            self.backupPlanVersionsList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupPlanVersionsOutputResponse: Swift.Equatable {
    /// An array of version list items containing metadata about your backup plans.
    public var backupPlanVersionsList: [BackupClientTypes.BackupPlansListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupPlanVersionsList: [BackupClientTypes.BackupPlansListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanVersionsList = backupPlanVersionsList
        self.nextToken = nextToken
    }
}

struct ListBackupPlanVersionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let backupPlanVersionsList: [BackupClientTypes.BackupPlansListMember]?
}

extension ListBackupPlanVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanVersionsList = "BackupPlanVersionsList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupPlanVersionsListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupPlansListMember?].self, forKey: .backupPlanVersionsList)
        var backupPlanVersionsListDecoded0:[BackupClientTypes.BackupPlansListMember]? = nil
        if let backupPlanVersionsListContainer = backupPlanVersionsListContainer {
            backupPlanVersionsListDecoded0 = [BackupClientTypes.BackupPlansListMember]()
            for structure0 in backupPlanVersionsListContainer {
                if let structure0 = structure0 {
                    backupPlanVersionsListDecoded0?.append(structure0)
                }
            }
        }
        backupPlanVersionsList = backupPlanVersionsListDecoded0
    }
}

extension ListBackupPlansInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let includeDeleted = includeDeleted {
                let includeDeletedQueryItem = ClientRuntime.URLQueryItem(name: "includeDeleted".urlPercentEncoding(), value: Swift.String(includeDeleted).urlPercentEncoding())
                items.append(includeDeletedQueryItem)
            }
            return items
        }
    }
}

extension ListBackupPlansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backup/plans"
    }
}

public struct ListBackupPlansInput: Swift.Equatable {
    /// A Boolean value with a default value of FALSE that returns deleted backup plans when set to TRUE.
    public var includeDeleted: Swift.Bool?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        includeDeleted: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.includeDeleted = includeDeleted
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupPlansInputBody: Swift.Equatable {
}

extension ListBackupPlansInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupPlansOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupPlansOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBackupPlansOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupPlansOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBackupPlansOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlansList = output.backupPlansList
            self.nextToken = output.nextToken
        } else {
            self.backupPlansList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupPlansOutputResponse: Swift.Equatable {
    /// An array of backup plan list items containing metadata about your saved backup plans.
    public var backupPlansList: [BackupClientTypes.BackupPlansListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupPlansList: [BackupClientTypes.BackupPlansListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlansList = backupPlansList
        self.nextToken = nextToken
    }
}

struct ListBackupPlansOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let backupPlansList: [BackupClientTypes.BackupPlansListMember]?
}

extension ListBackupPlansOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlansList = "BackupPlansList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupPlansListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupPlansListMember?].self, forKey: .backupPlansList)
        var backupPlansListDecoded0:[BackupClientTypes.BackupPlansListMember]? = nil
        if let backupPlansListContainer = backupPlansListContainer {
            backupPlansListDecoded0 = [BackupClientTypes.BackupPlansListMember]()
            for structure0 in backupPlansListContainer {
                if let structure0 = structure0 {
                    backupPlansListDecoded0?.append(structure0)
                }
            }
        }
        backupPlansList = backupPlansListDecoded0
    }
}

extension ListBackupSelectionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBackupSelectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections"
    }
}

public struct ListBackupSelectionsInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupSelectionsInputBody: Swift.Equatable {
}

extension ListBackupSelectionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupSelectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupSelectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBackupSelectionsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupSelectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBackupSelectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupSelectionsList = output.backupSelectionsList
            self.nextToken = output.nextToken
        } else {
            self.backupSelectionsList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupSelectionsOutputResponse: Swift.Equatable {
    /// An array of backup selection list items containing metadata about each resource in the list.
    public var backupSelectionsList: [BackupClientTypes.BackupSelectionsListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupSelectionsList: [BackupClientTypes.BackupSelectionsListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupSelectionsList = backupSelectionsList
        self.nextToken = nextToken
    }
}

struct ListBackupSelectionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let backupSelectionsList: [BackupClientTypes.BackupSelectionsListMember]?
}

extension ListBackupSelectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSelectionsList = "BackupSelectionsList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupSelectionsListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupSelectionsListMember?].self, forKey: .backupSelectionsList)
        var backupSelectionsListDecoded0:[BackupClientTypes.BackupSelectionsListMember]? = nil
        if let backupSelectionsListContainer = backupSelectionsListContainer {
            backupSelectionsListDecoded0 = [BackupClientTypes.BackupSelectionsListMember]()
            for structure0 in backupSelectionsListContainer {
                if let structure0 = structure0 {
                    backupSelectionsListDecoded0?.append(structure0)
                }
            }
        }
        backupSelectionsList = backupSelectionsListDecoded0
    }
}

extension ListBackupVaultsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBackupVaultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backup-vaults"
    }
}

public struct ListBackupVaultsInput: Swift.Equatable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupVaultsInputBody: Swift.Equatable {
}

extension ListBackupVaultsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupVaultsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupVaultsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBackupVaultsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupVaultsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBackupVaultsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultList = output.backupVaultList
            self.nextToken = output.nextToken
        } else {
            self.backupVaultList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupVaultsOutputResponse: Swift.Equatable {
    /// An array of backup vault list members containing vault metadata, including Amazon Resource Name (ARN), display name, creation date, number of saved recovery points, and encryption information if the resources saved in the backup vault are encrypted.
    public var backupVaultList: [BackupClientTypes.BackupVaultListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupVaultList: [BackupClientTypes.BackupVaultListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupVaultList = backupVaultList
        self.nextToken = nextToken
    }
}

struct ListBackupVaultsOutputResponseBody: Swift.Equatable {
    let backupVaultList: [BackupClientTypes.BackupVaultListMember]?
    let nextToken: Swift.String?
}

extension ListBackupVaultsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultList = "BackupVaultList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupVaultListMember?].self, forKey: .backupVaultList)
        var backupVaultListDecoded0:[BackupClientTypes.BackupVaultListMember]? = nil
        if let backupVaultListContainer = backupVaultListContainer {
            backupVaultListDecoded0 = [BackupClientTypes.BackupVaultListMember]()
            for structure0 in backupVaultListContainer {
                if let structure0 = structure0 {
                    backupVaultListDecoded0?.append(structure0)
                }
            }
        }
        backupVaultList = backupVaultListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCopyJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let byCreatedBefore = byCreatedBefore {
                let byCreatedBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedBefore)).urlPercentEncoding())
                items.append(byCreatedBeforeQueryItem)
            }
            if let byResourceType = byResourceType {
                let byResourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(byResourceType).urlPercentEncoding())
                items.append(byResourceTypeQueryItem)
            }
            if let byCompleteAfter = byCompleteAfter {
                let byCompleteAfterQueryItem = ClientRuntime.URLQueryItem(name: "completeAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCompleteAfter)).urlPercentEncoding())
                items.append(byCompleteAfterQueryItem)
            }
            if let byDestinationVaultArn = byDestinationVaultArn {
                let byDestinationVaultArnQueryItem = ClientRuntime.URLQueryItem(name: "destinationVaultArn".urlPercentEncoding(), value: Swift.String(byDestinationVaultArn).urlPercentEncoding())
                items.append(byDestinationVaultArnQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let byResourceArn = byResourceArn {
                let byResourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(byResourceArn).urlPercentEncoding())
                items.append(byResourceArnQueryItem)
            }
            if let byParentJobId = byParentJobId {
                let byParentJobIdQueryItem = ClientRuntime.URLQueryItem(name: "parentJobId".urlPercentEncoding(), value: Swift.String(byParentJobId).urlPercentEncoding())
                items.append(byParentJobIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let byState = byState {
                let byStateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(byState.rawValue).urlPercentEncoding())
                items.append(byStateQueryItem)
            }
            if let byAccountId = byAccountId {
                let byAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(byAccountId).urlPercentEncoding())
                items.append(byAccountIdQueryItem)
            }
            if let byCompleteBefore = byCompleteBefore {
                let byCompleteBeforeQueryItem = ClientRuntime.URLQueryItem(name: "completeBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCompleteBefore)).urlPercentEncoding())
                items.append(byCompleteBeforeQueryItem)
            }
            if let byCreatedAfter = byCreatedAfter {
                let byCreatedAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedAfter)).urlPercentEncoding())
                items.append(byCreatedAfterQueryItem)
            }
            return items
        }
    }
}

extension ListCopyJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/copy-jobs"
    }
}

public struct ListCopyJobsInput: Swift.Equatable {
    /// The account ID to list the jobs from. Returns only copy jobs associated with the specified account ID.
    public var byAccountId: Swift.String?
    /// Returns only copy jobs completed after a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteAfter: ClientRuntime.Date?
    /// Returns only copy jobs completed before a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteBefore: ClientRuntime.Date?
    /// Returns only copy jobs that were created after the specified date.
    public var byCreatedAfter: ClientRuntime.Date?
    /// Returns only copy jobs that were created before the specified date.
    public var byCreatedBefore: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a source backup vault to copy from; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var byDestinationVaultArn: Swift.String?
    /// This is a filter to list child (nested) jobs based on parent job ID.
    public var byParentJobId: Swift.String?
    /// Returns only copy jobs that match the specified resource Amazon Resource Name (ARN).
    public var byResourceArn: Swift.String?
    /// Returns only backup jobs for the specified resources:
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * DocumentDB for Amazon DocumentDB (with MongoDB compatibility)
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * FSx for Amazon FSx
    ///
    /// * Neptune for Amazon Neptune
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Storage Gateway for Storage Gateway
    ///
    /// * S3 for Amazon S3
    ///
    /// * VirtualMachine for virtual machines
    public var byResourceType: Swift.String?
    /// Returns only copy jobs that are in the specified state.
    public var byState: BackupClientTypes.CopyJobState?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        byAccountId: Swift.String? = nil,
        byCompleteAfter: ClientRuntime.Date? = nil,
        byCompleteBefore: ClientRuntime.Date? = nil,
        byCreatedAfter: ClientRuntime.Date? = nil,
        byCreatedBefore: ClientRuntime.Date? = nil,
        byDestinationVaultArn: Swift.String? = nil,
        byParentJobId: Swift.String? = nil,
        byResourceArn: Swift.String? = nil,
        byResourceType: Swift.String? = nil,
        byState: BackupClientTypes.CopyJobState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byCompleteAfter = byCompleteAfter
        self.byCompleteBefore = byCompleteBefore
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byDestinationVaultArn = byDestinationVaultArn
        self.byParentJobId = byParentJobId
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.byState = byState
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCopyJobsInputBody: Swift.Equatable {
}

extension ListCopyJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCopyJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCopyJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCopyJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCopyJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCopyJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.copyJobs = output.copyJobs
            self.nextToken = output.nextToken
        } else {
            self.copyJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListCopyJobsOutputResponse: Swift.Equatable {
    /// An array of structures containing metadata about your copy jobs returned in JSON format.
    public var copyJobs: [BackupClientTypes.CopyJob]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        copyJobs: [BackupClientTypes.CopyJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.copyJobs = copyJobs
        self.nextToken = nextToken
    }
}

struct ListCopyJobsOutputResponseBody: Swift.Equatable {
    let copyJobs: [BackupClientTypes.CopyJob]?
    let nextToken: Swift.String?
}

extension ListCopyJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyJobs = "CopyJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyJobsContainer = try containerValues.decodeIfPresent([BackupClientTypes.CopyJob?].self, forKey: .copyJobs)
        var copyJobsDecoded0:[BackupClientTypes.CopyJob]? = nil
        if let copyJobsContainer = copyJobsContainer {
            copyJobsDecoded0 = [BackupClientTypes.CopyJob]()
            for structure0 in copyJobsContainer {
                if let structure0 = structure0 {
                    copyJobsDecoded0?.append(structure0)
                }
            }
        }
        copyJobs = copyJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFrameworksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFrameworksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/frameworks"
    }
}

public struct ListFrameworksInput: Swift.Equatable {
    /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFrameworksInputBody: Swift.Equatable {
}

extension ListFrameworksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFrameworksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFrameworksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFrameworksOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFrameworksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFrameworksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.frameworks = output.frameworks
            self.nextToken = output.nextToken
        } else {
            self.frameworks = nil
            self.nextToken = nil
        }
    }
}

public struct ListFrameworksOutputResponse: Swift.Equatable {
    /// A list of frameworks with details for each framework, including the framework name, Amazon Resource Name (ARN), description, number of controls, creation time, and deployment status.
    public var frameworks: [BackupClientTypes.Framework]?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        frameworks: [BackupClientTypes.Framework]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.frameworks = frameworks
        self.nextToken = nextToken
    }
}

struct ListFrameworksOutputResponseBody: Swift.Equatable {
    let frameworks: [BackupClientTypes.Framework]?
    let nextToken: Swift.String?
}

extension ListFrameworksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworks = "Frameworks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworksContainer = try containerValues.decodeIfPresent([BackupClientTypes.Framework?].self, forKey: .frameworks)
        var frameworksDecoded0:[BackupClientTypes.Framework]? = nil
        if let frameworksContainer = frameworksContainer {
            frameworksDecoded0 = [BackupClientTypes.Framework]()
            for structure0 in frameworksContainer {
                if let structure0 = structure0 {
                    frameworksDecoded0?.append(structure0)
                }
            }
        }
        frameworks = frameworksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLegalHoldsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListLegalHoldsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/legal-holds"
    }
}

public struct ListLegalHoldsInput: Swift.Equatable {
    /// The maximum number of resource list items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLegalHoldsInputBody: Swift.Equatable {
}

extension ListLegalHoldsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLegalHoldsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLegalHoldsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLegalHoldsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLegalHoldsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLegalHoldsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.legalHolds = output.legalHolds
            self.nextToken = output.nextToken
        } else {
            self.legalHolds = nil
            self.nextToken = nil
        }
    }
}

public struct ListLegalHoldsOutputResponse: Swift.Equatable {
    /// This is an array of returned legal holds, both active and previous.
    public var legalHolds: [BackupClientTypes.LegalHold]?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        legalHolds: [BackupClientTypes.LegalHold]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.legalHolds = legalHolds
        self.nextToken = nextToken
    }
}

struct ListLegalHoldsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let legalHolds: [BackupClientTypes.LegalHold]?
}

extension ListLegalHoldsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case legalHolds = "LegalHolds"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let legalHoldsContainer = try containerValues.decodeIfPresent([BackupClientTypes.LegalHold?].self, forKey: .legalHolds)
        var legalHoldsDecoded0:[BackupClientTypes.LegalHold]? = nil
        if let legalHoldsContainer = legalHoldsContainer {
            legalHoldsDecoded0 = [BackupClientTypes.LegalHold]()
            for structure0 in legalHoldsContainer {
                if let structure0 = structure0 {
                    legalHoldsDecoded0?.append(structure0)
                }
            }
        }
        legalHolds = legalHoldsDecoded0
    }
}

extension ListProtectedResourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListProtectedResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resources"
    }
}

public struct ListProtectedResourcesInput: Swift.Equatable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProtectedResourcesInputBody: Swift.Equatable {
}

extension ListProtectedResourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProtectedResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProtectedResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProtectedResourcesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProtectedResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProtectedResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.results = output.results
        } else {
            self.nextToken = nil
            self.results = nil
        }
    }
}

public struct ListProtectedResourcesOutputResponse: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of resources successfully backed up by Backup including the time the resource was saved, an Amazon Resource Name (ARN) of the resource, and a resource type.
    public var results: [BackupClientTypes.ProtectedResource]?

    public init (
        nextToken: Swift.String? = nil,
        results: [BackupClientTypes.ProtectedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

struct ListProtectedResourcesOutputResponseBody: Swift.Equatable {
    let results: [BackupClientTypes.ProtectedResource]?
    let nextToken: Swift.String?
}

extension ListProtectedResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case results = "Results"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([BackupClientTypes.ProtectedResource?].self, forKey: .results)
        var resultsDecoded0:[BackupClientTypes.ProtectedResource]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [BackupClientTypes.ProtectedResource]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecoveryPointsByBackupVaultInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let byResourceType = byResourceType {
                let byResourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(byResourceType).urlPercentEncoding())
                items.append(byResourceTypeQueryItem)
            }
            if let byCreatedBefore = byCreatedBefore {
                let byCreatedBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedBefore)).urlPercentEncoding())
                items.append(byCreatedBeforeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let byResourceArn = byResourceArn {
                let byResourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(byResourceArn).urlPercentEncoding())
                items.append(byResourceArnQueryItem)
            }
            if let byBackupPlanId = byBackupPlanId {
                let byBackupPlanIdQueryItem = ClientRuntime.URLQueryItem(name: "backupPlanId".urlPercentEncoding(), value: Swift.String(byBackupPlanId).urlPercentEncoding())
                items.append(byBackupPlanIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let byParentRecoveryPointArn = byParentRecoveryPointArn {
                let byParentRecoveryPointArnQueryItem = ClientRuntime.URLQueryItem(name: "parentRecoveryPointArn".urlPercentEncoding(), value: Swift.String(byParentRecoveryPointArn).urlPercentEncoding())
                items.append(byParentRecoveryPointArnQueryItem)
            }
            if let byCreatedAfter = byCreatedAfter {
                let byCreatedAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedAfter)).urlPercentEncoding())
                items.append(byCreatedAfterQueryItem)
            }
            return items
        }
    }
}

extension ListRecoveryPointsByBackupVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points"
    }
}

public struct ListRecoveryPointsByBackupVaultInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens. Backup vault name might not be available when a supported service creates the backup.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// Returns only recovery points that match the specified backup plan ID.
    public var byBackupPlanId: Swift.String?
    /// Returns only recovery points that were created after the specified timestamp.
    public var byCreatedAfter: ClientRuntime.Date?
    /// Returns only recovery points that were created before the specified timestamp.
    public var byCreatedBefore: ClientRuntime.Date?
    /// This returns only recovery points that match the specified parent (composite) recovery point Amazon Resource Name (ARN).
    public var byParentRecoveryPointArn: Swift.String?
    /// Returns only recovery points that match the specified resource Amazon Resource Name (ARN).
    public var byResourceArn: Swift.String?
    /// Returns only recovery points that match the specified resource type.
    public var byResourceType: Swift.String?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        byBackupPlanId: Swift.String? = nil,
        byCreatedAfter: ClientRuntime.Date? = nil,
        byCreatedBefore: ClientRuntime.Date? = nil,
        byParentRecoveryPointArn: Swift.String? = nil,
        byResourceArn: Swift.String? = nil,
        byResourceType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.byBackupPlanId = byBackupPlanId
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byParentRecoveryPointArn = byParentRecoveryPointArn
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecoveryPointsByBackupVaultInputBody: Swift.Equatable {
}

extension ListRecoveryPointsByBackupVaultInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRecoveryPointsByBackupVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecoveryPointsByBackupVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRecoveryPointsByBackupVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecoveryPointsByBackupVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRecoveryPointsByBackupVaultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recoveryPoints = output.recoveryPoints
        } else {
            self.nextToken = nil
            self.recoveryPoints = nil
        }
    }
}

public struct ListRecoveryPointsByBackupVaultOutputResponse: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of objects that contain detailed information about recovery points saved in a backup vault.
    public var recoveryPoints: [BackupClientTypes.RecoveryPointByBackupVault]?

    public init (
        nextToken: Swift.String? = nil,
        recoveryPoints: [BackupClientTypes.RecoveryPointByBackupVault]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

struct ListRecoveryPointsByBackupVaultOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let recoveryPoints: [BackupClientTypes.RecoveryPointByBackupVault]?
}

extension ListRecoveryPointsByBackupVaultOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recoveryPoints = "RecoveryPoints"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recoveryPointsContainer = try containerValues.decodeIfPresent([BackupClientTypes.RecoveryPointByBackupVault?].self, forKey: .recoveryPoints)
        var recoveryPointsDecoded0:[BackupClientTypes.RecoveryPointByBackupVault]? = nil
        if let recoveryPointsContainer = recoveryPointsContainer {
            recoveryPointsDecoded0 = [BackupClientTypes.RecoveryPointByBackupVault]()
            for structure0 in recoveryPointsContainer {
                if let structure0 = structure0 {
                    recoveryPointsDecoded0?.append(structure0)
                }
            }
        }
        recoveryPoints = recoveryPointsDecoded0
    }
}

extension ListRecoveryPointsByLegalHoldInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRecoveryPointsByLegalHoldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let legalHoldId = legalHoldId else {
            return nil
        }
        return "/legal-holds/\(legalHoldId.urlPercentEncoding())/recovery-points"
    }
}

public struct ListRecoveryPointsByLegalHoldInput: Swift.Equatable {
    /// This is the ID of the legal hold.
    /// This member is required.
    public var legalHoldId: Swift.String?
    /// This is the maximum number of resource list items to be returned.
    public var maxResults: Swift.Int?
    /// This is the next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        legalHoldId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.legalHoldId = legalHoldId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecoveryPointsByLegalHoldInputBody: Swift.Equatable {
}

extension ListRecoveryPointsByLegalHoldInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRecoveryPointsByLegalHoldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecoveryPointsByLegalHoldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRecoveryPointsByLegalHoldOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecoveryPointsByLegalHoldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRecoveryPointsByLegalHoldOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recoveryPoints = output.recoveryPoints
        } else {
            self.nextToken = nil
            self.recoveryPoints = nil
        }
    }
}

public struct ListRecoveryPointsByLegalHoldOutputResponse: Swift.Equatable {
    /// This return is the next item following a partial list of returned resources.
    public var nextToken: Swift.String?
    /// This is a list of the recovery points returned by ListRecoveryPointsByLegalHold.
    public var recoveryPoints: [BackupClientTypes.RecoveryPointMember]?

    public init (
        nextToken: Swift.String? = nil,
        recoveryPoints: [BackupClientTypes.RecoveryPointMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

struct ListRecoveryPointsByLegalHoldOutputResponseBody: Swift.Equatable {
    let recoveryPoints: [BackupClientTypes.RecoveryPointMember]?
    let nextToken: Swift.String?
}

extension ListRecoveryPointsByLegalHoldOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recoveryPoints = "RecoveryPoints"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointsContainer = try containerValues.decodeIfPresent([BackupClientTypes.RecoveryPointMember?].self, forKey: .recoveryPoints)
        var recoveryPointsDecoded0:[BackupClientTypes.RecoveryPointMember]? = nil
        if let recoveryPointsContainer = recoveryPointsContainer {
            recoveryPointsDecoded0 = [BackupClientTypes.RecoveryPointMember]()
            for structure0 in recoveryPointsContainer {
                if let structure0 = structure0 {
                    recoveryPointsDecoded0?.append(structure0)
                }
            }
        }
        recoveryPoints = recoveryPointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecoveryPointsByResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRecoveryPointsByResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())/recovery-points"
    }
}

public struct ListRecoveryPointsByResourceInput: Swift.Equatable {
    /// The maximum number of items to be returned. Amazon RDS requires a value of at least 20.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListRecoveryPointsByResourceInputBody: Swift.Equatable {
}

extension ListRecoveryPointsByResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRecoveryPointsByResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecoveryPointsByResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRecoveryPointsByResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecoveryPointsByResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRecoveryPointsByResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recoveryPoints = output.recoveryPoints
        } else {
            self.nextToken = nil
            self.recoveryPoints = nil
        }
    }
}

public struct ListRecoveryPointsByResourceOutputResponse: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of objects that contain detailed information about recovery points of the specified resource type. Only Amazon EFS and Amazon EC2 recovery points return BackupVaultName.
    public var recoveryPoints: [BackupClientTypes.RecoveryPointByResource]?

    public init (
        nextToken: Swift.String? = nil,
        recoveryPoints: [BackupClientTypes.RecoveryPointByResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

struct ListRecoveryPointsByResourceOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let recoveryPoints: [BackupClientTypes.RecoveryPointByResource]?
}

extension ListRecoveryPointsByResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recoveryPoints = "RecoveryPoints"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recoveryPointsContainer = try containerValues.decodeIfPresent([BackupClientTypes.RecoveryPointByResource?].self, forKey: .recoveryPoints)
        var recoveryPointsDecoded0:[BackupClientTypes.RecoveryPointByResource]? = nil
        if let recoveryPointsContainer = recoveryPointsContainer {
            recoveryPointsDecoded0 = [BackupClientTypes.RecoveryPointByResource]()
            for structure0 in recoveryPointsContainer {
                if let structure0 = structure0 {
                    recoveryPointsDecoded0?.append(structure0)
                }
            }
        }
        recoveryPoints = recoveryPointsDecoded0
    }
}

extension ListReportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let byReportPlanName = byReportPlanName {
                let byReportPlanNameQueryItem = ClientRuntime.URLQueryItem(name: "ReportPlanName".urlPercentEncoding(), value: Swift.String(byReportPlanName).urlPercentEncoding())
                items.append(byReportPlanNameQueryItem)
            }
            if let byCreationAfter = byCreationAfter {
                let byCreationAfterQueryItem = ClientRuntime.URLQueryItem(name: "CreationAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreationAfter)).urlPercentEncoding())
                items.append(byCreationAfterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let byStatus = byStatus {
                let byStatusQueryItem = ClientRuntime.URLQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(byStatus).urlPercentEncoding())
                items.append(byStatusQueryItem)
            }
            if let byCreationBefore = byCreationBefore {
                let byCreationBeforeQueryItem = ClientRuntime.URLQueryItem(name: "CreationBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreationBefore)).urlPercentEncoding())
                items.append(byCreationBeforeQueryItem)
            }
            return items
        }
    }
}

extension ListReportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/report-jobs"
    }
}

public struct ListReportJobsInput: Swift.Equatable {
    /// Returns only report jobs that were created after the date and time specified in Unix format and Coordinated Universal Time (UTC). For example, the value 1516925490 represents Friday, January 26, 2018 12:11:30 AM.
    public var byCreationAfter: ClientRuntime.Date?
    /// Returns only report jobs that were created before the date and time specified in Unix format and Coordinated Universal Time (UTC). For example, the value 1516925490 represents Friday, January 26, 2018 12:11:30 AM.
    public var byCreationBefore: ClientRuntime.Date?
    /// Returns only report jobs with the specified report plan name.
    public var byReportPlanName: Swift.String?
    /// Returns only report jobs that are in the specified status. The statuses are: CREATED | RUNNING | COMPLETED | FAILED
    public var byStatus: Swift.String?
    /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        byCreationAfter: ClientRuntime.Date? = nil,
        byCreationBefore: ClientRuntime.Date? = nil,
        byReportPlanName: Swift.String? = nil,
        byStatus: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byCreationAfter = byCreationAfter
        self.byCreationBefore = byCreationBefore
        self.byReportPlanName = byReportPlanName
        self.byStatus = byStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReportJobsInputBody: Swift.Equatable {
}

extension ListReportJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListReportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportJobs = output.reportJobs
        } else {
            self.nextToken = nil
            self.reportJobs = nil
        }
    }
}

public struct ListReportJobsOutputResponse: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Details about your report jobs in JSON format.
    public var reportJobs: [BackupClientTypes.ReportJob]?

    public init (
        nextToken: Swift.String? = nil,
        reportJobs: [BackupClientTypes.ReportJob]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportJobs = reportJobs
    }
}

struct ListReportJobsOutputResponseBody: Swift.Equatable {
    let reportJobs: [BackupClientTypes.ReportJob]?
    let nextToken: Swift.String?
}

extension ListReportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reportJobs = "ReportJobs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportJobsContainer = try containerValues.decodeIfPresent([BackupClientTypes.ReportJob?].self, forKey: .reportJobs)
        var reportJobsDecoded0:[BackupClientTypes.ReportJob]? = nil
        if let reportJobsContainer = reportJobsContainer {
            reportJobsDecoded0 = [BackupClientTypes.ReportJob]()
            for structure0 in reportJobsContainer {
                if let structure0 = structure0 {
                    reportJobsDecoded0?.append(structure0)
                }
            }
        }
        reportJobs = reportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListReportPlansInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListReportPlansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/report-plans"
    }
}

public struct ListReportPlansInput: Swift.Equatable {
    /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReportPlansInputBody: Swift.Equatable {
}

extension ListReportPlansInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListReportPlansOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReportPlansOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReportPlansOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReportPlansOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReportPlansOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportPlans = output.reportPlans
        } else {
            self.nextToken = nil
            self.reportPlans = nil
        }
    }
}

public struct ListReportPlansOutputResponse: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// A list of your report plans with detailed information for each plan. This information includes the Amazon Resource Name (ARN), report plan name, description, settings, delivery channel, deployment status, creation time, and last times the report plan attempted to and successfully ran.
    public var reportPlans: [BackupClientTypes.ReportPlan]?

    public init (
        nextToken: Swift.String? = nil,
        reportPlans: [BackupClientTypes.ReportPlan]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportPlans = reportPlans
    }
}

struct ListReportPlansOutputResponseBody: Swift.Equatable {
    let reportPlans: [BackupClientTypes.ReportPlan]?
    let nextToken: Swift.String?
}

extension ListReportPlansOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reportPlans = "ReportPlans"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlansContainer = try containerValues.decodeIfPresent([BackupClientTypes.ReportPlan?].self, forKey: .reportPlans)
        var reportPlansDecoded0:[BackupClientTypes.ReportPlan]? = nil
        if let reportPlansContainer = reportPlansContainer {
            reportPlansDecoded0 = [BackupClientTypes.ReportPlan]()
            for structure0 in reportPlansContainer {
                if let structure0 = structure0 {
                    reportPlansDecoded0?.append(structure0)
                }
            }
        }
        reportPlans = reportPlansDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRestoreJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let byCreatedBefore = byCreatedBefore {
                let byCreatedBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedBefore)).urlPercentEncoding())
                items.append(byCreatedBeforeQueryItem)
            }
            if let byCompleteAfter = byCompleteAfter {
                let byCompleteAfterQueryItem = ClientRuntime.URLQueryItem(name: "completeAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCompleteAfter)).urlPercentEncoding())
                items.append(byCompleteAfterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let byAccountId = byAccountId {
                let byAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(byAccountId).urlPercentEncoding())
                items.append(byAccountIdQueryItem)
            }
            if let byCompleteBefore = byCompleteBefore {
                let byCompleteBeforeQueryItem = ClientRuntime.URLQueryItem(name: "completeBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCompleteBefore)).urlPercentEncoding())
                items.append(byCompleteBeforeQueryItem)
            }
            if let byCreatedAfter = byCreatedAfter {
                let byCreatedAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: byCreatedAfter)).urlPercentEncoding())
                items.append(byCreatedAfterQueryItem)
            }
            if let byStatus = byStatus {
                let byStatusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(byStatus.rawValue).urlPercentEncoding())
                items.append(byStatusQueryItem)
            }
            return items
        }
    }
}

extension ListRestoreJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/restore-jobs"
    }
}

public struct ListRestoreJobsInput: Swift.Equatable {
    /// The account ID to list the jobs from. Returns only restore jobs associated with the specified account ID.
    public var byAccountId: Swift.String?
    /// Returns only copy jobs completed after a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteAfter: ClientRuntime.Date?
    /// Returns only copy jobs completed before a date expressed in Unix format and Coordinated Universal Time (UTC).
    public var byCompleteBefore: ClientRuntime.Date?
    /// Returns only restore jobs that were created after the specified date.
    public var byCreatedAfter: ClientRuntime.Date?
    /// Returns only restore jobs that were created before the specified date.
    public var byCreatedBefore: ClientRuntime.Date?
    /// Returns only restore jobs associated with the specified job status.
    public var byStatus: BackupClientTypes.RestoreJobStatus?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        byAccountId: Swift.String? = nil,
        byCompleteAfter: ClientRuntime.Date? = nil,
        byCompleteBefore: ClientRuntime.Date? = nil,
        byCreatedAfter: ClientRuntime.Date? = nil,
        byCreatedBefore: ClientRuntime.Date? = nil,
        byStatus: BackupClientTypes.RestoreJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byCompleteAfter = byCompleteAfter
        self.byCompleteBefore = byCompleteBefore
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byStatus = byStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRestoreJobsInputBody: Swift.Equatable {
}

extension ListRestoreJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRestoreJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRestoreJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRestoreJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRestoreJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRestoreJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.restoreJobs = output.restoreJobs
        } else {
            self.nextToken = nil
            self.restoreJobs = nil
        }
    }
}

public struct ListRestoreJobsOutputResponse: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of objects that contain detailed information about jobs to restore saved resources.
    public var restoreJobs: [BackupClientTypes.RestoreJobsListMember]?

    public init (
        nextToken: Swift.String? = nil,
        restoreJobs: [BackupClientTypes.RestoreJobsListMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.restoreJobs = restoreJobs
    }
}

struct ListRestoreJobsOutputResponseBody: Swift.Equatable {
    let restoreJobs: [BackupClientTypes.RestoreJobsListMember]?
    let nextToken: Swift.String?
}

extension ListRestoreJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case restoreJobs = "RestoreJobs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restoreJobsContainer = try containerValues.decodeIfPresent([BackupClientTypes.RestoreJobsListMember?].self, forKey: .restoreJobs)
        var restoreJobsDecoded0:[BackupClientTypes.RestoreJobsListMember]? = nil
        if let restoreJobsContainer = restoreJobsContainer {
            restoreJobsDecoded0 = [BackupClientTypes.RestoreJobsListMember]()
            for structure0 in restoreJobsContainer {
                if let structure0 = structure0 {
                    restoreJobsDecoded0?.append(structure0)
                }
            }
        }
        restoreJobs = restoreJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsInput: Swift.Equatable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the type of resource. Valid targets for ListTags are recovery points, backup plans, and backup vaults.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsInputBody: Swift.Equatable {
}

extension ListTagsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \"CONTENT_REDACTED\")"}
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// To help organize your resources, you can assign your own metadata to the resources you create. Each tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MissingParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MissingParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a required parameter is missing.
public struct MissingParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct MissingParameterValueExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension MissingParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes.ProtectedResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastBackupTime = "LastBackupTime"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastBackupTime = self.lastBackupTime {
            try encodeContainer.encodeTimestamp(lastBackupTime, format: .epochSeconds, forKey: .lastBackupTime)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let lastBackupTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastBackupTime)
        lastBackupTime = lastBackupTimeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension BackupClientTypes {
    /// A structure that contains information about a backed-up resource.
    public struct ProtectedResource: Swift.Equatable {
        /// The date and time a resource was last backed up, in Unix format and Coordinated Universal Time (UTC). The value of LastBackupTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastBackupTime: ClientRuntime.Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var resourceArn: Swift.String?
        /// This is the non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?

        public init (
            lastBackupTime: ClientRuntime.Date? = nil,
            resourceArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.lastBackupTime = lastBackupTime
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
        }
    }

}

extension PutBackupVaultAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutBackupVaultAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/access-policy"
    }
}

public struct PutBackupVaultAccessPolicyInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The backup vault access policy document in JSON format.
    public var policy: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.policy = policy
    }
}

struct PutBackupVaultAccessPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutBackupVaultAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutBackupVaultAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutBackupVaultAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutBackupVaultAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBackupVaultAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBackupVaultAccessPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutBackupVaultLockConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeableForDays = "ChangeableForDays"
        case maxRetentionDays = "MaxRetentionDays"
        case minRetentionDays = "MinRetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeableForDays = self.changeableForDays {
            try encodeContainer.encode(changeableForDays, forKey: .changeableForDays)
        }
        if let maxRetentionDays = self.maxRetentionDays {
            try encodeContainer.encode(maxRetentionDays, forKey: .maxRetentionDays)
        }
        if let minRetentionDays = self.minRetentionDays {
            try encodeContainer.encode(minRetentionDays, forKey: .minRetentionDays)
        }
    }
}

extension PutBackupVaultLockConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/vault-lock"
    }
}

public struct PutBackupVaultLockConfigurationInput: Swift.Equatable {
    /// The Backup Vault Lock configuration that specifies the name of the backup vault it protects.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The Backup Vault Lock configuration that specifies the number of days before the lock date. For example, setting ChangeableForDays to 30 on Jan. 1, 2022 at 8pm UTC will set the lock date to Jan. 31, 2022 at 8pm UTC. Backup enforces a 72-hour cooling-off period before Vault Lock takes effect and becomes immutable. Therefore, you must set ChangeableForDays to 3 or greater. Before the lock date, you can delete Vault Lock from the vault using DeleteBackupVaultLockConfiguration or change the Vault Lock configuration using PutBackupVaultLockConfiguration. On and after the lock date, the Vault Lock becomes immutable and cannot be changed or deleted. If this parameter is not specified, you can delete Vault Lock from the vault using DeleteBackupVaultLockConfiguration or change the Vault Lock configuration using PutBackupVaultLockConfiguration at any time.
    public var changeableForDays: Swift.Int?
    /// The Backup Vault Lock configuration that specifies the maximum retention period that the vault retains its recovery points. This setting can be useful if, for example, your organization's policies require you to destroy certain data after retaining it for four years (1460 days). If this parameter is not included, Vault Lock does not enforce a maximum retention period on the recovery points in the vault. If this parameter is included without a value, Vault Lock will not enforce a maximum retention period. If this parameter is specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. The longest maximum retention period you can specify is 36500 days (approximately 100 years). Recovery points already saved in the vault prior to Vault Lock are not affected.
    public var maxRetentionDays: Swift.Int?
    /// The Backup Vault Lock configuration that specifies the minimum retention period that the vault retains its recovery points. This setting can be useful if, for example, your organization's policies require you to retain certain data for at least seven years (2555 days). If this parameter is not specified, Vault Lock will not enforce a minimum retention period. If this parameter is specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails that backup or copy job, and you should either modify your lifecycle settings or use a different vault. The shortest minimum retention period you can specify is 1 day. Recovery points already saved in the vault prior to Vault Lock are not affected.
    public var minRetentionDays: Swift.Int?

    public init (
        backupVaultName: Swift.String? = nil,
        changeableForDays: Swift.Int? = nil,
        maxRetentionDays: Swift.Int? = nil,
        minRetentionDays: Swift.Int? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.changeableForDays = changeableForDays
        self.maxRetentionDays = maxRetentionDays
        self.minRetentionDays = minRetentionDays
    }
}

struct PutBackupVaultLockConfigurationInputBody: Swift.Equatable {
    let minRetentionDays: Swift.Int?
    let maxRetentionDays: Swift.Int?
    let changeableForDays: Swift.Int?
}

extension PutBackupVaultLockConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeableForDays = "ChangeableForDays"
        case maxRetentionDays = "MaxRetentionDays"
        case minRetentionDays = "MinRetentionDays"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minRetentionDays)
        minRetentionDays = minRetentionDaysDecoded
        let maxRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetentionDays)
        maxRetentionDays = maxRetentionDaysDecoded
        let changeableForDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .changeableForDays)
        changeableForDays = changeableForDaysDecoded
    }
}

extension PutBackupVaultLockConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutBackupVaultLockConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutBackupVaultLockConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBackupVaultLockConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBackupVaultLockConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutBackupVaultNotificationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultEvents = "BackupVaultEvents"
        case snsTopicArn = "SNSTopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultEvents = backupVaultEvents {
            var backupVaultEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .backupVaultEvents)
            for backupvaultevent0 in backupVaultEvents {
                try backupVaultEventsContainer.encode(backupvaultevent0.rawValue)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }
}

extension PutBackupVaultNotificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/notification-configuration"
    }
}

public struct PutBackupVaultNotificationsInput: Swift.Equatable {
    /// An array of events that indicate the status of jobs to back up resources to the backup vault. For common use cases and code samples, see [Using Amazon SNS to track Backup events](https://docs.aws.amazon.com/aws-backup/latest/devguide/sns-notifications.html). The following events are supported:
    ///
    /// * BACKUP_JOB_STARTED | BACKUP_JOB_COMPLETED
    ///
    /// * COPY_JOB_STARTED | COPY_JOB_SUCCESSFUL | COPY_JOB_FAILED
    ///
    /// * RESTORE_JOB_STARTED | RESTORE_JOB_COMPLETED | RECOVERY_POINT_MODIFIED
    ///
    /// * S3_BACKUP_OBJECT_FAILED | S3_RESTORE_OBJECT_FAILED
    ///
    ///
    /// The list below shows items that are deprecated events (for reference) and are no longer in use. They are no longer supported and will not return statuses or notifications. Refer to the list above for current supported events.
    /// This member is required.
    public var backupVaultEvents: [BackupClientTypes.BackupVaultEvent]?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The Amazon Resource Name (ARN) that specifies the topic for a backup vault’s events; for example, arn:aws:sns:us-west-2:111122223333:MyVaultTopic.
    /// This member is required.
    public var snsTopicArn: Swift.String?

    public init (
        backupVaultEvents: [BackupClientTypes.BackupVaultEvent]? = nil,
        backupVaultName: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.backupVaultEvents = backupVaultEvents
        self.backupVaultName = backupVaultName
        self.snsTopicArn = snsTopicArn
    }
}

struct PutBackupVaultNotificationsInputBody: Swift.Equatable {
    let snsTopicArn: Swift.String?
    let backupVaultEvents: [BackupClientTypes.BackupVaultEvent]?
}

extension PutBackupVaultNotificationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultEvents = "BackupVaultEvents"
        case snsTopicArn = "SNSTopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let backupVaultEventsContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupVaultEvent?].self, forKey: .backupVaultEvents)
        var backupVaultEventsDecoded0:[BackupClientTypes.BackupVaultEvent]? = nil
        if let backupVaultEventsContainer = backupVaultEventsContainer {
            backupVaultEventsDecoded0 = [BackupClientTypes.BackupVaultEvent]()
            for enum0 in backupVaultEventsContainer {
                if let enum0 = enum0 {
                    backupVaultEventsDecoded0?.append(enum0)
                }
            }
        }
        backupVaultEvents = backupVaultEventsDecoded0
    }
}

extension PutBackupVaultNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutBackupVaultNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutBackupVaultNotificationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBackupVaultNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBackupVaultNotificationsOutputResponse: Swift.Equatable {

    public init () { }
}

extension BackupClientTypes.RecoveryPointByBackupVault: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case calculatedLifecycle = "CalculatedLifecycle"
        case completionDate = "CompletionDate"
        case compositeMemberIdentifier = "CompositeMemberIdentifier"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case encryptionKeyArn = "EncryptionKeyArn"
        case iamRoleArn = "IamRoleArn"
        case isEncrypted = "IsEncrypted"
        case isParent = "IsParent"
        case lastRestoreTime = "LastRestoreTime"
        case lifecycle = "Lifecycle"
        case parentRecoveryPointArn = "ParentRecoveryPointArn"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case sourceBackupVaultArn = "SourceBackupVaultArn"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupSizeInBytes = self.backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let backupVaultArn = self.backupVaultArn {
            try encodeContainer.encode(backupVaultArn, forKey: .backupVaultArn)
        }
        if let backupVaultName = self.backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let calculatedLifecycle = self.calculatedLifecycle {
            try encodeContainer.encode(calculatedLifecycle, forKey: .calculatedLifecycle)
        }
        if let completionDate = self.completionDate {
            try encodeContainer.encodeTimestamp(completionDate, format: .epochSeconds, forKey: .completionDate)
        }
        if let compositeMemberIdentifier = self.compositeMemberIdentifier {
            try encodeContainer.encode(compositeMemberIdentifier, forKey: .compositeMemberIdentifier)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if isEncrypted != false {
            try encodeContainer.encode(isEncrypted, forKey: .isEncrypted)
        }
        if isParent != false {
            try encodeContainer.encode(isParent, forKey: .isParent)
        }
        if let lastRestoreTime = self.lastRestoreTime {
            try encodeContainer.encodeTimestamp(lastRestoreTime, format: .epochSeconds, forKey: .lastRestoreTime)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let parentRecoveryPointArn = self.parentRecoveryPointArn {
            try encodeContainer.encode(parentRecoveryPointArn, forKey: .parentRecoveryPointArn)
        }
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let sourceBackupVaultArn = self.sourceBackupVaultArn {
            try encodeContainer.encode(sourceBackupVaultArn, forKey: .sourceBackupVaultArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let sourceBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupVaultArn)
        sourceBackupVaultArn = sourceBackupVaultArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDate)
        completionDate = completionDateDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let calculatedLifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CalculatedLifecycle.self, forKey: .calculatedLifecycle)
        calculatedLifecycle = calculatedLifecycleDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let isEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEncrypted) ?? false
        isEncrypted = isEncryptedDecoded
        let lastRestoreTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastRestoreTime)
        lastRestoreTime = lastRestoreTimeDecoded
        let parentRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentRecoveryPointArn)
        parentRecoveryPointArn = parentRecoveryPointArnDecoded
        let compositeMemberIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .compositeMemberIdentifier)
        compositeMemberIdentifier = compositeMemberIdentifierDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about the recovery points stored in a backup vault.
    public struct RecoveryPointByBackupVault: Swift.Equatable {
        /// The size, in bytes, of a backup.
        public var backupSizeInBytes: Swift.Int?
        /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
        public var calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
        /// The date and time a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: ClientRuntime.Date?
        /// This is the identifier of a resource within a composite group, such as nested (child) recovery point belonging to a composite (parent) stack. The ID is transferred from the [ logical ID](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html#resources-section-structure-syntax) within a stack.
        public var compositeMemberIdentifier: Swift.String?
        /// Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan that is used to create it.
        public var createdBy: BackupClientTypes.RecoveryPointCreator?
        /// The date and time a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public var encryptionKeyArn: Swift.String?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.
        public var isEncrypted: Swift.Bool
        /// This is a boolean value indicating this is a parent (composite) recovery point.
        public var isParent: Swift.Bool
        /// The date and time a recovery point was last restored, in Unix format and Coordinated Universal Time (UTC). The value of LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastRestoreTime: ClientRuntime.Date?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
        public var lifecycle: BackupClientTypes.Lifecycle?
        /// This is the Amazon Resource Name (ARN) of the parent (composite) recovery point.
        public var parentRecoveryPointArn: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var resourceArn: Swift.String?
        /// This is the non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource saved as a recovery point; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?
        /// The backup vault where the recovery point was originally copied from. If the recovery point is restored to the same account this value will be null.
        public var sourceBackupVaultArn: Swift.String?
        /// A status code specifying the state of the recovery point.
        public var status: BackupClientTypes.RecoveryPointStatus?
        /// A message explaining the reason of the recovery point deletion failure.
        public var statusMessage: Swift.String?

        public init (
            backupSizeInBytes: Swift.Int? = nil,
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            calculatedLifecycle: BackupClientTypes.CalculatedLifecycle? = nil,
            completionDate: ClientRuntime.Date? = nil,
            compositeMemberIdentifier: Swift.String? = nil,
            createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
            creationDate: ClientRuntime.Date? = nil,
            encryptionKeyArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            isEncrypted: Swift.Bool = false,
            isParent: Swift.Bool = false,
            lastRestoreTime: ClientRuntime.Date? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil,
            parentRecoveryPointArn: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            sourceBackupVaultArn: Swift.String? = nil,
            status: BackupClientTypes.RecoveryPointStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.backupSizeInBytes = backupSizeInBytes
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.calculatedLifecycle = calculatedLifecycle
            self.completionDate = completionDate
            self.compositeMemberIdentifier = compositeMemberIdentifier
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.iamRoleArn = iamRoleArn
            self.isEncrypted = isEncrypted
            self.isParent = isParent
            self.lastRestoreTime = lastRestoreTime
            self.lifecycle = lifecycle
            self.parentRecoveryPointArn = parentRecoveryPointArn
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes.RecoveryPointByResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSizeBytes = "BackupSizeBytes"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
        case encryptionKeyArn = "EncryptionKeyArn"
        case isParent = "IsParent"
        case parentRecoveryPointArn = "ParentRecoveryPointArn"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceName = "ResourceName"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupSizeBytes = self.backupSizeBytes {
            try encodeContainer.encode(backupSizeBytes, forKey: .backupSizeBytes)
        }
        if let backupVaultName = self.backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if isParent != false {
            try encodeContainer.encode(isParent, forKey: .isParent)
        }
        if let parentRecoveryPointArn = self.parentRecoveryPointArn {
            try encodeContainer.encode(parentRecoveryPointArn, forKey: .parentRecoveryPointArn)
        }
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let backupSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeBytes)
        backupSizeBytes = backupSizeBytesDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
        let parentRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentRecoveryPointArn)
        parentRecoveryPointArn = parentRecoveryPointArnDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about a saved recovery point.
    public struct RecoveryPointByResource: Swift.Equatable {
        /// The size, in bytes, of a backup.
        public var backupSizeBytes: Swift.Int?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// The date and time a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public var encryptionKeyArn: Swift.String?
        /// This is a boolean value indicating this is a parent (composite) recovery point.
        public var isParent: Swift.Bool
        /// This is the Amazon Resource Name (ARN) of the parent (composite) recovery point.
        public var parentRecoveryPointArn: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// This is the non-unique name of the resource that belongs to the specified backup.
        public var resourceName: Swift.String?
        /// A status code specifying the state of the recovery point.
        public var status: BackupClientTypes.RecoveryPointStatus?
        /// A message explaining the reason of the recovery point deletion failure.
        public var statusMessage: Swift.String?

        public init (
            backupSizeBytes: Swift.Int? = nil,
            backupVaultName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            encryptionKeyArn: Swift.String? = nil,
            isParent: Swift.Bool = false,
            parentRecoveryPointArn: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            status: BackupClientTypes.RecoveryPointStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.backupSizeBytes = backupSizeBytes
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.isParent = isParent
            self.parentRecoveryPointArn = parentRecoveryPointArn
            self.recoveryPointArn = recoveryPointArn
            self.resourceName = resourceName
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes.RecoveryPointCreator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case backupPlanVersion = "BackupPlanVersion"
        case backupRuleId = "BackupRuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanArn = self.backupPlanArn {
            try encodeContainer.encode(backupPlanArn, forKey: .backupPlanArn)
        }
        if let backupPlanId = self.backupPlanId {
            try encodeContainer.encode(backupPlanId, forKey: .backupPlanId)
        }
        if let backupPlanVersion = self.backupPlanVersion {
            try encodeContainer.encode(backupPlanVersion, forKey: .backupPlanVersion)
        }
        if let backupRuleId = self.backupRuleId {
            try encodeContainer.encode(backupRuleId, forKey: .backupRuleId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let backupPlanVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanVersion)
        backupPlanVersion = backupPlanVersionDecoded
        let backupRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupRuleId)
        backupRuleId = backupRuleIdDecoded
    }
}

extension BackupClientTypes {
    /// Contains information about the backup plan and rule that Backup used to initiate the recovery point backup.
    public struct RecoveryPointCreator: Swift.Equatable {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public var backupPlanArn: Swift.String?
        /// Uniquely identifies a backup plan.
        public var backupPlanId: Swift.String?
        /// Version IDs are unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. They cannot be edited.
        public var backupPlanVersion: Swift.String?
        /// Uniquely identifies a rule used to schedule the backup of a selection of resources.
        public var backupRuleId: Swift.String?

        public init (
            backupPlanArn: Swift.String? = nil,
            backupPlanId: Swift.String? = nil,
            backupPlanVersion: Swift.String? = nil,
            backupRuleId: Swift.String? = nil
        )
        {
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanVersion = backupPlanVersion
            self.backupRuleId = backupRuleId
        }
    }

}

extension BackupClientTypes.RecoveryPointMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryPointArn = "RecoveryPointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
    }
}

extension BackupClientTypes {
    /// This is a recovery point which is a child (nested) recovery point of a parent (composite) recovery point. These recovery points can be disassociated from their parent (composite) recovery point, in which case they will no longer be a member.
    public struct RecoveryPointMember: Swift.Equatable {
        /// This is the Amazon Resource Name (ARN) of the parent (composite) recovery point.
        public var recoveryPointArn: Swift.String?

        public init (
            recoveryPointArn: Swift.String? = nil
        )
        {
            self.recoveryPointArn = recoveryPointArn
        }
    }

}

extension BackupClientTypes.RecoveryPointSelection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateRange = "DateRange"
        case resourceIdentifiers = "ResourceIdentifiers"
        case vaultNames = "VaultNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRange = self.dateRange {
            try encodeContainer.encode(dateRange, forKey: .dateRange)
        }
        if let resourceIdentifiers = resourceIdentifiers {
            var resourceIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIdentifiers)
            for string0 in resourceIdentifiers {
                try resourceIdentifiersContainer.encode(string0)
            }
        }
        if let vaultNames = vaultNames {
            var vaultNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vaultNames)
            for string0 in vaultNames {
                try vaultNamesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vaultNames)
        var vaultNamesDecoded0:[Swift.String]? = nil
        if let vaultNamesContainer = vaultNamesContainer {
            vaultNamesDecoded0 = [Swift.String]()
            for string0 in vaultNamesContainer {
                if let string0 = string0 {
                    vaultNamesDecoded0?.append(string0)
                }
            }
        }
        vaultNames = vaultNamesDecoded0
        let resourceIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIdentifiers)
        var resourceIdentifiersDecoded0:[Swift.String]? = nil
        if let resourceIdentifiersContainer = resourceIdentifiersContainer {
            resourceIdentifiersDecoded0 = [Swift.String]()
            for string0 in resourceIdentifiersContainer {
                if let string0 = string0 {
                    resourceIdentifiersDecoded0?.append(string0)
                }
            }
        }
        resourceIdentifiers = resourceIdentifiersDecoded0
        let dateRangeDecoded = try containerValues.decodeIfPresent(BackupClientTypes.DateRange.self, forKey: .dateRange)
        dateRange = dateRangeDecoded
    }
}

extension BackupClientTypes {
    /// This specifies criteria to assign a set of resources, such as resource types or backup vaults.
    public struct RecoveryPointSelection: Swift.Equatable {
        /// This is a resource filter containing FromDate: DateTime and ToDate: DateTime. Both values are required. Future DateTime values are not permitted. The date and time are in Unix format and Coordinated Universal Time (UTC), and it is accurate to milliseconds ((milliseconds are optional). For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var dateRange: BackupClientTypes.DateRange?
        /// These are the resources included in the resource selection (including type of resources and vaults).
        public var resourceIdentifiers: [Swift.String]?
        /// These are the names of the vaults in which the selected recovery points are contained.
        public var vaultNames: [Swift.String]?

        public init (
            dateRange: BackupClientTypes.DateRange? = nil,
            resourceIdentifiers: [Swift.String]? = nil,
            vaultNames: [Swift.String]? = nil
        )
        {
            self.dateRange = dateRange
            self.resourceIdentifiers = resourceIdentifiers
            self.vaultNames = vaultNames
        }
    }

}

extension BackupClientTypes {
    public enum RecoveryPointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case deleting
        case expired
        case partial
        case sdkUnknown(Swift.String)

        public static var allCases: [RecoveryPointStatus] {
            return [
                .completed,
                .deleting,
                .expired,
                .partial,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .deleting: return "DELETING"
            case .expired: return "EXPIRED"
            case .partial: return "PARTIAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecoveryPointStatus(rawValue: rawValue) ?? RecoveryPointStatus.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.ReportDeliveryChannel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formats = "Formats"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formats = formats {
            var formatsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .formats)
            for string0 in formats {
                try formatsContainer.encode(string0)
            }
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let formatsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .formats)
        var formatsDecoded0:[Swift.String]? = nil
        if let formatsContainer = formatsContainer {
            formatsDecoded0 = [Swift.String]()
            for string0 in formatsContainer {
                if let string0 = string0 {
                    formatsDecoded0?.append(string0)
                }
            }
        }
        formats = formatsDecoded0
    }
}

extension BackupClientTypes {
    /// Contains information from your report plan about where to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
    public struct ReportDeliveryChannel: Swift.Equatable {
        /// A list of the format of your reports: CSV, JSON, or both. If not specified, the default format is CSV.
        public var formats: [Swift.String]?
        /// The unique name of the S3 bucket that receives your reports.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// The prefix for where Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name. If not specified, there is no prefix.
        public var s3KeyPrefix: Swift.String?

        public init (
            formats: [Swift.String]? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil
        )
        {
            self.formats = formats
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }
    }

}

extension BackupClientTypes.ReportDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName = "S3BucketName"
        case s3Keys = "S3Keys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3Keys = s3Keys {
            var s3KeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Keys)
            for string0 in s3Keys {
                try s3KeysContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Keys)
        var s3KeysDecoded0:[Swift.String]? = nil
        if let s3KeysContainer = s3KeysContainer {
            s3KeysDecoded0 = [Swift.String]()
            for string0 in s3KeysContainer {
                if let string0 = string0 {
                    s3KeysDecoded0?.append(string0)
                }
            }
        }
        s3Keys = s3KeysDecoded0
    }
}

extension BackupClientTypes {
    /// Contains information from your report job about your report destination.
    public struct ReportDestination: Swift.Equatable {
        /// The unique name of the Amazon S3 bucket that receives your reports.
        public var s3BucketName: Swift.String?
        /// The object key that uniquely identifies your reports in your S3 bucket.
        public var s3Keys: [Swift.String]?

        public init (
            s3BucketName: Swift.String? = nil,
            s3Keys: [Swift.String]? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3Keys = s3Keys
        }
    }

}

extension BackupClientTypes.ReportJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime = "CompletionTime"
        case creationTime = "CreationTime"
        case reportDestination = "ReportDestination"
        case reportJobId = "ReportJobId"
        case reportPlanArn = "ReportPlanArn"
        case reportTemplate = "ReportTemplate"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .epochSeconds, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let reportDestination = self.reportDestination {
            try encodeContainer.encode(reportDestination, forKey: .reportDestination)
        }
        if let reportJobId = self.reportJobId {
            try encodeContainer.encode(reportJobId, forKey: .reportJobId)
        }
        if let reportPlanArn = self.reportPlanArn {
            try encodeContainer.encode(reportPlanArn, forKey: .reportPlanArn)
        }
        if let reportTemplate = self.reportTemplate {
            try encodeContainer.encode(reportTemplate, forKey: .reportTemplate)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportJobId)
        reportJobId = reportJobIdDecoded
        let reportPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanArn)
        reportPlanArn = reportPlanArnDecoded
        let reportTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportTemplate)
        reportTemplate = reportTemplateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let reportDestinationDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportDestination.self, forKey: .reportDestination)
        reportDestination = reportDestinationDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about a report job. A report job compiles a report based on a report plan and publishes it to Amazon S3.
    public struct ReportJob: Swift.Equatable {
        /// The date and time that a report job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionTime: ClientRuntime.Date?
        /// The date and time that a report job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationTime: ClientRuntime.Date?
        /// The S3 bucket name and S3 keys for the destination where the report job publishes the report.
        public var reportDestination: BackupClientTypes.ReportDestination?
        /// The identifier for a report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. Report job IDs cannot be edited.
        public var reportJobId: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var reportPlanArn: Swift.String?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        public var reportTemplate: Swift.String?
        /// The status of a report job. The statuses are: CREATED | RUNNING | COMPLETED | FAILEDCOMPLETED means that the report is available for your review at your designated destination. If the status is FAILED, review the StatusMessage for the reason.
        public var status: Swift.String?
        /// A message explaining the status of the report job.
        public var statusMessage: Swift.String?

        public init (
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            reportDestination: BackupClientTypes.ReportDestination? = nil,
            reportJobId: Swift.String? = nil,
            reportPlanArn: Swift.String? = nil,
            reportTemplate: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.reportDestination = reportDestination
            self.reportJobId = reportJobId
            self.reportPlanArn = reportPlanArn
            self.reportTemplate = reportTemplate
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes.ReportPlan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case deploymentStatus = "DeploymentStatus"
        case lastAttemptedExecutionTime = "LastAttemptedExecutionTime"
        case lastSuccessfulExecutionTime = "LastSuccessfulExecutionTime"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanArn = "ReportPlanArn"
        case reportPlanDescription = "ReportPlanDescription"
        case reportPlanName = "ReportPlanName"
        case reportSetting = "ReportSetting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus, forKey: .deploymentStatus)
        }
        if let lastAttemptedExecutionTime = self.lastAttemptedExecutionTime {
            try encodeContainer.encodeTimestamp(lastAttemptedExecutionTime, format: .epochSeconds, forKey: .lastAttemptedExecutionTime)
        }
        if let lastSuccessfulExecutionTime = self.lastSuccessfulExecutionTime {
            try encodeContainer.encodeTimestamp(lastSuccessfulExecutionTime, format: .epochSeconds, forKey: .lastSuccessfulExecutionTime)
        }
        if let reportDeliveryChannel = self.reportDeliveryChannel {
            try encodeContainer.encode(reportDeliveryChannel, forKey: .reportDeliveryChannel)
        }
        if let reportPlanArn = self.reportPlanArn {
            try encodeContainer.encode(reportPlanArn, forKey: .reportPlanArn)
        }
        if let reportPlanDescription = self.reportPlanDescription {
            try encodeContainer.encode(reportPlanDescription, forKey: .reportPlanDescription)
        }
        if let reportPlanName = self.reportPlanName {
            try encodeContainer.encode(reportPlanName, forKey: .reportPlanName)
        }
        if let reportSetting = self.reportSetting {
            try encodeContainer.encode(reportSetting, forKey: .reportSetting)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanArn)
        reportPlanArn = reportPlanArnDecoded
        let reportPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanName)
        reportPlanName = reportPlanNameDecoded
        let reportPlanDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanDescription)
        reportPlanDescription = reportPlanDescriptionDecoded
        let reportSettingDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportSetting.self, forKey: .reportSetting)
        reportSetting = reportSettingDecoded
        let reportDeliveryChannelDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportDeliveryChannel.self, forKey: .reportDeliveryChannel)
        reportDeliveryChannel = reportDeliveryChannelDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastAttemptedExecutionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAttemptedExecutionTime)
        lastAttemptedExecutionTime = lastAttemptedExecutionTimeDecoded
        let lastSuccessfulExecutionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSuccessfulExecutionTime)
        lastSuccessfulExecutionTime = lastSuccessfulExecutionTimeDecoded
    }
}

extension BackupClientTypes {
    /// Contains detailed information about a report plan.
    public struct ReportPlan: Swift.Equatable {
        /// The date and time that a report plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationTime: ClientRuntime.Date?
        /// The deployment status of a report plan. The statuses are: CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED
        public var deploymentStatus: Swift.String?
        /// The date and time that a report job associated with this report plan last attempted to run, in Unix format and Coordinated Universal Time (UTC). The value of LastAttemptedExecutionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastAttemptedExecutionTime: ClientRuntime.Date?
        /// The date and time that a report job associated with this report plan last successfully ran, in Unix format and Coordinated Universal Time (UTC). The value of LastSuccessfulExecutionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastSuccessfulExecutionTime: ClientRuntime.Date?
        /// Contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
        public var reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var reportPlanArn: Swift.String?
        /// An optional description of the report plan with a maximum 1,024 characters.
        public var reportPlanDescription: Swift.String?
        /// The unique name of the report plan. This name is between 1 and 256 characters starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public var reportPlanName: Swift.String?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
        public var reportSetting: BackupClientTypes.ReportSetting?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            deploymentStatus: Swift.String? = nil,
            lastAttemptedExecutionTime: ClientRuntime.Date? = nil,
            lastSuccessfulExecutionTime: ClientRuntime.Date? = nil,
            reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel? = nil,
            reportPlanArn: Swift.String? = nil,
            reportPlanDescription: Swift.String? = nil,
            reportPlanName: Swift.String? = nil,
            reportSetting: BackupClientTypes.ReportSetting? = nil
        )
        {
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.lastAttemptedExecutionTime = lastAttemptedExecutionTime
            self.lastSuccessfulExecutionTime = lastSuccessfulExecutionTime
            self.reportDeliveryChannel = reportDeliveryChannel
            self.reportPlanArn = reportPlanArn
            self.reportPlanDescription = reportPlanDescription
            self.reportPlanName = reportPlanName
            self.reportSetting = reportSetting
        }
    }

}

extension BackupClientTypes.ReportSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts = "Accounts"
        case frameworkArns = "FrameworkArns"
        case numberOfFrameworks = "NumberOfFrameworks"
        case organizationUnits = "OrganizationUnits"
        case regions = "Regions"
        case reportTemplate = "ReportTemplate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for string0 in accounts {
                try accountsContainer.encode(string0)
            }
        }
        if let frameworkArns = frameworkArns {
            var frameworkArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .frameworkArns)
            for string0 in frameworkArns {
                try frameworkArnsContainer.encode(string0)
            }
        }
        if numberOfFrameworks != 0 {
            try encodeContainer.encode(numberOfFrameworks, forKey: .numberOfFrameworks)
        }
        if let organizationUnits = organizationUnits {
            var organizationUnitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationUnits)
            for string0 in organizationUnits {
                try organizationUnitsContainer.encode(string0)
            }
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for string0 in regions {
                try regionsContainer.encode(string0)
            }
        }
        if let reportTemplate = self.reportTemplate {
            try encodeContainer.encode(reportTemplate, forKey: .reportTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportTemplate)
        reportTemplate = reportTemplateDecoded
        let frameworkArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .frameworkArns)
        var frameworkArnsDecoded0:[Swift.String]? = nil
        if let frameworkArnsContainer = frameworkArnsContainer {
            frameworkArnsDecoded0 = [Swift.String]()
            for string0 in frameworkArnsContainer {
                if let string0 = string0 {
                    frameworkArnsDecoded0?.append(string0)
                }
            }
        }
        frameworkArns = frameworkArnsDecoded0
        let numberOfFrameworksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfFrameworks) ?? 0
        numberOfFrameworks = numberOfFrameworksDecoded
        let accountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accounts)
        var accountsDecoded0:[Swift.String]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Swift.String]()
            for string0 in accountsContainer {
                if let string0 = string0 {
                    accountsDecoded0?.append(string0)
                }
            }
        }
        accounts = accountsDecoded0
        let organizationUnitsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationUnits)
        var organizationUnitsDecoded0:[Swift.String]? = nil
        if let organizationUnitsContainer = organizationUnitsContainer {
            organizationUnitsDecoded0 = [Swift.String]()
            for string0 in organizationUnitsContainer {
                if let string0 = string0 {
                    organizationUnitsDecoded0?.append(string0)
                }
            }
        }
        organizationUnits = organizationUnitsDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
    }
}

extension BackupClientTypes {
    /// Contains detailed information about a report setting.
    public struct ReportSetting: Swift.Equatable {
        /// These are the accounts to be included in the report.
        public var accounts: [Swift.String]?
        /// The Amazon Resource Names (ARNs) of the frameworks a report covers.
        public var frameworkArns: [Swift.String]?
        /// The number of frameworks a report covers.
        public var numberOfFrameworks: Swift.Int
        /// These are the Organizational Units to be included in the report.
        public var organizationUnits: [Swift.String]?
        /// These are the Regions to be included in the report.
        public var regions: [Swift.String]?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        /// This member is required.
        public var reportTemplate: Swift.String?

        public init (
            accounts: [Swift.String]? = nil,
            frameworkArns: [Swift.String]? = nil,
            numberOfFrameworks: Swift.Int = 0,
            organizationUnits: [Swift.String]? = nil,
            regions: [Swift.String]? = nil,
            reportTemplate: Swift.String? = nil
        )
        {
            self.accounts = accounts
            self.frameworkArns = frameworkArns
            self.numberOfFrameworks = numberOfFrameworks
            self.organizationUnits = organizationUnits
            self.regions = regions
            self.reportTemplate = reportTemplate
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource that is required for the action doesn't exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes {
    public enum RestoreJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case completed
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [RestoreJobStatus] {
            return [
                .aborted,
                .completed,
                .failed,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RestoreJobStatus(rawValue: rawValue) ?? RestoreJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.RestoreJobsListMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupSizeInBytes = "BackupSizeInBytes"
        case completionDate = "CompletionDate"
        case createdResourceArn = "CreatedResourceArn"
        case creationDate = "CreationDate"
        case expectedCompletionTimeMinutes = "ExpectedCompletionTimeMinutes"
        case iamRoleArn = "IamRoleArn"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
        case restoreJobId = "RestoreJobId"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let backupSizeInBytes = self.backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let completionDate = self.completionDate {
            try encodeContainer.encodeTimestamp(completionDate, format: .epochSeconds, forKey: .completionDate)
        }
        if let createdResourceArn = self.createdResourceArn {
            try encodeContainer.encode(createdResourceArn, forKey: .createdResourceArn)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let expectedCompletionTimeMinutes = self.expectedCompletionTimeMinutes {
            try encodeContainer.encode(expectedCompletionTimeMinutes, forKey: .expectedCompletionTimeMinutes)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let percentDone = self.percentDone {
            try encodeContainer.encode(percentDone, forKey: .percentDone)
        }
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let restoreJobId = self.restoreJobId {
            try encodeContainer.encode(restoreJobId, forKey: .restoreJobId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let restoreJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreJobId)
        restoreJobId = restoreJobIdDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDate)
        completionDate = completionDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RestoreJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let expectedCompletionTimeMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expectedCompletionTimeMinutes)
        expectedCompletionTimeMinutes = expectedCompletionTimeMinutesDecoded
        let createdResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdResourceArn)
        createdResourceArn = createdResourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension BackupClientTypes {
    /// Contains metadata about a restore job.
    public struct RestoreJobsListMember: Swift.Equatable {
        /// The account ID that owns the restore job.
        public var accountId: Swift.String?
        /// The size, in bytes, of the restored resource.
        public var backupSizeInBytes: Swift.Int?
        /// The date and time a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: ClientRuntime.Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var createdResourceArn: Swift.String?
        /// The date and time a restore job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// The amount of time in minutes that a job restoring a recovery point is expected to take.
        public var expectedCompletionTimeMinutes: Swift.Int?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// Contains an estimated percentage complete of a job at the time the job status was queried.
        public var percentDone: Swift.String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// The resource type of the listed restore jobs; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?
        /// Uniquely identifies the job that restores a recovery point.
        public var restoreJobId: Swift.String?
        /// A status code specifying the state of the job initiated by Backup to restore a recovery point.
        public var status: BackupClientTypes.RestoreJobStatus?
        /// A detailed message explaining the status of the job to restore a recovery point.
        public var statusMessage: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            backupSizeInBytes: Swift.Int? = nil,
            completionDate: ClientRuntime.Date? = nil,
            createdResourceArn: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            expectedCompletionTimeMinutes: Swift.Int? = nil,
            iamRoleArn: Swift.String? = nil,
            percentDone: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            restoreJobId: Swift.String? = nil,
            status: BackupClientTypes.RestoreJobStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.backupSizeInBytes = backupSizeInBytes
            self.completionDate = completionDate
            self.createdResourceArn = createdResourceArn
            self.creationDate = creationDate
            self.expectedCompletionTimeMinutes = expectedCompletionTimeMinutes
            self.iamRoleArn = iamRoleArn
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.resourceType = resourceType
            self.restoreJobId = restoreJobId
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed due to a temporary failure of the server.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let type: Swift.String?
    let context: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension StartBackupJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartBackupJobInput(backupOptions: \(Swift.String(describing: backupOptions)), backupVaultName: \(Swift.String(describing: backupVaultName)), completeWindowMinutes: \(Swift.String(describing: completeWindowMinutes)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), lifecycle: \(Swift.String(describing: lifecycle)), resourceArn: \(Swift.String(describing: resourceArn)), startWindowMinutes: \(Swift.String(describing: startWindowMinutes)), recoveryPointTags: \"CONTENT_REDACTED\")"}
}

extension StartBackupJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupOptions = "BackupOptions"
        case backupVaultName = "BackupVaultName"
        case completeWindowMinutes = "CompleteWindowMinutes"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case resourceArn = "ResourceArn"
        case startWindowMinutes = "StartWindowMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupOptions = backupOptions {
            var backupOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupOptions)
            for (dictKey0, backupOptions0) in backupOptions {
                try backupOptionsContainer.encode(backupOptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let backupVaultName = self.backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let completeWindowMinutes = self.completeWindowMinutes {
            try encodeContainer.encode(completeWindowMinutes, forKey: .completeWindowMinutes)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointTags = recoveryPointTags {
            var recoveryPointTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .recoveryPointTags)
            for (dictKey0, tags0) in recoveryPointTags {
                try recoveryPointTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let startWindowMinutes = self.startWindowMinutes {
            try encodeContainer.encode(startWindowMinutes, forKey: .startWindowMinutes)
        }
    }
}

extension StartBackupJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backup-jobs"
    }
}

public struct StartBackupJobInput: Swift.Equatable {
    /// Specifies the backup option for a selected resource. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS""disabled" to create a regular backup. The WindowsVSS option is not enabled by default.
    public var backupOptions: [Swift.String:Swift.String]?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// A value in minutes during which a successfully started backup must complete, or else Backup will cancel the job. This value is optional. This value begins counting down from when the backup was scheduled. It does not add additional time for StartWindowMinutes, or if the backup started later than scheduled.
    public var completeWindowMinutes: Swift.Int?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartBackupJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup will transition and expire backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair.
    public var recoveryPointTags: [Swift.String:Swift.String]?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional, and the default is 8 hours. If this value is included, it must be at least 60 minutes to avoid errors.
    public var startWindowMinutes: Swift.Int?

    public init (
        backupOptions: [Swift.String:Swift.String]? = nil,
        backupVaultName: Swift.String? = nil,
        completeWindowMinutes: Swift.Int? = nil,
        iamRoleArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointTags: [Swift.String:Swift.String]? = nil,
        resourceArn: Swift.String? = nil,
        startWindowMinutes: Swift.Int? = nil
    )
    {
        self.backupOptions = backupOptions
        self.backupVaultName = backupVaultName
        self.completeWindowMinutes = completeWindowMinutes
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.lifecycle = lifecycle
        self.recoveryPointTags = recoveryPointTags
        self.resourceArn = resourceArn
        self.startWindowMinutes = startWindowMinutes
    }
}

struct StartBackupJobInputBody: Swift.Equatable {
    let backupVaultName: Swift.String?
    let resourceArn: Swift.String?
    let iamRoleArn: Swift.String?
    let idempotencyToken: Swift.String?
    let startWindowMinutes: Swift.Int?
    let completeWindowMinutes: Swift.Int?
    let lifecycle: BackupClientTypes.Lifecycle?
    let recoveryPointTags: [Swift.String:Swift.String]?
    let backupOptions: [Swift.String:Swift.String]?
}

extension StartBackupJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupOptions = "BackupOptions"
        case backupVaultName = "BackupVaultName"
        case completeWindowMinutes = "CompleteWindowMinutes"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case resourceArn = "ResourceArn"
        case startWindowMinutes = "StartWindowMinutes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let startWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startWindowMinutes)
        startWindowMinutes = startWindowMinutesDecoded
        let completeWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completeWindowMinutes)
        completeWindowMinutes = completeWindowMinutesDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let recoveryPointTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .recoveryPointTags)
        var recoveryPointTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let recoveryPointTagsContainer = recoveryPointTagsContainer {
            recoveryPointTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in recoveryPointTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    recoveryPointTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        recoveryPointTags = recoveryPointTagsDecoded0
        let backupOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
    }
}

extension StartBackupJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBackupJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartBackupJobOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBackupJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartBackupJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupJobId = output.backupJobId
            self.creationDate = output.creationDate
            self.isParent = output.isParent
            self.recoveryPointArn = output.recoveryPointArn
        } else {
            self.backupJobId = nil
            self.creationDate = nil
            self.isParent = false
            self.recoveryPointArn = nil
        }
    }
}

public struct StartBackupJobOutputResponse: Swift.Equatable {
    /// Uniquely identifies a request to Backup to back up a resource.
    public var backupJobId: Swift.String?
    /// The date and time that a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// This is a returned boolean value indicating this is a parent (composite) backup job.
    public var isParent: Swift.Bool
    /// Note: This field is only returned for Amazon EFS and Advanced DynamoDB resources. An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?

    public init (
        backupJobId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        isParent: Swift.Bool = false,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
        self.creationDate = creationDate
        self.isParent = isParent
        self.recoveryPointArn = recoveryPointArn
    }
}

struct StartBackupJobOutputResponseBody: Swift.Equatable {
    let backupJobId: Swift.String?
    let recoveryPointArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let isParent: Swift.Bool
}

extension StartBackupJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupJobId = "BackupJobId"
        case creationDate = "CreationDate"
        case isParent = "IsParent"
        case recoveryPointArn = "RecoveryPointArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupJobId)
        backupJobId = backupJobIdDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
    }
}

extension StartCopyJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
        case sourceBackupVaultName = "SourceBackupVaultName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationBackupVaultArn = self.destinationBackupVaultArn {
            try encodeContainer.encode(destinationBackupVaultArn, forKey: .destinationBackupVaultArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let sourceBackupVaultName = self.sourceBackupVaultName {
            try encodeContainer.encode(sourceBackupVaultName, forKey: .sourceBackupVaultName)
        }
    }
}

extension StartCopyJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/copy-jobs"
    }
}

public struct StartCopyJobInput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a destination backup vault to copy to; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    /// This member is required.
    public var destinationBackupVaultArn: Swift.String?
    /// Specifies the IAM role ARN used to copy the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartCopyJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// Contains an array of Transition objects specifying how long in days before a recovery point transitions to cold storage or is deleted. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// An ARN that uniquely identifies a recovery point to use for the copy job; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?
    /// The name of a logical source container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var sourceBackupVaultName: Swift.String?

    public init (
        destinationBackupVaultArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointArn: Swift.String? = nil,
        sourceBackupVaultName: Swift.String? = nil
    )
    {
        self.destinationBackupVaultArn = destinationBackupVaultArn
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
        self.sourceBackupVaultName = sourceBackupVaultName
    }
}

struct StartCopyJobInputBody: Swift.Equatable {
    let recoveryPointArn: Swift.String?
    let sourceBackupVaultName: Swift.String?
    let destinationBackupVaultArn: Swift.String?
    let iamRoleArn: Swift.String?
    let idempotencyToken: Swift.String?
    let lifecycle: BackupClientTypes.Lifecycle?
}

extension StartCopyJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
        case sourceBackupVaultName = "SourceBackupVaultName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let sourceBackupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupVaultName)
        sourceBackupVaultName = sourceBackupVaultNameDecoded
        let destinationBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationBackupVaultArn)
        destinationBackupVaultArn = destinationBackupVaultArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

extension StartCopyJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartCopyJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartCopyJobOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartCopyJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartCopyJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.copyJobId = output.copyJobId
            self.creationDate = output.creationDate
            self.isParent = output.isParent
        } else {
            self.copyJobId = nil
            self.creationDate = nil
            self.isParent = false
        }
    }
}

public struct StartCopyJobOutputResponse: Swift.Equatable {
    /// Uniquely identifies a copy job.
    public var copyJobId: Swift.String?
    /// The date and time that a copy job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// This is a returned boolean value indicating this is a parent (composite) copy job.
    public var isParent: Swift.Bool

    public init (
        copyJobId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        isParent: Swift.Bool = false
    )
    {
        self.copyJobId = copyJobId
        self.creationDate = creationDate
        self.isParent = isParent
    }
}

struct StartCopyJobOutputResponseBody: Swift.Equatable {
    let copyJobId: Swift.String?
    let creationDate: ClientRuntime.Date?
    let isParent: Swift.Bool
}

extension StartCopyJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyJobId = "CopyJobId"
        case creationDate = "CreationDate"
        case isParent = "IsParent"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .copyJobId)
        copyJobId = copyJobIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let isParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isParent) ?? false
        isParent = isParentDecoded
    }
}

extension StartReportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
    }
}

extension StartReportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportPlanName = reportPlanName else {
            return nil
        }
        return "/audit/report-jobs/\(reportPlanName.urlPercentEncoding())"
    }
}

public struct StartReportJobInput: Swift.Equatable {
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartReportJobInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// The unique name of a report plan.
    /// This member is required.
    public var reportPlanName: Swift.String?

    public init (
        idempotencyToken: Swift.String? = nil,
        reportPlanName: Swift.String? = nil
    )
    {
        self.idempotencyToken = idempotencyToken
        self.reportPlanName = reportPlanName
    }
}

struct StartReportJobInputBody: Swift.Equatable {
    let idempotencyToken: Swift.String?
}

extension StartReportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension StartReportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartReportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartReportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportJobId = output.reportJobId
        } else {
            self.reportJobId = nil
        }
    }
}

public struct StartReportJobOutputResponse: Swift.Equatable {
    /// The identifier of the report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. The report job ID cannot be edited.
    public var reportJobId: Swift.String?

    public init (
        reportJobId: Swift.String? = nil
    )
    {
        self.reportJobId = reportJobId
    }
}

struct StartReportJobOutputResponseBody: Swift.Equatable {
    let reportJobId: Swift.String?
}

extension StartReportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportJobId = "ReportJobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportJobId)
        reportJobId = reportJobIdDecoded
    }
}

extension StartRestoreJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartRestoreJobInput(iamRoleArn: \(Swift.String(describing: iamRoleArn)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), resourceType: \(Swift.String(describing: resourceType)), metadata: \"CONTENT_REDACTED\")"}
}

extension StartRestoreJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case metadata = "Metadata"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, metadata0) in metadata {
                try metadataContainer.encode(metadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension StartRestoreJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/restore-jobs"
    }
}

public struct StartRestoreJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM role that Backup uses to create the target resource; for example: arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartRestoreJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// A set of metadata key-value pairs. Contains information, such as a resource name, required to restore a recovery point. You can get configuration metadata about a resource at the time it was backed up by calling GetRecoveryPointRestoreMetadata. However, values in addition to those provided by GetRecoveryPointRestoreMetadata might be required to restore a resource. For example, you might need to provide a new resource name if the original already exists. You need to specify specific metadata to restore an Amazon Elastic File System (Amazon EFS) instance:
    ///
    /// * file-system-id: The ID of the Amazon EFS file system that is backed up by Backup. Returned in GetRecoveryPointRestoreMetadata.
    ///
    /// * Encrypted: A Boolean value that, if true, specifies that the file system is encrypted. If KmsKeyId is specified, Encrypted must be set to true.
    ///
    /// * KmsKeyId: Specifies the Amazon Web Services KMS key that is used to encrypt the restored file system. You can specify a key from another Amazon Web Services account provided that key it is properly shared with your account via Amazon Web Services KMS.
    ///
    /// * PerformanceMode: Specifies the throughput mode of the file system.
    ///
    /// * CreationToken: A user-supplied value that ensures the uniqueness (idempotency) of the request.
    ///
    /// * newFileSystem: A Boolean value that, if true, specifies that the recovery point is restored to a new Amazon EFS file system.
    ///
    /// * ItemsToRestore: An array of one to five strings where each string is a file path. Use ItemsToRestore to restore specific files or directories rather than the entire file system. This parameter is optional. For example, "itemsToRestore":"[\"/my.test\"]".
    /// This member is required.
    public var metadata: [Swift.String:Swift.String]?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?
    /// Starts a job to restore a recovery point for one of the following resources:
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * DocumentDB for Amazon DocumentDB (with MongoDB compatibility)
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * FSx for Amazon FSx
    ///
    /// * Neptune for Amazon Neptune
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Storage Gateway for Storage Gateway
    ///
    /// * S3 for Amazon S3
    ///
    /// * VirtualMachine for virtual machines
    public var resourceType: Swift.String?

    public init (
        iamRoleArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.metadata = metadata
        self.recoveryPointArn = recoveryPointArn
        self.resourceType = resourceType
    }
}

struct StartRestoreJobInputBody: Swift.Equatable {
    let recoveryPointArn: Swift.String?
    let metadata: [Swift.String:Swift.String]?
    let iamRoleArn: Swift.String?
    let idempotencyToken: Swift.String?
    let resourceType: Swift.String?
}

extension StartRestoreJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case metadata = "Metadata"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, metadatavalue0) in metadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    metadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        metadata = metadataDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension StartRestoreJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartRestoreJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartRestoreJobOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartRestoreJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartRestoreJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.restoreJobId = output.restoreJobId
        } else {
            self.restoreJobId = nil
        }
    }
}

public struct StartRestoreJobOutputResponse: Swift.Equatable {
    /// Uniquely identifies the job that restores a recovery point.
    public var restoreJobId: Swift.String?

    public init (
        restoreJobId: Swift.String? = nil
    )
    {
        self.restoreJobId = restoreJobId
    }
}

struct StartRestoreJobOutputResponseBody: Swift.Equatable {
    let restoreJobId: Swift.String?
}

extension StartRestoreJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case restoreJobId = "RestoreJobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restoreJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreJobId)
        restoreJobId = restoreJobIdDecoded
    }
}

extension StopBackupJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupJobId = backupJobId else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())"
    }
}

public struct StopBackupJobInput: Swift.Equatable {
    /// Uniquely identifies a request to Backup to back up a resource.
    /// This member is required.
    public var backupJobId: Swift.String?

    public init (
        backupJobId: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
    }
}

struct StopBackupJobInputBody: Swift.Equatable {
}

extension StopBackupJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopBackupJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopBackupJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopBackupJobOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopBackupJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopBackupJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension BackupClientTypes {
    public enum StorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cold
        case deleted
        case warm
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageClass] {
            return [
                .cold,
                .deleted,
                .warm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cold: return "COLD"
            case .deleted: return "DELETED"
            case .warm: return "WARM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the type of the tagged resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Key-value pairs that are used to help organize your resources. You can assign your own metadata to the resources you create. For clarity, this is the structure to assign tags: [{"Key":"string","Value":"string"}].
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeyList: \"CONTENT_REDACTED\")"}
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for string0 in tagKeyList {
                try tagKeyListContainer.encode(string0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/untag/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the type of the tagged resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys to identify which key-value tags to remove from a resource.
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeyList = tagKeyList
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let tagKeyList: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeyList = "TagKeyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[Swift.String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [Swift.String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateBackupPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlan = self.backupPlan {
            try encodeContainer.encode(backupPlan, forKey: .backupPlan)
        }
    }
}

extension UpdateBackupPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupPlanId = backupPlanId else {
            return nil
        }
        return "/backup/plans/\(backupPlanId.urlPercentEncoding())"
    }
}

public struct UpdateBackupPlanInput: Swift.Equatable {
    /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    /// This member is required.
    public var backupPlan: BackupClientTypes.BackupPlanInput?
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?

    public init (
        backupPlan: BackupClientTypes.BackupPlanInput? = nil,
        backupPlanId: Swift.String? = nil
    )
    {
        self.backupPlan = backupPlan
        self.backupPlanId = backupPlanId
    }
}

struct UpdateBackupPlanInputBody: Swift.Equatable {
    let backupPlan: BackupClientTypes.BackupPlanInput?
}

extension UpdateBackupPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlanInput.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
    }
}

extension UpdateBackupPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackupPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateBackupPlanOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackupPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateBackupPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedBackupSettings = output.advancedBackupSettings
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.versionId = output.versionId
        } else {
            self.advancedBackupSettings = nil
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.creationDate = nil
            self.versionId = nil
        }
    }
}

public struct UpdateBackupPlanOutputResponse: Swift.Equatable {
    /// Contains a list of BackupOptions for each resource type.
    public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version Ids cannot be edited.
    public var versionId: Swift.String?

    public init (
        advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.versionId = versionId
    }
}

struct UpdateBackupPlanOutputResponseBody: Swift.Equatable {
    let backupPlanId: Swift.String?
    let backupPlanArn: Swift.String?
    let creationDate: ClientRuntime.Date?
    let versionId: Swift.String?
    let advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
}

extension UpdateBackupPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension UpdateFrameworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case idempotencyToken = "IdempotencyToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameworkControls = frameworkControls {
            var frameworkControlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .frameworkControls)
            for frameworkcontrol0 in frameworkControls {
                try frameworkControlsContainer.encode(frameworkcontrol0)
            }
        }
        if let frameworkDescription = self.frameworkDescription {
            try encodeContainer.encode(frameworkDescription, forKey: .frameworkDescription)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
    }
}

extension UpdateFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let frameworkName = frameworkName else {
            return nil
        }
        return "/audit/frameworks/\(frameworkName.urlPercentEncoding())"
    }
}

public struct UpdateFrameworkInput: Swift.Equatable {
    /// A list of the controls that make up the framework. Each control in the list has a name, input parameters, and scope.
    public var frameworkControls: [BackupClientTypes.FrameworkControl]?
    /// An optional description of the framework with a maximum 1,024 characters.
    public var frameworkDescription: Swift.String?
    /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var frameworkName: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to UpdateFrameworkInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?

    public init (
        frameworkControls: [BackupClientTypes.FrameworkControl]? = nil,
        frameworkDescription: Swift.String? = nil,
        frameworkName: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil
    )
    {
        self.frameworkControls = frameworkControls
        self.frameworkDescription = frameworkDescription
        self.frameworkName = frameworkName
        self.idempotencyToken = idempotencyToken
    }
}

struct UpdateFrameworkInputBody: Swift.Equatable {
    let frameworkDescription: Swift.String?
    let frameworkControls: [BackupClientTypes.FrameworkControl]?
    let idempotencyToken: Swift.String?
}

extension UpdateFrameworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case idempotencyToken = "IdempotencyToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkDescription)
        frameworkDescription = frameworkDescriptionDecoded
        let frameworkControlsContainer = try containerValues.decodeIfPresent([BackupClientTypes.FrameworkControl?].self, forKey: .frameworkControls)
        var frameworkControlsDecoded0:[BackupClientTypes.FrameworkControl]? = nil
        if let frameworkControlsContainer = frameworkControlsContainer {
            frameworkControlsDecoded0 = [BackupClientTypes.FrameworkControl]()
            for structure0 in frameworkControlsContainer {
                if let structure0 = structure0 {
                    frameworkControlsDecoded0?.append(structure0)
                }
            }
        }
        frameworkControls = frameworkControlsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension UpdateFrameworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFrameworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFrameworkOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case conflictException(ConflictException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFrameworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateFrameworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.frameworkArn = output.frameworkArn
            self.frameworkName = output.frameworkName
        } else {
            self.creationTime = nil
            self.frameworkArn = nil
            self.frameworkName = nil
        }
    }
}

public struct UpdateFrameworkOutputResponse: Swift.Equatable {
    /// The date and time that a framework is created, in ISO 8601 representation. The value of CreationTime is accurate to milliseconds. For example, 2020-07-10T15:00:00.000-08:00 represents the 10th of July 2020 at 3:00 PM 8 hours behind UTC.
    public var creationTime: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var frameworkArn: Swift.String?
    /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    public var frameworkName: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        frameworkArn: Swift.String? = nil,
        frameworkName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.frameworkArn = frameworkArn
        self.frameworkName = frameworkName
    }
}

struct UpdateFrameworkOutputResponseBody: Swift.Equatable {
    let frameworkName: Swift.String?
    let frameworkArn: Swift.String?
    let creationTime: ClientRuntime.Date?
}

extension UpdateFrameworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case frameworkArn = "FrameworkArn"
        case frameworkName = "FrameworkName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkArn)
        frameworkArn = frameworkArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension UpdateGlobalSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalSettings = "GlobalSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let globalSettings = globalSettings {
            var globalSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .globalSettings)
            for (dictKey0, globalSettings0) in globalSettings {
                try globalSettingsContainer.encode(globalSettings0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateGlobalSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/global-settings"
    }
}

public struct UpdateGlobalSettingsInput: Swift.Equatable {
    /// A value for isCrossAccountBackupEnabled and a Region. Example: update-global-settings --global-settings isCrossAccountBackupEnabled=false --region us-west-2.
    public var globalSettings: [Swift.String:Swift.String]?

    public init (
        globalSettings: [Swift.String:Swift.String]? = nil
    )
    {
        self.globalSettings = globalSettings
    }
}

struct UpdateGlobalSettingsInputBody: Swift.Equatable {
    let globalSettings: [Swift.String:Swift.String]?
}

extension UpdateGlobalSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalSettings = "GlobalSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalSettingsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .globalSettings)
        var globalSettingsDecoded0: [Swift.String:Swift.String]? = nil
        if let globalSettingsContainer = globalSettingsContainer {
            globalSettingsDecoded0 = [Swift.String:Swift.String]()
            for (key0, globalsettingsvalue0) in globalSettingsContainer {
                if let globalsettingsvalue0 = globalsettingsvalue0 {
                    globalSettingsDecoded0?[key0] = globalsettingsvalue0
                }
            }
        }
        globalSettings = globalSettingsDecoded0
    }
}

extension UpdateGlobalSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGlobalSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGlobalSettingsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGlobalSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGlobalSettingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateRecoveryPointLifecycleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycle = "Lifecycle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
    }
}

extension UpdateRecoveryPointLifecycleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupVaultName = backupVaultName else {
            return nil
        }
        guard let recoveryPointArn = recoveryPointArn else {
            return nil
        }
        return "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())"
    }
}

public struct UpdateRecoveryPointLifecycleInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
    }
}

struct UpdateRecoveryPointLifecycleInputBody: Swift.Equatable {
    let lifecycle: BackupClientTypes.Lifecycle?
}

extension UpdateRecoveryPointLifecycleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycle = "Lifecycle"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

extension UpdateRecoveryPointLifecycleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRecoveryPointLifecycleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRecoveryPointLifecycleOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRecoveryPointLifecycleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateRecoveryPointLifecycleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.calculatedLifecycle = output.calculatedLifecycle
            self.lifecycle = output.lifecycle
            self.recoveryPointArn = output.recoveryPointArn
        } else {
            self.backupVaultArn = nil
            self.calculatedLifecycle = nil
            self.lifecycle = nil
            self.recoveryPointArn = nil
        }
    }
}

public struct UpdateRecoveryPointLifecycleOutputResponse: Swift.Equatable {
    /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
    public var calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that are able to be transitioned to cold storage are listed in the "Lifecycle to cold storage" section of the [ Feature availability by resource](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html#features-by-resource) table. Backup ignores this expression for other resource types.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?

    public init (
        backupVaultArn: Swift.String? = nil,
        calculatedLifecycle: BackupClientTypes.CalculatedLifecycle? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.calculatedLifecycle = calculatedLifecycle
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
    }
}

struct UpdateRecoveryPointLifecycleOutputResponseBody: Swift.Equatable {
    let backupVaultArn: Swift.String?
    let recoveryPointArn: Swift.String?
    let lifecycle: BackupClientTypes.Lifecycle?
    let calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
}

extension UpdateRecoveryPointLifecycleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case calculatedLifecycle = "CalculatedLifecycle"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let calculatedLifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CalculatedLifecycle.self, forKey: .calculatedLifecycle)
        calculatedLifecycle = calculatedLifecycleDecoded
    }
}

extension UpdateRegionSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTypeManagementPreference = "ResourceTypeManagementPreference"
        case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceTypeManagementPreference = resourceTypeManagementPreference {
            var resourceTypeManagementPreferenceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTypeManagementPreference)
            for (dictKey0, resourceTypeManagementPreference0) in resourceTypeManagementPreference {
                try resourceTypeManagementPreferenceContainer.encode(resourceTypeManagementPreference0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceTypeOptInPreference = resourceTypeOptInPreference {
            var resourceTypeOptInPreferenceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTypeOptInPreference)
            for (dictKey0, resourceTypeOptInPreference0) in resourceTypeOptInPreference {
                try resourceTypeOptInPreferenceContainer.encode(resourceTypeOptInPreference0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateRegionSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account-settings"
    }
}

public struct UpdateRegionSettingsInput: Swift.Equatable {
    /// Enables or disables full Backup management of backups for a resource type. To enable full Backup management for DynamoDB along with [ Backup's advanced DynamoDB backup features](https://docs.aws.amazon.com/aws-backup/latest/devguide/advanced-ddb-backup.html), follow the procedure to [ enable advanced DynamoDB backup programmatically](https://docs.aws.amazon.com/aws-backup/latest/devguide/advanced-ddb-backup.html#advanced-ddb-backup-enable-cli).
    public var resourceTypeManagementPreference: [Swift.String:Swift.Bool]?
    /// Updates the list of services along with the opt-in preferences for the Region.
    public var resourceTypeOptInPreference: [Swift.String:Swift.Bool]?

    public init (
        resourceTypeManagementPreference: [Swift.String:Swift.Bool]? = nil,
        resourceTypeOptInPreference: [Swift.String:Swift.Bool]? = nil
    )
    {
        self.resourceTypeManagementPreference = resourceTypeManagementPreference
        self.resourceTypeOptInPreference = resourceTypeOptInPreference
    }
}

struct UpdateRegionSettingsInputBody: Swift.Equatable {
    let resourceTypeOptInPreference: [Swift.String:Swift.Bool]?
    let resourceTypeManagementPreference: [Swift.String:Swift.Bool]?
}

extension UpdateRegionSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTypeManagementPreference = "ResourceTypeManagementPreference"
        case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeOptInPreferenceContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .resourceTypeOptInPreference)
        var resourceTypeOptInPreferenceDecoded0: [Swift.String:Swift.Bool]? = nil
        if let resourceTypeOptInPreferenceContainer = resourceTypeOptInPreferenceContainer {
            resourceTypeOptInPreferenceDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, isenabled0) in resourceTypeOptInPreferenceContainer {
                if let isenabled0 = isenabled0 {
                    resourceTypeOptInPreferenceDecoded0?[key0] = isenabled0
                }
            }
        }
        resourceTypeOptInPreference = resourceTypeOptInPreferenceDecoded0
        let resourceTypeManagementPreferenceContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .resourceTypeManagementPreference)
        var resourceTypeManagementPreferenceDecoded0: [Swift.String:Swift.Bool]? = nil
        if let resourceTypeManagementPreferenceContainer = resourceTypeManagementPreferenceContainer {
            resourceTypeManagementPreferenceDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, isenabled0) in resourceTypeManagementPreferenceContainer {
                if let isenabled0 = isenabled0 {
                    resourceTypeManagementPreferenceDecoded0?[key0] = isenabled0
                }
            }
        }
        resourceTypeManagementPreference = resourceTypeManagementPreferenceDecoded0
    }
}

extension UpdateRegionSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRegionSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRegionSettingsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRegionSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRegionSettingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateReportPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanDescription = "ReportPlanDescription"
        case reportSetting = "ReportSetting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let reportDeliveryChannel = self.reportDeliveryChannel {
            try encodeContainer.encode(reportDeliveryChannel, forKey: .reportDeliveryChannel)
        }
        if let reportPlanDescription = self.reportPlanDescription {
            try encodeContainer.encode(reportPlanDescription, forKey: .reportPlanDescription)
        }
        if let reportSetting = self.reportSetting {
            try encodeContainer.encode(reportSetting, forKey: .reportSetting)
        }
    }
}

extension UpdateReportPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportPlanName = reportPlanName else {
            return nil
        }
        return "/audit/report-plans/\(reportPlanName.urlPercentEncoding())"
    }
}

public struct UpdateReportPlanInput: Swift.Equatable {
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to UpdateReportPlanInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// A structure that contains information about where to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
    public var reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
    /// An optional description of the report plan with a maximum 1,024 characters.
    public var reportPlanDescription: Swift.String?
    /// The unique name of the report plan. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var reportPlanName: Swift.String?
    /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
    public var reportSetting: BackupClientTypes.ReportSetting?

    public init (
        idempotencyToken: Swift.String? = nil,
        reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel? = nil,
        reportPlanDescription: Swift.String? = nil,
        reportPlanName: Swift.String? = nil,
        reportSetting: BackupClientTypes.ReportSetting? = nil
    )
    {
        self.idempotencyToken = idempotencyToken
        self.reportDeliveryChannel = reportDeliveryChannel
        self.reportPlanDescription = reportPlanDescription
        self.reportPlanName = reportPlanName
        self.reportSetting = reportSetting
    }
}

struct UpdateReportPlanInputBody: Swift.Equatable {
    let reportPlanDescription: Swift.String?
    let reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
    let reportSetting: BackupClientTypes.ReportSetting?
    let idempotencyToken: Swift.String?
}

extension UpdateReportPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanDescription = "ReportPlanDescription"
        case reportSetting = "ReportSetting"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanDescription)
        reportPlanDescription = reportPlanDescriptionDecoded
        let reportDeliveryChannelDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportDeliveryChannel.self, forKey: .reportDeliveryChannel)
        reportDeliveryChannel = reportDeliveryChannelDecoded
        let reportSettingDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportSetting.self, forKey: .reportSetting)
        reportSetting = reportSettingDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension UpdateReportPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReportPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateReportPlanOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReportPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateReportPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.reportPlanArn = output.reportPlanArn
            self.reportPlanName = output.reportPlanName
        } else {
            self.creationTime = nil
            self.reportPlanArn = nil
            self.reportPlanName = nil
        }
    }
}

public struct UpdateReportPlanOutputResponse: Swift.Equatable {
    /// The date and time that a report plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationTime: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var reportPlanArn: Swift.String?
    /// The unique name of the report plan.
    public var reportPlanName: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        reportPlanArn: Swift.String? = nil,
        reportPlanName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.reportPlanArn = reportPlanArn
        self.reportPlanName = reportPlanName
    }
}

struct UpdateReportPlanOutputResponseBody: Swift.Equatable {
    let reportPlanName: Swift.String?
    let reportPlanArn: Swift.String?
    let creationTime: ClientRuntime.Date?
}

extension UpdateReportPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case reportPlanArn = "ReportPlanArn"
        case reportPlanName = "ReportPlanName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanName)
        reportPlanName = reportPlanNameDecoded
        let reportPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanArn)
        reportPlanArn = reportPlanArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}
