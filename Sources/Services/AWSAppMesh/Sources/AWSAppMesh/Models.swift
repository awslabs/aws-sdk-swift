//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

extension AppMeshClientTypes {
    /// An object that represents the key value pairs for the JSON.
    public struct JsonFormatRef {
        /// The specified key for the JSON.
        /// This member is required.
        public var key: Swift.String?
        /// The specified value for the JSON.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the format for the logs.
    public enum LoggingFormat {
        ///
        case text(Swift.String)
        ///
        case json([AppMeshClientTypes.JsonFormatRef])
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object that represents an access log file.
    public struct FileAccessLog {
        /// The specified format for the logs. The format is either json_format or text_format.
        public var format: AppMeshClientTypes.LoggingFormat?
        /// The file path to write access logs to. You can use /dev/stdout to send access logs to standard out and configure your Envoy container to use a log driver, such as awslogs, to export the access logs to a log storage service such as Amazon CloudWatch Logs. You can also specify a path in the Envoy container's file system to write the files to disk. The Envoy process must have write permissions to the path that you specify here. Otherwise, Envoy fails to bootstrap properly.
        /// This member is required.
        public var path: Swift.String?

        public init(
            format: AppMeshClientTypes.LoggingFormat? = nil,
            path: Swift.String? = nil
        )
        {
            self.format = format
            self.path = path
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the access logging information for a virtual node.
    public enum AccessLog {
        /// The file object to send virtual node access logs to.
        case file(AppMeshClientTypes.FileAccessLog)
        case sdkUnknown(Swift.String)
    }

}

/// The request syntax was malformed. Check your request syntax and try again.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You don't have permissions to perform this action.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request processing has failed because of an unknown error, exception, or failure.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource doesn't exist. Check your request syntax and try again.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request has failed due to a temporary failure of the service.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum request rate permitted by the App Mesh APIs has been exceeded for your account. For best results, use an increasing or variable sleep interval between requests.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ListTagsForResourceInput {
    /// The maximum number of tag results returned by ListTagsForResource in paginated output. When this parameter is used, ListTagsForResource returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListTagsForResource request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListTagsForResource returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The nextToken value returned from a previous paginated ListTagsForResource request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the resource to list the tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

extension AppMeshClientTypes {
    /// Optional metadata that you apply to a resource to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public struct TagRef {
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        /// This member is required.
        public var key: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

///
public struct ListTagsForResourceOutput {
    /// The nextToken value to include in a future ListTagsForResource request. When the results of a ListTagsForResource request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [AppMeshClientTypes.TagRef]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

/// The request contains a client token that was used for a previous update resource call with different specifications. Try the request again with a new client token.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have exceeded a service limit for your account. For more information, see [Service Limits](https://docs.aws.amazon.com/app-mesh/latest/userguide/service-quotas.html) in the App Mesh User Guide.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AppMeshClientTypes {

    public enum EgressFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowAll
        case dropAll
        case sdkUnknown(Swift.String)

        public static var allCases: [EgressFilterType] {
            return [
                .allowAll,
                .dropAll
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowAll: return "ALLOW_ALL"
            case .dropAll: return "DROP_ALL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents the egress filter rules for a service mesh.
    public struct EgressFilter {
        /// The egress filter type. By default, the type is DROP_ALL, which allows egress only from virtual nodes to other defined resources in the service mesh (and any traffic to *.amazonaws.com for Amazon Web Services API calls). You can set the egress filter type to ALLOW_ALL to allow egress to any endpoint inside or outside of the service mesh.
        /// This member is required.
        public var type: AppMeshClientTypes.EgressFilterType?

        public init(
            type: AppMeshClientTypes.EgressFilterType? = nil
        )
        {
            self.type = type
        }
    }

}

extension AppMeshClientTypes {

    public enum IpPreference: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ipv4Only
        case ipv4Preferred
        case ipv6Only
        case ipv6Preferred
        case sdkUnknown(Swift.String)

        public static var allCases: [IpPreference] {
            return [
                .ipv4Only,
                .ipv4Preferred,
                .ipv6Only,
                .ipv6Preferred
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ipv4Only: return "IPv4_ONLY"
            case .ipv4Preferred: return "IPv4_PREFERRED"
            case .ipv6Only: return "IPv6_ONLY"
            case .ipv6Preferred: return "IPv6_PREFERRED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents the service discovery information for a service mesh.
    public struct MeshServiceDiscovery {
        /// The IP version to use to control traffic within the mesh.
        public var ipPreference: AppMeshClientTypes.IpPreference?

        public init(
            ipPreference: AppMeshClientTypes.IpPreference? = nil
        )
        {
            self.ipPreference = ipPreference
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the specification of a service mesh.
    public struct MeshSpec {
        /// The egress filter rules for the service mesh.
        public var egressFilter: AppMeshClientTypes.EgressFilter?
        /// An object that represents the service discovery information for a service mesh.
        public var serviceDiscovery: AppMeshClientTypes.MeshServiceDiscovery?

        public init(
            egressFilter: AppMeshClientTypes.EgressFilter? = nil,
            serviceDiscovery: AppMeshClientTypes.MeshServiceDiscovery? = nil
        )
        {
            self.egressFilter = egressFilter
            self.serviceDiscovery = serviceDiscovery
        }
    }

}

///
public struct CreateMeshInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name to use for the service mesh.
    /// This member is required.
    public var meshName: Swift.String?
    /// The service mesh specification to apply.
    public var spec: AppMeshClientTypes.MeshSpec?
    /// Optional metadata that you can apply to the service mesh to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [AppMeshClientTypes.TagRef]?

    public init(
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        spec: AppMeshClientTypes.MeshSpec? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.spec = spec
        self.tags = tags
    }
}

extension AppMeshClientTypes {
    /// An object that represents metadata for a resource.
    public struct ResourceMetadata {
        /// The full Amazon Resource Name (ARN) for the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The unique identifier for the resource.
        /// This member is required.
        public var uid: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            uid: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.uid = uid
            self.version = version
        }
    }

}

extension AppMeshClientTypes {

    public enum MeshStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [MeshStatusCode] {
            return [
                .active,
                .deleted,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents the status of a service mesh.
    public struct MeshStatus {
        /// The current mesh status.
        public var status: AppMeshClientTypes.MeshStatusCode?

        public init(
            status: AppMeshClientTypes.MeshStatusCode? = nil
        )
        {
            self.status = status
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a service mesh returned by a describe operation.
    public struct MeshData {
        /// The name of the service mesh.
        /// This member is required.
        public var meshName: Swift.String?
        /// The associated metadata for the service mesh.
        /// This member is required.
        public var metadata: AppMeshClientTypes.ResourceMetadata?
        /// The associated specification for the service mesh.
        /// This member is required.
        public var spec: AppMeshClientTypes.MeshSpec?
        /// The status of the service mesh.
        /// This member is required.
        public var status: AppMeshClientTypes.MeshStatus?

        public init(
            meshName: Swift.String? = nil,
            metadata: AppMeshClientTypes.ResourceMetadata? = nil,
            spec: AppMeshClientTypes.MeshSpec? = nil,
            status: AppMeshClientTypes.MeshStatus? = nil
        )
        {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
        }
    }

}

///
public struct CreateMeshOutput {
    /// The full description of your service mesh following the create call.
    /// This member is required.
    public var mesh: AppMeshClientTypes.MeshData?

    public init(
        mesh: AppMeshClientTypes.MeshData? = nil
    )
    {
        self.mesh = mesh
    }
}

/// You can't delete the specified resource because it's in use or required by another resource.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct DeleteMeshInput {
    /// The name of the service mesh to delete.
    /// This member is required.
    public var meshName: Swift.String?

    public init(
        meshName: Swift.String? = nil
    )
    {
        self.meshName = meshName
    }
}

///
public struct DeleteMeshOutput {
    /// The service mesh that was deleted.
    /// This member is required.
    public var mesh: AppMeshClientTypes.MeshData?

    public init(
        mesh: AppMeshClientTypes.MeshData? = nil
    )
    {
        self.mesh = mesh
    }
}

///
public struct DescribeMeshInput {
    /// The name of the service mesh to describe.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?

    public init(
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
    }
}

///
public struct DescribeMeshOutput {
    /// The full description of your service mesh.
    /// This member is required.
    public var mesh: AppMeshClientTypes.MeshData?

    public init(
        mesh: AppMeshClientTypes.MeshData? = nil
    )
    {
        self.mesh = mesh
    }
}

///
public struct ListMeshesInput {
    /// The maximum number of results returned by ListMeshes in paginated output. When you use this parameter, ListMeshes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListMeshes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListMeshes returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The nextToken value returned from a previous paginated ListMeshes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This token should be treated as an opaque identifier that is used only to retrieve the next items in a list and not for other programmatic purposes.
    public var nextToken: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
    }
}

extension AppMeshClientTypes {
    /// An object that represents a service mesh returned by a list operation.
    public struct MeshRef {
        /// The full Amazon Resource Name (ARN) of the service mesh.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the service mesh.
        /// This member is required.
        public var meshName: Swift.String?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            meshName: Swift.String? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
        }
    }

}

///
public struct ListMeshesOutput {
    /// The list of existing service meshes.
    /// This member is required.
    public var meshes: [AppMeshClientTypes.MeshRef]?
    /// The nextToken value to include in a future ListMeshes request. When the results of a ListMeshes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        meshes: [AppMeshClientTypes.MeshRef]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.meshes = meshes
        self.nextToken = nextToken
    }
}

///
public struct UpdateMeshInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh to update.
    /// This member is required.
    public var meshName: Swift.String?
    /// The service mesh specification to apply.
    public var spec: AppMeshClientTypes.MeshSpec?

    public init(
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        spec: AppMeshClientTypes.MeshSpec? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.spec = spec
    }
}

///
public struct UpdateMeshOutput {
    /// An object that represents a service mesh returned by a describe operation.
    /// This member is required.
    public var mesh: AppMeshClientTypes.MeshData?

    public init(
        mesh: AppMeshClientTypes.MeshData? = nil
    )
    {
        self.mesh = mesh
    }
}

extension AppMeshClientTypes {
    /// An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see [Transport Layer Security (TLS)](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites).
    public struct VirtualGatewayListenerTlsFileCertificate {
        /// The certificate chain for the certificate.
        /// This member is required.
        public var certificateChain: Swift.String?
        /// The private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
        /// This member is required.
        public var privateKey: Swift.String?

        public init(
            certificateChain: Swift.String? = nil,
            privateKey: Swift.String? = nil
        )
        {
            self.certificateChain = certificateChain
            self.privateKey = privateKey
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the virtual gateway's listener's Secret Discovery Service certificate.The proxy must be configured with a local SDS provider via a Unix Domain Socket. See App Mesh[TLS documentation](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html) for more info.
    public struct VirtualGatewayListenerTlsSdsCertificate {
        /// A reference to an object that represents the name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
        /// This member is required.
        public var secretName: Swift.String?

        public init(
            secretName: Swift.String? = nil
        )
        {
            self.secretName = secretName
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the virtual gateway's client's Transport Layer Security (TLS) certificate.
    public enum VirtualGatewayClientTlsCertificate {
        /// An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see [ Transport Layer Security (TLS) ](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html).
        case file(AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate)
        /// A reference to an object that represents a virtual gateway's client's Secret Discovery Service certificate.
        case sds(AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object that represents the methods by which a subject alternative name on a peer Transport Layer Security (TLS) certificate can be matched.
    public struct SubjectAlternativeNameMatchers {
        /// The values sent must match the specified values exactly.
        /// This member is required.
        public var exact: [Swift.String]?

        public init(
            exact: [Swift.String]? = nil
        )
        {
            self.exact = exact
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the subject alternative names secured by the certificate.
    public struct SubjectAlternativeNames {
        /// An object that represents the criteria for determining a SANs match.
        /// This member is required.
        public var match: AppMeshClientTypes.SubjectAlternativeNameMatchers?

        public init(
            match: AppMeshClientTypes.SubjectAlternativeNameMatchers? = nil
        )
        {
            self.match = match
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) validation context trust for an Certificate Manager certificate.
    public struct VirtualGatewayTlsValidationContextAcmTrust {
        /// One or more ACM Amazon Resource Name (ARN)s.
        /// This member is required.
        public var certificateAuthorityArns: [Swift.String]?

        public init(
            certificateAuthorityArns: [Swift.String]? = nil
        )
        {
            self.certificateAuthorityArns = certificateAuthorityArns
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
    public struct VirtualGatewayTlsValidationContextFileTrust {
        /// The certificate trust chain for a certificate stored on the file system of the virtual node that the proxy is running on.
        /// This member is required.
        public var certificateChain: Swift.String?

        public init(
            certificateChain: Swift.String? = nil
        )
        {
            self.certificateChain = certificateChain
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a virtual gateway's listener's Transport Layer Security (TLS) Secret Discovery Service validation context trust. The proxy must be configured with a local SDS provider via a Unix Domain Socket. See App Mesh [TLS documentation](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html) for more info.
    public struct VirtualGatewayTlsValidationContextSdsTrust {
        /// A reference to an object that represents the name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        /// This member is required.
        public var secretName: Swift.String?

        public init(
            secretName: Swift.String? = nil
        )
        {
            self.secretName = secretName
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) validation context trust.
    public enum VirtualGatewayTlsValidationContextTrust {
        /// A reference to an object that represents a Transport Layer Security (TLS) validation context trust for an Certificate Manager certificate.
        case acm(AppMeshClientTypes.VirtualGatewayTlsValidationContextAcmTrust)
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        case file(AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust)
        /// A reference to an object that represents a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        case sds(AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) validation context.
    public struct VirtualGatewayTlsValidationContext {
        /// A reference to an object that represents the SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        public var subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS) certificate.
        /// This member is required.
        public var trust: AppMeshClientTypes.VirtualGatewayTlsValidationContextTrust?

        public init(
            subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames? = nil,
            trust: AppMeshClientTypes.VirtualGatewayTlsValidationContextTrust? = nil
        )
        {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) client policy.
    public struct VirtualGatewayClientPolicyTls {
        /// A reference to an object that represents a virtual gateway's client's Transport Layer Security (TLS) certificate.
        public var certificate: AppMeshClientTypes.VirtualGatewayClientTlsCertificate?
        /// Whether the policy is enforced. The default is True, if a value isn't specified.
        public var enforce: Swift.Bool?
        /// One or more ports that the policy is enforced for.
        public var ports: [Swift.Int]?
        /// A reference to an object that represents a Transport Layer Security (TLS) validation context.
        /// This member is required.
        public var validation: AppMeshClientTypes.VirtualGatewayTlsValidationContext?

        public init(
            certificate: AppMeshClientTypes.VirtualGatewayClientTlsCertificate? = nil,
            enforce: Swift.Bool? = nil,
            ports: [Swift.Int]? = nil,
            validation: AppMeshClientTypes.VirtualGatewayTlsValidationContext? = nil
        )
        {
            self.certificate = certificate
            self.enforce = enforce
            self.ports = ports
            self.validation = validation
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a client policy.
    public struct VirtualGatewayClientPolicy {
        /// A reference to an object that represents a Transport Layer Security (TLS) client policy.
        public var tls: AppMeshClientTypes.VirtualGatewayClientPolicyTls?

        public init(
            tls: AppMeshClientTypes.VirtualGatewayClientPolicyTls? = nil
        )
        {
            self.tls = tls
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the default properties for a backend.
    public struct VirtualGatewayBackendDefaults {
        /// A reference to an object that represents a client policy.
        public var clientPolicy: AppMeshClientTypes.VirtualGatewayClientPolicy?

        public init(
            clientPolicy: AppMeshClientTypes.VirtualGatewayClientPolicy? = nil
        )
        {
            self.clientPolicy = clientPolicy
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a type of connection pool.
    public struct VirtualGatewayGrpcConnectionPool {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        /// This member is required.
        public var maxRequests: Swift.Int?

        public init(
            maxRequests: Swift.Int? = nil
        )
        {
            self.maxRequests = maxRequests
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a type of connection pool.
    public struct VirtualGatewayHttpConnectionPool {
        /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.
        /// This member is required.
        public var maxConnections: Swift.Int?
        /// Number of overflowing requests after max_connections Envoy will queue to upstream cluster.
        public var maxPendingRequests: Swift.Int?

        public init(
            maxConnections: Swift.Int? = nil,
            maxPendingRequests: Swift.Int? = nil
        )
        {
            self.maxConnections = maxConnections
            self.maxPendingRequests = maxPendingRequests
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a type of connection pool.
    public struct VirtualGatewayHttp2ConnectionPool {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        /// This member is required.
        public var maxRequests: Swift.Int?

        public init(
            maxRequests: Swift.Int? = nil
        )
        {
            self.maxRequests = maxRequests
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the type of virtual gateway connection pool. Only one protocol is used at a time and should be the same protocol as the one chosen under port mapping. If not present the default value for maxPendingRequests is 2147483647.
    public enum VirtualGatewayConnectionPool {
        /// An object that represents a type of connection pool.
        case http(AppMeshClientTypes.VirtualGatewayHttpConnectionPool)
        /// An object that represents a type of connection pool.
        case http2(AppMeshClientTypes.VirtualGatewayHttp2ConnectionPool)
        /// An object that represents a type of connection pool.
        case grpc(AppMeshClientTypes.VirtualGatewayGrpcConnectionPool)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {

    public enum VirtualGatewayPortProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case grpc
        case http
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualGatewayPortProtocol] {
            return [
                .grpc,
                .http,
                .http2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .grpc: return "grpc"
            case .http: return "http"
            case .http2: return "http2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents the health check policy for a virtual gateway's listener.
    public struct VirtualGatewayHealthCheckPolicy {
        /// The number of consecutive successful health checks that must occur before declaring the listener healthy.
        /// This member is required.
        public var healthyThreshold: Swift.Int?
        /// The time period in milliseconds between each health check execution.
        /// This member is required.
        public var intervalMillis: Swift.Int?
        /// The destination path for the health check request. This value is only used if the specified protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.
        public var path: Swift.String?
        /// The destination port for the health check request. This port must match the port defined in the [PortMapping] for the listener.
        public var port: Swift.Int?
        /// The protocol for the health check request. If you specify grpc, then your service must conform to the [GRPC Health Checking Protocol](https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
        /// This member is required.
        public var `protocol`: AppMeshClientTypes.VirtualGatewayPortProtocol?
        /// The amount of time to wait when receiving a response from the health check, in milliseconds.
        /// This member is required.
        public var timeoutMillis: Swift.Int?
        /// The number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
        /// This member is required.
        public var unhealthyThreshold: Swift.Int?

        public init(
            healthyThreshold: Swift.Int? = nil,
            intervalMillis: Swift.Int? = nil,
            path: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: AppMeshClientTypes.VirtualGatewayPortProtocol? = nil,
            timeoutMillis: Swift.Int? = nil,
            unhealthyThreshold: Swift.Int? = nil
        )
        {
            self.healthyThreshold = healthyThreshold
            self.intervalMillis = intervalMillis
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.timeoutMillis = timeoutMillis
            self.unhealthyThreshold = unhealthyThreshold
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a port mapping.
    public struct VirtualGatewayPortMapping {
        /// The port used for the port mapping. Specify one protocol.
        /// This member is required.
        public var port: Swift.Int?
        /// The protocol used for the port mapping.
        /// This member is required.
        public var `protocol`: AppMeshClientTypes.VirtualGatewayPortProtocol?

        public init(
            port: Swift.Int? = nil,
            `protocol`: AppMeshClientTypes.VirtualGatewayPortProtocol? = nil
        )
        {
            self.port = port
            self.`protocol` = `protocol`
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents an Certificate Manager certificate.
    public struct VirtualGatewayListenerTlsAcmCertificate {
        /// The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see [Transport Layer Security (TLS)](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites).
        /// This member is required.
        public var certificateArn: Swift.String?

        public init(
            certificateArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a listener's Transport Layer Security (TLS) certificate.
    public enum VirtualGatewayListenerTlsCertificate {
        /// A reference to an object that represents an Certificate Manager certificate.
        case acm(AppMeshClientTypes.VirtualGatewayListenerTlsAcmCertificate)
        /// A reference to an object that represents a local file certificate.
        case file(AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate)
        /// A reference to an object that represents a virtual gateway's listener's Secret Discovery Service certificate.
        case sds(AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {

    public enum VirtualGatewayListenerTlsMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case permissive
        case strict
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualGatewayListenerTlsMode] {
            return [
                .disabled,
                .permissive,
                .strict
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .permissive: return "PERMISSIVE"
            case .strict: return "STRICT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual gateway's listener's Transport Layer Security (TLS) validation context trust.
    public enum VirtualGatewayListenerTlsValidationContextTrust {
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        case file(AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust)
        /// A reference to an object that represents a virtual gateway's listener's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        case sds(AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object that represents a virtual gateway's listener's Transport Layer Security (TLS) validation context.
    public struct VirtualGatewayListenerTlsValidationContext {
        /// A reference to an object that represents the SANs for a virtual gateway listener's Transport Layer Security (TLS) validation context.
        public var subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS) certificate.
        /// This member is required.
        public var trust: AppMeshClientTypes.VirtualGatewayListenerTlsValidationContextTrust?

        public init(
            subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames? = nil,
            trust: AppMeshClientTypes.VirtualGatewayListenerTlsValidationContextTrust? = nil
        )
        {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the Transport Layer Security (TLS) properties for a listener.
    public struct VirtualGatewayListenerTls {
        /// An object that represents a Transport Layer Security (TLS) certificate.
        /// This member is required.
        public var certificate: AppMeshClientTypes.VirtualGatewayListenerTlsCertificate?
        /// Specify one of the following modes.
        ///
        /// * STRICT – Listener only accepts connections with TLS enabled.
        ///
        /// * PERMISSIVE – Listener accepts connections with or without TLS enabled.
        ///
        /// * DISABLED – Listener only accepts connections without TLS.
        /// This member is required.
        public var mode: AppMeshClientTypes.VirtualGatewayListenerTlsMode?
        /// A reference to an object that represents a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        public var validation: AppMeshClientTypes.VirtualGatewayListenerTlsValidationContext?

        public init(
            certificate: AppMeshClientTypes.VirtualGatewayListenerTlsCertificate? = nil,
            mode: AppMeshClientTypes.VirtualGatewayListenerTlsMode? = nil,
            validation: AppMeshClientTypes.VirtualGatewayListenerTlsValidationContext? = nil
        )
        {
            self.certificate = certificate
            self.mode = mode
            self.validation = validation
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a listener for a virtual gateway.
    public struct VirtualGatewayListener {
        /// The connection pool information for the virtual gateway listener.
        public var connectionPool: AppMeshClientTypes.VirtualGatewayConnectionPool?
        /// The health check information for the listener.
        public var healthCheck: AppMeshClientTypes.VirtualGatewayHealthCheckPolicy?
        /// The port mapping information for the listener.
        /// This member is required.
        public var portMapping: AppMeshClientTypes.VirtualGatewayPortMapping?
        /// A reference to an object that represents the Transport Layer Security (TLS) properties for the listener.
        public var tls: AppMeshClientTypes.VirtualGatewayListenerTls?

        public init(
            connectionPool: AppMeshClientTypes.VirtualGatewayConnectionPool? = nil,
            healthCheck: AppMeshClientTypes.VirtualGatewayHealthCheckPolicy? = nil,
            portMapping: AppMeshClientTypes.VirtualGatewayPortMapping? = nil,
            tls: AppMeshClientTypes.VirtualGatewayListenerTls? = nil
        )
        {
            self.connectionPool = connectionPool
            self.healthCheck = healthCheck
            self.portMapping = portMapping
            self.tls = tls
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents an access log file.
    public struct VirtualGatewayFileAccessLog {
        /// The specified format for the virtual gateway access logs. It can be either json_format or text_format.
        public var format: AppMeshClientTypes.LoggingFormat?
        /// The file path to write access logs to. You can use /dev/stdout to send access logs to standard out and configure your Envoy container to use a log driver, such as awslogs, to export the access logs to a log storage service such as Amazon CloudWatch Logs. You can also specify a path in the Envoy container's file system to write the files to disk.
        /// This member is required.
        public var path: Swift.String?

        public init(
            format: AppMeshClientTypes.LoggingFormat? = nil,
            path: Swift.String? = nil
        )
        {
            self.format = format
            self.path = path
        }
    }

}

extension AppMeshClientTypes {
    /// The access log configuration for a virtual gateway.
    public enum VirtualGatewayAccessLog {
        /// The file object to send virtual gateway access logs to.
        case file(AppMeshClientTypes.VirtualGatewayFileAccessLog)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object that represents logging information.
    public struct VirtualGatewayLogging {
        /// The access log configuration.
        public var accessLog: AppMeshClientTypes.VirtualGatewayAccessLog?

        public init(
            accessLog: AppMeshClientTypes.VirtualGatewayAccessLog? = nil
        )
        {
            self.accessLog = accessLog
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the specification of a service mesh resource.
    public struct VirtualGatewaySpec {
        /// A reference to an object that represents the defaults for backends.
        public var backendDefaults: AppMeshClientTypes.VirtualGatewayBackendDefaults?
        /// The listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
        /// This member is required.
        public var listeners: [AppMeshClientTypes.VirtualGatewayListener]?
        /// An object that represents logging information.
        public var logging: AppMeshClientTypes.VirtualGatewayLogging?

        public init(
            backendDefaults: AppMeshClientTypes.VirtualGatewayBackendDefaults? = nil,
            listeners: [AppMeshClientTypes.VirtualGatewayListener]? = nil,
            logging: AppMeshClientTypes.VirtualGatewayLogging? = nil
        )
        {
            self.backendDefaults = backendDefaults
            self.listeners = listeners
            self.logging = logging
        }
    }

}

public struct CreateVirtualGatewayInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh to create the virtual gateway in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The virtual gateway specification to apply.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualGatewaySpec?
    /// Optional metadata that you can apply to the virtual gateway to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [AppMeshClientTypes.TagRef]?
    /// The name to use for the virtual gateway.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualGatewaySpec? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualGatewayName = virtualGatewayName
    }
}

extension AppMeshClientTypes {

    public enum VirtualGatewayStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualGatewayStatusCode] {
            return [
                .active,
                .deleted,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents the status of the mesh resource.
    public struct VirtualGatewayStatus {
        /// The current status.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualGatewayStatusCode?

        public init(
            status: AppMeshClientTypes.VirtualGatewayStatusCode? = nil
        )
        {
            self.status = status
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a virtual gateway returned by a describe operation.
    public struct VirtualGatewayData {
        /// The name of the service mesh that the virtual gateway resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// An object that represents metadata for a resource.
        /// This member is required.
        public var metadata: AppMeshClientTypes.ResourceMetadata?
        /// The specifications of the virtual gateway.
        /// This member is required.
        public var spec: AppMeshClientTypes.VirtualGatewaySpec?
        /// The current status of the virtual gateway.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualGatewayStatus?
        /// The name of the virtual gateway.
        /// This member is required.
        public var virtualGatewayName: Swift.String?

        public init(
            meshName: Swift.String? = nil,
            metadata: AppMeshClientTypes.ResourceMetadata? = nil,
            spec: AppMeshClientTypes.VirtualGatewaySpec? = nil,
            status: AppMeshClientTypes.VirtualGatewayStatus? = nil,
            virtualGatewayName: Swift.String? = nil
        )
        {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualGatewayName = virtualGatewayName
        }
    }

}

public struct CreateVirtualGatewayOutput {
    /// The full description of your virtual gateway following the create call.
    /// This member is required.
    public var virtualGateway: AppMeshClientTypes.VirtualGatewayData?

    public init(
        virtualGateway: AppMeshClientTypes.VirtualGatewayData? = nil
    )
    {
        self.virtualGateway = virtualGateway
    }
}

public struct DeleteVirtualGatewayInput {
    /// The name of the service mesh to delete the virtual gateway from.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual gateway to delete.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init(
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualGatewayName = virtualGatewayName
    }
}

public struct DeleteVirtualGatewayOutput {
    /// The virtual gateway that was deleted.
    /// This member is required.
    public var virtualGateway: AppMeshClientTypes.VirtualGatewayData?

    public init(
        virtualGateway: AppMeshClientTypes.VirtualGatewayData? = nil
    )
    {
        self.virtualGateway = virtualGateway
    }
}

public struct DescribeVirtualGatewayInput {
    /// The name of the service mesh that the gateway route resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual gateway to describe.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init(
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualGatewayName = virtualGatewayName
    }
}

public struct DescribeVirtualGatewayOutput {
    /// The full description of your virtual gateway.
    /// This member is required.
    public var virtualGateway: AppMeshClientTypes.VirtualGatewayData?

    public init(
        virtualGateway: AppMeshClientTypes.VirtualGatewayData? = nil
    )
    {
        self.virtualGateway = virtualGateway
    }
}

extension AppMeshClientTypes {

    public enum DefaultGatewayRouteRewrite: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DefaultGatewayRouteRewrite] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object representing the gateway route host name to rewrite.
    public struct GatewayRouteHostnameRewrite {
        /// The default target host name to write to.
        public var defaultTargetHostname: AppMeshClientTypes.DefaultGatewayRouteRewrite?

        public init(
            defaultTargetHostname: AppMeshClientTypes.DefaultGatewayRouteRewrite? = nil
        )
        {
            self.defaultTargetHostname = defaultTargetHostname
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the gateway route to rewrite.
    public struct GrpcGatewayRouteRewrite {
        /// The host name of the gateway route to rewrite.
        public var hostname: AppMeshClientTypes.GatewayRouteHostnameRewrite?

        public init(
            hostname: AppMeshClientTypes.GatewayRouteHostnameRewrite? = nil
        )
        {
            self.hostname = hostname
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the virtual service that traffic is routed to.
    public struct GatewayRouteVirtualService {
        /// The name of the virtual service that traffic is routed to.
        /// This member is required.
        public var virtualServiceName: Swift.String?

        public init(
            virtualServiceName: Swift.String? = nil
        )
        {
            self.virtualServiceName = virtualServiceName
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a gateway route target.
    public struct GatewayRouteTarget {
        /// The port number of the gateway route target.
        public var port: Swift.Int?
        /// An object that represents a virtual service gateway route target.
        /// This member is required.
        public var virtualService: AppMeshClientTypes.GatewayRouteVirtualService?

        public init(
            port: Swift.Int? = nil,
            virtualService: AppMeshClientTypes.GatewayRouteVirtualService? = nil
        )
        {
            self.port = port
            self.virtualService = virtualService
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the action to take if a match is determined.
    public struct GrpcGatewayRouteAction {
        /// The gateway route action to rewrite.
        public var rewrite: AppMeshClientTypes.GrpcGatewayRouteRewrite?
        /// An object that represents the target that traffic is routed to when a request matches the gateway route.
        /// This member is required.
        public var target: AppMeshClientTypes.GatewayRouteTarget?

        public init(
            rewrite: AppMeshClientTypes.GrpcGatewayRouteRewrite? = nil,
            target: AppMeshClientTypes.GatewayRouteTarget? = nil
        )
        {
            self.rewrite = rewrite
            self.target = target
        }
    }

}

extension AppMeshClientTypes {
    /// An object representing the gateway route host name to match.
    public struct GatewayRouteHostnameMatch {
        /// The exact host name to match on.
        public var exact: Swift.String?
        /// The specified ending characters of the host name to match on.
        public var suffix: Swift.String?

        public init(
            exact: Swift.String? = nil,
            suffix: Swift.String? = nil
        )
        {
            self.exact = exact
            self.suffix = suffix
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the range of values to match on. The first character of the range is included in the range, though the last character is not. For example, if the range specified were 1-100, only values 1-99 would be matched.
    public struct MatchRange {
        /// The end of the range.
        /// This member is required.
        public var end: Swift.Int?
        /// The start of the range.
        /// This member is required.
        public var start: Swift.Int?

        public init(
            end: Swift.Int? = nil,
            start: Swift.Int? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension AppMeshClientTypes {
    /// An object representing the method header to be matched.
    public enum GrpcMetadataMatchMethod {
        /// The exact method header to be matched on.
        case exact(Swift.String)
        /// The regex used to match the method header.
        case regex(Swift.String)
        /// An object that represents the range of values to match on. The first character of the range is included in the range, though the last character is not. For example, if the range specified were 1-100, only values 1-99 would be matched.
        case range(AppMeshClientTypes.MatchRange)
        /// The specified beginning characters of the method header to be matched on.
        case `prefix`(Swift.String)
        /// The specified ending characters of the method header to match on.
        case suffix(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object representing the metadata of the gateway route.
    public struct GrpcGatewayRouteMetadata {
        /// Specify True to match anything except the match criteria. The default value is False.
        public var invert: Swift.Bool?
        /// The criteria for determining a metadata match.
        public var match: AppMeshClientTypes.GrpcMetadataMatchMethod?
        /// A name for the gateway route metadata.
        /// This member is required.
        public var name: Swift.String?

        public init(
            invert: Swift.Bool? = nil,
            match: AppMeshClientTypes.GrpcMetadataMatchMethod? = nil,
            name: Swift.String? = nil
        )
        {
            self.invert = invert
            self.match = match
            self.name = name
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the criteria for determining a request match.
    public struct GrpcGatewayRouteMatch {
        /// The gateway route host name to be matched on.
        public var hostname: AppMeshClientTypes.GatewayRouteHostnameMatch?
        /// The gateway route metadata to be matched on.
        public var metadata: [AppMeshClientTypes.GrpcGatewayRouteMetadata]?
        /// The gateway route port to be matched on.
        public var port: Swift.Int?
        /// The fully qualified domain name for the service to match from the request.
        public var serviceName: Swift.String?

        public init(
            hostname: AppMeshClientTypes.GatewayRouteHostnameMatch? = nil,
            metadata: [AppMeshClientTypes.GrpcGatewayRouteMetadata]? = nil,
            port: Swift.Int? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.hostname = hostname
            self.metadata = metadata
            self.port = port
            self.serviceName = serviceName
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a gRPC gateway route.
    public struct GrpcGatewayRoute {
        /// An object that represents the action to take if a match is determined.
        /// This member is required.
        public var action: AppMeshClientTypes.GrpcGatewayRouteAction?
        /// An object that represents the criteria for determining a request match.
        /// This member is required.
        public var match: AppMeshClientTypes.GrpcGatewayRouteMatch?

        public init(
            action: AppMeshClientTypes.GrpcGatewayRouteAction? = nil,
            match: AppMeshClientTypes.GrpcGatewayRouteMatch? = nil
        )
        {
            self.action = action
            self.match = match
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the path to rewrite.
    public struct HttpGatewayRoutePathRewrite {
        /// The exact path to rewrite.
        public var exact: Swift.String?

        public init(
            exact: Swift.String? = nil
        )
        {
            self.exact = exact
        }
    }

}

extension AppMeshClientTypes {
    /// An object representing the beginning characters of the route to rewrite.
    public struct HttpGatewayRoutePrefixRewrite {
        /// The default prefix used to replace the incoming route prefix when rewritten.
        public var defaultPrefix: AppMeshClientTypes.DefaultGatewayRouteRewrite?
        /// The value used to replace the incoming route prefix when rewritten.
        public var value: Swift.String?

        public init(
            defaultPrefix: AppMeshClientTypes.DefaultGatewayRouteRewrite? = nil,
            value: Swift.String? = nil
        )
        {
            self.defaultPrefix = defaultPrefix
            self.value = value
        }
    }

}

extension AppMeshClientTypes {
    /// An object representing the gateway route to rewrite.
    public struct HttpGatewayRouteRewrite {
        /// The host name to rewrite.
        public var hostname: AppMeshClientTypes.GatewayRouteHostnameRewrite?
        /// The path to rewrite.
        public var path: AppMeshClientTypes.HttpGatewayRoutePathRewrite?
        /// The specified beginning characters to rewrite.
        public var `prefix`: AppMeshClientTypes.HttpGatewayRoutePrefixRewrite?

        public init(
            hostname: AppMeshClientTypes.GatewayRouteHostnameRewrite? = nil,
            path: AppMeshClientTypes.HttpGatewayRoutePathRewrite? = nil,
            `prefix`: AppMeshClientTypes.HttpGatewayRoutePrefixRewrite? = nil
        )
        {
            self.hostname = hostname
            self.path = path
            self.`prefix` = `prefix`
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the action to take if a match is determined.
    public struct HttpGatewayRouteAction {
        /// The gateway route action to rewrite.
        public var rewrite: AppMeshClientTypes.HttpGatewayRouteRewrite?
        /// An object that represents the target that traffic is routed to when a request matches the gateway route.
        /// This member is required.
        public var target: AppMeshClientTypes.GatewayRouteTarget?

        public init(
            rewrite: AppMeshClientTypes.HttpGatewayRouteRewrite? = nil,
            target: AppMeshClientTypes.GatewayRouteTarget? = nil
        )
        {
            self.rewrite = rewrite
            self.target = target
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the method and value to match with the header value sent in a request. Specify one match method.
    public enum HeaderMatchMethod {
        /// The value sent by the client must match the specified value exactly.
        case exact(Swift.String)
        /// The value sent by the client must include the specified characters.
        case regex(Swift.String)
        /// An object that represents the range of values to match on.
        case range(AppMeshClientTypes.MatchRange)
        /// The value sent by the client must begin with the specified characters.
        case `prefix`(Swift.String)
        /// The value sent by the client must end with the specified characters.
        case suffix(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object that represents the HTTP header in the gateway route.
    public struct HttpGatewayRouteHeader {
        /// Specify True to match anything except the match criteria. The default value is False.
        public var invert: Swift.Bool?
        /// An object that represents the method and value to match with the header value sent in a request. Specify one match method.
        public var match: AppMeshClientTypes.HeaderMatchMethod?
        /// A name for the HTTP header in the gateway route that will be matched on.
        /// This member is required.
        public var name: Swift.String?

        public init(
            invert: Swift.Bool? = nil,
            match: AppMeshClientTypes.HeaderMatchMethod? = nil,
            name: Swift.String? = nil
        )
        {
            self.invert = invert
            self.match = match
            self.name = name
        }
    }

}

extension AppMeshClientTypes {

    public enum HttpMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connect
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case trace
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpMethod] {
            return [
                .connect,
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put,
                .trace
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connect: return "CONNECT"
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case .trace: return "TRACE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object representing the path to match in the request.
    public struct HttpPathMatch {
        /// The exact path to match on.
        public var exact: Swift.String?
        /// The regex used to match the path.
        public var regex: Swift.String?

        public init(
            exact: Swift.String? = nil,
            regex: Swift.String? = nil
        )
        {
            self.exact = exact
            self.regex = regex
        }
    }

}

extension AppMeshClientTypes {
    /// An object representing the query parameter to match.
    public struct QueryParameterMatch {
        /// The exact query parameter to match on.
        public var exact: Swift.String?

        public init(
            exact: Swift.String? = nil
        )
        {
            self.exact = exact
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the query parameter in the request.
    public struct HttpQueryParameter {
        /// The query parameter to match on.
        public var match: AppMeshClientTypes.QueryParameterMatch?
        /// A name for the query parameter that will be matched on.
        /// This member is required.
        public var name: Swift.String?

        public init(
            match: AppMeshClientTypes.QueryParameterMatch? = nil,
            name: Swift.String? = nil
        )
        {
            self.match = match
            self.name = name
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the criteria for determining a request match.
    public struct HttpGatewayRouteMatch {
        /// The client request headers to match on.
        public var headers: [AppMeshClientTypes.HttpGatewayRouteHeader]?
        /// The host name to match on.
        public var hostname: AppMeshClientTypes.GatewayRouteHostnameMatch?
        /// The method to match on.
        public var method: AppMeshClientTypes.HttpMethod?
        /// The path to match on.
        public var path: AppMeshClientTypes.HttpPathMatch?
        /// The port number to match on.
        public var port: Swift.Int?
        /// Specifies the path to match requests with. This parameter must always start with /, which by itself matches all requests to the virtual service name. You can also match for path-based routing of requests. For example, if your virtual service name is my-service.local and you want the route to match requests to my-service.local/metrics, your prefix should be /metrics.
        public var `prefix`: Swift.String?
        /// The query parameter to match on.
        public var queryParameters: [AppMeshClientTypes.HttpQueryParameter]?

        public init(
            headers: [AppMeshClientTypes.HttpGatewayRouteHeader]? = nil,
            hostname: AppMeshClientTypes.GatewayRouteHostnameMatch? = nil,
            method: AppMeshClientTypes.HttpMethod? = nil,
            path: AppMeshClientTypes.HttpPathMatch? = nil,
            port: Swift.Int? = nil,
            `prefix`: Swift.String? = nil,
            queryParameters: [AppMeshClientTypes.HttpQueryParameter]? = nil
        )
        {
            self.headers = headers
            self.hostname = hostname
            self.method = method
            self.path = path
            self.port = port
            self.`prefix` = `prefix`
            self.queryParameters = queryParameters
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents an HTTP gateway route.
    public struct HttpGatewayRoute {
        /// An object that represents the action to take if a match is determined.
        /// This member is required.
        public var action: AppMeshClientTypes.HttpGatewayRouteAction?
        /// An object that represents the criteria for determining a request match.
        /// This member is required.
        public var match: AppMeshClientTypes.HttpGatewayRouteMatch?

        public init(
            action: AppMeshClientTypes.HttpGatewayRouteAction? = nil,
            match: AppMeshClientTypes.HttpGatewayRouteMatch? = nil
        )
        {
            self.action = action
            self.match = match
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a gateway route specification. Specify one gateway route type.
    public struct GatewayRouteSpec {
        /// An object that represents the specification of a gRPC gateway route.
        public var grpcRoute: AppMeshClientTypes.GrpcGatewayRoute?
        /// An object that represents the specification of an HTTP/2 gateway route.
        public var http2Route: AppMeshClientTypes.HttpGatewayRoute?
        /// An object that represents the specification of an HTTP gateway route.
        public var httpRoute: AppMeshClientTypes.HttpGatewayRoute?
        /// The ordering of the gateway routes spec.
        public var priority: Swift.Int?

        public init(
            grpcRoute: AppMeshClientTypes.GrpcGatewayRoute? = nil,
            http2Route: AppMeshClientTypes.HttpGatewayRoute? = nil,
            httpRoute: AppMeshClientTypes.HttpGatewayRoute? = nil,
            priority: Swift.Int? = nil
        )
        {
            self.grpcRoute = grpcRoute
            self.http2Route = http2Route
            self.httpRoute = httpRoute
            self.priority = priority
        }
    }

}

public struct CreateGatewayRouteInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name to use for the gateway route.
    /// This member is required.
    public var gatewayRouteName: Swift.String?
    /// The name of the service mesh to create the gateway route in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The gateway route specification to apply.
    /// This member is required.
    public var spec: AppMeshClientTypes.GatewayRouteSpec?
    /// Optional metadata that you can apply to the gateway route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [AppMeshClientTypes.TagRef]?
    /// The name of the virtual gateway to associate the gateway route with. If the virtual gateway is in a shared mesh, then you must be the owner of the virtual gateway resource.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        gatewayRouteName: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.GatewayRouteSpec? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.gatewayRouteName = gatewayRouteName
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualGatewayName = virtualGatewayName
    }
}

extension AppMeshClientTypes {

    public enum GatewayRouteStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayRouteStatusCode] {
            return [
                .active,
                .deleted,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents the current status of a gateway route.
    public struct GatewayRouteStatus {
        /// The current status for the gateway route.
        /// This member is required.
        public var status: AppMeshClientTypes.GatewayRouteStatusCode?

        public init(
            status: AppMeshClientTypes.GatewayRouteStatusCode? = nil
        )
        {
            self.status = status
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a gateway route returned by a describe operation.
    public struct GatewayRouteData {
        /// The name of the gateway route.
        /// This member is required.
        public var gatewayRouteName: Swift.String?
        /// The name of the service mesh that the resource resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// An object that represents metadata for a resource.
        /// This member is required.
        public var metadata: AppMeshClientTypes.ResourceMetadata?
        /// The specifications of the gateway route.
        /// This member is required.
        public var spec: AppMeshClientTypes.GatewayRouteSpec?
        /// The status of the gateway route.
        /// This member is required.
        public var status: AppMeshClientTypes.GatewayRouteStatus?
        /// The virtual gateway that the gateway route is associated with.
        /// This member is required.
        public var virtualGatewayName: Swift.String?

        public init(
            gatewayRouteName: Swift.String? = nil,
            meshName: Swift.String? = nil,
            metadata: AppMeshClientTypes.ResourceMetadata? = nil,
            spec: AppMeshClientTypes.GatewayRouteSpec? = nil,
            status: AppMeshClientTypes.GatewayRouteStatus? = nil,
            virtualGatewayName: Swift.String? = nil
        )
        {
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualGatewayName = virtualGatewayName
        }
    }

}

public struct CreateGatewayRouteOutput {
    /// The full description of your gateway route following the create call.
    /// This member is required.
    public var gatewayRoute: AppMeshClientTypes.GatewayRouteData?

    public init(
        gatewayRoute: AppMeshClientTypes.GatewayRouteData? = nil
    )
    {
        self.gatewayRoute = gatewayRoute
    }
}

public struct DeleteGatewayRouteInput {
    /// The name of the gateway route to delete.
    /// This member is required.
    public var gatewayRouteName: Swift.String?
    /// The name of the service mesh to delete the gateway route from.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual gateway to delete the route from.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init(
        gatewayRouteName: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.gatewayRouteName = gatewayRouteName
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualGatewayName = virtualGatewayName
    }
}

public struct DeleteGatewayRouteOutput {
    /// The gateway route that was deleted.
    /// This member is required.
    public var gatewayRoute: AppMeshClientTypes.GatewayRouteData?

    public init(
        gatewayRoute: AppMeshClientTypes.GatewayRouteData? = nil
    )
    {
        self.gatewayRoute = gatewayRoute
    }
}

public struct DescribeGatewayRouteInput {
    /// The name of the gateway route to describe.
    /// This member is required.
    public var gatewayRouteName: Swift.String?
    /// The name of the service mesh that the gateway route resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual gateway that the gateway route is associated with.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init(
        gatewayRouteName: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.gatewayRouteName = gatewayRouteName
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualGatewayName = virtualGatewayName
    }
}

public struct DescribeGatewayRouteOutput {
    /// The full description of your gateway route.
    /// This member is required.
    public var gatewayRoute: AppMeshClientTypes.GatewayRouteData?

    public init(
        gatewayRoute: AppMeshClientTypes.GatewayRouteData? = nil
    )
    {
        self.gatewayRoute = gatewayRoute
    }
}

public struct ListGatewayRoutesInput {
    /// The maximum number of results returned by ListGatewayRoutes in paginated output. When you use this parameter, ListGatewayRoutes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListGatewayRoutes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListGatewayRoutes returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The name of the service mesh to list gateway routes in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The nextToken value returned from a previous paginated ListGatewayRoutes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    public var nextToken: Swift.String?
    /// The name of the virtual gateway to list gateway routes in.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
        self.virtualGatewayName = virtualGatewayName
    }
}

extension AppMeshClientTypes {
    /// An object that represents a gateway route returned by a list operation.
    public struct GatewayRouteRef {
        /// The full Amazon Resource Name (ARN) for the gateway route.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The name of the gateway route.
        /// This member is required.
        public var gatewayRouteName: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the service mesh that the resource resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?
        /// The virtual gateway that the gateway route is associated with.
        /// This member is required.
        public var virtualGatewayName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            gatewayRouteName: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            meshName: Swift.String? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            version: Swift.Int? = nil,
            virtualGatewayName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.gatewayRouteName = gatewayRouteName
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualGatewayName = virtualGatewayName
        }
    }

}

public struct ListGatewayRoutesOutput {
    /// The list of existing gateway routes for the specified service mesh and virtual gateway.
    /// This member is required.
    public var gatewayRoutes: [AppMeshClientTypes.GatewayRouteRef]?
    /// The nextToken value to include in a future ListGatewayRoutes request. When the results of a ListGatewayRoutes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        gatewayRoutes: [AppMeshClientTypes.GatewayRouteRef]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gatewayRoutes = gatewayRoutes
        self.nextToken = nextToken
    }
}

public struct UpdateGatewayRouteInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the gateway route to update.
    /// This member is required.
    public var gatewayRouteName: Swift.String?
    /// The name of the service mesh that the gateway route resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The new gateway route specification to apply. This overwrites the existing data.
    /// This member is required.
    public var spec: AppMeshClientTypes.GatewayRouteSpec?
    /// The name of the virtual gateway that the gateway route is associated with.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        gatewayRouteName: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.GatewayRouteSpec? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.gatewayRouteName = gatewayRouteName
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualGatewayName = virtualGatewayName
    }
}

public struct UpdateGatewayRouteOutput {
    /// A full description of the gateway route that was updated.
    /// This member is required.
    public var gatewayRoute: AppMeshClientTypes.GatewayRouteData?

    public init(
        gatewayRoute: AppMeshClientTypes.GatewayRouteData? = nil
    )
    {
        self.gatewayRoute = gatewayRoute
    }
}

public struct ListVirtualGatewaysInput {
    /// The maximum number of results returned by ListVirtualGateways in paginated output. When you use this parameter, ListVirtualGateways returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualGateways request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualGateways returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The name of the service mesh to list virtual gateways in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The nextToken value returned from a previous paginated ListVirtualGateways request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    public var nextToken: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual gateway returned by a list operation.
    public struct VirtualGatewayRef {
        /// The full Amazon Resource Name (ARN) for the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the service mesh that the resource resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?
        /// The name of the resource.
        /// This member is required.
        public var virtualGatewayName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            meshName: Swift.String? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            version: Swift.Int? = nil,
            virtualGatewayName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualGatewayName = virtualGatewayName
        }
    }

}

public struct ListVirtualGatewaysOutput {
    /// The nextToken value to include in a future ListVirtualGateways request. When the results of a ListVirtualGateways request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of existing virtual gateways for the specified service mesh.
    /// This member is required.
    public var virtualGateways: [AppMeshClientTypes.VirtualGatewayRef]?

    public init(
        nextToken: Swift.String? = nil,
        virtualGateways: [AppMeshClientTypes.VirtualGatewayRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualGateways = virtualGateways
    }
}

public struct UpdateVirtualGatewayInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh that the virtual gateway resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The new virtual gateway specification to apply. This overwrites the existing data.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualGatewaySpec?
    /// The name of the virtual gateway to update.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualGatewaySpec? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualGatewayName = virtualGatewayName
    }
}

public struct UpdateVirtualGatewayOutput {
    /// A full description of the virtual gateway that was updated.
    /// This member is required.
    public var virtualGateway: AppMeshClientTypes.VirtualGatewayData?

    public init(
        virtualGateway: AppMeshClientTypes.VirtualGatewayData? = nil
    )
    {
        self.virtualGateway = virtualGateway
    }
}

extension AppMeshClientTypes {
    /// An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see [Transport Layer Security (TLS)](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites).
    public struct ListenerTlsFileCertificate {
        /// The certificate chain for the certificate.
        /// This member is required.
        public var certificateChain: Swift.String?
        /// The private key for a certificate stored on the file system of the virtual node that the proxy is running on.
        /// This member is required.
        public var privateKey: Swift.String?

        public init(
            certificateChain: Swift.String? = nil,
            privateKey: Swift.String? = nil
        )
        {
            self.certificateChain = certificateChain
            self.privateKey = privateKey
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the listener's Secret Discovery Service certificate. The proxy must be configured with a local SDS provider via a Unix Domain Socket. See App Mesh [TLS documentation](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html) for more info.
    public struct ListenerTlsSdsCertificate {
        /// A reference to an object that represents the name of the secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
        /// This member is required.
        public var secretName: Swift.String?

        public init(
            secretName: Swift.String? = nil
        )
        {
            self.secretName = secretName
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the client's certificate.
    public enum ClientTlsCertificate {
        /// An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see [Transport Layer Security (TLS)](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html).
        case file(AppMeshClientTypes.ListenerTlsFileCertificate)
        /// A reference to an object that represents a client's TLS Secret Discovery Service certificate.
        case sds(AppMeshClientTypes.ListenerTlsSdsCertificate)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) validation context trust for an Certificate Manager certificate.
    public struct TlsValidationContextAcmTrust {
        /// One or more ACM Amazon Resource Name (ARN)s.
        /// This member is required.
        public var certificateAuthorityArns: [Swift.String]?

        public init(
            certificateAuthorityArns: [Swift.String]? = nil
        )
        {
            self.certificateAuthorityArns = certificateAuthorityArns
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
    public struct TlsValidationContextFileTrust {
        /// The certificate trust chain for a certificate stored on the file system of the virtual node that the proxy is running on.
        /// This member is required.
        public var certificateChain: Swift.String?

        public init(
            certificateChain: Swift.String? = nil
        )
        {
            self.certificateChain = certificateChain
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) Secret Discovery Service validation context trust. The proxy must be configured with a local SDS provider via a Unix Domain Socket. See App Mesh [TLS documentation](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html) for more info.
    public struct TlsValidationContextSdsTrust {
        /// A reference to an object that represents the name of the secret for a Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        /// This member is required.
        public var secretName: Swift.String?

        public init(
            secretName: Swift.String? = nil
        )
        {
            self.secretName = secretName
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) validation context trust.
    public enum TlsValidationContextTrust {
        /// A reference to an object that represents a Transport Layer Security (TLS) validation context trust for an Certificate Manager certificate.
        case acm(AppMeshClientTypes.TlsValidationContextAcmTrust)
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        case file(AppMeshClientTypes.TlsValidationContextFileTrust)
        /// A reference to an object that represents a Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        case sds(AppMeshClientTypes.TlsValidationContextSdsTrust)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object that represents how the proxy will validate its peer during Transport Layer Security (TLS) negotiation.
    public struct TlsValidationContext {
        /// A reference to an object that represents the SANs for a Transport Layer Security (TLS) validation context. If you don't specify SANs on the terminating mesh endpoint, the Envoy proxy for that node doesn't verify the SAN on a peer client certificate. If you don't specify SANs on the originating mesh endpoint, the SAN on the certificate provided by the terminating endpoint must match the mesh endpoint service discovery configuration. Since SPIRE vended certificates have a SPIFFE ID as a name, you must set the SAN since the name doesn't match the service discovery name.
        public var subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS) certificate.
        /// This member is required.
        public var trust: AppMeshClientTypes.TlsValidationContextTrust?

        public init(
            subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames? = nil,
            trust: AppMeshClientTypes.TlsValidationContextTrust? = nil
        )
        {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }
    }

}

extension AppMeshClientTypes {
    /// A reference to an object that represents a Transport Layer Security (TLS) client policy.
    public struct ClientPolicyTls {
        /// A reference to an object that represents a client's TLS certificate.
        public var certificate: AppMeshClientTypes.ClientTlsCertificate?
        /// Whether the policy is enforced. The default is True, if a value isn't specified.
        public var enforce: Swift.Bool?
        /// One or more ports that the policy is enforced for.
        public var ports: [Swift.Int]?
        /// A reference to an object that represents a TLS validation context.
        /// This member is required.
        public var validation: AppMeshClientTypes.TlsValidationContext?

        public init(
            certificate: AppMeshClientTypes.ClientTlsCertificate? = nil,
            enforce: Swift.Bool? = nil,
            ports: [Swift.Int]? = nil,
            validation: AppMeshClientTypes.TlsValidationContext? = nil
        )
        {
            self.certificate = certificate
            self.enforce = enforce
            self.ports = ports
            self.validation = validation
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a client policy.
    public struct ClientPolicy {
        /// A reference to an object that represents a Transport Layer Security (TLS) client policy.
        public var tls: AppMeshClientTypes.ClientPolicyTls?

        public init(
            tls: AppMeshClientTypes.ClientPolicyTls? = nil
        )
        {
            self.tls = tls
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the default properties for a backend.
    public struct BackendDefaults {
        /// A reference to an object that represents a client policy.
        public var clientPolicy: AppMeshClientTypes.ClientPolicy?

        public init(
            clientPolicy: AppMeshClientTypes.ClientPolicy? = nil
        )
        {
            self.clientPolicy = clientPolicy
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a virtual service backend for a virtual node.
    public struct VirtualServiceBackend {
        /// A reference to an object that represents the client policy for a backend.
        public var clientPolicy: AppMeshClientTypes.ClientPolicy?
        /// The name of the virtual service that is acting as a virtual node backend.
        /// This member is required.
        public var virtualServiceName: Swift.String?

        public init(
            clientPolicy: AppMeshClientTypes.ClientPolicy? = nil,
            virtualServiceName: Swift.String? = nil
        )
        {
            self.clientPolicy = clientPolicy
            self.virtualServiceName = virtualServiceName
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the backends that a virtual node is expected to send outbound traffic to.
    public enum Backend {
        /// Specifies a virtual service to use as a backend.
        case virtualservice(AppMeshClientTypes.VirtualServiceBackend)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object that represents a type of connection pool.
    public struct VirtualNodeGrpcConnectionPool {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        /// This member is required.
        public var maxRequests: Swift.Int?

        public init(
            maxRequests: Swift.Int? = nil
        )
        {
            self.maxRequests = maxRequests
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a type of connection pool.
    public struct VirtualNodeHttpConnectionPool {
        /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.
        /// This member is required.
        public var maxConnections: Swift.Int?
        /// Number of overflowing requests after max_connections Envoy will queue to upstream cluster.
        public var maxPendingRequests: Swift.Int?

        public init(
            maxConnections: Swift.Int? = nil,
            maxPendingRequests: Swift.Int? = nil
        )
        {
            self.maxConnections = maxConnections
            self.maxPendingRequests = maxPendingRequests
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a type of connection pool.
    public struct VirtualNodeHttp2ConnectionPool {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        /// This member is required.
        public var maxRequests: Swift.Int?

        public init(
            maxRequests: Swift.Int? = nil
        )
        {
            self.maxRequests = maxRequests
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a type of connection pool.
    public struct VirtualNodeTcpConnectionPool {
        /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.
        /// This member is required.
        public var maxConnections: Swift.Int?

        public init(
            maxConnections: Swift.Int? = nil
        )
        {
            self.maxConnections = maxConnections
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the type of virtual node connection pool. Only one protocol is used at a time and should be the same protocol as the one chosen under port mapping. If not present the default value for maxPendingRequests is 2147483647.
    public enum VirtualNodeConnectionPool {
        /// An object that represents a type of connection pool.
        case tcp(AppMeshClientTypes.VirtualNodeTcpConnectionPool)
        /// An object that represents a type of connection pool.
        case http(AppMeshClientTypes.VirtualNodeHttpConnectionPool)
        /// An object that represents a type of connection pool.
        case http2(AppMeshClientTypes.VirtualNodeHttp2ConnectionPool)
        /// An object that represents a type of connection pool.
        case grpc(AppMeshClientTypes.VirtualNodeGrpcConnectionPool)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {

    public enum PortProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case grpc
        case http
        case http2
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [PortProtocol] {
            return [
                .grpc,
                .http,
                .http2,
                .tcp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .grpc: return "grpc"
            case .http: return "http"
            case .http2: return "http2"
            case .tcp: return "tcp"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents the health check policy for a virtual node's listener.
    public struct HealthCheckPolicy {
        /// The number of consecutive successful health checks that must occur before declaring listener healthy.
        /// This member is required.
        public var healthyThreshold: Swift.Int?
        /// The time period in milliseconds between each health check execution.
        /// This member is required.
        public var intervalMillis: Swift.Int?
        /// The destination path for the health check request. This value is only used if the specified protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.
        public var path: Swift.String?
        /// The destination port for the health check request. This port must match the port defined in the [PortMapping] for the listener.
        public var port: Swift.Int?
        /// The protocol for the health check request. If you specify grpc, then your service must conform to the [GRPC Health Checking Protocol](https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
        /// This member is required.
        public var `protocol`: AppMeshClientTypes.PortProtocol?
        /// The amount of time to wait when receiving a response from the health check, in milliseconds.
        /// This member is required.
        public var timeoutMillis: Swift.Int?
        /// The number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
        /// This member is required.
        public var unhealthyThreshold: Swift.Int?

        public init(
            healthyThreshold: Swift.Int? = nil,
            intervalMillis: Swift.Int? = nil,
            path: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: AppMeshClientTypes.PortProtocol? = nil,
            timeoutMillis: Swift.Int? = nil,
            unhealthyThreshold: Swift.Int? = nil
        )
        {
            self.healthyThreshold = healthyThreshold
            self.intervalMillis = intervalMillis
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.timeoutMillis = timeoutMillis
            self.unhealthyThreshold = unhealthyThreshold
        }
    }

}

extension AppMeshClientTypes {

    public enum DurationUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ms
        case s
        case sdkUnknown(Swift.String)

        public static var allCases: [DurationUnit] {
            return [
                .ms,
                .s
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ms: return "ms"
            case .s: return "s"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents a duration of time.
    public struct Duration {
        /// A unit of time.
        public var unit: AppMeshClientTypes.DurationUnit?
        /// A number of time units.
        public var value: Swift.Int?

        public init(
            unit: AppMeshClientTypes.DurationUnit? = nil,
            value: Swift.Int? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the outlier detection for a virtual node's listener.
    public struct OutlierDetection {
        /// The base amount of time for which a host is ejected.
        /// This member is required.
        public var baseEjectionDuration: AppMeshClientTypes.Duration?
        /// The time interval between ejection sweep analysis.
        /// This member is required.
        public var interval: AppMeshClientTypes.Duration?
        /// Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
        /// This member is required.
        public var maxEjectionPercent: Swift.Int?
        /// Number of consecutive 5xx errors required for ejection.
        /// This member is required.
        public var maxServerErrors: Swift.Int?

        public init(
            baseEjectionDuration: AppMeshClientTypes.Duration? = nil,
            interval: AppMeshClientTypes.Duration? = nil,
            maxEjectionPercent: Swift.Int? = nil,
            maxServerErrors: Swift.Int? = nil
        )
        {
            self.baseEjectionDuration = baseEjectionDuration
            self.interval = interval
            self.maxEjectionPercent = maxEjectionPercent
            self.maxServerErrors = maxServerErrors
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a port mapping.
    public struct PortMapping {
        /// The port used for the port mapping.
        /// This member is required.
        public var port: Swift.Int?
        /// The protocol used for the port mapping. Specify one protocol.
        /// This member is required.
        public var `protocol`: AppMeshClientTypes.PortProtocol?

        public init(
            port: Swift.Int? = nil,
            `protocol`: AppMeshClientTypes.PortProtocol? = nil
        )
        {
            self.port = port
            self.`protocol` = `protocol`
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents types of timeouts.
    public struct GrpcTimeout {
        /// An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.
        public var idle: AppMeshClientTypes.Duration?
        /// An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15 seconds for the source and destination virtual node and the route.
        public var perRequest: AppMeshClientTypes.Duration?

        public init(
            idle: AppMeshClientTypes.Duration? = nil,
            perRequest: AppMeshClientTypes.Duration? = nil
        )
        {
            self.idle = idle
            self.perRequest = perRequest
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents types of timeouts.
    public struct HttpTimeout {
        /// An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.
        public var idle: AppMeshClientTypes.Duration?
        /// An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15 seconds for the source and destination virtual node and the route.
        public var perRequest: AppMeshClientTypes.Duration?

        public init(
            idle: AppMeshClientTypes.Duration? = nil,
            perRequest: AppMeshClientTypes.Duration? = nil
        )
        {
            self.idle = idle
            self.perRequest = perRequest
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents types of timeouts.
    public struct TcpTimeout {
        /// An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.
        public var idle: AppMeshClientTypes.Duration?

        public init(
            idle: AppMeshClientTypes.Duration? = nil
        )
        {
            self.idle = idle
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents timeouts for different protocols.
    public enum ListenerTimeout {
        /// An object that represents types of timeouts.
        case tcp(AppMeshClientTypes.TcpTimeout)
        /// An object that represents types of timeouts.
        case http(AppMeshClientTypes.HttpTimeout)
        /// An object that represents types of timeouts.
        case http2(AppMeshClientTypes.HttpTimeout)
        /// An object that represents types of timeouts.
        case grpc(AppMeshClientTypes.GrpcTimeout)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object that represents an Certificate Manager certificate.
    public struct ListenerTlsAcmCertificate {
        /// The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see [Transport Layer Security (TLS)](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites).
        /// This member is required.
        public var certificateArn: Swift.String?

        public init(
            certificateArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a listener's Transport Layer Security (TLS) certificate.
    public enum ListenerTlsCertificate {
        /// A reference to an object that represents an Certificate Manager certificate.
        case acm(AppMeshClientTypes.ListenerTlsAcmCertificate)
        /// A reference to an object that represents a local file certificate.
        case file(AppMeshClientTypes.ListenerTlsFileCertificate)
        /// A reference to an object that represents a listener's Secret Discovery Service certificate.
        case sds(AppMeshClientTypes.ListenerTlsSdsCertificate)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {

    public enum ListenerTlsMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case permissive
        case strict
        case sdkUnknown(Swift.String)

        public static var allCases: [ListenerTlsMode] {
            return [
                .disabled,
                .permissive,
                .strict
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .permissive: return "PERMISSIVE"
            case .strict: return "STRICT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents a listener's Transport Layer Security (TLS) validation context trust.
    public enum ListenerTlsValidationContextTrust {
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        case file(AppMeshClientTypes.TlsValidationContextFileTrust)
        /// A reference to an object that represents a listener's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        case sds(AppMeshClientTypes.TlsValidationContextSdsTrust)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object that represents a listener's Transport Layer Security (TLS) validation context.
    public struct ListenerTlsValidationContext {
        /// A reference to an object that represents the SANs for a listener's Transport Layer Security (TLS) validation context.
        public var subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS) certificate.
        /// This member is required.
        public var trust: AppMeshClientTypes.ListenerTlsValidationContextTrust?

        public init(
            subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames? = nil,
            trust: AppMeshClientTypes.ListenerTlsValidationContextTrust? = nil
        )
        {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the Transport Layer Security (TLS) properties for a listener.
    public struct ListenerTls {
        /// A reference to an object that represents a listener's Transport Layer Security (TLS) certificate.
        /// This member is required.
        public var certificate: AppMeshClientTypes.ListenerTlsCertificate?
        /// Specify one of the following modes.
        ///
        /// * STRICT – Listener only accepts connections with TLS enabled.
        ///
        /// * PERMISSIVE – Listener accepts connections with or without TLS enabled.
        ///
        /// * DISABLED – Listener only accepts connections without TLS.
        /// This member is required.
        public var mode: AppMeshClientTypes.ListenerTlsMode?
        /// A reference to an object that represents a listener's Transport Layer Security (TLS) validation context.
        public var validation: AppMeshClientTypes.ListenerTlsValidationContext?

        public init(
            certificate: AppMeshClientTypes.ListenerTlsCertificate? = nil,
            mode: AppMeshClientTypes.ListenerTlsMode? = nil,
            validation: AppMeshClientTypes.ListenerTlsValidationContext? = nil
        )
        {
            self.certificate = certificate
            self.mode = mode
            self.validation = validation
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a listener for a virtual node.
    public struct Listener {
        /// The connection pool information for the listener.
        public var connectionPool: AppMeshClientTypes.VirtualNodeConnectionPool?
        /// The health check information for the listener.
        public var healthCheck: AppMeshClientTypes.HealthCheckPolicy?
        /// The outlier detection information for the listener.
        public var outlierDetection: AppMeshClientTypes.OutlierDetection?
        /// The port mapping information for the listener.
        /// This member is required.
        public var portMapping: AppMeshClientTypes.PortMapping?
        /// An object that represents timeouts for different protocols.
        public var timeout: AppMeshClientTypes.ListenerTimeout?
        /// A reference to an object that represents the Transport Layer Security (TLS) properties for a listener.
        public var tls: AppMeshClientTypes.ListenerTls?

        public init(
            connectionPool: AppMeshClientTypes.VirtualNodeConnectionPool? = nil,
            healthCheck: AppMeshClientTypes.HealthCheckPolicy? = nil,
            outlierDetection: AppMeshClientTypes.OutlierDetection? = nil,
            portMapping: AppMeshClientTypes.PortMapping? = nil,
            timeout: AppMeshClientTypes.ListenerTimeout? = nil,
            tls: AppMeshClientTypes.ListenerTls? = nil
        )
        {
            self.connectionPool = connectionPool
            self.healthCheck = healthCheck
            self.outlierDetection = outlierDetection
            self.portMapping = portMapping
            self.timeout = timeout
            self.tls = tls
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the logging information for a virtual node.
    public struct Logging {
        /// The access log configuration for a virtual node.
        public var accessLog: AppMeshClientTypes.AccessLog?

        public init(
            accessLog: AppMeshClientTypes.AccessLog? = nil
        )
        {
            self.accessLog = accessLog
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the Cloud Map attribute information for your virtual node. Cloud Map is not available in the eu-south-1 Region.
    public struct AwsCloudMapInstanceAttribute {
        /// The name of an Cloud Map service instance attribute key. Any Cloud Map service instance that contains the specified key and value is returned.
        /// This member is required.
        public var key: Swift.String?
        /// The value of an Cloud Map service instance attribute key. Any Cloud Map service instance that contains the specified key and value is returned.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the Cloud Map service discovery information for your virtual node. Cloud Map is not available in the eu-south-1 Region.
    public struct AwsCloudMapServiceDiscovery {
        /// A string map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
        public var attributes: [AppMeshClientTypes.AwsCloudMapInstanceAttribute]?
        /// The preferred IP version that this virtual node uses. Setting the IP preference on the virtual node only overrides the IP preference set for the mesh on this specific node.
        public var ipPreference: AppMeshClientTypes.IpPreference?
        /// The name of the Cloud Map namespace to use.
        /// This member is required.
        public var namespaceName: Swift.String?
        /// The name of the Cloud Map service to use.
        /// This member is required.
        public var serviceName: Swift.String?

        public init(
            attributes: [AppMeshClientTypes.AwsCloudMapInstanceAttribute]? = nil,
            ipPreference: AppMeshClientTypes.IpPreference? = nil,
            namespaceName: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.ipPreference = ipPreference
            self.namespaceName = namespaceName
            self.serviceName = serviceName
        }
    }

}

extension AppMeshClientTypes {

    public enum DnsResponseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case endpoints
        case loadbalancer
        case sdkUnknown(Swift.String)

        public static var allCases: [DnsResponseType] {
            return [
                .endpoints,
                .loadbalancer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .endpoints: return "ENDPOINTS"
            case .loadbalancer: return "LOADBALANCER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents the DNS service discovery information for your virtual node.
    public struct DnsServiceDiscovery {
        /// Specifies the DNS service discovery hostname for the virtual node.
        /// This member is required.
        public var hostname: Swift.String?
        /// The preferred IP version that this virtual node uses. Setting the IP preference on the virtual node only overrides the IP preference set for the mesh on this specific node.
        public var ipPreference: AppMeshClientTypes.IpPreference?
        /// Specifies the DNS response type for the virtual node.
        public var responseType: AppMeshClientTypes.DnsResponseType?

        public init(
            hostname: Swift.String? = nil,
            ipPreference: AppMeshClientTypes.IpPreference? = nil,
            responseType: AppMeshClientTypes.DnsResponseType? = nil
        )
        {
            self.hostname = hostname
            self.ipPreference = ipPreference
            self.responseType = responseType
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the service discovery information for a virtual node.
    public enum ServiceDiscovery {
        /// Specifies the DNS information for the virtual node.
        case dns(AppMeshClientTypes.DnsServiceDiscovery)
        /// Specifies any Cloud Map information for the virtual node.
        case awscloudmap(AppMeshClientTypes.AwsCloudMapServiceDiscovery)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object that represents the specification of a virtual node.
    public struct VirtualNodeSpec {
        /// A reference to an object that represents the defaults for backends.
        public var backendDefaults: AppMeshClientTypes.BackendDefaults?
        /// The backends that the virtual node is expected to send outbound traffic to.
        public var backends: [AppMeshClientTypes.Backend]?
        /// The listener that the virtual node is expected to receive inbound traffic from. You can specify one listener.
        public var listeners: [AppMeshClientTypes.Listener]?
        /// The inbound and outbound access logging information for the virtual node.
        public var logging: AppMeshClientTypes.Logging?
        /// The service discovery information for the virtual node. If your virtual node does not expect ingress traffic, you can omit this parameter. If you specify a listener, then you must specify service discovery information.
        public var serviceDiscovery: AppMeshClientTypes.ServiceDiscovery?

        public init(
            backendDefaults: AppMeshClientTypes.BackendDefaults? = nil,
            backends: [AppMeshClientTypes.Backend]? = nil,
            listeners: [AppMeshClientTypes.Listener]? = nil,
            logging: AppMeshClientTypes.Logging? = nil,
            serviceDiscovery: AppMeshClientTypes.ServiceDiscovery? = nil
        )
        {
            self.backendDefaults = backendDefaults
            self.backends = backends
            self.listeners = listeners
            self.logging = logging
            self.serviceDiscovery = serviceDiscovery
        }
    }

}

///
public struct CreateVirtualNodeInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh to create the virtual node in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The virtual node specification to apply.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualNodeSpec?
    /// Optional metadata that you can apply to the virtual node to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [AppMeshClientTypes.TagRef]?
    /// The name to use for the virtual node.
    /// This member is required.
    public var virtualNodeName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualNodeSpec? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil,
        virtualNodeName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualNodeName = virtualNodeName
    }
}

extension AppMeshClientTypes {

    public enum VirtualNodeStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualNodeStatusCode] {
            return [
                .active,
                .deleted,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents the current status of the virtual node.
    public struct VirtualNodeStatus {
        /// The current status of the virtual node.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualNodeStatusCode?

        public init(
            status: AppMeshClientTypes.VirtualNodeStatusCode? = nil
        )
        {
            self.status = status
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a virtual node returned by a describe operation.
    public struct VirtualNodeData {
        /// The name of the service mesh that the virtual node resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The associated metadata for the virtual node.
        /// This member is required.
        public var metadata: AppMeshClientTypes.ResourceMetadata?
        /// The specifications of the virtual node.
        /// This member is required.
        public var spec: AppMeshClientTypes.VirtualNodeSpec?
        /// The current status for the virtual node.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualNodeStatus?
        /// The name of the virtual node.
        /// This member is required.
        public var virtualNodeName: Swift.String?

        public init(
            meshName: Swift.String? = nil,
            metadata: AppMeshClientTypes.ResourceMetadata? = nil,
            spec: AppMeshClientTypes.VirtualNodeSpec? = nil,
            status: AppMeshClientTypes.VirtualNodeStatus? = nil,
            virtualNodeName: Swift.String? = nil
        )
        {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualNodeName = virtualNodeName
        }
    }

}

///
public struct CreateVirtualNodeOutput {
    /// The full description of your virtual node following the create call.
    /// This member is required.
    public var virtualNode: AppMeshClientTypes.VirtualNodeData?

    public init(
        virtualNode: AppMeshClientTypes.VirtualNodeData? = nil
    )
    {
        self.virtualNode = virtualNode
    }
}

/// Deletes a virtual node input.
public struct DeleteVirtualNodeInput {
    /// The name of the service mesh to delete the virtual node in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual node to delete.
    /// This member is required.
    public var virtualNodeName: Swift.String?

    public init(
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualNodeName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualNodeName = virtualNodeName
    }
}

///
public struct DeleteVirtualNodeOutput {
    /// The virtual node that was deleted.
    /// This member is required.
    public var virtualNode: AppMeshClientTypes.VirtualNodeData?

    public init(
        virtualNode: AppMeshClientTypes.VirtualNodeData? = nil
    )
    {
        self.virtualNode = virtualNode
    }
}

///
public struct DescribeVirtualNodeInput {
    /// The name of the service mesh that the virtual node resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual node to describe.
    /// This member is required.
    public var virtualNodeName: Swift.String?

    public init(
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualNodeName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualNodeName = virtualNodeName
    }
}

///
public struct DescribeVirtualNodeOutput {
    /// The full description of your virtual node.
    /// This member is required.
    public var virtualNode: AppMeshClientTypes.VirtualNodeData?

    public init(
        virtualNode: AppMeshClientTypes.VirtualNodeData? = nil
    )
    {
        self.virtualNode = virtualNode
    }
}

///
public struct ListVirtualNodesInput {
    /// The maximum number of results returned by ListVirtualNodes in paginated output. When you use this parameter, ListVirtualNodes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualNodes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualNodes returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The name of the service mesh to list virtual nodes in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The nextToken value returned from a previous paginated ListVirtualNodes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    public var nextToken: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual node returned by a list operation.
    public struct VirtualNodeRef {
        /// The full Amazon Resource Name (ARN) for the virtual node.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the service mesh that the virtual node resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?
        /// The name of the virtual node.
        /// This member is required.
        public var virtualNodeName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            meshName: Swift.String? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            version: Swift.Int? = nil,
            virtualNodeName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualNodeName = virtualNodeName
        }
    }

}

///
public struct ListVirtualNodesOutput {
    /// The nextToken value to include in a future ListVirtualNodes request. When the results of a ListVirtualNodes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of existing virtual nodes for the specified service mesh.
    /// This member is required.
    public var virtualNodes: [AppMeshClientTypes.VirtualNodeRef]?

    public init(
        nextToken: Swift.String? = nil,
        virtualNodes: [AppMeshClientTypes.VirtualNodeRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualNodes = virtualNodes
    }
}

///
public struct UpdateVirtualNodeInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh that the virtual node resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The new virtual node specification to apply. This overwrites the existing data.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualNodeSpec?
    /// The name of the virtual node to update.
    /// This member is required.
    public var virtualNodeName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualNodeSpec? = nil,
        virtualNodeName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualNodeName = virtualNodeName
    }
}

///
public struct UpdateVirtualNodeOutput {
    /// A full description of the virtual node that was updated.
    /// This member is required.
    public var virtualNode: AppMeshClientTypes.VirtualNodeData?

    public init(
        virtualNode: AppMeshClientTypes.VirtualNodeData? = nil
    )
    {
        self.virtualNode = virtualNode
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual router listener.
    public struct VirtualRouterListener {
        /// An object that represents a port mapping.
        /// This member is required.
        public var portMapping: AppMeshClientTypes.PortMapping?

        public init(
            portMapping: AppMeshClientTypes.PortMapping? = nil
        )
        {
            self.portMapping = portMapping
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the specification of a virtual router.
    public struct VirtualRouterSpec {
        /// The listeners that the virtual router is expected to receive inbound traffic from. You can specify one listener.
        public var listeners: [AppMeshClientTypes.VirtualRouterListener]?

        public init(
            listeners: [AppMeshClientTypes.VirtualRouterListener]? = nil
        )
        {
            self.listeners = listeners
        }
    }

}

///
public struct CreateVirtualRouterInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh to create the virtual router in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The virtual router specification to apply.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualRouterSpec?
    /// Optional metadata that you can apply to the virtual router to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [AppMeshClientTypes.TagRef]?
    /// The name to use for the virtual router.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualRouterSpec? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualRouterName = virtualRouterName
    }
}

extension AppMeshClientTypes {

    public enum VirtualRouterStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualRouterStatusCode] {
            return [
                .active,
                .deleted,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents the status of a virtual router.
    public struct VirtualRouterStatus {
        /// The current status of the virtual router.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualRouterStatusCode?

        public init(
            status: AppMeshClientTypes.VirtualRouterStatusCode? = nil
        )
        {
            self.status = status
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a virtual router returned by a describe operation.
    public struct VirtualRouterData {
        /// The name of the service mesh that the virtual router resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The associated metadata for the virtual router.
        /// This member is required.
        public var metadata: AppMeshClientTypes.ResourceMetadata?
        /// The specifications of the virtual router.
        /// This member is required.
        public var spec: AppMeshClientTypes.VirtualRouterSpec?
        /// The current status of the virtual router.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualRouterStatus?
        /// The name of the virtual router.
        /// This member is required.
        public var virtualRouterName: Swift.String?

        public init(
            meshName: Swift.String? = nil,
            metadata: AppMeshClientTypes.ResourceMetadata? = nil,
            spec: AppMeshClientTypes.VirtualRouterSpec? = nil,
            status: AppMeshClientTypes.VirtualRouterStatus? = nil,
            virtualRouterName: Swift.String? = nil
        )
        {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualRouterName = virtualRouterName
        }
    }

}

///
public struct CreateVirtualRouterOutput {
    /// The full description of your virtual router following the create call.
    /// This member is required.
    public var virtualRouter: AppMeshClientTypes.VirtualRouterData?

    public init(
        virtualRouter: AppMeshClientTypes.VirtualRouterData? = nil
    )
    {
        self.virtualRouter = virtualRouter
    }
}

///
public struct DeleteVirtualRouterInput {
    /// The name of the service mesh to delete the virtual router in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual router to delete.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init(
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualRouterName = virtualRouterName
    }
}

///
public struct DeleteVirtualRouterOutput {
    /// The virtual router that was deleted.
    /// This member is required.
    public var virtualRouter: AppMeshClientTypes.VirtualRouterData?

    public init(
        virtualRouter: AppMeshClientTypes.VirtualRouterData? = nil
    )
    {
        self.virtualRouter = virtualRouter
    }
}

///
public struct DescribeVirtualRouterInput {
    /// The name of the service mesh that the virtual router resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual router to describe.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init(
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualRouterName = virtualRouterName
    }
}

///
public struct DescribeVirtualRouterOutput {
    /// The full description of your virtual router.
    /// This member is required.
    public var virtualRouter: AppMeshClientTypes.VirtualRouterData?

    public init(
        virtualRouter: AppMeshClientTypes.VirtualRouterData? = nil
    )
    {
        self.virtualRouter = virtualRouter
    }
}

///
public struct ListVirtualRoutersInput {
    /// The maximum number of results returned by ListVirtualRouters in paginated output. When you use this parameter, ListVirtualRouters returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualRouters request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualRouters returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The name of the service mesh to list virtual routers in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The nextToken value returned from a previous paginated ListVirtualRouters request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    public var nextToken: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual router returned by a list operation.
    public struct VirtualRouterRef {
        /// The full Amazon Resource Name (ARN) for the virtual router.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the service mesh that the virtual router resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?
        /// The name of the virtual router.
        /// This member is required.
        public var virtualRouterName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            meshName: Swift.String? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            version: Swift.Int? = nil,
            virtualRouterName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualRouterName = virtualRouterName
        }
    }

}

///
public struct ListVirtualRoutersOutput {
    /// The nextToken value to include in a future ListVirtualRouters request. When the results of a ListVirtualRouters request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of existing virtual routers for the specified service mesh.
    /// This member is required.
    public var virtualRouters: [AppMeshClientTypes.VirtualRouterRef]?

    public init(
        nextToken: Swift.String? = nil,
        virtualRouters: [AppMeshClientTypes.VirtualRouterRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualRouters = virtualRouters
    }
}

extension AppMeshClientTypes {
    /// An object that represents a target and its relative weight. Traffic is distributed across targets according to their relative weight. For example, a weighted target with a relative weight of 50 receives five times as much traffic as one with a relative weight of 10. The total weight for all targets combined must be less than or equal to 100.
    public struct WeightedTarget {
        /// The targeted port of the weighted object.
        public var port: Swift.Int?
        /// The virtual node to associate with the weighted target.
        /// This member is required.
        public var virtualNode: Swift.String?
        /// The relative weight of the weighted target.
        /// This member is required.
        public var weight: Swift.Int

        public init(
            port: Swift.Int? = nil,
            virtualNode: Swift.String? = nil,
            weight: Swift.Int = 0
        )
        {
            self.port = port
            self.virtualNode = virtualNode
            self.weight = weight
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the action to take if a match is determined.
    public struct GrpcRouteAction {
        /// An object that represents the targets that traffic is routed to when a request matches the route.
        /// This member is required.
        public var weightedTargets: [AppMeshClientTypes.WeightedTarget]?

        public init(
            weightedTargets: [AppMeshClientTypes.WeightedTarget]? = nil
        )
        {
            self.weightedTargets = weightedTargets
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the match method. Specify one of the match values.
    public enum GrpcRouteMetadataMatchMethod {
        /// The value sent by the client must match the specified value exactly.
        case exact(Swift.String)
        /// The value sent by the client must include the specified characters.
        case regex(Swift.String)
        /// An object that represents the range of values to match on.
        case range(AppMeshClientTypes.MatchRange)
        /// The value sent by the client must begin with the specified characters.
        case `prefix`(Swift.String)
        /// The value sent by the client must end with the specified characters.
        case suffix(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object that represents the match metadata for the route.
    public struct GrpcRouteMetadata {
        /// Specify True to match anything except the match criteria. The default value is False.
        public var invert: Swift.Bool?
        /// An object that represents the data to match from the request.
        public var match: AppMeshClientTypes.GrpcRouteMetadataMatchMethod?
        /// The name of the route.
        /// This member is required.
        public var name: Swift.String?

        public init(
            invert: Swift.Bool? = nil,
            match: AppMeshClientTypes.GrpcRouteMetadataMatchMethod? = nil,
            name: Swift.String? = nil
        )
        {
            self.invert = invert
            self.match = match
            self.name = name
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the criteria for determining a request match.
    public struct GrpcRouteMatch {
        /// An object that represents the data to match from the request.
        public var metadata: [AppMeshClientTypes.GrpcRouteMetadata]?
        /// The method name to match from the request. If you specify a name, you must also specify a serviceName.
        public var methodName: Swift.String?
        /// The port number to match on.
        public var port: Swift.Int?
        /// The fully qualified domain name for the service to match from the request.
        public var serviceName: Swift.String?

        public init(
            metadata: [AppMeshClientTypes.GrpcRouteMetadata]? = nil,
            methodName: Swift.String? = nil,
            port: Swift.Int? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.metadata = metadata
            self.methodName = methodName
            self.port = port
            self.serviceName = serviceName
        }
    }

}

extension AppMeshClientTypes {

    public enum GrpcRetryPolicyEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case deadlineExceeded
        case `internal`
        case resourceExhausted
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [GrpcRetryPolicyEvent] {
            return [
                .cancelled,
                .deadlineExceeded,
                .internal,
                .resourceExhausted,
                .unavailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "cancelled"
            case .deadlineExceeded: return "deadline-exceeded"
            case .internal: return "internal"
            case .resourceExhausted: return "resource-exhausted"
            case .unavailable: return "unavailable"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {

    public enum TcpRetryPolicyEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connectionError
        case sdkUnknown(Swift.String)

        public static var allCases: [TcpRetryPolicyEvent] {
            return [
                .connectionError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connectionError: return "connection-error"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents a retry policy. Specify at least one value for at least one of the types of RetryEvents, a value for maxRetries, and a value for perRetryTimeout. Both server-error and gateway-error under httpRetryEvents include the Envoy reset policy. For more information on the reset policy, see the [Envoy documentation](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on).
    public struct GrpcRetryPolicy {
        /// Specify at least one of the valid values.
        public var grpcRetryEvents: [AppMeshClientTypes.GrpcRetryPolicyEvent]?
        /// Specify at least one of the following values.
        ///
        /// * server-error – HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511
        ///
        /// * gateway-error – HTTP status codes 502, 503, and 504
        ///
        /// * client-error – HTTP status code 409
        ///
        /// * stream-error – Retry on refused stream
        public var httpRetryEvents: [Swift.String]?
        /// The maximum number of retry attempts.
        /// This member is required.
        public var maxRetries: Swift.Int?
        /// The timeout for each retry attempt.
        /// This member is required.
        public var perRetryTimeout: AppMeshClientTypes.Duration?
        /// Specify a valid value. The event occurs before any processing of a request has started and is encountered when the upstream is temporarily or permanently unavailable.
        public var tcpRetryEvents: [AppMeshClientTypes.TcpRetryPolicyEvent]?

        public init(
            grpcRetryEvents: [AppMeshClientTypes.GrpcRetryPolicyEvent]? = nil,
            httpRetryEvents: [Swift.String]? = nil,
            maxRetries: Swift.Int? = nil,
            perRetryTimeout: AppMeshClientTypes.Duration? = nil,
            tcpRetryEvents: [AppMeshClientTypes.TcpRetryPolicyEvent]? = nil
        )
        {
            self.grpcRetryEvents = grpcRetryEvents
            self.httpRetryEvents = httpRetryEvents
            self.maxRetries = maxRetries
            self.perRetryTimeout = perRetryTimeout
            self.tcpRetryEvents = tcpRetryEvents
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a gRPC route type.
    public struct GrpcRoute {
        /// An object that represents the action to take if a match is determined.
        /// This member is required.
        public var action: AppMeshClientTypes.GrpcRouteAction?
        /// An object that represents the criteria for determining a request match.
        /// This member is required.
        public var match: AppMeshClientTypes.GrpcRouteMatch?
        /// An object that represents a retry policy.
        public var retryPolicy: AppMeshClientTypes.GrpcRetryPolicy?
        /// An object that represents types of timeouts.
        public var timeout: AppMeshClientTypes.GrpcTimeout?

        public init(
            action: AppMeshClientTypes.GrpcRouteAction? = nil,
            match: AppMeshClientTypes.GrpcRouteMatch? = nil,
            retryPolicy: AppMeshClientTypes.GrpcRetryPolicy? = nil,
            timeout: AppMeshClientTypes.GrpcTimeout? = nil
        )
        {
            self.action = action
            self.match = match
            self.retryPolicy = retryPolicy
            self.timeout = timeout
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the action to take if a match is determined.
    public struct HttpRouteAction {
        /// An object that represents the targets that traffic is routed to when a request matches the route.
        /// This member is required.
        public var weightedTargets: [AppMeshClientTypes.WeightedTarget]?

        public init(
            weightedTargets: [AppMeshClientTypes.WeightedTarget]? = nil
        )
        {
            self.weightedTargets = weightedTargets
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the HTTP header in the request.
    public struct HttpRouteHeader {
        /// Specify True to match anything except the match criteria. The default value is False.
        public var invert: Swift.Bool?
        /// The HeaderMatchMethod object.
        public var match: AppMeshClientTypes.HeaderMatchMethod?
        /// A name for the HTTP header in the client request that will be matched on.
        /// This member is required.
        public var name: Swift.String?

        public init(
            invert: Swift.Bool? = nil,
            match: AppMeshClientTypes.HeaderMatchMethod? = nil,
            name: Swift.String? = nil
        )
        {
            self.invert = invert
            self.match = match
            self.name = name
        }
    }

}

extension AppMeshClientTypes {

    public enum HttpScheme: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case http
        case https
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpScheme] {
            return [
                .http,
                .https
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "http"
            case .https: return "https"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents the requirements for a route to match HTTP requests for a virtual router.
    public struct HttpRouteMatch {
        /// The client request headers to match on.
        public var headers: [AppMeshClientTypes.HttpRouteHeader]?
        /// The client request method to match on. Specify only one.
        public var method: AppMeshClientTypes.HttpMethod?
        /// The client request path to match on.
        public var path: AppMeshClientTypes.HttpPathMatch?
        /// The port number to match on.
        public var port: Swift.Int?
        /// Specifies the path to match requests with. This parameter must always start with /, which by itself matches all requests to the virtual service name. You can also match for path-based routing of requests. For example, if your virtual service name is my-service.local and you want the route to match requests to my-service.local/metrics, your prefix should be /metrics.
        public var `prefix`: Swift.String?
        /// The client request query parameters to match on.
        public var queryParameters: [AppMeshClientTypes.HttpQueryParameter]?
        /// The client request scheme to match on. Specify only one. Applicable only for HTTP2 routes.
        public var scheme: AppMeshClientTypes.HttpScheme?

        public init(
            headers: [AppMeshClientTypes.HttpRouteHeader]? = nil,
            method: AppMeshClientTypes.HttpMethod? = nil,
            path: AppMeshClientTypes.HttpPathMatch? = nil,
            port: Swift.Int? = nil,
            `prefix`: Swift.String? = nil,
            queryParameters: [AppMeshClientTypes.HttpQueryParameter]? = nil,
            scheme: AppMeshClientTypes.HttpScheme? = nil
        )
        {
            self.headers = headers
            self.method = method
            self.path = path
            self.port = port
            self.`prefix` = `prefix`
            self.queryParameters = queryParameters
            self.scheme = scheme
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a retry policy. Specify at least one value for at least one of the types of RetryEvents, a value for maxRetries, and a value for perRetryTimeout. Both server-error and gateway-error under httpRetryEvents include the Envoy reset policy. For more information on the reset policy, see the [Envoy documentation](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on).
    public struct HttpRetryPolicy {
        /// Specify at least one of the following values.
        ///
        /// * server-error – HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511
        ///
        /// * gateway-error – HTTP status codes 502, 503, and 504
        ///
        /// * client-error – HTTP status code 409
        ///
        /// * stream-error – Retry on refused stream
        public var httpRetryEvents: [Swift.String]?
        /// The maximum number of retry attempts.
        /// This member is required.
        public var maxRetries: Swift.Int?
        /// The timeout for each retry attempt.
        /// This member is required.
        public var perRetryTimeout: AppMeshClientTypes.Duration?
        /// Specify a valid value. The event occurs before any processing of a request has started and is encountered when the upstream is temporarily or permanently unavailable.
        public var tcpRetryEvents: [AppMeshClientTypes.TcpRetryPolicyEvent]?

        public init(
            httpRetryEvents: [Swift.String]? = nil,
            maxRetries: Swift.Int? = nil,
            perRetryTimeout: AppMeshClientTypes.Duration? = nil,
            tcpRetryEvents: [AppMeshClientTypes.TcpRetryPolicyEvent]? = nil
        )
        {
            self.httpRetryEvents = httpRetryEvents
            self.maxRetries = maxRetries
            self.perRetryTimeout = perRetryTimeout
            self.tcpRetryEvents = tcpRetryEvents
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents an HTTP or HTTP/2 route type.
    public struct HttpRoute {
        /// An object that represents the action to take if a match is determined.
        /// This member is required.
        public var action: AppMeshClientTypes.HttpRouteAction?
        /// An object that represents the criteria for determining a request match.
        /// This member is required.
        public var match: AppMeshClientTypes.HttpRouteMatch?
        /// An object that represents a retry policy.
        public var retryPolicy: AppMeshClientTypes.HttpRetryPolicy?
        /// An object that represents types of timeouts.
        public var timeout: AppMeshClientTypes.HttpTimeout?

        public init(
            action: AppMeshClientTypes.HttpRouteAction? = nil,
            match: AppMeshClientTypes.HttpRouteMatch? = nil,
            retryPolicy: AppMeshClientTypes.HttpRetryPolicy? = nil,
            timeout: AppMeshClientTypes.HttpTimeout? = nil
        )
        {
            self.action = action
            self.match = match
            self.retryPolicy = retryPolicy
            self.timeout = timeout
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the action to take if a match is determined.
    public struct TcpRouteAction {
        /// An object that represents the targets that traffic is routed to when a request matches the route.
        /// This member is required.
        public var weightedTargets: [AppMeshClientTypes.WeightedTarget]?

        public init(
            weightedTargets: [AppMeshClientTypes.WeightedTarget]? = nil
        )
        {
            self.weightedTargets = weightedTargets
        }
    }

}

extension AppMeshClientTypes {
    /// An object representing the TCP route to match.
    public struct TcpRouteMatch {
        /// The port number to match on.
        public var port: Swift.Int?

        public init(
            port: Swift.Int? = nil
        )
        {
            self.port = port
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a TCP route type.
    public struct TcpRoute {
        /// The action to take if a match is determined.
        /// This member is required.
        public var action: AppMeshClientTypes.TcpRouteAction?
        /// An object that represents the criteria for determining a request match.
        public var match: AppMeshClientTypes.TcpRouteMatch?
        /// An object that represents types of timeouts.
        public var timeout: AppMeshClientTypes.TcpTimeout?

        public init(
            action: AppMeshClientTypes.TcpRouteAction? = nil,
            match: AppMeshClientTypes.TcpRouteMatch? = nil,
            timeout: AppMeshClientTypes.TcpTimeout? = nil
        )
        {
            self.action = action
            self.match = match
            self.timeout = timeout
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a route specification. Specify one route type.
    public struct RouteSpec {
        /// An object that represents the specification of a gRPC route.
        public var grpcRoute: AppMeshClientTypes.GrpcRoute?
        /// An object that represents the specification of an HTTP/2 route.
        public var http2Route: AppMeshClientTypes.HttpRoute?
        /// An object that represents the specification of an HTTP route.
        public var httpRoute: AppMeshClientTypes.HttpRoute?
        /// The priority for the route. Routes are matched based on the specified value, where 0 is the highest priority.
        public var priority: Swift.Int?
        /// An object that represents the specification of a TCP route.
        public var tcpRoute: AppMeshClientTypes.TcpRoute?

        public init(
            grpcRoute: AppMeshClientTypes.GrpcRoute? = nil,
            http2Route: AppMeshClientTypes.HttpRoute? = nil,
            httpRoute: AppMeshClientTypes.HttpRoute? = nil,
            priority: Swift.Int? = nil,
            tcpRoute: AppMeshClientTypes.TcpRoute? = nil
        )
        {
            self.grpcRoute = grpcRoute
            self.http2Route = http2Route
            self.httpRoute = httpRoute
            self.priority = priority
            self.tcpRoute = tcpRoute
        }
    }

}

///
public struct CreateRouteInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh to create the route in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name to use for the route.
    /// This member is required.
    public var routeName: Swift.String?
    /// The route specification to apply.
    /// This member is required.
    public var spec: AppMeshClientTypes.RouteSpec?
    /// Optional metadata that you can apply to the route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [AppMeshClientTypes.TagRef]?
    /// The name of the virtual router in which to create the route. If the virtual router is in a shared mesh, then you must be the owner of the virtual router resource.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        routeName: Swift.String? = nil,
        spec: AppMeshClientTypes.RouteSpec? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.routeName = routeName
        self.spec = spec
        self.tags = tags
        self.virtualRouterName = virtualRouterName
    }
}

extension AppMeshClientTypes {

    public enum RouteStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteStatusCode] {
            return [
                .active,
                .deleted,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents the current status of a route.
    public struct RouteStatus {
        /// The current status for the route.
        /// This member is required.
        public var status: AppMeshClientTypes.RouteStatusCode?

        public init(
            status: AppMeshClientTypes.RouteStatusCode? = nil
        )
        {
            self.status = status
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a route returned by a describe operation.
    public struct RouteData {
        /// The name of the service mesh that the route resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The associated metadata for the route.
        /// This member is required.
        public var metadata: AppMeshClientTypes.ResourceMetadata?
        /// The name of the route.
        /// This member is required.
        public var routeName: Swift.String?
        /// The specifications of the route.
        /// This member is required.
        public var spec: AppMeshClientTypes.RouteSpec?
        /// The status of the route.
        /// This member is required.
        public var status: AppMeshClientTypes.RouteStatus?
        /// The virtual router that the route is associated with.
        /// This member is required.
        public var virtualRouterName: Swift.String?

        public init(
            meshName: Swift.String? = nil,
            metadata: AppMeshClientTypes.ResourceMetadata? = nil,
            routeName: Swift.String? = nil,
            spec: AppMeshClientTypes.RouteSpec? = nil,
            status: AppMeshClientTypes.RouteStatus? = nil,
            virtualRouterName: Swift.String? = nil
        )
        {
            self.meshName = meshName
            self.metadata = metadata
            self.routeName = routeName
            self.spec = spec
            self.status = status
            self.virtualRouterName = virtualRouterName
        }
    }

}

///
public struct CreateRouteOutput {
    /// The full description of your mesh following the create call.
    /// This member is required.
    public var route: AppMeshClientTypes.RouteData?

    public init(
        route: AppMeshClientTypes.RouteData? = nil
    )
    {
        self.route = route
    }
}

///
public struct DeleteRouteInput {
    /// The name of the service mesh to delete the route in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the route to delete.
    /// This member is required.
    public var routeName: Swift.String?
    /// The name of the virtual router to delete the route in.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init(
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        routeName: Swift.String? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.routeName = routeName
        self.virtualRouterName = virtualRouterName
    }
}

///
public struct DeleteRouteOutput {
    /// The route that was deleted.
    /// This member is required.
    public var route: AppMeshClientTypes.RouteData?

    public init(
        route: AppMeshClientTypes.RouteData? = nil
    )
    {
        self.route = route
    }
}

///
public struct DescribeRouteInput {
    /// The name of the service mesh that the route resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the route to describe.
    /// This member is required.
    public var routeName: Swift.String?
    /// The name of the virtual router that the route is associated with.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init(
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        routeName: Swift.String? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.routeName = routeName
        self.virtualRouterName = virtualRouterName
    }
}

///
public struct DescribeRouteOutput {
    /// The full description of your route.
    /// This member is required.
    public var route: AppMeshClientTypes.RouteData?

    public init(
        route: AppMeshClientTypes.RouteData? = nil
    )
    {
        self.route = route
    }
}

///
public struct ListRoutesInput {
    /// The maximum number of results returned by ListRoutes in paginated output. When you use this parameter, ListRoutes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListRoutes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListRoutes returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The name of the service mesh to list routes in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The nextToken value returned from a previous paginated ListRoutes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    public var nextToken: Swift.String?
    /// The name of the virtual router to list routes in.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
        self.virtualRouterName = virtualRouterName
    }
}

extension AppMeshClientTypes {
    /// An object that represents a route returned by a list operation.
    public struct RouteRef {
        /// The full Amazon Resource Name (ARN) for the route.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the service mesh that the route resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The name of the route.
        /// This member is required.
        public var routeName: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?
        /// The virtual router that the route is associated with.
        /// This member is required.
        public var virtualRouterName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            meshName: Swift.String? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            routeName: Swift.String? = nil,
            version: Swift.Int? = nil,
            virtualRouterName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.routeName = routeName
            self.version = version
            self.virtualRouterName = virtualRouterName
        }
    }

}

///
public struct ListRoutesOutput {
    /// The nextToken value to include in a future ListRoutes request. When the results of a ListRoutes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of existing routes for the specified service mesh and virtual router.
    /// This member is required.
    public var routes: [AppMeshClientTypes.RouteRef]?

    public init(
        nextToken: Swift.String? = nil,
        routes: [AppMeshClientTypes.RouteRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.routes = routes
    }
}

///
public struct UpdateRouteInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh that the route resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the route to update.
    /// This member is required.
    public var routeName: Swift.String?
    /// The new route specification to apply. This overwrites the existing data.
    /// This member is required.
    public var spec: AppMeshClientTypes.RouteSpec?
    /// The name of the virtual router that the route is associated with.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        routeName: Swift.String? = nil,
        spec: AppMeshClientTypes.RouteSpec? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.routeName = routeName
        self.spec = spec
        self.virtualRouterName = virtualRouterName
    }
}

///
public struct UpdateRouteOutput {
    /// A full description of the route that was updated.
    /// This member is required.
    public var route: AppMeshClientTypes.RouteData?

    public init(
        route: AppMeshClientTypes.RouteData? = nil
    )
    {
        self.route = route
    }
}

///
public struct UpdateVirtualRouterInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh that the virtual router resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The new virtual router specification to apply. This overwrites the existing data.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualRouterSpec?
    /// The name of the virtual router to update.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualRouterSpec? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualRouterName = virtualRouterName
    }
}

///
public struct UpdateVirtualRouterOutput {
    /// A full description of the virtual router that was updated.
    /// This member is required.
    public var virtualRouter: AppMeshClientTypes.VirtualRouterData?

    public init(
        virtualRouter: AppMeshClientTypes.VirtualRouterData? = nil
    )
    {
        self.virtualRouter = virtualRouter
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual node service provider.
    public struct VirtualNodeServiceProvider {
        /// The name of the virtual node that is acting as a service provider.
        /// This member is required.
        public var virtualNodeName: Swift.String?

        public init(
            virtualNodeName: Swift.String? = nil
        )
        {
            self.virtualNodeName = virtualNodeName
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a virtual node service provider.
    public struct VirtualRouterServiceProvider {
        /// The name of the virtual router that is acting as a service provider.
        /// This member is required.
        public var virtualRouterName: Swift.String?

        public init(
            virtualRouterName: Swift.String? = nil
        )
        {
            self.virtualRouterName = virtualRouterName
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents the provider for a virtual service.
    public enum VirtualServiceProvider {
        /// The virtual node associated with a virtual service.
        case virtualnode(AppMeshClientTypes.VirtualNodeServiceProvider)
        /// The virtual router associated with a virtual service.
        case virtualrouter(AppMeshClientTypes.VirtualRouterServiceProvider)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes {
    /// An object that represents the specification of a virtual service.
    public struct VirtualServiceSpec {
        /// The App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
        public var provider: AppMeshClientTypes.VirtualServiceProvider?

        public init(
            provider: AppMeshClientTypes.VirtualServiceProvider? = nil
        )
        {
            self.provider = provider
        }
    }

}

///
public struct CreateVirtualServiceInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh to create the virtual service in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The virtual service specification to apply.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualServiceSpec?
    /// Optional metadata that you can apply to the virtual service to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [AppMeshClientTypes.TagRef]?
    /// The name to use for the virtual service.
    /// This member is required.
    public var virtualServiceName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualServiceSpec? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil,
        virtualServiceName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualServiceName = virtualServiceName
    }
}

extension AppMeshClientTypes {

    public enum VirtualServiceStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualServiceStatusCode] {
            return [
                .active,
                .deleted,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppMeshClientTypes {
    /// An object that represents the status of a virtual service.
    public struct VirtualServiceStatus {
        /// The current status of the virtual service.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualServiceStatusCode?

        public init(
            status: AppMeshClientTypes.VirtualServiceStatusCode? = nil
        )
        {
            self.status = status
        }
    }

}

extension AppMeshClientTypes {
    /// An object that represents a virtual service returned by a describe operation.
    public struct VirtualServiceData {
        /// The name of the service mesh that the virtual service resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// An object that represents metadata for a resource.
        /// This member is required.
        public var metadata: AppMeshClientTypes.ResourceMetadata?
        /// The specifications of the virtual service.
        /// This member is required.
        public var spec: AppMeshClientTypes.VirtualServiceSpec?
        /// The current status of the virtual service.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualServiceStatus?
        /// The name of the virtual service.
        /// This member is required.
        public var virtualServiceName: Swift.String?

        public init(
            meshName: Swift.String? = nil,
            metadata: AppMeshClientTypes.ResourceMetadata? = nil,
            spec: AppMeshClientTypes.VirtualServiceSpec? = nil,
            status: AppMeshClientTypes.VirtualServiceStatus? = nil,
            virtualServiceName: Swift.String? = nil
        )
        {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualServiceName = virtualServiceName
        }
    }

}

///
public struct CreateVirtualServiceOutput {
    /// The full description of your virtual service following the create call.
    /// This member is required.
    public var virtualService: AppMeshClientTypes.VirtualServiceData?

    public init(
        virtualService: AppMeshClientTypes.VirtualServiceData? = nil
    )
    {
        self.virtualService = virtualService
    }
}

///
public struct DeleteVirtualServiceInput {
    /// The name of the service mesh to delete the virtual service in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual service to delete.
    /// This member is required.
    public var virtualServiceName: Swift.String?

    public init(
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualServiceName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualServiceName = virtualServiceName
    }
}

///
public struct DeleteVirtualServiceOutput {
    /// The virtual service that was deleted.
    /// This member is required.
    public var virtualService: AppMeshClientTypes.VirtualServiceData?

    public init(
        virtualService: AppMeshClientTypes.VirtualServiceData? = nil
    )
    {
        self.virtualService = virtualService
    }
}

///
public struct DescribeVirtualServiceInput {
    /// The name of the service mesh that the virtual service resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual service to describe.
    /// This member is required.
    public var virtualServiceName: Swift.String?

    public init(
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualServiceName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualServiceName = virtualServiceName
    }
}

///
public struct DescribeVirtualServiceOutput {
    /// The full description of your virtual service.
    /// This member is required.
    public var virtualService: AppMeshClientTypes.VirtualServiceData?

    public init(
        virtualService: AppMeshClientTypes.VirtualServiceData? = nil
    )
    {
        self.virtualService = virtualService
    }
}

///
public struct ListVirtualServicesInput {
    /// The maximum number of results returned by ListVirtualServices in paginated output. When you use this parameter, ListVirtualServices returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualServices request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualServices returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The name of the service mesh to list virtual services in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The nextToken value returned from a previous paginated ListVirtualServices request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    public var nextToken: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual service returned by a list operation.
    public struct VirtualServiceRef {
        /// The full Amazon Resource Name (ARN) for the virtual service.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the service mesh that the virtual service resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?
        /// The name of the virtual service.
        /// This member is required.
        public var virtualServiceName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            meshName: Swift.String? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            version: Swift.Int? = nil,
            virtualServiceName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualServiceName = virtualServiceName
        }
    }

}

///
public struct ListVirtualServicesOutput {
    /// The nextToken value to include in a future ListVirtualServices request. When the results of a ListVirtualServices request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of existing virtual services for the specified service mesh.
    /// This member is required.
    public var virtualServices: [AppMeshClientTypes.VirtualServiceRef]?

    public init(
        nextToken: Swift.String? = nil,
        virtualServices: [AppMeshClientTypes.VirtualServiceRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualServices = virtualServices
    }
}

///
public struct UpdateVirtualServiceInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh that the virtual service resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The new virtual service specification to apply. This overwrites the existing data.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualServiceSpec?
    /// The name of the virtual service to update.
    /// This member is required.
    public var virtualServiceName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualServiceSpec? = nil,
        virtualServiceName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualServiceName = virtualServiceName
    }
}

///
public struct UpdateVirtualServiceOutput {
    /// A full description of the virtual service that was updated.
    /// This member is required.
    public var virtualService: AppMeshClientTypes.VirtualServiceData?

    public init(
        virtualService: AppMeshClientTypes.VirtualServiceData? = nil
    )
    {
        self.virtualService = virtualService
    }
}

/// The request exceeds the maximum allowed number of tags allowed per resource. The current limit is 50 user tags per resource. You must reduce the number of tags in the request. None of the tags in this request were applied.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to add tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    /// This member is required.
    public var tags: [AppMeshClientTypes.TagRef]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

///
public struct TagResourceOutput {

    public init() { }
}

///
public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to delete tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

///
public struct UntagResourceOutput {

    public init() { }
}

extension CreateGatewayRouteInput {

    static func urlPathProvider(_ value: CreateGatewayRouteInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualGatewayName = value.virtualGatewayName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateway/\(virtualGatewayName.urlPercentEncoding())/gatewayRoutes"
    }
}

extension CreateGatewayRouteInput {

    static func queryItemProvider(_ value: CreateGatewayRouteInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension CreateMeshInput {

    static func urlPathProvider(_ value: CreateMeshInput) -> Swift.String? {
        return "/v20190125/meshes"
    }
}

extension CreateRouteInput {

    static func urlPathProvider(_ value: CreateRouteInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualRouterName = value.virtualRouterName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouter/\(virtualRouterName.urlPercentEncoding())/routes"
    }
}

extension CreateRouteInput {

    static func queryItemProvider(_ value: CreateRouteInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension CreateVirtualGatewayInput {

    static func urlPathProvider(_ value: CreateVirtualGatewayInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateways"
    }
}

extension CreateVirtualGatewayInput {

    static func queryItemProvider(_ value: CreateVirtualGatewayInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension CreateVirtualNodeInput {

    static func urlPathProvider(_ value: CreateVirtualNodeInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualNodes"
    }
}

extension CreateVirtualNodeInput {

    static func queryItemProvider(_ value: CreateVirtualNodeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension CreateVirtualRouterInput {

    static func urlPathProvider(_ value: CreateVirtualRouterInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouters"
    }
}

extension CreateVirtualRouterInput {

    static func queryItemProvider(_ value: CreateVirtualRouterInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension CreateVirtualServiceInput {

    static func urlPathProvider(_ value: CreateVirtualServiceInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualServices"
    }
}

extension CreateVirtualServiceInput {

    static func queryItemProvider(_ value: CreateVirtualServiceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension DeleteGatewayRouteInput {

    static func urlPathProvider(_ value: DeleteGatewayRouteInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualGatewayName = value.virtualGatewayName else {
            return nil
        }
        guard let gatewayRouteName = value.gatewayRouteName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateway/\(virtualGatewayName.urlPercentEncoding())/gatewayRoutes/\(gatewayRouteName.urlPercentEncoding())"
    }
}

extension DeleteGatewayRouteInput {

    static func queryItemProvider(_ value: DeleteGatewayRouteInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension DeleteMeshInput {

    static func urlPathProvider(_ value: DeleteMeshInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())"
    }
}

extension DeleteRouteInput {

    static func urlPathProvider(_ value: DeleteRouteInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualRouterName = value.virtualRouterName else {
            return nil
        }
        guard let routeName = value.routeName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouter/\(virtualRouterName.urlPercentEncoding())/routes/\(routeName.urlPercentEncoding())"
    }
}

extension DeleteRouteInput {

    static func queryItemProvider(_ value: DeleteRouteInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension DeleteVirtualGatewayInput {

    static func urlPathProvider(_ value: DeleteVirtualGatewayInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualGatewayName = value.virtualGatewayName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateways/\(virtualGatewayName.urlPercentEncoding())"
    }
}

extension DeleteVirtualGatewayInput {

    static func queryItemProvider(_ value: DeleteVirtualGatewayInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension DeleteVirtualNodeInput {

    static func urlPathProvider(_ value: DeleteVirtualNodeInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualNodeName = value.virtualNodeName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualNodes/\(virtualNodeName.urlPercentEncoding())"
    }
}

extension DeleteVirtualNodeInput {

    static func queryItemProvider(_ value: DeleteVirtualNodeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension DeleteVirtualRouterInput {

    static func urlPathProvider(_ value: DeleteVirtualRouterInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualRouterName = value.virtualRouterName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouters/\(virtualRouterName.urlPercentEncoding())"
    }
}

extension DeleteVirtualRouterInput {

    static func queryItemProvider(_ value: DeleteVirtualRouterInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension DeleteVirtualServiceInput {

    static func urlPathProvider(_ value: DeleteVirtualServiceInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualServiceName = value.virtualServiceName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualServices/\(virtualServiceName.urlPercentEncoding())"
    }
}

extension DeleteVirtualServiceInput {

    static func queryItemProvider(_ value: DeleteVirtualServiceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension DescribeGatewayRouteInput {

    static func urlPathProvider(_ value: DescribeGatewayRouteInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualGatewayName = value.virtualGatewayName else {
            return nil
        }
        guard let gatewayRouteName = value.gatewayRouteName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateway/\(virtualGatewayName.urlPercentEncoding())/gatewayRoutes/\(gatewayRouteName.urlPercentEncoding())"
    }
}

extension DescribeGatewayRouteInput {

    static func queryItemProvider(_ value: DescribeGatewayRouteInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension DescribeMeshInput {

    static func urlPathProvider(_ value: DescribeMeshInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())"
    }
}

extension DescribeMeshInput {

    static func queryItemProvider(_ value: DescribeMeshInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension DescribeRouteInput {

    static func urlPathProvider(_ value: DescribeRouteInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualRouterName = value.virtualRouterName else {
            return nil
        }
        guard let routeName = value.routeName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouter/\(virtualRouterName.urlPercentEncoding())/routes/\(routeName.urlPercentEncoding())"
    }
}

extension DescribeRouteInput {

    static func queryItemProvider(_ value: DescribeRouteInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension DescribeVirtualGatewayInput {

    static func urlPathProvider(_ value: DescribeVirtualGatewayInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualGatewayName = value.virtualGatewayName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateways/\(virtualGatewayName.urlPercentEncoding())"
    }
}

extension DescribeVirtualGatewayInput {

    static func queryItemProvider(_ value: DescribeVirtualGatewayInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension DescribeVirtualNodeInput {

    static func urlPathProvider(_ value: DescribeVirtualNodeInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualNodeName = value.virtualNodeName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualNodes/\(virtualNodeName.urlPercentEncoding())"
    }
}

extension DescribeVirtualNodeInput {

    static func queryItemProvider(_ value: DescribeVirtualNodeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension DescribeVirtualRouterInput {

    static func urlPathProvider(_ value: DescribeVirtualRouterInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualRouterName = value.virtualRouterName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouters/\(virtualRouterName.urlPercentEncoding())"
    }
}

extension DescribeVirtualRouterInput {

    static func queryItemProvider(_ value: DescribeVirtualRouterInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension DescribeVirtualServiceInput {

    static func urlPathProvider(_ value: DescribeVirtualServiceInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualServiceName = value.virtualServiceName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualServices/\(virtualServiceName.urlPercentEncoding())"
    }
}

extension DescribeVirtualServiceInput {

    static func queryItemProvider(_ value: DescribeVirtualServiceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension ListGatewayRoutesInput {

    static func urlPathProvider(_ value: ListGatewayRoutesInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualGatewayName = value.virtualGatewayName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateway/\(virtualGatewayName.urlPercentEncoding())/gatewayRoutes"
    }
}

extension ListGatewayRoutesInput {

    static func queryItemProvider(_ value: ListGatewayRoutesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension ListMeshesInput {

    static func urlPathProvider(_ value: ListMeshesInput) -> Swift.String? {
        return "/v20190125/meshes"
    }
}

extension ListMeshesInput {

    static func queryItemProvider(_ value: ListMeshesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListRoutesInput {

    static func urlPathProvider(_ value: ListRoutesInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualRouterName = value.virtualRouterName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouter/\(virtualRouterName.urlPercentEncoding())/routes"
    }
}

extension ListRoutesInput {

    static func queryItemProvider(_ value: ListRoutesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/v20190125/tags"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension ListVirtualGatewaysInput {

    static func urlPathProvider(_ value: ListVirtualGatewaysInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateways"
    }
}

extension ListVirtualGatewaysInput {

    static func queryItemProvider(_ value: ListVirtualGatewaysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension ListVirtualNodesInput {

    static func urlPathProvider(_ value: ListVirtualNodesInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualNodes"
    }
}

extension ListVirtualNodesInput {

    static func queryItemProvider(_ value: ListVirtualNodesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension ListVirtualRoutersInput {

    static func urlPathProvider(_ value: ListVirtualRoutersInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouters"
    }
}

extension ListVirtualRoutersInput {

    static func queryItemProvider(_ value: ListVirtualRoutersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension ListVirtualServicesInput {

    static func urlPathProvider(_ value: ListVirtualServicesInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualServices"
    }
}

extension ListVirtualServicesInput {

    static func queryItemProvider(_ value: ListVirtualServicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/v20190125/tag"
    }
}

extension TagResourceInput {

    static func queryItemProvider(_ value: TagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/v20190125/untag"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension UpdateGatewayRouteInput {

    static func urlPathProvider(_ value: UpdateGatewayRouteInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualGatewayName = value.virtualGatewayName else {
            return nil
        }
        guard let gatewayRouteName = value.gatewayRouteName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateway/\(virtualGatewayName.urlPercentEncoding())/gatewayRoutes/\(gatewayRouteName.urlPercentEncoding())"
    }
}

extension UpdateGatewayRouteInput {

    static func queryItemProvider(_ value: UpdateGatewayRouteInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension UpdateMeshInput {

    static func urlPathProvider(_ value: UpdateMeshInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())"
    }
}

extension UpdateRouteInput {

    static func urlPathProvider(_ value: UpdateRouteInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualRouterName = value.virtualRouterName else {
            return nil
        }
        guard let routeName = value.routeName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouter/\(virtualRouterName.urlPercentEncoding())/routes/\(routeName.urlPercentEncoding())"
    }
}

extension UpdateRouteInput {

    static func queryItemProvider(_ value: UpdateRouteInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension UpdateVirtualGatewayInput {

    static func urlPathProvider(_ value: UpdateVirtualGatewayInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualGatewayName = value.virtualGatewayName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateways/\(virtualGatewayName.urlPercentEncoding())"
    }
}

extension UpdateVirtualGatewayInput {

    static func queryItemProvider(_ value: UpdateVirtualGatewayInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension UpdateVirtualNodeInput {

    static func urlPathProvider(_ value: UpdateVirtualNodeInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualNodeName = value.virtualNodeName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualNodes/\(virtualNodeName.urlPercentEncoding())"
    }
}

extension UpdateVirtualNodeInput {

    static func queryItemProvider(_ value: UpdateVirtualNodeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension UpdateVirtualRouterInput {

    static func urlPathProvider(_ value: UpdateVirtualRouterInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualRouterName = value.virtualRouterName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouters/\(virtualRouterName.urlPercentEncoding())"
    }
}

extension UpdateVirtualRouterInput {

    static func queryItemProvider(_ value: UpdateVirtualRouterInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension UpdateVirtualServiceInput {

    static func urlPathProvider(_ value: UpdateVirtualServiceInput) -> Swift.String? {
        guard let meshName = value.meshName else {
            return nil
        }
        guard let virtualServiceName = value.virtualServiceName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualServices/\(virtualServiceName.urlPercentEncoding())"
    }
}

extension UpdateVirtualServiceInput {

    static func queryItemProvider(_ value: UpdateVirtualServiceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let meshOwner = value.meshOwner {
            let meshOwnerQueryItem = Smithy.URIQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
            items.append(meshOwnerQueryItem)
        }
        return items
    }
}

extension CreateGatewayRouteInput {

    static func write(value: CreateGatewayRouteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["gatewayRouteName"].write(value.gatewayRouteName)
        try writer["spec"].write(value.spec, with: AppMeshClientTypes.GatewayRouteSpec.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppMeshClientTypes.TagRef.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMeshInput {

    static func write(value: CreateMeshInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["meshName"].write(value.meshName)
        try writer["spec"].write(value.spec, with: AppMeshClientTypes.MeshSpec.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppMeshClientTypes.TagRef.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateRouteInput {

    static func write(value: CreateRouteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["routeName"].write(value.routeName)
        try writer["spec"].write(value.spec, with: AppMeshClientTypes.RouteSpec.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppMeshClientTypes.TagRef.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateVirtualGatewayInput {

    static func write(value: CreateVirtualGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["spec"].write(value.spec, with: AppMeshClientTypes.VirtualGatewaySpec.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppMeshClientTypes.TagRef.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["virtualGatewayName"].write(value.virtualGatewayName)
    }
}

extension CreateVirtualNodeInput {

    static func write(value: CreateVirtualNodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["spec"].write(value.spec, with: AppMeshClientTypes.VirtualNodeSpec.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppMeshClientTypes.TagRef.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["virtualNodeName"].write(value.virtualNodeName)
    }
}

extension CreateVirtualRouterInput {

    static func write(value: CreateVirtualRouterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["spec"].write(value.spec, with: AppMeshClientTypes.VirtualRouterSpec.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppMeshClientTypes.TagRef.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["virtualRouterName"].write(value.virtualRouterName)
    }
}

extension CreateVirtualServiceInput {

    static func write(value: CreateVirtualServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["spec"].write(value.spec, with: AppMeshClientTypes.VirtualServiceSpec.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppMeshClientTypes.TagRef.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["virtualServiceName"].write(value.virtualServiceName)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppMeshClientTypes.TagRef.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateGatewayRouteInput {

    static func write(value: UpdateGatewayRouteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["spec"].write(value.spec, with: AppMeshClientTypes.GatewayRouteSpec.write(value:to:))
    }
}

extension UpdateMeshInput {

    static func write(value: UpdateMeshInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["spec"].write(value.spec, with: AppMeshClientTypes.MeshSpec.write(value:to:))
    }
}

extension UpdateRouteInput {

    static func write(value: UpdateRouteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["spec"].write(value.spec, with: AppMeshClientTypes.RouteSpec.write(value:to:))
    }
}

extension UpdateVirtualGatewayInput {

    static func write(value: UpdateVirtualGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["spec"].write(value.spec, with: AppMeshClientTypes.VirtualGatewaySpec.write(value:to:))
    }
}

extension UpdateVirtualNodeInput {

    static func write(value: UpdateVirtualNodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["spec"].write(value.spec, with: AppMeshClientTypes.VirtualNodeSpec.write(value:to:))
    }
}

extension UpdateVirtualRouterInput {

    static func write(value: UpdateVirtualRouterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["spec"].write(value.spec, with: AppMeshClientTypes.VirtualRouterSpec.write(value:to:))
    }
}

extension UpdateVirtualServiceInput {

    static func write(value: UpdateVirtualServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["spec"].write(value.spec, with: AppMeshClientTypes.VirtualServiceSpec.write(value:to:))
    }
}

extension CreateGatewayRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGatewayRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGatewayRouteOutput()
        value.gatewayRoute = try reader.readIfPresent(with: AppMeshClientTypes.GatewayRouteData.read(from:))
        return value
    }
}

extension CreateMeshOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMeshOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMeshOutput()
        value.mesh = try reader.readIfPresent(with: AppMeshClientTypes.MeshData.read(from:))
        return value
    }
}

extension CreateRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRouteOutput()
        value.route = try reader.readIfPresent(with: AppMeshClientTypes.RouteData.read(from:))
        return value
    }
}

extension CreateVirtualGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVirtualGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVirtualGatewayOutput()
        value.virtualGateway = try reader.readIfPresent(with: AppMeshClientTypes.VirtualGatewayData.read(from:))
        return value
    }
}

extension CreateVirtualNodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVirtualNodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVirtualNodeOutput()
        value.virtualNode = try reader.readIfPresent(with: AppMeshClientTypes.VirtualNodeData.read(from:))
        return value
    }
}

extension CreateVirtualRouterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVirtualRouterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVirtualRouterOutput()
        value.virtualRouter = try reader.readIfPresent(with: AppMeshClientTypes.VirtualRouterData.read(from:))
        return value
    }
}

extension CreateVirtualServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVirtualServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVirtualServiceOutput()
        value.virtualService = try reader.readIfPresent(with: AppMeshClientTypes.VirtualServiceData.read(from:))
        return value
    }
}

extension DeleteGatewayRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGatewayRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGatewayRouteOutput()
        value.gatewayRoute = try reader.readIfPresent(with: AppMeshClientTypes.GatewayRouteData.read(from:))
        return value
    }
}

extension DeleteMeshOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMeshOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteMeshOutput()
        value.mesh = try reader.readIfPresent(with: AppMeshClientTypes.MeshData.read(from:))
        return value
    }
}

extension DeleteRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRouteOutput()
        value.route = try reader.readIfPresent(with: AppMeshClientTypes.RouteData.read(from:))
        return value
    }
}

extension DeleteVirtualGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVirtualGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVirtualGatewayOutput()
        value.virtualGateway = try reader.readIfPresent(with: AppMeshClientTypes.VirtualGatewayData.read(from:))
        return value
    }
}

extension DeleteVirtualNodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVirtualNodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVirtualNodeOutput()
        value.virtualNode = try reader.readIfPresent(with: AppMeshClientTypes.VirtualNodeData.read(from:))
        return value
    }
}

extension DeleteVirtualRouterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVirtualRouterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVirtualRouterOutput()
        value.virtualRouter = try reader.readIfPresent(with: AppMeshClientTypes.VirtualRouterData.read(from:))
        return value
    }
}

extension DeleteVirtualServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVirtualServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVirtualServiceOutput()
        value.virtualService = try reader.readIfPresent(with: AppMeshClientTypes.VirtualServiceData.read(from:))
        return value
    }
}

extension DescribeGatewayRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeGatewayRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGatewayRouteOutput()
        value.gatewayRoute = try reader.readIfPresent(with: AppMeshClientTypes.GatewayRouteData.read(from:))
        return value
    }
}

extension DescribeMeshOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMeshOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMeshOutput()
        value.mesh = try reader.readIfPresent(with: AppMeshClientTypes.MeshData.read(from:))
        return value
    }
}

extension DescribeRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRouteOutput()
        value.route = try reader.readIfPresent(with: AppMeshClientTypes.RouteData.read(from:))
        return value
    }
}

extension DescribeVirtualGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVirtualGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVirtualGatewayOutput()
        value.virtualGateway = try reader.readIfPresent(with: AppMeshClientTypes.VirtualGatewayData.read(from:))
        return value
    }
}

extension DescribeVirtualNodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVirtualNodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVirtualNodeOutput()
        value.virtualNode = try reader.readIfPresent(with: AppMeshClientTypes.VirtualNodeData.read(from:))
        return value
    }
}

extension DescribeVirtualRouterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVirtualRouterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVirtualRouterOutput()
        value.virtualRouter = try reader.readIfPresent(with: AppMeshClientTypes.VirtualRouterData.read(from:))
        return value
    }
}

extension DescribeVirtualServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVirtualServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVirtualServiceOutput()
        value.virtualService = try reader.readIfPresent(with: AppMeshClientTypes.VirtualServiceData.read(from:))
        return value
    }
}

extension ListGatewayRoutesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGatewayRoutesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGatewayRoutesOutput()
        value.gatewayRoutes = try reader["gatewayRoutes"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.GatewayRouteRef.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMeshesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMeshesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMeshesOutput()
        value.meshes = try reader["meshes"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.MeshRef.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListRoutesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRoutesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRoutesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.routes = try reader["routes"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.RouteRef.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.TagRef.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListVirtualGatewaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVirtualGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVirtualGatewaysOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.virtualGateways = try reader["virtualGateways"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.VirtualGatewayRef.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListVirtualNodesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVirtualNodesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVirtualNodesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.virtualNodes = try reader["virtualNodes"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.VirtualNodeRef.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListVirtualRoutersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVirtualRoutersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVirtualRoutersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.virtualRouters = try reader["virtualRouters"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.VirtualRouterRef.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListVirtualServicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVirtualServicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVirtualServicesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.virtualServices = try reader["virtualServices"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.VirtualServiceRef.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateGatewayRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGatewayRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGatewayRouteOutput()
        value.gatewayRoute = try reader.readIfPresent(with: AppMeshClientTypes.GatewayRouteData.read(from:))
        return value
    }
}

extension UpdateMeshOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMeshOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMeshOutput()
        value.mesh = try reader.readIfPresent(with: AppMeshClientTypes.MeshData.read(from:))
        return value
    }
}

extension UpdateRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRouteOutput()
        value.route = try reader.readIfPresent(with: AppMeshClientTypes.RouteData.read(from:))
        return value
    }
}

extension UpdateVirtualGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVirtualGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVirtualGatewayOutput()
        value.virtualGateway = try reader.readIfPresent(with: AppMeshClientTypes.VirtualGatewayData.read(from:))
        return value
    }
}

extension UpdateVirtualNodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVirtualNodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVirtualNodeOutput()
        value.virtualNode = try reader.readIfPresent(with: AppMeshClientTypes.VirtualNodeData.read(from:))
        return value
    }
}

extension UpdateVirtualRouterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVirtualRouterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVirtualRouterOutput()
        value.virtualRouter = try reader.readIfPresent(with: AppMeshClientTypes.VirtualRouterData.read(from:))
        return value
    }
}

extension UpdateVirtualServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVirtualServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVirtualServiceOutput()
        value.virtualService = try reader.readIfPresent(with: AppMeshClientTypes.VirtualServiceData.read(from:))
        return value
    }
}

enum CreateGatewayRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMeshOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVirtualGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVirtualNodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVirtualRouterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVirtualServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGatewayRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMeshOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVirtualGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVirtualNodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVirtualRouterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVirtualServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeGatewayRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMeshOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVirtualGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVirtualNodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVirtualRouterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVirtualServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGatewayRoutesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMeshesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRoutesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVirtualGatewaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVirtualNodesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVirtualRoutersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVirtualServicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGatewayRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMeshOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVirtualGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVirtualNodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVirtualRouterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVirtualServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AppMeshClientTypes.GatewayRouteData {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GatewayRouteData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GatewayRouteData()
        value.meshName = try reader["meshName"].readIfPresent() ?? ""
        value.gatewayRouteName = try reader["gatewayRouteName"].readIfPresent() ?? ""
        value.virtualGatewayName = try reader["virtualGatewayName"].readIfPresent() ?? ""
        value.spec = try reader["spec"].readIfPresent(with: AppMeshClientTypes.GatewayRouteSpec.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: AppMeshClientTypes.ResourceMetadata.read(from:))
        value.status = try reader["status"].readIfPresent(with: AppMeshClientTypes.GatewayRouteStatus.read(from:))
        return value
    }
}

extension AppMeshClientTypes.GatewayRouteStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GatewayRouteStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GatewayRouteStatus()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppMeshClientTypes.ResourceMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.ResourceMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.ResourceMetadata()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? 0
        value.uid = try reader["uid"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.meshOwner = try reader["meshOwner"].readIfPresent() ?? ""
        value.resourceOwner = try reader["resourceOwner"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.GatewayRouteSpec {

    static func write(value: AppMeshClientTypes.GatewayRouteSpec?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["grpcRoute"].write(value.grpcRoute, with: AppMeshClientTypes.GrpcGatewayRoute.write(value:to:))
        try writer["http2Route"].write(value.http2Route, with: AppMeshClientTypes.HttpGatewayRoute.write(value:to:))
        try writer["httpRoute"].write(value.httpRoute, with: AppMeshClientTypes.HttpGatewayRoute.write(value:to:))
        try writer["priority"].write(value.priority)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GatewayRouteSpec {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GatewayRouteSpec()
        value.priority = try reader["priority"].readIfPresent()
        value.httpRoute = try reader["httpRoute"].readIfPresent(with: AppMeshClientTypes.HttpGatewayRoute.read(from:))
        value.http2Route = try reader["http2Route"].readIfPresent(with: AppMeshClientTypes.HttpGatewayRoute.read(from:))
        value.grpcRoute = try reader["grpcRoute"].readIfPresent(with: AppMeshClientTypes.GrpcGatewayRoute.read(from:))
        return value
    }
}

extension AppMeshClientTypes.GrpcGatewayRoute {

    static func write(value: AppMeshClientTypes.GrpcGatewayRoute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: AppMeshClientTypes.GrpcGatewayRouteAction.write(value:to:))
        try writer["match"].write(value.match, with: AppMeshClientTypes.GrpcGatewayRouteMatch.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GrpcGatewayRoute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GrpcGatewayRoute()
        value.match = try reader["match"].readIfPresent(with: AppMeshClientTypes.GrpcGatewayRouteMatch.read(from:))
        value.action = try reader["action"].readIfPresent(with: AppMeshClientTypes.GrpcGatewayRouteAction.read(from:))
        return value
    }
}

extension AppMeshClientTypes.GrpcGatewayRouteAction {

    static func write(value: AppMeshClientTypes.GrpcGatewayRouteAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rewrite"].write(value.rewrite, with: AppMeshClientTypes.GrpcGatewayRouteRewrite.write(value:to:))
        try writer["target"].write(value.target, with: AppMeshClientTypes.GatewayRouteTarget.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GrpcGatewayRouteAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GrpcGatewayRouteAction()
        value.target = try reader["target"].readIfPresent(with: AppMeshClientTypes.GatewayRouteTarget.read(from:))
        value.rewrite = try reader["rewrite"].readIfPresent(with: AppMeshClientTypes.GrpcGatewayRouteRewrite.read(from:))
        return value
    }
}

extension AppMeshClientTypes.GrpcGatewayRouteRewrite {

    static func write(value: AppMeshClientTypes.GrpcGatewayRouteRewrite?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["hostname"].write(value.hostname, with: AppMeshClientTypes.GatewayRouteHostnameRewrite.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GrpcGatewayRouteRewrite {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GrpcGatewayRouteRewrite()
        value.hostname = try reader["hostname"].readIfPresent(with: AppMeshClientTypes.GatewayRouteHostnameRewrite.read(from:))
        return value
    }
}

extension AppMeshClientTypes.GatewayRouteHostnameRewrite {

    static func write(value: AppMeshClientTypes.GatewayRouteHostnameRewrite?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultTargetHostname"].write(value.defaultTargetHostname)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GatewayRouteHostnameRewrite {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GatewayRouteHostnameRewrite()
        value.defaultTargetHostname = try reader["defaultTargetHostname"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.GatewayRouteTarget {

    static func write(value: AppMeshClientTypes.GatewayRouteTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["port"].write(value.port)
        try writer["virtualService"].write(value.virtualService, with: AppMeshClientTypes.GatewayRouteVirtualService.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GatewayRouteTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GatewayRouteTarget()
        value.virtualService = try reader["virtualService"].readIfPresent(with: AppMeshClientTypes.GatewayRouteVirtualService.read(from:))
        value.port = try reader["port"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.GatewayRouteVirtualService {

    static func write(value: AppMeshClientTypes.GatewayRouteVirtualService?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["virtualServiceName"].write(value.virtualServiceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GatewayRouteVirtualService {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GatewayRouteVirtualService()
        value.virtualServiceName = try reader["virtualServiceName"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.GrpcGatewayRouteMatch {

    static func write(value: AppMeshClientTypes.GrpcGatewayRouteMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["hostname"].write(value.hostname, with: AppMeshClientTypes.GatewayRouteHostnameMatch.write(value:to:))
        try writer["metadata"].writeList(value.metadata, memberWritingClosure: AppMeshClientTypes.GrpcGatewayRouteMetadata.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["port"].write(value.port)
        try writer["serviceName"].write(value.serviceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GrpcGatewayRouteMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GrpcGatewayRouteMatch()
        value.serviceName = try reader["serviceName"].readIfPresent()
        value.hostname = try reader["hostname"].readIfPresent(with: AppMeshClientTypes.GatewayRouteHostnameMatch.read(from:))
        value.metadata = try reader["metadata"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.GrpcGatewayRouteMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.port = try reader["port"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.GrpcGatewayRouteMetadata {

    static func write(value: AppMeshClientTypes.GrpcGatewayRouteMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invert"].write(value.invert)
        try writer["match"].write(value.match, with: AppMeshClientTypes.GrpcMetadataMatchMethod.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GrpcGatewayRouteMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GrpcGatewayRouteMetadata()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.invert = try reader["invert"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: AppMeshClientTypes.GrpcMetadataMatchMethod.read(from:))
        return value
    }
}

extension AppMeshClientTypes.GrpcMetadataMatchMethod {

    static func write(value: AppMeshClientTypes.GrpcMetadataMatchMethod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .exact(exact):
                try writer["exact"].write(exact)
            case let .`prefix`(`prefix`):
                try writer["prefix"].write(`prefix`)
            case let .range(range):
                try writer["range"].write(range, with: AppMeshClientTypes.MatchRange.write(value:to:))
            case let .regex(regex):
                try writer["regex"].write(regex)
            case let .suffix(suffix):
                try writer["suffix"].write(suffix)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GrpcMetadataMatchMethod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "exact":
                return .exact(try reader["exact"].read())
            case "regex":
                return .regex(try reader["regex"].read())
            case "range":
                return .range(try reader["range"].read(with: AppMeshClientTypes.MatchRange.read(from:)))
            case "prefix":
                return .`prefix`(try reader["prefix"].read())
            case "suffix":
                return .suffix(try reader["suffix"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.MatchRange {

    static func write(value: AppMeshClientTypes.MatchRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["end"].write(value.end)
        try writer["start"].write(value.start)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.MatchRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.MatchRange()
        value.start = try reader["start"].readIfPresent() ?? 0
        value.end = try reader["end"].readIfPresent() ?? 0
        return value
    }
}

extension AppMeshClientTypes.GatewayRouteHostnameMatch {

    static func write(value: AppMeshClientTypes.GatewayRouteHostnameMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exact"].write(value.exact)
        try writer["suffix"].write(value.suffix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GatewayRouteHostnameMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GatewayRouteHostnameMatch()
        value.exact = try reader["exact"].readIfPresent()
        value.suffix = try reader["suffix"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.HttpGatewayRoute {

    static func write(value: AppMeshClientTypes.HttpGatewayRoute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: AppMeshClientTypes.HttpGatewayRouteAction.write(value:to:))
        try writer["match"].write(value.match, with: AppMeshClientTypes.HttpGatewayRouteMatch.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpGatewayRoute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpGatewayRoute()
        value.match = try reader["match"].readIfPresent(with: AppMeshClientTypes.HttpGatewayRouteMatch.read(from:))
        value.action = try reader["action"].readIfPresent(with: AppMeshClientTypes.HttpGatewayRouteAction.read(from:))
        return value
    }
}

extension AppMeshClientTypes.HttpGatewayRouteAction {

    static func write(value: AppMeshClientTypes.HttpGatewayRouteAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rewrite"].write(value.rewrite, with: AppMeshClientTypes.HttpGatewayRouteRewrite.write(value:to:))
        try writer["target"].write(value.target, with: AppMeshClientTypes.GatewayRouteTarget.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpGatewayRouteAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpGatewayRouteAction()
        value.target = try reader["target"].readIfPresent(with: AppMeshClientTypes.GatewayRouteTarget.read(from:))
        value.rewrite = try reader["rewrite"].readIfPresent(with: AppMeshClientTypes.HttpGatewayRouteRewrite.read(from:))
        return value
    }
}

extension AppMeshClientTypes.HttpGatewayRouteRewrite {

    static func write(value: AppMeshClientTypes.HttpGatewayRouteRewrite?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["hostname"].write(value.hostname, with: AppMeshClientTypes.GatewayRouteHostnameRewrite.write(value:to:))
        try writer["path"].write(value.path, with: AppMeshClientTypes.HttpGatewayRoutePathRewrite.write(value:to:))
        try writer["prefix"].write(value.`prefix`, with: AppMeshClientTypes.HttpGatewayRoutePrefixRewrite.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpGatewayRouteRewrite {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpGatewayRouteRewrite()
        value.`prefix` = try reader["prefix"].readIfPresent(with: AppMeshClientTypes.HttpGatewayRoutePrefixRewrite.read(from:))
        value.path = try reader["path"].readIfPresent(with: AppMeshClientTypes.HttpGatewayRoutePathRewrite.read(from:))
        value.hostname = try reader["hostname"].readIfPresent(with: AppMeshClientTypes.GatewayRouteHostnameRewrite.read(from:))
        return value
    }
}

extension AppMeshClientTypes.HttpGatewayRoutePathRewrite {

    static func write(value: AppMeshClientTypes.HttpGatewayRoutePathRewrite?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exact"].write(value.exact)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpGatewayRoutePathRewrite {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpGatewayRoutePathRewrite()
        value.exact = try reader["exact"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.HttpGatewayRoutePrefixRewrite {

    static func write(value: AppMeshClientTypes.HttpGatewayRoutePrefixRewrite?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultPrefix"].write(value.defaultPrefix)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpGatewayRoutePrefixRewrite {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpGatewayRoutePrefixRewrite()
        value.defaultPrefix = try reader["defaultPrefix"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.HttpGatewayRouteMatch {

    static func write(value: AppMeshClientTypes.HttpGatewayRouteMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["headers"].writeList(value.headers, memberWritingClosure: AppMeshClientTypes.HttpGatewayRouteHeader.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["hostname"].write(value.hostname, with: AppMeshClientTypes.GatewayRouteHostnameMatch.write(value:to:))
        try writer["method"].write(value.method)
        try writer["path"].write(value.path, with: AppMeshClientTypes.HttpPathMatch.write(value:to:))
        try writer["port"].write(value.port)
        try writer["prefix"].write(value.`prefix`)
        try writer["queryParameters"].writeList(value.queryParameters, memberWritingClosure: AppMeshClientTypes.HttpQueryParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpGatewayRouteMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpGatewayRouteMatch()
        value.`prefix` = try reader["prefix"].readIfPresent()
        value.path = try reader["path"].readIfPresent(with: AppMeshClientTypes.HttpPathMatch.read(from:))
        value.queryParameters = try reader["queryParameters"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.HttpQueryParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.method = try reader["method"].readIfPresent()
        value.hostname = try reader["hostname"].readIfPresent(with: AppMeshClientTypes.GatewayRouteHostnameMatch.read(from:))
        value.headers = try reader["headers"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.HttpGatewayRouteHeader.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.port = try reader["port"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.HttpGatewayRouteHeader {

    static func write(value: AppMeshClientTypes.HttpGatewayRouteHeader?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invert"].write(value.invert)
        try writer["match"].write(value.match, with: AppMeshClientTypes.HeaderMatchMethod.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpGatewayRouteHeader {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpGatewayRouteHeader()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.invert = try reader["invert"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: AppMeshClientTypes.HeaderMatchMethod.read(from:))
        return value
    }
}

extension AppMeshClientTypes.HeaderMatchMethod {

    static func write(value: AppMeshClientTypes.HeaderMatchMethod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .exact(exact):
                try writer["exact"].write(exact)
            case let .`prefix`(`prefix`):
                try writer["prefix"].write(`prefix`)
            case let .range(range):
                try writer["range"].write(range, with: AppMeshClientTypes.MatchRange.write(value:to:))
            case let .regex(regex):
                try writer["regex"].write(regex)
            case let .suffix(suffix):
                try writer["suffix"].write(suffix)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HeaderMatchMethod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "exact":
                return .exact(try reader["exact"].read())
            case "regex":
                return .regex(try reader["regex"].read())
            case "range":
                return .range(try reader["range"].read(with: AppMeshClientTypes.MatchRange.read(from:)))
            case "prefix":
                return .`prefix`(try reader["prefix"].read())
            case "suffix":
                return .suffix(try reader["suffix"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.HttpQueryParameter {

    static func write(value: AppMeshClientTypes.HttpQueryParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["match"].write(value.match, with: AppMeshClientTypes.QueryParameterMatch.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpQueryParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpQueryParameter()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.match = try reader["match"].readIfPresent(with: AppMeshClientTypes.QueryParameterMatch.read(from:))
        return value
    }
}

extension AppMeshClientTypes.QueryParameterMatch {

    static func write(value: AppMeshClientTypes.QueryParameterMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exact"].write(value.exact)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.QueryParameterMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.QueryParameterMatch()
        value.exact = try reader["exact"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.HttpPathMatch {

    static func write(value: AppMeshClientTypes.HttpPathMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exact"].write(value.exact)
        try writer["regex"].write(value.regex)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpPathMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpPathMatch()
        value.exact = try reader["exact"].readIfPresent()
        value.regex = try reader["regex"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.MeshData {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.MeshData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.MeshData()
        value.meshName = try reader["meshName"].readIfPresent() ?? ""
        value.spec = try reader["spec"].readIfPresent(with: AppMeshClientTypes.MeshSpec.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: AppMeshClientTypes.ResourceMetadata.read(from:))
        value.status = try reader["status"].readIfPresent(with: AppMeshClientTypes.MeshStatus.read(from:))
        return value
    }
}

extension AppMeshClientTypes.MeshStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.MeshStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.MeshStatus()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.MeshSpec {

    static func write(value: AppMeshClientTypes.MeshSpec?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["egressFilter"].write(value.egressFilter, with: AppMeshClientTypes.EgressFilter.write(value:to:))
        try writer["serviceDiscovery"].write(value.serviceDiscovery, with: AppMeshClientTypes.MeshServiceDiscovery.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.MeshSpec {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.MeshSpec()
        value.egressFilter = try reader["egressFilter"].readIfPresent(with: AppMeshClientTypes.EgressFilter.read(from:))
        value.serviceDiscovery = try reader["serviceDiscovery"].readIfPresent(with: AppMeshClientTypes.MeshServiceDiscovery.read(from:))
        return value
    }
}

extension AppMeshClientTypes.MeshServiceDiscovery {

    static func write(value: AppMeshClientTypes.MeshServiceDiscovery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ipPreference"].write(value.ipPreference)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.MeshServiceDiscovery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.MeshServiceDiscovery()
        value.ipPreference = try reader["ipPreference"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.EgressFilter {

    static func write(value: AppMeshClientTypes.EgressFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.EgressFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.EgressFilter()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppMeshClientTypes.RouteData {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.RouteData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.RouteData()
        value.meshName = try reader["meshName"].readIfPresent() ?? ""
        value.virtualRouterName = try reader["virtualRouterName"].readIfPresent() ?? ""
        value.routeName = try reader["routeName"].readIfPresent() ?? ""
        value.spec = try reader["spec"].readIfPresent(with: AppMeshClientTypes.RouteSpec.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: AppMeshClientTypes.ResourceMetadata.read(from:))
        value.status = try reader["status"].readIfPresent(with: AppMeshClientTypes.RouteStatus.read(from:))
        return value
    }
}

extension AppMeshClientTypes.RouteStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.RouteStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.RouteStatus()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppMeshClientTypes.RouteSpec {

    static func write(value: AppMeshClientTypes.RouteSpec?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["grpcRoute"].write(value.grpcRoute, with: AppMeshClientTypes.GrpcRoute.write(value:to:))
        try writer["http2Route"].write(value.http2Route, with: AppMeshClientTypes.HttpRoute.write(value:to:))
        try writer["httpRoute"].write(value.httpRoute, with: AppMeshClientTypes.HttpRoute.write(value:to:))
        try writer["priority"].write(value.priority)
        try writer["tcpRoute"].write(value.tcpRoute, with: AppMeshClientTypes.TcpRoute.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.RouteSpec {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.RouteSpec()
        value.priority = try reader["priority"].readIfPresent()
        value.httpRoute = try reader["httpRoute"].readIfPresent(with: AppMeshClientTypes.HttpRoute.read(from:))
        value.tcpRoute = try reader["tcpRoute"].readIfPresent(with: AppMeshClientTypes.TcpRoute.read(from:))
        value.http2Route = try reader["http2Route"].readIfPresent(with: AppMeshClientTypes.HttpRoute.read(from:))
        value.grpcRoute = try reader["grpcRoute"].readIfPresent(with: AppMeshClientTypes.GrpcRoute.read(from:))
        return value
    }
}

extension AppMeshClientTypes.GrpcRoute {

    static func write(value: AppMeshClientTypes.GrpcRoute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: AppMeshClientTypes.GrpcRouteAction.write(value:to:))
        try writer["match"].write(value.match, with: AppMeshClientTypes.GrpcRouteMatch.write(value:to:))
        try writer["retryPolicy"].write(value.retryPolicy, with: AppMeshClientTypes.GrpcRetryPolicy.write(value:to:))
        try writer["timeout"].write(value.timeout, with: AppMeshClientTypes.GrpcTimeout.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GrpcRoute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GrpcRoute()
        value.action = try reader["action"].readIfPresent(with: AppMeshClientTypes.GrpcRouteAction.read(from:))
        value.match = try reader["match"].readIfPresent(with: AppMeshClientTypes.GrpcRouteMatch.read(from:))
        value.retryPolicy = try reader["retryPolicy"].readIfPresent(with: AppMeshClientTypes.GrpcRetryPolicy.read(from:))
        value.timeout = try reader["timeout"].readIfPresent(with: AppMeshClientTypes.GrpcTimeout.read(from:))
        return value
    }
}

extension AppMeshClientTypes.GrpcTimeout {

    static func write(value: AppMeshClientTypes.GrpcTimeout?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["idle"].write(value.idle, with: AppMeshClientTypes.Duration.write(value:to:))
        try writer["perRequest"].write(value.perRequest, with: AppMeshClientTypes.Duration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GrpcTimeout {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GrpcTimeout()
        value.perRequest = try reader["perRequest"].readIfPresent(with: AppMeshClientTypes.Duration.read(from:))
        value.idle = try reader["idle"].readIfPresent(with: AppMeshClientTypes.Duration.read(from:))
        return value
    }
}

extension AppMeshClientTypes.Duration {

    static func write(value: AppMeshClientTypes.Duration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["unit"].write(value.unit)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.Duration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.Duration()
        value.value = try reader["value"].readIfPresent()
        value.unit = try reader["unit"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.GrpcRetryPolicy {

    static func write(value: AppMeshClientTypes.GrpcRetryPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["grpcRetryEvents"].writeList(value.grpcRetryEvents, memberWritingClosure: SmithyReadWrite.WritingClosureBox<AppMeshClientTypes.GrpcRetryPolicyEvent>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["httpRetryEvents"].writeList(value.httpRetryEvents, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxRetries"].write(value.maxRetries)
        try writer["perRetryTimeout"].write(value.perRetryTimeout, with: AppMeshClientTypes.Duration.write(value:to:))
        try writer["tcpRetryEvents"].writeList(value.tcpRetryEvents, memberWritingClosure: SmithyReadWrite.WritingClosureBox<AppMeshClientTypes.TcpRetryPolicyEvent>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GrpcRetryPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GrpcRetryPolicy()
        value.perRetryTimeout = try reader["perRetryTimeout"].readIfPresent(with: AppMeshClientTypes.Duration.read(from:))
        value.maxRetries = try reader["maxRetries"].readIfPresent() ?? 0
        value.httpRetryEvents = try reader["httpRetryEvents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tcpRetryEvents = try reader["tcpRetryEvents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppMeshClientTypes.TcpRetryPolicyEvent>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.grpcRetryEvents = try reader["grpcRetryEvents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppMeshClientTypes.GrpcRetryPolicyEvent>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppMeshClientTypes.GrpcRouteMatch {

    static func write(value: AppMeshClientTypes.GrpcRouteMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadata"].writeList(value.metadata, memberWritingClosure: AppMeshClientTypes.GrpcRouteMetadata.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["methodName"].write(value.methodName)
        try writer["port"].write(value.port)
        try writer["serviceName"].write(value.serviceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GrpcRouteMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GrpcRouteMatch()
        value.serviceName = try reader["serviceName"].readIfPresent()
        value.methodName = try reader["methodName"].readIfPresent()
        value.metadata = try reader["metadata"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.GrpcRouteMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.port = try reader["port"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.GrpcRouteMetadata {

    static func write(value: AppMeshClientTypes.GrpcRouteMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invert"].write(value.invert)
        try writer["match"].write(value.match, with: AppMeshClientTypes.GrpcRouteMetadataMatchMethod.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GrpcRouteMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GrpcRouteMetadata()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.invert = try reader["invert"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: AppMeshClientTypes.GrpcRouteMetadataMatchMethod.read(from:))
        return value
    }
}

extension AppMeshClientTypes.GrpcRouteMetadataMatchMethod {

    static func write(value: AppMeshClientTypes.GrpcRouteMetadataMatchMethod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .exact(exact):
                try writer["exact"].write(exact)
            case let .`prefix`(`prefix`):
                try writer["prefix"].write(`prefix`)
            case let .range(range):
                try writer["range"].write(range, with: AppMeshClientTypes.MatchRange.write(value:to:))
            case let .regex(regex):
                try writer["regex"].write(regex)
            case let .suffix(suffix):
                try writer["suffix"].write(suffix)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GrpcRouteMetadataMatchMethod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "exact":
                return .exact(try reader["exact"].read())
            case "regex":
                return .regex(try reader["regex"].read())
            case "range":
                return .range(try reader["range"].read(with: AppMeshClientTypes.MatchRange.read(from:)))
            case "prefix":
                return .`prefix`(try reader["prefix"].read())
            case "suffix":
                return .suffix(try reader["suffix"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.GrpcRouteAction {

    static func write(value: AppMeshClientTypes.GrpcRouteAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["weightedTargets"].writeList(value.weightedTargets, memberWritingClosure: AppMeshClientTypes.WeightedTarget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GrpcRouteAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GrpcRouteAction()
        value.weightedTargets = try reader["weightedTargets"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.WeightedTarget.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension AppMeshClientTypes.WeightedTarget {

    static func write(value: AppMeshClientTypes.WeightedTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["port"].write(value.port)
        try writer["virtualNode"].write(value.virtualNode)
        try writer["weight"].write(value.weight)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.WeightedTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.WeightedTarget()
        value.virtualNode = try reader["virtualNode"].readIfPresent() ?? ""
        value.weight = try reader["weight"].readIfPresent() ?? 0
        value.port = try reader["port"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.HttpRoute {

    static func write(value: AppMeshClientTypes.HttpRoute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: AppMeshClientTypes.HttpRouteAction.write(value:to:))
        try writer["match"].write(value.match, with: AppMeshClientTypes.HttpRouteMatch.write(value:to:))
        try writer["retryPolicy"].write(value.retryPolicy, with: AppMeshClientTypes.HttpRetryPolicy.write(value:to:))
        try writer["timeout"].write(value.timeout, with: AppMeshClientTypes.HttpTimeout.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpRoute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpRoute()
        value.match = try reader["match"].readIfPresent(with: AppMeshClientTypes.HttpRouteMatch.read(from:))
        value.action = try reader["action"].readIfPresent(with: AppMeshClientTypes.HttpRouteAction.read(from:))
        value.retryPolicy = try reader["retryPolicy"].readIfPresent(with: AppMeshClientTypes.HttpRetryPolicy.read(from:))
        value.timeout = try reader["timeout"].readIfPresent(with: AppMeshClientTypes.HttpTimeout.read(from:))
        return value
    }
}

extension AppMeshClientTypes.HttpTimeout {

    static func write(value: AppMeshClientTypes.HttpTimeout?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["idle"].write(value.idle, with: AppMeshClientTypes.Duration.write(value:to:))
        try writer["perRequest"].write(value.perRequest, with: AppMeshClientTypes.Duration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpTimeout {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpTimeout()
        value.perRequest = try reader["perRequest"].readIfPresent(with: AppMeshClientTypes.Duration.read(from:))
        value.idle = try reader["idle"].readIfPresent(with: AppMeshClientTypes.Duration.read(from:))
        return value
    }
}

extension AppMeshClientTypes.HttpRetryPolicy {

    static func write(value: AppMeshClientTypes.HttpRetryPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["httpRetryEvents"].writeList(value.httpRetryEvents, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxRetries"].write(value.maxRetries)
        try writer["perRetryTimeout"].write(value.perRetryTimeout, with: AppMeshClientTypes.Duration.write(value:to:))
        try writer["tcpRetryEvents"].writeList(value.tcpRetryEvents, memberWritingClosure: SmithyReadWrite.WritingClosureBox<AppMeshClientTypes.TcpRetryPolicyEvent>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpRetryPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpRetryPolicy()
        value.perRetryTimeout = try reader["perRetryTimeout"].readIfPresent(with: AppMeshClientTypes.Duration.read(from:))
        value.maxRetries = try reader["maxRetries"].readIfPresent() ?? 0
        value.httpRetryEvents = try reader["httpRetryEvents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tcpRetryEvents = try reader["tcpRetryEvents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppMeshClientTypes.TcpRetryPolicyEvent>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppMeshClientTypes.HttpRouteAction {

    static func write(value: AppMeshClientTypes.HttpRouteAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["weightedTargets"].writeList(value.weightedTargets, memberWritingClosure: AppMeshClientTypes.WeightedTarget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpRouteAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpRouteAction()
        value.weightedTargets = try reader["weightedTargets"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.WeightedTarget.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension AppMeshClientTypes.HttpRouteMatch {

    static func write(value: AppMeshClientTypes.HttpRouteMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["headers"].writeList(value.headers, memberWritingClosure: AppMeshClientTypes.HttpRouteHeader.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["method"].write(value.method)
        try writer["path"].write(value.path, with: AppMeshClientTypes.HttpPathMatch.write(value:to:))
        try writer["port"].write(value.port)
        try writer["prefix"].write(value.`prefix`)
        try writer["queryParameters"].writeList(value.queryParameters, memberWritingClosure: AppMeshClientTypes.HttpQueryParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scheme"].write(value.scheme)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpRouteMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpRouteMatch()
        value.`prefix` = try reader["prefix"].readIfPresent()
        value.path = try reader["path"].readIfPresent(with: AppMeshClientTypes.HttpPathMatch.read(from:))
        value.queryParameters = try reader["queryParameters"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.HttpQueryParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.method = try reader["method"].readIfPresent()
        value.scheme = try reader["scheme"].readIfPresent()
        value.headers = try reader["headers"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.HttpRouteHeader.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.port = try reader["port"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.HttpRouteHeader {

    static func write(value: AppMeshClientTypes.HttpRouteHeader?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invert"].write(value.invert)
        try writer["match"].write(value.match, with: AppMeshClientTypes.HeaderMatchMethod.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HttpRouteHeader {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HttpRouteHeader()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.invert = try reader["invert"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: AppMeshClientTypes.HeaderMatchMethod.read(from:))
        return value
    }
}

extension AppMeshClientTypes.TcpRoute {

    static func write(value: AppMeshClientTypes.TcpRoute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: AppMeshClientTypes.TcpRouteAction.write(value:to:))
        try writer["match"].write(value.match, with: AppMeshClientTypes.TcpRouteMatch.write(value:to:))
        try writer["timeout"].write(value.timeout, with: AppMeshClientTypes.TcpTimeout.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.TcpRoute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.TcpRoute()
        value.action = try reader["action"].readIfPresent(with: AppMeshClientTypes.TcpRouteAction.read(from:))
        value.timeout = try reader["timeout"].readIfPresent(with: AppMeshClientTypes.TcpTimeout.read(from:))
        value.match = try reader["match"].readIfPresent(with: AppMeshClientTypes.TcpRouteMatch.read(from:))
        return value
    }
}

extension AppMeshClientTypes.TcpRouteMatch {

    static func write(value: AppMeshClientTypes.TcpRouteMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.TcpRouteMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.TcpRouteMatch()
        value.port = try reader["port"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.TcpTimeout {

    static func write(value: AppMeshClientTypes.TcpTimeout?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["idle"].write(value.idle, with: AppMeshClientTypes.Duration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.TcpTimeout {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.TcpTimeout()
        value.idle = try reader["idle"].readIfPresent(with: AppMeshClientTypes.Duration.read(from:))
        return value
    }
}

extension AppMeshClientTypes.TcpRouteAction {

    static func write(value: AppMeshClientTypes.TcpRouteAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["weightedTargets"].writeList(value.weightedTargets, memberWritingClosure: AppMeshClientTypes.WeightedTarget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.TcpRouteAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.TcpRouteAction()
        value.weightedTargets = try reader["weightedTargets"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.WeightedTarget.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayData {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayData()
        value.meshName = try reader["meshName"].readIfPresent() ?? ""
        value.virtualGatewayName = try reader["virtualGatewayName"].readIfPresent() ?? ""
        value.spec = try reader["spec"].readIfPresent(with: AppMeshClientTypes.VirtualGatewaySpec.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: AppMeshClientTypes.ResourceMetadata.read(from:))
        value.status = try reader["status"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayStatus.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayStatus()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewaySpec {

    static func write(value: AppMeshClientTypes.VirtualGatewaySpec?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["backendDefaults"].write(value.backendDefaults, with: AppMeshClientTypes.VirtualGatewayBackendDefaults.write(value:to:))
        try writer["listeners"].writeList(value.listeners, memberWritingClosure: AppMeshClientTypes.VirtualGatewayListener.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["logging"].write(value.logging, with: AppMeshClientTypes.VirtualGatewayLogging.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewaySpec {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewaySpec()
        value.backendDefaults = try reader["backendDefaults"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayBackendDefaults.read(from:))
        value.listeners = try reader["listeners"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.VirtualGatewayListener.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.logging = try reader["logging"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayLogging.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayLogging {

    static func write(value: AppMeshClientTypes.VirtualGatewayLogging?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessLog"].write(value.accessLog, with: AppMeshClientTypes.VirtualGatewayAccessLog.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayLogging {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayLogging()
        value.accessLog = try reader["accessLog"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayAccessLog.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayAccessLog {

    static func write(value: AppMeshClientTypes.VirtualGatewayAccessLog?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .file(file):
                try writer["file"].write(file, with: AppMeshClientTypes.VirtualGatewayFileAccessLog.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayAccessLog {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "file":
                return .file(try reader["file"].read(with: AppMeshClientTypes.VirtualGatewayFileAccessLog.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.VirtualGatewayFileAccessLog {

    static func write(value: AppMeshClientTypes.VirtualGatewayFileAccessLog?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["format"].write(value.format, with: AppMeshClientTypes.LoggingFormat.write(value:to:))
        try writer["path"].write(value.path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayFileAccessLog {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayFileAccessLog()
        value.path = try reader["path"].readIfPresent() ?? ""
        value.format = try reader["format"].readIfPresent(with: AppMeshClientTypes.LoggingFormat.read(from:))
        return value
    }
}

extension AppMeshClientTypes.LoggingFormat {

    static func write(value: AppMeshClientTypes.LoggingFormat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .json(json):
                try writer["json"].writeList(json, memberWritingClosure: AppMeshClientTypes.JsonFormatRef.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.LoggingFormat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read())
            case "json":
                return .json(try reader["json"].readList(memberReadingClosure: AppMeshClientTypes.JsonFormatRef.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.JsonFormatRef {

    static func write(value: AppMeshClientTypes.JsonFormatRef?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.JsonFormatRef {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.JsonFormatRef()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayListener {

    static func write(value: AppMeshClientTypes.VirtualGatewayListener?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionPool"].write(value.connectionPool, with: AppMeshClientTypes.VirtualGatewayConnectionPool.write(value:to:))
        try writer["healthCheck"].write(value.healthCheck, with: AppMeshClientTypes.VirtualGatewayHealthCheckPolicy.write(value:to:))
        try writer["portMapping"].write(value.portMapping, with: AppMeshClientTypes.VirtualGatewayPortMapping.write(value:to:))
        try writer["tls"].write(value.tls, with: AppMeshClientTypes.VirtualGatewayListenerTls.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayListener {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayListener()
        value.healthCheck = try reader["healthCheck"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayHealthCheckPolicy.read(from:))
        value.portMapping = try reader["portMapping"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayPortMapping.read(from:))
        value.tls = try reader["tls"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayListenerTls.read(from:))
        value.connectionPool = try reader["connectionPool"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayConnectionPool.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayConnectionPool {

    static func write(value: AppMeshClientTypes.VirtualGatewayConnectionPool?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .grpc(grpc):
                try writer["grpc"].write(grpc, with: AppMeshClientTypes.VirtualGatewayGrpcConnectionPool.write(value:to:))
            case let .http(http):
                try writer["http"].write(http, with: AppMeshClientTypes.VirtualGatewayHttpConnectionPool.write(value:to:))
            case let .http2(http2):
                try writer["http2"].write(http2, with: AppMeshClientTypes.VirtualGatewayHttp2ConnectionPool.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayConnectionPool {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "http":
                return .http(try reader["http"].read(with: AppMeshClientTypes.VirtualGatewayHttpConnectionPool.read(from:)))
            case "http2":
                return .http2(try reader["http2"].read(with: AppMeshClientTypes.VirtualGatewayHttp2ConnectionPool.read(from:)))
            case "grpc":
                return .grpc(try reader["grpc"].read(with: AppMeshClientTypes.VirtualGatewayGrpcConnectionPool.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.VirtualGatewayGrpcConnectionPool {

    static func write(value: AppMeshClientTypes.VirtualGatewayGrpcConnectionPool?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxRequests"].write(value.maxRequests)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayGrpcConnectionPool {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayGrpcConnectionPool()
        value.maxRequests = try reader["maxRequests"].readIfPresent() ?? 0
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayHttp2ConnectionPool {

    static func write(value: AppMeshClientTypes.VirtualGatewayHttp2ConnectionPool?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxRequests"].write(value.maxRequests)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayHttp2ConnectionPool {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayHttp2ConnectionPool()
        value.maxRequests = try reader["maxRequests"].readIfPresent() ?? 0
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayHttpConnectionPool {

    static func write(value: AppMeshClientTypes.VirtualGatewayHttpConnectionPool?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxConnections"].write(value.maxConnections)
        try writer["maxPendingRequests"].write(value.maxPendingRequests)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayHttpConnectionPool {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayHttpConnectionPool()
        value.maxConnections = try reader["maxConnections"].readIfPresent() ?? 0
        value.maxPendingRequests = try reader["maxPendingRequests"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayListenerTls {

    static func write(value: AppMeshClientTypes.VirtualGatewayListenerTls?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificate"].write(value.certificate, with: AppMeshClientTypes.VirtualGatewayListenerTlsCertificate.write(value:to:))
        try writer["mode"].write(value.mode)
        try writer["validation"].write(value.validation, with: AppMeshClientTypes.VirtualGatewayListenerTlsValidationContext.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayListenerTls {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayListenerTls()
        value.mode = try reader["mode"].readIfPresent() ?? .sdkUnknown("")
        value.validation = try reader["validation"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayListenerTlsValidationContext.read(from:))
        value.certificate = try reader["certificate"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayListenerTlsCertificate.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayListenerTlsCertificate {

    static func write(value: AppMeshClientTypes.VirtualGatewayListenerTlsCertificate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .acm(acm):
                try writer["acm"].write(acm, with: AppMeshClientTypes.VirtualGatewayListenerTlsAcmCertificate.write(value:to:))
            case let .file(file):
                try writer["file"].write(file, with: AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate.write(value:to:))
            case let .sds(sds):
                try writer["sds"].write(sds, with: AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayListenerTlsCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "acm":
                return .acm(try reader["acm"].read(with: AppMeshClientTypes.VirtualGatewayListenerTlsAcmCertificate.read(from:)))
            case "file":
                return .file(try reader["file"].read(with: AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate.read(from:)))
            case "sds":
                return .sds(try reader["sds"].read(with: AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate {

    static func write(value: AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["secretName"].write(value.secretName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate()
        value.secretName = try reader["secretName"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate {

    static func write(value: AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateChain"].write(value.certificateChain)
        try writer["privateKey"].write(value.privateKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate()
        value.certificateChain = try reader["certificateChain"].readIfPresent() ?? ""
        value.privateKey = try reader["privateKey"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayListenerTlsAcmCertificate {

    static func write(value: AppMeshClientTypes.VirtualGatewayListenerTlsAcmCertificate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateArn"].write(value.certificateArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayListenerTlsAcmCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayListenerTlsAcmCertificate()
        value.certificateArn = try reader["certificateArn"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayListenerTlsValidationContext {

    static func write(value: AppMeshClientTypes.VirtualGatewayListenerTlsValidationContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["subjectAlternativeNames"].write(value.subjectAlternativeNames, with: AppMeshClientTypes.SubjectAlternativeNames.write(value:to:))
        try writer["trust"].write(value.trust, with: AppMeshClientTypes.VirtualGatewayListenerTlsValidationContextTrust.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayListenerTlsValidationContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayListenerTlsValidationContext()
        value.trust = try reader["trust"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayListenerTlsValidationContextTrust.read(from:))
        value.subjectAlternativeNames = try reader["subjectAlternativeNames"].readIfPresent(with: AppMeshClientTypes.SubjectAlternativeNames.read(from:))
        return value
    }
}

extension AppMeshClientTypes.SubjectAlternativeNames {

    static func write(value: AppMeshClientTypes.SubjectAlternativeNames?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["match"].write(value.match, with: AppMeshClientTypes.SubjectAlternativeNameMatchers.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.SubjectAlternativeNames {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.SubjectAlternativeNames()
        value.match = try reader["match"].readIfPresent(with: AppMeshClientTypes.SubjectAlternativeNameMatchers.read(from:))
        return value
    }
}

extension AppMeshClientTypes.SubjectAlternativeNameMatchers {

    static func write(value: AppMeshClientTypes.SubjectAlternativeNameMatchers?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exact"].writeList(value.exact, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.SubjectAlternativeNameMatchers {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.SubjectAlternativeNameMatchers()
        value.exact = try reader["exact"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayListenerTlsValidationContextTrust {

    static func write(value: AppMeshClientTypes.VirtualGatewayListenerTlsValidationContextTrust?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .file(file):
                try writer["file"].write(file, with: AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust.write(value:to:))
            case let .sds(sds):
                try writer["sds"].write(sds, with: AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayListenerTlsValidationContextTrust {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "file":
                return .file(try reader["file"].read(with: AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust.read(from:)))
            case "sds":
                return .sds(try reader["sds"].read(with: AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust {

    static func write(value: AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["secretName"].write(value.secretName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust()
        value.secretName = try reader["secretName"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust {

    static func write(value: AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateChain"].write(value.certificateChain)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust()
        value.certificateChain = try reader["certificateChain"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayPortMapping {

    static func write(value: AppMeshClientTypes.VirtualGatewayPortMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayPortMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayPortMapping()
        value.port = try reader["port"].readIfPresent() ?? 0
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayHealthCheckPolicy {

    static func write(value: AppMeshClientTypes.VirtualGatewayHealthCheckPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["healthyThreshold"].write(value.healthyThreshold)
        try writer["intervalMillis"].write(value.intervalMillis)
        try writer["path"].write(value.path)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["timeoutMillis"].write(value.timeoutMillis)
        try writer["unhealthyThreshold"].write(value.unhealthyThreshold)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayHealthCheckPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayHealthCheckPolicy()
        value.timeoutMillis = try reader["timeoutMillis"].readIfPresent() ?? 0
        value.intervalMillis = try reader["intervalMillis"].readIfPresent() ?? 0
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.port = try reader["port"].readIfPresent()
        value.path = try reader["path"].readIfPresent()
        value.healthyThreshold = try reader["healthyThreshold"].readIfPresent() ?? 0
        value.unhealthyThreshold = try reader["unhealthyThreshold"].readIfPresent() ?? 0
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayBackendDefaults {

    static func write(value: AppMeshClientTypes.VirtualGatewayBackendDefaults?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientPolicy"].write(value.clientPolicy, with: AppMeshClientTypes.VirtualGatewayClientPolicy.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayBackendDefaults {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayBackendDefaults()
        value.clientPolicy = try reader["clientPolicy"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayClientPolicy.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayClientPolicy {

    static func write(value: AppMeshClientTypes.VirtualGatewayClientPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tls"].write(value.tls, with: AppMeshClientTypes.VirtualGatewayClientPolicyTls.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayClientPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayClientPolicy()
        value.tls = try reader["tls"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayClientPolicyTls.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayClientPolicyTls {

    static func write(value: AppMeshClientTypes.VirtualGatewayClientPolicyTls?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificate"].write(value.certificate, with: AppMeshClientTypes.VirtualGatewayClientTlsCertificate.write(value:to:))
        try writer["enforce"].write(value.enforce)
        try writer["ports"].writeList(value.ports, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["validation"].write(value.validation, with: AppMeshClientTypes.VirtualGatewayTlsValidationContext.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayClientPolicyTls {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayClientPolicyTls()
        value.enforce = try reader["enforce"].readIfPresent()
        value.ports = try reader["ports"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.certificate = try reader["certificate"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayClientTlsCertificate.read(from:))
        value.validation = try reader["validation"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayTlsValidationContext.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayTlsValidationContext {

    static func write(value: AppMeshClientTypes.VirtualGatewayTlsValidationContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["subjectAlternativeNames"].write(value.subjectAlternativeNames, with: AppMeshClientTypes.SubjectAlternativeNames.write(value:to:))
        try writer["trust"].write(value.trust, with: AppMeshClientTypes.VirtualGatewayTlsValidationContextTrust.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayTlsValidationContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayTlsValidationContext()
        value.trust = try reader["trust"].readIfPresent(with: AppMeshClientTypes.VirtualGatewayTlsValidationContextTrust.read(from:))
        value.subjectAlternativeNames = try reader["subjectAlternativeNames"].readIfPresent(with: AppMeshClientTypes.SubjectAlternativeNames.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayTlsValidationContextTrust {

    static func write(value: AppMeshClientTypes.VirtualGatewayTlsValidationContextTrust?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .acm(acm):
                try writer["acm"].write(acm, with: AppMeshClientTypes.VirtualGatewayTlsValidationContextAcmTrust.write(value:to:))
            case let .file(file):
                try writer["file"].write(file, with: AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust.write(value:to:))
            case let .sds(sds):
                try writer["sds"].write(sds, with: AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayTlsValidationContextTrust {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "acm":
                return .acm(try reader["acm"].read(with: AppMeshClientTypes.VirtualGatewayTlsValidationContextAcmTrust.read(from:)))
            case "file":
                return .file(try reader["file"].read(with: AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust.read(from:)))
            case "sds":
                return .sds(try reader["sds"].read(with: AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.VirtualGatewayTlsValidationContextAcmTrust {

    static func write(value: AppMeshClientTypes.VirtualGatewayTlsValidationContextAcmTrust?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateAuthorityArns"].writeList(value.certificateAuthorityArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayTlsValidationContextAcmTrust {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayTlsValidationContextAcmTrust()
        value.certificateAuthorityArns = try reader["certificateAuthorityArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayClientTlsCertificate {

    static func write(value: AppMeshClientTypes.VirtualGatewayClientTlsCertificate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .file(file):
                try writer["file"].write(file, with: AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate.write(value:to:))
            case let .sds(sds):
                try writer["sds"].write(sds, with: AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayClientTlsCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "file":
                return .file(try reader["file"].read(with: AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate.read(from:)))
            case "sds":
                return .sds(try reader["sds"].read(with: AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.VirtualNodeData {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualNodeData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualNodeData()
        value.meshName = try reader["meshName"].readIfPresent() ?? ""
        value.virtualNodeName = try reader["virtualNodeName"].readIfPresent() ?? ""
        value.spec = try reader["spec"].readIfPresent(with: AppMeshClientTypes.VirtualNodeSpec.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: AppMeshClientTypes.ResourceMetadata.read(from:))
        value.status = try reader["status"].readIfPresent(with: AppMeshClientTypes.VirtualNodeStatus.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualNodeStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualNodeStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualNodeStatus()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppMeshClientTypes.VirtualNodeSpec {

    static func write(value: AppMeshClientTypes.VirtualNodeSpec?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["backendDefaults"].write(value.backendDefaults, with: AppMeshClientTypes.BackendDefaults.write(value:to:))
        try writer["backends"].writeList(value.backends, memberWritingClosure: AppMeshClientTypes.Backend.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["listeners"].writeList(value.listeners, memberWritingClosure: AppMeshClientTypes.Listener.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["logging"].write(value.logging, with: AppMeshClientTypes.Logging.write(value:to:))
        try writer["serviceDiscovery"].write(value.serviceDiscovery, with: AppMeshClientTypes.ServiceDiscovery.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualNodeSpec {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualNodeSpec()
        value.serviceDiscovery = try reader["serviceDiscovery"].readIfPresent(with: AppMeshClientTypes.ServiceDiscovery.read(from:))
        value.listeners = try reader["listeners"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.Listener.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.backends = try reader["backends"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.Backend.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.backendDefaults = try reader["backendDefaults"].readIfPresent(with: AppMeshClientTypes.BackendDefaults.read(from:))
        value.logging = try reader["logging"].readIfPresent(with: AppMeshClientTypes.Logging.read(from:))
        return value
    }
}

extension AppMeshClientTypes.Logging {

    static func write(value: AppMeshClientTypes.Logging?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessLog"].write(value.accessLog, with: AppMeshClientTypes.AccessLog.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.Logging {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.Logging()
        value.accessLog = try reader["accessLog"].readIfPresent(with: AppMeshClientTypes.AccessLog.read(from:))
        return value
    }
}

extension AppMeshClientTypes.AccessLog {

    static func write(value: AppMeshClientTypes.AccessLog?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .file(file):
                try writer["file"].write(file, with: AppMeshClientTypes.FileAccessLog.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.AccessLog {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "file":
                return .file(try reader["file"].read(with: AppMeshClientTypes.FileAccessLog.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.FileAccessLog {

    static func write(value: AppMeshClientTypes.FileAccessLog?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["format"].write(value.format, with: AppMeshClientTypes.LoggingFormat.write(value:to:))
        try writer["path"].write(value.path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.FileAccessLog {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.FileAccessLog()
        value.path = try reader["path"].readIfPresent() ?? ""
        value.format = try reader["format"].readIfPresent(with: AppMeshClientTypes.LoggingFormat.read(from:))
        return value
    }
}

extension AppMeshClientTypes.BackendDefaults {

    static func write(value: AppMeshClientTypes.BackendDefaults?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientPolicy"].write(value.clientPolicy, with: AppMeshClientTypes.ClientPolicy.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.BackendDefaults {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.BackendDefaults()
        value.clientPolicy = try reader["clientPolicy"].readIfPresent(with: AppMeshClientTypes.ClientPolicy.read(from:))
        return value
    }
}

extension AppMeshClientTypes.ClientPolicy {

    static func write(value: AppMeshClientTypes.ClientPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tls"].write(value.tls, with: AppMeshClientTypes.ClientPolicyTls.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.ClientPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.ClientPolicy()
        value.tls = try reader["tls"].readIfPresent(with: AppMeshClientTypes.ClientPolicyTls.read(from:))
        return value
    }
}

extension AppMeshClientTypes.ClientPolicyTls {

    static func write(value: AppMeshClientTypes.ClientPolicyTls?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificate"].write(value.certificate, with: AppMeshClientTypes.ClientTlsCertificate.write(value:to:))
        try writer["enforce"].write(value.enforce)
        try writer["ports"].writeList(value.ports, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["validation"].write(value.validation, with: AppMeshClientTypes.TlsValidationContext.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.ClientPolicyTls {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.ClientPolicyTls()
        value.enforce = try reader["enforce"].readIfPresent()
        value.ports = try reader["ports"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.certificate = try reader["certificate"].readIfPresent(with: AppMeshClientTypes.ClientTlsCertificate.read(from:))
        value.validation = try reader["validation"].readIfPresent(with: AppMeshClientTypes.TlsValidationContext.read(from:))
        return value
    }
}

extension AppMeshClientTypes.TlsValidationContext {

    static func write(value: AppMeshClientTypes.TlsValidationContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["subjectAlternativeNames"].write(value.subjectAlternativeNames, with: AppMeshClientTypes.SubjectAlternativeNames.write(value:to:))
        try writer["trust"].write(value.trust, with: AppMeshClientTypes.TlsValidationContextTrust.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.TlsValidationContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.TlsValidationContext()
        value.trust = try reader["trust"].readIfPresent(with: AppMeshClientTypes.TlsValidationContextTrust.read(from:))
        value.subjectAlternativeNames = try reader["subjectAlternativeNames"].readIfPresent(with: AppMeshClientTypes.SubjectAlternativeNames.read(from:))
        return value
    }
}

extension AppMeshClientTypes.TlsValidationContextTrust {

    static func write(value: AppMeshClientTypes.TlsValidationContextTrust?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .acm(acm):
                try writer["acm"].write(acm, with: AppMeshClientTypes.TlsValidationContextAcmTrust.write(value:to:))
            case let .file(file):
                try writer["file"].write(file, with: AppMeshClientTypes.TlsValidationContextFileTrust.write(value:to:))
            case let .sds(sds):
                try writer["sds"].write(sds, with: AppMeshClientTypes.TlsValidationContextSdsTrust.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.TlsValidationContextTrust {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "acm":
                return .acm(try reader["acm"].read(with: AppMeshClientTypes.TlsValidationContextAcmTrust.read(from:)))
            case "file":
                return .file(try reader["file"].read(with: AppMeshClientTypes.TlsValidationContextFileTrust.read(from:)))
            case "sds":
                return .sds(try reader["sds"].read(with: AppMeshClientTypes.TlsValidationContextSdsTrust.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.TlsValidationContextSdsTrust {

    static func write(value: AppMeshClientTypes.TlsValidationContextSdsTrust?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["secretName"].write(value.secretName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.TlsValidationContextSdsTrust {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.TlsValidationContextSdsTrust()
        value.secretName = try reader["secretName"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.TlsValidationContextFileTrust {

    static func write(value: AppMeshClientTypes.TlsValidationContextFileTrust?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateChain"].write(value.certificateChain)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.TlsValidationContextFileTrust {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.TlsValidationContextFileTrust()
        value.certificateChain = try reader["certificateChain"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.TlsValidationContextAcmTrust {

    static func write(value: AppMeshClientTypes.TlsValidationContextAcmTrust?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateAuthorityArns"].writeList(value.certificateAuthorityArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.TlsValidationContextAcmTrust {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.TlsValidationContextAcmTrust()
        value.certificateAuthorityArns = try reader["certificateAuthorityArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension AppMeshClientTypes.ClientTlsCertificate {

    static func write(value: AppMeshClientTypes.ClientTlsCertificate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .file(file):
                try writer["file"].write(file, with: AppMeshClientTypes.ListenerTlsFileCertificate.write(value:to:))
            case let .sds(sds):
                try writer["sds"].write(sds, with: AppMeshClientTypes.ListenerTlsSdsCertificate.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.ClientTlsCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "file":
                return .file(try reader["file"].read(with: AppMeshClientTypes.ListenerTlsFileCertificate.read(from:)))
            case "sds":
                return .sds(try reader["sds"].read(with: AppMeshClientTypes.ListenerTlsSdsCertificate.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.ListenerTlsSdsCertificate {

    static func write(value: AppMeshClientTypes.ListenerTlsSdsCertificate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["secretName"].write(value.secretName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.ListenerTlsSdsCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.ListenerTlsSdsCertificate()
        value.secretName = try reader["secretName"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.ListenerTlsFileCertificate {

    static func write(value: AppMeshClientTypes.ListenerTlsFileCertificate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateChain"].write(value.certificateChain)
        try writer["privateKey"].write(value.privateKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.ListenerTlsFileCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.ListenerTlsFileCertificate()
        value.certificateChain = try reader["certificateChain"].readIfPresent() ?? ""
        value.privateKey = try reader["privateKey"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.Backend {

    static func write(value: AppMeshClientTypes.Backend?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .virtualservice(virtualservice):
                try writer["virtualService"].write(virtualservice, with: AppMeshClientTypes.VirtualServiceBackend.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.Backend {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "virtualService":
                return .virtualservice(try reader["virtualService"].read(with: AppMeshClientTypes.VirtualServiceBackend.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.VirtualServiceBackend {

    static func write(value: AppMeshClientTypes.VirtualServiceBackend?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientPolicy"].write(value.clientPolicy, with: AppMeshClientTypes.ClientPolicy.write(value:to:))
        try writer["virtualServiceName"].write(value.virtualServiceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualServiceBackend {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualServiceBackend()
        value.virtualServiceName = try reader["virtualServiceName"].readIfPresent() ?? ""
        value.clientPolicy = try reader["clientPolicy"].readIfPresent(with: AppMeshClientTypes.ClientPolicy.read(from:))
        return value
    }
}

extension AppMeshClientTypes.Listener {

    static func write(value: AppMeshClientTypes.Listener?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionPool"].write(value.connectionPool, with: AppMeshClientTypes.VirtualNodeConnectionPool.write(value:to:))
        try writer["healthCheck"].write(value.healthCheck, with: AppMeshClientTypes.HealthCheckPolicy.write(value:to:))
        try writer["outlierDetection"].write(value.outlierDetection, with: AppMeshClientTypes.OutlierDetection.write(value:to:))
        try writer["portMapping"].write(value.portMapping, with: AppMeshClientTypes.PortMapping.write(value:to:))
        try writer["timeout"].write(value.timeout, with: AppMeshClientTypes.ListenerTimeout.write(value:to:))
        try writer["tls"].write(value.tls, with: AppMeshClientTypes.ListenerTls.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.Listener {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.Listener()
        value.portMapping = try reader["portMapping"].readIfPresent(with: AppMeshClientTypes.PortMapping.read(from:))
        value.tls = try reader["tls"].readIfPresent(with: AppMeshClientTypes.ListenerTls.read(from:))
        value.healthCheck = try reader["healthCheck"].readIfPresent(with: AppMeshClientTypes.HealthCheckPolicy.read(from:))
        value.timeout = try reader["timeout"].readIfPresent(with: AppMeshClientTypes.ListenerTimeout.read(from:))
        value.outlierDetection = try reader["outlierDetection"].readIfPresent(with: AppMeshClientTypes.OutlierDetection.read(from:))
        value.connectionPool = try reader["connectionPool"].readIfPresent(with: AppMeshClientTypes.VirtualNodeConnectionPool.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualNodeConnectionPool {

    static func write(value: AppMeshClientTypes.VirtualNodeConnectionPool?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .grpc(grpc):
                try writer["grpc"].write(grpc, with: AppMeshClientTypes.VirtualNodeGrpcConnectionPool.write(value:to:))
            case let .http(http):
                try writer["http"].write(http, with: AppMeshClientTypes.VirtualNodeHttpConnectionPool.write(value:to:))
            case let .http2(http2):
                try writer["http2"].write(http2, with: AppMeshClientTypes.VirtualNodeHttp2ConnectionPool.write(value:to:))
            case let .tcp(tcp):
                try writer["tcp"].write(tcp, with: AppMeshClientTypes.VirtualNodeTcpConnectionPool.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualNodeConnectionPool {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "tcp":
                return .tcp(try reader["tcp"].read(with: AppMeshClientTypes.VirtualNodeTcpConnectionPool.read(from:)))
            case "http":
                return .http(try reader["http"].read(with: AppMeshClientTypes.VirtualNodeHttpConnectionPool.read(from:)))
            case "http2":
                return .http2(try reader["http2"].read(with: AppMeshClientTypes.VirtualNodeHttp2ConnectionPool.read(from:)))
            case "grpc":
                return .grpc(try reader["grpc"].read(with: AppMeshClientTypes.VirtualNodeGrpcConnectionPool.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.VirtualNodeGrpcConnectionPool {

    static func write(value: AppMeshClientTypes.VirtualNodeGrpcConnectionPool?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxRequests"].write(value.maxRequests)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualNodeGrpcConnectionPool {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualNodeGrpcConnectionPool()
        value.maxRequests = try reader["maxRequests"].readIfPresent() ?? 0
        return value
    }
}

extension AppMeshClientTypes.VirtualNodeHttp2ConnectionPool {

    static func write(value: AppMeshClientTypes.VirtualNodeHttp2ConnectionPool?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxRequests"].write(value.maxRequests)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualNodeHttp2ConnectionPool {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualNodeHttp2ConnectionPool()
        value.maxRequests = try reader["maxRequests"].readIfPresent() ?? 0
        return value
    }
}

extension AppMeshClientTypes.VirtualNodeHttpConnectionPool {

    static func write(value: AppMeshClientTypes.VirtualNodeHttpConnectionPool?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxConnections"].write(value.maxConnections)
        try writer["maxPendingRequests"].write(value.maxPendingRequests)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualNodeHttpConnectionPool {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualNodeHttpConnectionPool()
        value.maxConnections = try reader["maxConnections"].readIfPresent() ?? 0
        value.maxPendingRequests = try reader["maxPendingRequests"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.VirtualNodeTcpConnectionPool {

    static func write(value: AppMeshClientTypes.VirtualNodeTcpConnectionPool?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxConnections"].write(value.maxConnections)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualNodeTcpConnectionPool {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualNodeTcpConnectionPool()
        value.maxConnections = try reader["maxConnections"].readIfPresent() ?? 0
        return value
    }
}

extension AppMeshClientTypes.OutlierDetection {

    static func write(value: AppMeshClientTypes.OutlierDetection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["baseEjectionDuration"].write(value.baseEjectionDuration, with: AppMeshClientTypes.Duration.write(value:to:))
        try writer["interval"].write(value.interval, with: AppMeshClientTypes.Duration.write(value:to:))
        try writer["maxEjectionPercent"].write(value.maxEjectionPercent)
        try writer["maxServerErrors"].write(value.maxServerErrors)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.OutlierDetection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.OutlierDetection()
        value.maxServerErrors = try reader["maxServerErrors"].readIfPresent() ?? 0
        value.interval = try reader["interval"].readIfPresent(with: AppMeshClientTypes.Duration.read(from:))
        value.baseEjectionDuration = try reader["baseEjectionDuration"].readIfPresent(with: AppMeshClientTypes.Duration.read(from:))
        value.maxEjectionPercent = try reader["maxEjectionPercent"].readIfPresent() ?? 0
        return value
    }
}

extension AppMeshClientTypes.ListenerTimeout {

    static func write(value: AppMeshClientTypes.ListenerTimeout?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .grpc(grpc):
                try writer["grpc"].write(grpc, with: AppMeshClientTypes.GrpcTimeout.write(value:to:))
            case let .http(http):
                try writer["http"].write(http, with: AppMeshClientTypes.HttpTimeout.write(value:to:))
            case let .http2(http2):
                try writer["http2"].write(http2, with: AppMeshClientTypes.HttpTimeout.write(value:to:))
            case let .tcp(tcp):
                try writer["tcp"].write(tcp, with: AppMeshClientTypes.TcpTimeout.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.ListenerTimeout {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "tcp":
                return .tcp(try reader["tcp"].read(with: AppMeshClientTypes.TcpTimeout.read(from:)))
            case "http":
                return .http(try reader["http"].read(with: AppMeshClientTypes.HttpTimeout.read(from:)))
            case "http2":
                return .http2(try reader["http2"].read(with: AppMeshClientTypes.HttpTimeout.read(from:)))
            case "grpc":
                return .grpc(try reader["grpc"].read(with: AppMeshClientTypes.GrpcTimeout.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.HealthCheckPolicy {

    static func write(value: AppMeshClientTypes.HealthCheckPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["healthyThreshold"].write(value.healthyThreshold)
        try writer["intervalMillis"].write(value.intervalMillis)
        try writer["path"].write(value.path)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["timeoutMillis"].write(value.timeoutMillis)
        try writer["unhealthyThreshold"].write(value.unhealthyThreshold)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.HealthCheckPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.HealthCheckPolicy()
        value.timeoutMillis = try reader["timeoutMillis"].readIfPresent() ?? 0
        value.intervalMillis = try reader["intervalMillis"].readIfPresent() ?? 0
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.port = try reader["port"].readIfPresent()
        value.path = try reader["path"].readIfPresent()
        value.healthyThreshold = try reader["healthyThreshold"].readIfPresent() ?? 0
        value.unhealthyThreshold = try reader["unhealthyThreshold"].readIfPresent() ?? 0
        return value
    }
}

extension AppMeshClientTypes.ListenerTls {

    static func write(value: AppMeshClientTypes.ListenerTls?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificate"].write(value.certificate, with: AppMeshClientTypes.ListenerTlsCertificate.write(value:to:))
        try writer["mode"].write(value.mode)
        try writer["validation"].write(value.validation, with: AppMeshClientTypes.ListenerTlsValidationContext.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.ListenerTls {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.ListenerTls()
        value.mode = try reader["mode"].readIfPresent() ?? .sdkUnknown("")
        value.certificate = try reader["certificate"].readIfPresent(with: AppMeshClientTypes.ListenerTlsCertificate.read(from:))
        value.validation = try reader["validation"].readIfPresent(with: AppMeshClientTypes.ListenerTlsValidationContext.read(from:))
        return value
    }
}

extension AppMeshClientTypes.ListenerTlsValidationContext {

    static func write(value: AppMeshClientTypes.ListenerTlsValidationContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["subjectAlternativeNames"].write(value.subjectAlternativeNames, with: AppMeshClientTypes.SubjectAlternativeNames.write(value:to:))
        try writer["trust"].write(value.trust, with: AppMeshClientTypes.ListenerTlsValidationContextTrust.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.ListenerTlsValidationContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.ListenerTlsValidationContext()
        value.trust = try reader["trust"].readIfPresent(with: AppMeshClientTypes.ListenerTlsValidationContextTrust.read(from:))
        value.subjectAlternativeNames = try reader["subjectAlternativeNames"].readIfPresent(with: AppMeshClientTypes.SubjectAlternativeNames.read(from:))
        return value
    }
}

extension AppMeshClientTypes.ListenerTlsValidationContextTrust {

    static func write(value: AppMeshClientTypes.ListenerTlsValidationContextTrust?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .file(file):
                try writer["file"].write(file, with: AppMeshClientTypes.TlsValidationContextFileTrust.write(value:to:))
            case let .sds(sds):
                try writer["sds"].write(sds, with: AppMeshClientTypes.TlsValidationContextSdsTrust.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.ListenerTlsValidationContextTrust {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "file":
                return .file(try reader["file"].read(with: AppMeshClientTypes.TlsValidationContextFileTrust.read(from:)))
            case "sds":
                return .sds(try reader["sds"].read(with: AppMeshClientTypes.TlsValidationContextSdsTrust.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.ListenerTlsCertificate {

    static func write(value: AppMeshClientTypes.ListenerTlsCertificate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .acm(acm):
                try writer["acm"].write(acm, with: AppMeshClientTypes.ListenerTlsAcmCertificate.write(value:to:))
            case let .file(file):
                try writer["file"].write(file, with: AppMeshClientTypes.ListenerTlsFileCertificate.write(value:to:))
            case let .sds(sds):
                try writer["sds"].write(sds, with: AppMeshClientTypes.ListenerTlsSdsCertificate.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.ListenerTlsCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "acm":
                return .acm(try reader["acm"].read(with: AppMeshClientTypes.ListenerTlsAcmCertificate.read(from:)))
            case "file":
                return .file(try reader["file"].read(with: AppMeshClientTypes.ListenerTlsFileCertificate.read(from:)))
            case "sds":
                return .sds(try reader["sds"].read(with: AppMeshClientTypes.ListenerTlsSdsCertificate.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.ListenerTlsAcmCertificate {

    static func write(value: AppMeshClientTypes.ListenerTlsAcmCertificate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateArn"].write(value.certificateArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.ListenerTlsAcmCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.ListenerTlsAcmCertificate()
        value.certificateArn = try reader["certificateArn"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.PortMapping {

    static func write(value: AppMeshClientTypes.PortMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.PortMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.PortMapping()
        value.port = try reader["port"].readIfPresent() ?? 0
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppMeshClientTypes.ServiceDiscovery {

    static func write(value: AppMeshClientTypes.ServiceDiscovery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .awscloudmap(awscloudmap):
                try writer["awsCloudMap"].write(awscloudmap, with: AppMeshClientTypes.AwsCloudMapServiceDiscovery.write(value:to:))
            case let .dns(dns):
                try writer["dns"].write(dns, with: AppMeshClientTypes.DnsServiceDiscovery.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.ServiceDiscovery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "dns":
                return .dns(try reader["dns"].read(with: AppMeshClientTypes.DnsServiceDiscovery.read(from:)))
            case "awsCloudMap":
                return .awscloudmap(try reader["awsCloudMap"].read(with: AppMeshClientTypes.AwsCloudMapServiceDiscovery.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.AwsCloudMapServiceDiscovery {

    static func write(value: AppMeshClientTypes.AwsCloudMapServiceDiscovery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeList(value.attributes, memberWritingClosure: AppMeshClientTypes.AwsCloudMapInstanceAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ipPreference"].write(value.ipPreference)
        try writer["namespaceName"].write(value.namespaceName)
        try writer["serviceName"].write(value.serviceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.AwsCloudMapServiceDiscovery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.AwsCloudMapServiceDiscovery()
        value.namespaceName = try reader["namespaceName"].readIfPresent() ?? ""
        value.serviceName = try reader["serviceName"].readIfPresent() ?? ""
        value.attributes = try reader["attributes"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.AwsCloudMapInstanceAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipPreference = try reader["ipPreference"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.AwsCloudMapInstanceAttribute {

    static func write(value: AppMeshClientTypes.AwsCloudMapInstanceAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.AwsCloudMapInstanceAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.AwsCloudMapInstanceAttribute()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.DnsServiceDiscovery {

    static func write(value: AppMeshClientTypes.DnsServiceDiscovery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["hostname"].write(value.hostname)
        try writer["ipPreference"].write(value.ipPreference)
        try writer["responseType"].write(value.responseType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.DnsServiceDiscovery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.DnsServiceDiscovery()
        value.hostname = try reader["hostname"].readIfPresent() ?? ""
        value.responseType = try reader["responseType"].readIfPresent()
        value.ipPreference = try reader["ipPreference"].readIfPresent()
        return value
    }
}

extension AppMeshClientTypes.VirtualRouterData {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualRouterData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualRouterData()
        value.meshName = try reader["meshName"].readIfPresent() ?? ""
        value.virtualRouterName = try reader["virtualRouterName"].readIfPresent() ?? ""
        value.spec = try reader["spec"].readIfPresent(with: AppMeshClientTypes.VirtualRouterSpec.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: AppMeshClientTypes.ResourceMetadata.read(from:))
        value.status = try reader["status"].readIfPresent(with: AppMeshClientTypes.VirtualRouterStatus.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualRouterStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualRouterStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualRouterStatus()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppMeshClientTypes.VirtualRouterSpec {

    static func write(value: AppMeshClientTypes.VirtualRouterSpec?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["listeners"].writeList(value.listeners, memberWritingClosure: AppMeshClientTypes.VirtualRouterListener.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualRouterSpec {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualRouterSpec()
        value.listeners = try reader["listeners"].readListIfPresent(memberReadingClosure: AppMeshClientTypes.VirtualRouterListener.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppMeshClientTypes.VirtualRouterListener {

    static func write(value: AppMeshClientTypes.VirtualRouterListener?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["portMapping"].write(value.portMapping, with: AppMeshClientTypes.PortMapping.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualRouterListener {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualRouterListener()
        value.portMapping = try reader["portMapping"].readIfPresent(with: AppMeshClientTypes.PortMapping.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualServiceData {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualServiceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualServiceData()
        value.meshName = try reader["meshName"].readIfPresent() ?? ""
        value.virtualServiceName = try reader["virtualServiceName"].readIfPresent() ?? ""
        value.spec = try reader["spec"].readIfPresent(with: AppMeshClientTypes.VirtualServiceSpec.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: AppMeshClientTypes.ResourceMetadata.read(from:))
        value.status = try reader["status"].readIfPresent(with: AppMeshClientTypes.VirtualServiceStatus.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualServiceStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualServiceStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualServiceStatus()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppMeshClientTypes.VirtualServiceSpec {

    static func write(value: AppMeshClientTypes.VirtualServiceSpec?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["provider"].write(value.provider, with: AppMeshClientTypes.VirtualServiceProvider.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualServiceSpec {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualServiceSpec()
        value.provider = try reader["provider"].readIfPresent(with: AppMeshClientTypes.VirtualServiceProvider.read(from:))
        return value
    }
}

extension AppMeshClientTypes.VirtualServiceProvider {

    static func write(value: AppMeshClientTypes.VirtualServiceProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .virtualnode(virtualnode):
                try writer["virtualNode"].write(virtualnode, with: AppMeshClientTypes.VirtualNodeServiceProvider.write(value:to:))
            case let .virtualrouter(virtualrouter):
                try writer["virtualRouter"].write(virtualrouter, with: AppMeshClientTypes.VirtualRouterServiceProvider.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualServiceProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "virtualNode":
                return .virtualnode(try reader["virtualNode"].read(with: AppMeshClientTypes.VirtualNodeServiceProvider.read(from:)))
            case "virtualRouter":
                return .virtualrouter(try reader["virtualRouter"].read(with: AppMeshClientTypes.VirtualRouterServiceProvider.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppMeshClientTypes.VirtualRouterServiceProvider {

    static func write(value: AppMeshClientTypes.VirtualRouterServiceProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["virtualRouterName"].write(value.virtualRouterName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualRouterServiceProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualRouterServiceProvider()
        value.virtualRouterName = try reader["virtualRouterName"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.VirtualNodeServiceProvider {

    static func write(value: AppMeshClientTypes.VirtualNodeServiceProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["virtualNodeName"].write(value.virtualNodeName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualNodeServiceProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualNodeServiceProvider()
        value.virtualNodeName = try reader["virtualNodeName"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.GatewayRouteRef {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.GatewayRouteRef {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.GatewayRouteRef()
        value.meshName = try reader["meshName"].readIfPresent() ?? ""
        value.gatewayRouteName = try reader["gatewayRouteName"].readIfPresent() ?? ""
        value.virtualGatewayName = try reader["virtualGatewayName"].readIfPresent() ?? ""
        value.meshOwner = try reader["meshOwner"].readIfPresent() ?? ""
        value.resourceOwner = try reader["resourceOwner"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AppMeshClientTypes.MeshRef {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.MeshRef {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.MeshRef()
        value.meshName = try reader["meshName"].readIfPresent() ?? ""
        value.meshOwner = try reader["meshOwner"].readIfPresent() ?? ""
        value.resourceOwner = try reader["resourceOwner"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AppMeshClientTypes.RouteRef {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.RouteRef {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.RouteRef()
        value.meshName = try reader["meshName"].readIfPresent() ?? ""
        value.virtualRouterName = try reader["virtualRouterName"].readIfPresent() ?? ""
        value.routeName = try reader["routeName"].readIfPresent() ?? ""
        value.meshOwner = try reader["meshOwner"].readIfPresent() ?? ""
        value.resourceOwner = try reader["resourceOwner"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AppMeshClientTypes.TagRef {

    static func write(value: AppMeshClientTypes.TagRef?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.TagRef {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.TagRef()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension AppMeshClientTypes.VirtualGatewayRef {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualGatewayRef {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualGatewayRef()
        value.meshName = try reader["meshName"].readIfPresent() ?? ""
        value.virtualGatewayName = try reader["virtualGatewayName"].readIfPresent() ?? ""
        value.meshOwner = try reader["meshOwner"].readIfPresent() ?? ""
        value.resourceOwner = try reader["resourceOwner"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AppMeshClientTypes.VirtualNodeRef {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualNodeRef {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualNodeRef()
        value.meshName = try reader["meshName"].readIfPresent() ?? ""
        value.virtualNodeName = try reader["virtualNodeName"].readIfPresent() ?? ""
        value.meshOwner = try reader["meshOwner"].readIfPresent() ?? ""
        value.resourceOwner = try reader["resourceOwner"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AppMeshClientTypes.VirtualRouterRef {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualRouterRef {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualRouterRef()
        value.meshName = try reader["meshName"].readIfPresent() ?? ""
        value.virtualRouterName = try reader["virtualRouterName"].readIfPresent() ?? ""
        value.meshOwner = try reader["meshOwner"].readIfPresent() ?? ""
        value.resourceOwner = try reader["resourceOwner"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AppMeshClientTypes.VirtualServiceRef {

    static func read(from reader: SmithyJSON.Reader) throws -> AppMeshClientTypes.VirtualServiceRef {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppMeshClientTypes.VirtualServiceRef()
        value.meshName = try reader["meshName"].readIfPresent() ?? ""
        value.virtualServiceName = try reader["virtualServiceName"].readIfPresent() ?? ""
        value.meshOwner = try reader["meshOwner"].readIfPresent() ?? ""
        value.resourceOwner = try reader["resourceOwner"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

public enum AppMeshClientTypes {}
