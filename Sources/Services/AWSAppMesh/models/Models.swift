// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AppMeshClientTypes.AccessLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .file(file):
                try container.encode(file, forKey: .file)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try values.decodeIfPresent(AppMeshClientTypes.FileAccessLog.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents the access logging information for a virtual node.
    public enum AccessLog: Swift.Equatable {
        /// The file object to send virtual node access logs to.
        case file(AppMeshClientTypes.FileAccessLog)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.AwsCloudMapInstanceAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the Cloud Map attribute information for your virtual node. Cloud Map is not available in the eu-south-1 Region.
    public struct AwsCloudMapInstanceAttribute: Swift.Equatable {
        /// The name of an Cloud Map service instance attribute key. Any Cloud Map service instance that contains the specified key and value is returned.
        /// This member is required.
        public var key: Swift.String?
        /// The value of an Cloud Map service instance attribute key. Any Cloud Map service instance that contains the specified key and value is returned.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension AppMeshClientTypes.AwsCloudMapServiceDiscovery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case ipPreference
        case namespaceName
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for awscloudmapinstanceattribute0 in attributes {
                try attributesContainer.encode(awscloudmapinstanceattribute0)
            }
        }
        if let ipPreference = self.ipPreference {
            try encodeContainer.encode(ipPreference.rawValue, forKey: .ipPreference)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.AwsCloudMapInstanceAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[AppMeshClientTypes.AwsCloudMapInstanceAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AppMeshClientTypes.AwsCloudMapInstanceAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let ipPreferenceDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.IpPreference.self, forKey: .ipPreference)
        ipPreference = ipPreferenceDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the Cloud Map service discovery information for your virtual node. Cloud Map is not available in the eu-south-1 Region.
    public struct AwsCloudMapServiceDiscovery: Swift.Equatable {
        /// A string map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
        public var attributes: [AppMeshClientTypes.AwsCloudMapInstanceAttribute]?
        /// The preferred IP version that this virtual node uses. Setting the IP preference on the virtual node only overrides the IP preference set for the mesh on this specific node.
        public var ipPreference: AppMeshClientTypes.IpPreference?
        /// The name of the Cloud Map namespace to use.
        /// This member is required.
        public var namespaceName: Swift.String?
        /// The name of the Cloud Map service to use.
        /// This member is required.
        public var serviceName: Swift.String?

        public init (
            attributes: [AppMeshClientTypes.AwsCloudMapInstanceAttribute]? = nil,
            ipPreference: AppMeshClientTypes.IpPreference? = nil,
            namespaceName: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.ipPreference = ipPreference
            self.namespaceName = namespaceName
            self.serviceName = serviceName
        }
    }

}

extension AppMeshClientTypes.Backend: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case virtualservice = "virtualService"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .virtualservice(virtualservice):
                try container.encode(virtualservice, forKey: .virtualservice)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let virtualserviceDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualServiceBackend.self, forKey: .virtualservice)
        if let virtualservice = virtualserviceDecoded {
            self = .virtualservice(virtualservice)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents the backends that a virtual node is expected to send outbound traffic to.
    public enum Backend: Swift.Equatable {
        /// Specifies a virtual service to use as a backend.
        case virtualservice(AppMeshClientTypes.VirtualServiceBackend)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.BackendDefaults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientPolicy = self.clientPolicy {
            try encodeContainer.encode(clientPolicy, forKey: .clientPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientPolicyDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ClientPolicy.self, forKey: .clientPolicy)
        clientPolicy = clientPolicyDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the default properties for a backend.
    public struct BackendDefaults: Swift.Equatable {
        /// A reference to an object that represents a client policy.
        public var clientPolicy: AppMeshClientTypes.ClientPolicy?

        public init (
            clientPolicy: AppMeshClientTypes.ClientPolicy? = nil
        )
        {
            self.clientPolicy = clientPolicy
        }
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request syntax was malformed. Check your request syntax and try again.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppMeshClientTypes.ClientPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tls
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tls = self.tls {
            try encodeContainer.encode(tls, forKey: .tls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tlsDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ClientPolicyTls.self, forKey: .tls)
        tls = tlsDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a client policy.
    public struct ClientPolicy: Swift.Equatable {
        /// A reference to an object that represents a Transport Layer Security (TLS) client policy.
        public var tls: AppMeshClientTypes.ClientPolicyTls?

        public init (
            tls: AppMeshClientTypes.ClientPolicyTls? = nil
        )
        {
            self.tls = tls
        }
    }

}

extension AppMeshClientTypes.ClientPolicyTls: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate
        case enforce
        case ports
        case validation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let enforce = self.enforce {
            try encodeContainer.encode(enforce, forKey: .enforce)
        }
        if let ports = ports {
            var portsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ports)
            for portnumber0 in ports {
                try portsContainer.encode(portnumber0)
            }
        }
        if let validation = self.validation {
            try encodeContainer.encode(validation, forKey: .validation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforce)
        enforce = enforceDecoded
        let portsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .ports)
        var portsDecoded0:[Swift.Int]? = nil
        if let portsContainer = portsContainer {
            portsDecoded0 = [Swift.Int]()
            for integer0 in portsContainer {
                if let integer0 = integer0 {
                    portsDecoded0?.append(integer0)
                }
            }
        }
        ports = portsDecoded0
        let certificateDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ClientTlsCertificate.self, forKey: .certificate)
        certificate = certificateDecoded
        let validationDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.TlsValidationContext.self, forKey: .validation)
        validation = validationDecoded
    }
}

extension AppMeshClientTypes {
    /// A reference to an object that represents a Transport Layer Security (TLS) client policy.
    public struct ClientPolicyTls: Swift.Equatable {
        /// A reference to an object that represents a client's TLS certificate.
        public var certificate: AppMeshClientTypes.ClientTlsCertificate?
        /// Whether the policy is enforced. The default is True, if a value isn't specified.
        public var enforce: Swift.Bool?
        /// One or more ports that the policy is enforced for.
        public var ports: [Swift.Int]?
        /// A reference to an object that represents a TLS validation context.
        /// This member is required.
        public var validation: AppMeshClientTypes.TlsValidationContext?

        public init (
            certificate: AppMeshClientTypes.ClientTlsCertificate? = nil,
            enforce: Swift.Bool? = nil,
            ports: [Swift.Int]? = nil,
            validation: AppMeshClientTypes.TlsValidationContext? = nil
        )
        {
            self.certificate = certificate
            self.enforce = enforce
            self.ports = ports
            self.validation = validation
        }
    }

}

extension AppMeshClientTypes.ClientTlsCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .file(file):
                try container.encode(file, forKey: .file)
            case let .sds(sds):
                try container.encode(sds, forKey: .sds)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try values.decodeIfPresent(AppMeshClientTypes.ListenerTlsFileCertificate.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(AppMeshClientTypes.ListenerTlsSdsCertificate.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents the client's certificate.
    public enum ClientTlsCertificate: Swift.Equatable {
        /// An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see [Transport Layer Security (TLS)](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html).
        case file(AppMeshClientTypes.ListenerTlsFileCertificate)
        /// A reference to an object that represents a client's TLS Secret Discovery Service certificate.
        case sds(AppMeshClientTypes.ListenerTlsSdsCertificate)
        case sdkUnknown(Swift.String)
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request contains a client token that was used for a previous update resource call with different specifications. Try the request again with a new client token.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateGatewayRouteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case gatewayRouteName
        case spec
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let gatewayRouteName = self.gatewayRouteName {
            try encodeContainer.encode(gatewayRouteName, forKey: .gatewayRouteName)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagref0 in tags {
                try tagsContainer.encode(tagref0)
            }
        }
    }
}

extension CreateGatewayRouteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension CreateGatewayRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualGatewayName = virtualGatewayName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateway/\(virtualGatewayName.urlPercentEncoding())/gatewayRoutes"
    }
}

public struct CreateGatewayRouteInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name to use for the gateway route.
    /// This member is required.
    public var gatewayRouteName: Swift.String?
    /// The name of the service mesh to create the gateway route in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The gateway route specification to apply.
    /// This member is required.
    public var spec: AppMeshClientTypes.GatewayRouteSpec?
    /// Optional metadata that you can apply to the gateway route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [AppMeshClientTypes.TagRef]?
    /// The name of the virtual gateway to associate the gateway route with. If the virtual gateway is in a shared mesh, then you must be the owner of the virtual gateway resource.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        gatewayRouteName: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.GatewayRouteSpec? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.gatewayRouteName = gatewayRouteName
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualGatewayName = virtualGatewayName
    }
}

struct CreateGatewayRouteInputBody: Swift.Equatable {
    let gatewayRouteName: Swift.String?
    let spec: AppMeshClientTypes.GatewayRouteSpec?
    let tags: [AppMeshClientTypes.TagRef]?
    let clientToken: Swift.String?
}

extension CreateGatewayRouteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case gatewayRouteName
        case spec
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayRouteNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayRouteName)
        gatewayRouteName = gatewayRouteNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteSpec.self, forKey: .spec)
        spec = specDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.TagRef?].self, forKey: .tags)
        var tagsDecoded0:[AppMeshClientTypes.TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppMeshClientTypes.TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateGatewayRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGatewayRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGatewayRouteOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGatewayRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.GatewayRouteData = try responseDecoder.decode(responseBody: data)
                self.gatewayRoute = output
            } else {
                self.gatewayRoute = nil
            }
        } else {
            self.gatewayRoute = nil
        }
    }
}

public struct CreateGatewayRouteOutputResponse: Swift.Equatable {
    /// The full description of your gateway route following the create call.
    /// This member is required.
    public var gatewayRoute: AppMeshClientTypes.GatewayRouteData?

    public init (
        gatewayRoute: AppMeshClientTypes.GatewayRouteData? = nil
    )
    {
        self.gatewayRoute = gatewayRoute
    }
}

struct CreateGatewayRouteOutputResponseBody: Swift.Equatable {
    let gatewayRoute: AppMeshClientTypes.GatewayRouteData?
}

extension CreateGatewayRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayRoute
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayRouteDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteData.self, forKey: .gatewayRoute)
        gatewayRoute = gatewayRouteDecoded
    }
}

extension CreateMeshInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case meshName
        case spec
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagref0 in tags {
                try tagsContainer.encode(tagref0)
            }
        }
    }
}

extension CreateMeshInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20190125/meshes"
    }
}

///
public struct CreateMeshInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name to use for the service mesh.
    /// This member is required.
    public var meshName: Swift.String?
    /// The service mesh specification to apply.
    public var spec: AppMeshClientTypes.MeshSpec?
    /// Optional metadata that you can apply to the service mesh to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [AppMeshClientTypes.TagRef]?

    public init (
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        spec: AppMeshClientTypes.MeshSpec? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.spec = spec
        self.tags = tags
    }
}

struct CreateMeshInputBody: Swift.Equatable {
    let meshName: Swift.String?
    let spec: AppMeshClientTypes.MeshSpec?
    let tags: [AppMeshClientTypes.TagRef]?
    let clientToken: Swift.String?
}

extension CreateMeshInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case meshName
        case spec
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.MeshSpec.self, forKey: .spec)
        spec = specDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.TagRef?].self, forKey: .tags)
        var tagsDecoded0:[AppMeshClientTypes.TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppMeshClientTypes.TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateMeshOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMeshOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMeshOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMeshOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.MeshData = try responseDecoder.decode(responseBody: data)
                self.mesh = output
            } else {
                self.mesh = nil
            }
        } else {
            self.mesh = nil
        }
    }
}

///
public struct CreateMeshOutputResponse: Swift.Equatable {
    /// The full description of your service mesh following the create call.
    /// This member is required.
    public var mesh: AppMeshClientTypes.MeshData?

    public init (
        mesh: AppMeshClientTypes.MeshData? = nil
    )
    {
        self.mesh = mesh
    }
}

struct CreateMeshOutputResponseBody: Swift.Equatable {
    let mesh: AppMeshClientTypes.MeshData?
}

extension CreateMeshOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mesh
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.MeshData.self, forKey: .mesh)
        mesh = meshDecoded
    }
}

extension CreateRouteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case routeName
        case spec
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let routeName = self.routeName {
            try encodeContainer.encode(routeName, forKey: .routeName)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagref0 in tags {
                try tagsContainer.encode(tagref0)
            }
        }
    }
}

extension CreateRouteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension CreateRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualRouterName = virtualRouterName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouter/\(virtualRouterName.urlPercentEncoding())/routes"
    }
}

///
public struct CreateRouteInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh to create the route in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name to use for the route.
    /// This member is required.
    public var routeName: Swift.String?
    /// The route specification to apply.
    /// This member is required.
    public var spec: AppMeshClientTypes.RouteSpec?
    /// Optional metadata that you can apply to the route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [AppMeshClientTypes.TagRef]?
    /// The name of the virtual router in which to create the route. If the virtual router is in a shared mesh, then you must be the owner of the virtual router resource.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        routeName: Swift.String? = nil,
        spec: AppMeshClientTypes.RouteSpec? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.routeName = routeName
        self.spec = spec
        self.tags = tags
        self.virtualRouterName = virtualRouterName
    }
}

struct CreateRouteInputBody: Swift.Equatable {
    let routeName: Swift.String?
    let spec: AppMeshClientTypes.RouteSpec?
    let tags: [AppMeshClientTypes.TagRef]?
    let clientToken: Swift.String?
}

extension CreateRouteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case routeName
        case spec
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeName)
        routeName = routeNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.RouteSpec.self, forKey: .spec)
        spec = specDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.TagRef?].self, forKey: .tags)
        var tagsDecoded0:[AppMeshClientTypes.TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppMeshClientTypes.TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRouteOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.RouteData = try responseDecoder.decode(responseBody: data)
                self.route = output
            } else {
                self.route = nil
            }
        } else {
            self.route = nil
        }
    }
}

///
public struct CreateRouteOutputResponse: Swift.Equatable {
    /// The full description of your mesh following the create call.
    /// This member is required.
    public var route: AppMeshClientTypes.RouteData?

    public init (
        route: AppMeshClientTypes.RouteData? = nil
    )
    {
        self.route = route
    }
}

struct CreateRouteOutputResponseBody: Swift.Equatable {
    let route: AppMeshClientTypes.RouteData?
}

extension CreateRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case route
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.RouteData.self, forKey: .route)
        route = routeDecoded
    }
}

extension CreateVirtualGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
        case tags
        case virtualGatewayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagref0 in tags {
                try tagsContainer.encode(tagref0)
            }
        }
        if let virtualGatewayName = self.virtualGatewayName {
            try encodeContainer.encode(virtualGatewayName, forKey: .virtualGatewayName)
        }
    }
}

extension CreateVirtualGatewayInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension CreateVirtualGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateways"
    }
}

public struct CreateVirtualGatewayInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh to create the virtual gateway in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The virtual gateway specification to apply.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualGatewaySpec?
    /// Optional metadata that you can apply to the virtual gateway to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [AppMeshClientTypes.TagRef]?
    /// The name to use for the virtual gateway.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualGatewaySpec? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualGatewayName = virtualGatewayName
    }
}

struct CreateVirtualGatewayInputBody: Swift.Equatable {
    let virtualGatewayName: Swift.String?
    let spec: AppMeshClientTypes.VirtualGatewaySpec?
    let tags: [AppMeshClientTypes.TagRef]?
    let clientToken: Swift.String?
}

extension CreateVirtualGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
        case tags
        case virtualGatewayName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayName)
        virtualGatewayName = virtualGatewayNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewaySpec.self, forKey: .spec)
        spec = specDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.TagRef?].self, forKey: .tags)
        var tagsDecoded0:[AppMeshClientTypes.TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppMeshClientTypes.TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateVirtualGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVirtualGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVirtualGatewayOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVirtualGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualGatewayData = try responseDecoder.decode(responseBody: data)
                self.virtualGateway = output
            } else {
                self.virtualGateway = nil
            }
        } else {
            self.virtualGateway = nil
        }
    }
}

public struct CreateVirtualGatewayOutputResponse: Swift.Equatable {
    /// The full description of your virtual gateway following the create call.
    /// This member is required.
    public var virtualGateway: AppMeshClientTypes.VirtualGatewayData?

    public init (
        virtualGateway: AppMeshClientTypes.VirtualGatewayData? = nil
    )
    {
        self.virtualGateway = virtualGateway
    }
}

struct CreateVirtualGatewayOutputResponseBody: Swift.Equatable {
    let virtualGateway: AppMeshClientTypes.VirtualGatewayData?
}

extension CreateVirtualGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualGateway
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewayDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayData.self, forKey: .virtualGateway)
        virtualGateway = virtualGatewayDecoded
    }
}

extension CreateVirtualNodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
        case tags
        case virtualNodeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagref0 in tags {
                try tagsContainer.encode(tagref0)
            }
        }
        if let virtualNodeName = self.virtualNodeName {
            try encodeContainer.encode(virtualNodeName, forKey: .virtualNodeName)
        }
    }
}

extension CreateVirtualNodeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension CreateVirtualNodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualNodes"
    }
}

///
public struct CreateVirtualNodeInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh to create the virtual node in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The virtual node specification to apply.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualNodeSpec?
    /// Optional metadata that you can apply to the virtual node to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [AppMeshClientTypes.TagRef]?
    /// The name to use for the virtual node.
    /// This member is required.
    public var virtualNodeName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualNodeSpec? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil,
        virtualNodeName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualNodeName = virtualNodeName
    }
}

struct CreateVirtualNodeInputBody: Swift.Equatable {
    let virtualNodeName: Swift.String?
    let spec: AppMeshClientTypes.VirtualNodeSpec?
    let tags: [AppMeshClientTypes.TagRef]?
    let clientToken: Swift.String?
}

extension CreateVirtualNodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
        case tags
        case virtualNodeName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualNodeName)
        virtualNodeName = virtualNodeNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualNodeSpec.self, forKey: .spec)
        spec = specDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.TagRef?].self, forKey: .tags)
        var tagsDecoded0:[AppMeshClientTypes.TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppMeshClientTypes.TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateVirtualNodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVirtualNodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVirtualNodeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVirtualNodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualNodeData = try responseDecoder.decode(responseBody: data)
                self.virtualNode = output
            } else {
                self.virtualNode = nil
            }
        } else {
            self.virtualNode = nil
        }
    }
}

///
public struct CreateVirtualNodeOutputResponse: Swift.Equatable {
    /// The full description of your virtual node following the create call.
    /// This member is required.
    public var virtualNode: AppMeshClientTypes.VirtualNodeData?

    public init (
        virtualNode: AppMeshClientTypes.VirtualNodeData? = nil
    )
    {
        self.virtualNode = virtualNode
    }
}

struct CreateVirtualNodeOutputResponseBody: Swift.Equatable {
    let virtualNode: AppMeshClientTypes.VirtualNodeData?
}

extension CreateVirtualNodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualNode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualNodeData.self, forKey: .virtualNode)
        virtualNode = virtualNodeDecoded
    }
}

extension CreateVirtualRouterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
        case tags
        case virtualRouterName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagref0 in tags {
                try tagsContainer.encode(tagref0)
            }
        }
        if let virtualRouterName = self.virtualRouterName {
            try encodeContainer.encode(virtualRouterName, forKey: .virtualRouterName)
        }
    }
}

extension CreateVirtualRouterInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension CreateVirtualRouterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouters"
    }
}

///
public struct CreateVirtualRouterInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh to create the virtual router in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The virtual router specification to apply.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualRouterSpec?
    /// Optional metadata that you can apply to the virtual router to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [AppMeshClientTypes.TagRef]?
    /// The name to use for the virtual router.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualRouterSpec? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualRouterName = virtualRouterName
    }
}

struct CreateVirtualRouterInputBody: Swift.Equatable {
    let virtualRouterName: Swift.String?
    let spec: AppMeshClientTypes.VirtualRouterSpec?
    let tags: [AppMeshClientTypes.TagRef]?
    let clientToken: Swift.String?
}

extension CreateVirtualRouterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
        case tags
        case virtualRouterName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualRouterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualRouterName)
        virtualRouterName = virtualRouterNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualRouterSpec.self, forKey: .spec)
        spec = specDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.TagRef?].self, forKey: .tags)
        var tagsDecoded0:[AppMeshClientTypes.TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppMeshClientTypes.TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateVirtualRouterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVirtualRouterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVirtualRouterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVirtualRouterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualRouterData = try responseDecoder.decode(responseBody: data)
                self.virtualRouter = output
            } else {
                self.virtualRouter = nil
            }
        } else {
            self.virtualRouter = nil
        }
    }
}

///
public struct CreateVirtualRouterOutputResponse: Swift.Equatable {
    /// The full description of your virtual router following the create call.
    /// This member is required.
    public var virtualRouter: AppMeshClientTypes.VirtualRouterData?

    public init (
        virtualRouter: AppMeshClientTypes.VirtualRouterData? = nil
    )
    {
        self.virtualRouter = virtualRouter
    }
}

struct CreateVirtualRouterOutputResponseBody: Swift.Equatable {
    let virtualRouter: AppMeshClientTypes.VirtualRouterData?
}

extension CreateVirtualRouterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualRouter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualRouterDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualRouterData.self, forKey: .virtualRouter)
        virtualRouter = virtualRouterDecoded
    }
}

extension CreateVirtualServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
        case tags
        case virtualServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagref0 in tags {
                try tagsContainer.encode(tagref0)
            }
        }
        if let virtualServiceName = self.virtualServiceName {
            try encodeContainer.encode(virtualServiceName, forKey: .virtualServiceName)
        }
    }
}

extension CreateVirtualServiceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension CreateVirtualServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualServices"
    }
}

///
public struct CreateVirtualServiceInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh to create the virtual service in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The virtual service specification to apply.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualServiceSpec?
    /// Optional metadata that you can apply to the virtual service to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [AppMeshClientTypes.TagRef]?
    /// The name to use for the virtual service.
    /// This member is required.
    public var virtualServiceName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualServiceSpec? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil,
        virtualServiceName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualServiceName = virtualServiceName
    }
}

struct CreateVirtualServiceInputBody: Swift.Equatable {
    let virtualServiceName: Swift.String?
    let spec: AppMeshClientTypes.VirtualServiceSpec?
    let tags: [AppMeshClientTypes.TagRef]?
    let clientToken: Swift.String?
}

extension CreateVirtualServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
        case tags
        case virtualServiceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualServiceName)
        virtualServiceName = virtualServiceNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualServiceSpec.self, forKey: .spec)
        spec = specDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.TagRef?].self, forKey: .tags)
        var tagsDecoded0:[AppMeshClientTypes.TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppMeshClientTypes.TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateVirtualServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVirtualServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVirtualServiceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVirtualServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualServiceData = try responseDecoder.decode(responseBody: data)
                self.virtualService = output
            } else {
                self.virtualService = nil
            }
        } else {
            self.virtualService = nil
        }
    }
}

///
public struct CreateVirtualServiceOutputResponse: Swift.Equatable {
    /// The full description of your virtual service following the create call.
    /// This member is required.
    public var virtualService: AppMeshClientTypes.VirtualServiceData?

    public init (
        virtualService: AppMeshClientTypes.VirtualServiceData? = nil
    )
    {
        self.virtualService = virtualService
    }
}

struct CreateVirtualServiceOutputResponseBody: Swift.Equatable {
    let virtualService: AppMeshClientTypes.VirtualServiceData?
}

extension CreateVirtualServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualService
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualServiceData.self, forKey: .virtualService)
        virtualService = virtualServiceDecoded
    }
}

extension AppMeshClientTypes {
    public enum DefaultGatewayRouteRewrite: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DefaultGatewayRouteRewrite] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DefaultGatewayRouteRewrite(rawValue: rawValue) ?? DefaultGatewayRouteRewrite.sdkUnknown(rawValue)
        }
    }
}

extension DeleteGatewayRouteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension DeleteGatewayRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualGatewayName = virtualGatewayName else {
            return nil
        }
        guard let gatewayRouteName = gatewayRouteName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateway/\(virtualGatewayName.urlPercentEncoding())/gatewayRoutes/\(gatewayRouteName.urlPercentEncoding())"
    }
}

public struct DeleteGatewayRouteInput: Swift.Equatable {
    /// The name of the gateway route to delete.
    /// This member is required.
    public var gatewayRouteName: Swift.String?
    /// The name of the service mesh to delete the gateway route from.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual gateway to delete the route from.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init (
        gatewayRouteName: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.gatewayRouteName = gatewayRouteName
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualGatewayName = virtualGatewayName
    }
}

struct DeleteGatewayRouteInputBody: Swift.Equatable {
}

extension DeleteGatewayRouteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGatewayRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGatewayRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGatewayRouteOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGatewayRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.GatewayRouteData = try responseDecoder.decode(responseBody: data)
                self.gatewayRoute = output
            } else {
                self.gatewayRoute = nil
            }
        } else {
            self.gatewayRoute = nil
        }
    }
}

public struct DeleteGatewayRouteOutputResponse: Swift.Equatable {
    /// The gateway route that was deleted.
    /// This member is required.
    public var gatewayRoute: AppMeshClientTypes.GatewayRouteData?

    public init (
        gatewayRoute: AppMeshClientTypes.GatewayRouteData? = nil
    )
    {
        self.gatewayRoute = gatewayRoute
    }
}

struct DeleteGatewayRouteOutputResponseBody: Swift.Equatable {
    let gatewayRoute: AppMeshClientTypes.GatewayRouteData?
}

extension DeleteGatewayRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayRoute
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayRouteDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteData.self, forKey: .gatewayRoute)
        gatewayRoute = gatewayRouteDecoded
    }
}

extension DeleteMeshInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())"
    }
}

///
public struct DeleteMeshInput: Swift.Equatable {
    /// The name of the service mesh to delete.
    /// This member is required.
    public var meshName: Swift.String?

    public init (
        meshName: Swift.String? = nil
    )
    {
        self.meshName = meshName
    }
}

struct DeleteMeshInputBody: Swift.Equatable {
}

extension DeleteMeshInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMeshOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMeshOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMeshOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMeshOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.MeshData = try responseDecoder.decode(responseBody: data)
                self.mesh = output
            } else {
                self.mesh = nil
            }
        } else {
            self.mesh = nil
        }
    }
}

///
public struct DeleteMeshOutputResponse: Swift.Equatable {
    /// The service mesh that was deleted.
    /// This member is required.
    public var mesh: AppMeshClientTypes.MeshData?

    public init (
        mesh: AppMeshClientTypes.MeshData? = nil
    )
    {
        self.mesh = mesh
    }
}

struct DeleteMeshOutputResponseBody: Swift.Equatable {
    let mesh: AppMeshClientTypes.MeshData?
}

extension DeleteMeshOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mesh
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.MeshData.self, forKey: .mesh)
        mesh = meshDecoded
    }
}

extension DeleteRouteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension DeleteRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualRouterName = virtualRouterName else {
            return nil
        }
        guard let routeName = routeName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouter/\(virtualRouterName.urlPercentEncoding())/routes/\(routeName.urlPercentEncoding())"
    }
}

///
public struct DeleteRouteInput: Swift.Equatable {
    /// The name of the service mesh to delete the route in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the route to delete.
    /// This member is required.
    public var routeName: Swift.String?
    /// The name of the virtual router to delete the route in.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init (
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        routeName: Swift.String? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.routeName = routeName
        self.virtualRouterName = virtualRouterName
    }
}

struct DeleteRouteInputBody: Swift.Equatable {
}

extension DeleteRouteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRouteOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.RouteData = try responseDecoder.decode(responseBody: data)
                self.route = output
            } else {
                self.route = nil
            }
        } else {
            self.route = nil
        }
    }
}

///
public struct DeleteRouteOutputResponse: Swift.Equatable {
    /// The route that was deleted.
    /// This member is required.
    public var route: AppMeshClientTypes.RouteData?

    public init (
        route: AppMeshClientTypes.RouteData? = nil
    )
    {
        self.route = route
    }
}

struct DeleteRouteOutputResponseBody: Swift.Equatable {
    let route: AppMeshClientTypes.RouteData?
}

extension DeleteRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case route
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.RouteData.self, forKey: .route)
        route = routeDecoded
    }
}

extension DeleteVirtualGatewayInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension DeleteVirtualGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualGatewayName = virtualGatewayName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateways/\(virtualGatewayName.urlPercentEncoding())"
    }
}

public struct DeleteVirtualGatewayInput: Swift.Equatable {
    /// The name of the service mesh to delete the virtual gateway from.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual gateway to delete.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init (
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualGatewayName = virtualGatewayName
    }
}

struct DeleteVirtualGatewayInputBody: Swift.Equatable {
}

extension DeleteVirtualGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVirtualGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVirtualGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVirtualGatewayOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualGatewayData = try responseDecoder.decode(responseBody: data)
                self.virtualGateway = output
            } else {
                self.virtualGateway = nil
            }
        } else {
            self.virtualGateway = nil
        }
    }
}

public struct DeleteVirtualGatewayOutputResponse: Swift.Equatable {
    /// The virtual gateway that was deleted.
    /// This member is required.
    public var virtualGateway: AppMeshClientTypes.VirtualGatewayData?

    public init (
        virtualGateway: AppMeshClientTypes.VirtualGatewayData? = nil
    )
    {
        self.virtualGateway = virtualGateway
    }
}

struct DeleteVirtualGatewayOutputResponseBody: Swift.Equatable {
    let virtualGateway: AppMeshClientTypes.VirtualGatewayData?
}

extension DeleteVirtualGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualGateway
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewayDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayData.self, forKey: .virtualGateway)
        virtualGateway = virtualGatewayDecoded
    }
}

extension DeleteVirtualNodeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension DeleteVirtualNodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualNodeName = virtualNodeName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualNodes/\(virtualNodeName.urlPercentEncoding())"
    }
}

/// Deletes a virtual node input.
public struct DeleteVirtualNodeInput: Swift.Equatable {
    /// The name of the service mesh to delete the virtual node in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual node to delete.
    /// This member is required.
    public var virtualNodeName: Swift.String?

    public init (
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualNodeName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualNodeName = virtualNodeName
    }
}

struct DeleteVirtualNodeInputBody: Swift.Equatable {
}

extension DeleteVirtualNodeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVirtualNodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVirtualNodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVirtualNodeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualNodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualNodeData = try responseDecoder.decode(responseBody: data)
                self.virtualNode = output
            } else {
                self.virtualNode = nil
            }
        } else {
            self.virtualNode = nil
        }
    }
}

///
public struct DeleteVirtualNodeOutputResponse: Swift.Equatable {
    /// The virtual node that was deleted.
    /// This member is required.
    public var virtualNode: AppMeshClientTypes.VirtualNodeData?

    public init (
        virtualNode: AppMeshClientTypes.VirtualNodeData? = nil
    )
    {
        self.virtualNode = virtualNode
    }
}

struct DeleteVirtualNodeOutputResponseBody: Swift.Equatable {
    let virtualNode: AppMeshClientTypes.VirtualNodeData?
}

extension DeleteVirtualNodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualNode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualNodeData.self, forKey: .virtualNode)
        virtualNode = virtualNodeDecoded
    }
}

extension DeleteVirtualRouterInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension DeleteVirtualRouterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualRouterName = virtualRouterName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouters/\(virtualRouterName.urlPercentEncoding())"
    }
}

///
public struct DeleteVirtualRouterInput: Swift.Equatable {
    /// The name of the service mesh to delete the virtual router in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual router to delete.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init (
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualRouterName = virtualRouterName
    }
}

struct DeleteVirtualRouterInputBody: Swift.Equatable {
}

extension DeleteVirtualRouterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVirtualRouterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVirtualRouterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVirtualRouterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualRouterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualRouterData = try responseDecoder.decode(responseBody: data)
                self.virtualRouter = output
            } else {
                self.virtualRouter = nil
            }
        } else {
            self.virtualRouter = nil
        }
    }
}

///
public struct DeleteVirtualRouterOutputResponse: Swift.Equatable {
    /// The virtual router that was deleted.
    /// This member is required.
    public var virtualRouter: AppMeshClientTypes.VirtualRouterData?

    public init (
        virtualRouter: AppMeshClientTypes.VirtualRouterData? = nil
    )
    {
        self.virtualRouter = virtualRouter
    }
}

struct DeleteVirtualRouterOutputResponseBody: Swift.Equatable {
    let virtualRouter: AppMeshClientTypes.VirtualRouterData?
}

extension DeleteVirtualRouterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualRouter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualRouterDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualRouterData.self, forKey: .virtualRouter)
        virtualRouter = virtualRouterDecoded
    }
}

extension DeleteVirtualServiceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension DeleteVirtualServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualServiceName = virtualServiceName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualServices/\(virtualServiceName.urlPercentEncoding())"
    }
}

///
public struct DeleteVirtualServiceInput: Swift.Equatable {
    /// The name of the service mesh to delete the virtual service in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual service to delete.
    /// This member is required.
    public var virtualServiceName: Swift.String?

    public init (
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualServiceName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualServiceName = virtualServiceName
    }
}

struct DeleteVirtualServiceInputBody: Swift.Equatable {
}

extension DeleteVirtualServiceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVirtualServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVirtualServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVirtualServiceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualServiceData = try responseDecoder.decode(responseBody: data)
                self.virtualService = output
            } else {
                self.virtualService = nil
            }
        } else {
            self.virtualService = nil
        }
    }
}

///
public struct DeleteVirtualServiceOutputResponse: Swift.Equatable {
    /// The virtual service that was deleted.
    /// This member is required.
    public var virtualService: AppMeshClientTypes.VirtualServiceData?

    public init (
        virtualService: AppMeshClientTypes.VirtualServiceData? = nil
    )
    {
        self.virtualService = virtualService
    }
}

struct DeleteVirtualServiceOutputResponseBody: Swift.Equatable {
    let virtualService: AppMeshClientTypes.VirtualServiceData?
}

extension DeleteVirtualServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualService
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualServiceData.self, forKey: .virtualService)
        virtualService = virtualServiceDecoded
    }
}

extension DescribeGatewayRouteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension DescribeGatewayRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualGatewayName = virtualGatewayName else {
            return nil
        }
        guard let gatewayRouteName = gatewayRouteName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateway/\(virtualGatewayName.urlPercentEncoding())/gatewayRoutes/\(gatewayRouteName.urlPercentEncoding())"
    }
}

public struct DescribeGatewayRouteInput: Swift.Equatable {
    /// The name of the gateway route to describe.
    /// This member is required.
    public var gatewayRouteName: Swift.String?
    /// The name of the service mesh that the gateway route resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual gateway that the gateway route is associated with.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init (
        gatewayRouteName: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.gatewayRouteName = gatewayRouteName
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualGatewayName = virtualGatewayName
    }
}

struct DescribeGatewayRouteInputBody: Swift.Equatable {
}

extension DescribeGatewayRouteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGatewayRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGatewayRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeGatewayRouteOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGatewayRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.GatewayRouteData = try responseDecoder.decode(responseBody: data)
                self.gatewayRoute = output
            } else {
                self.gatewayRoute = nil
            }
        } else {
            self.gatewayRoute = nil
        }
    }
}

public struct DescribeGatewayRouteOutputResponse: Swift.Equatable {
    /// The full description of your gateway route.
    /// This member is required.
    public var gatewayRoute: AppMeshClientTypes.GatewayRouteData?

    public init (
        gatewayRoute: AppMeshClientTypes.GatewayRouteData? = nil
    )
    {
        self.gatewayRoute = gatewayRoute
    }
}

struct DescribeGatewayRouteOutputResponseBody: Swift.Equatable {
    let gatewayRoute: AppMeshClientTypes.GatewayRouteData?
}

extension DescribeGatewayRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayRoute
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayRouteDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteData.self, forKey: .gatewayRoute)
        gatewayRoute = gatewayRouteDecoded
    }
}

extension DescribeMeshInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension DescribeMeshInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())"
    }
}

///
public struct DescribeMeshInput: Swift.Equatable {
    /// The name of the service mesh to describe.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?

    public init (
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
    }
}

struct DescribeMeshInputBody: Swift.Equatable {
}

extension DescribeMeshInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeMeshOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMeshOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeMeshOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMeshOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.MeshData = try responseDecoder.decode(responseBody: data)
                self.mesh = output
            } else {
                self.mesh = nil
            }
        } else {
            self.mesh = nil
        }
    }
}

///
public struct DescribeMeshOutputResponse: Swift.Equatable {
    /// The full description of your service mesh.
    /// This member is required.
    public var mesh: AppMeshClientTypes.MeshData?

    public init (
        mesh: AppMeshClientTypes.MeshData? = nil
    )
    {
        self.mesh = mesh
    }
}

struct DescribeMeshOutputResponseBody: Swift.Equatable {
    let mesh: AppMeshClientTypes.MeshData?
}

extension DescribeMeshOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mesh
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.MeshData.self, forKey: .mesh)
        mesh = meshDecoded
    }
}

extension DescribeRouteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension DescribeRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualRouterName = virtualRouterName else {
            return nil
        }
        guard let routeName = routeName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouter/\(virtualRouterName.urlPercentEncoding())/routes/\(routeName.urlPercentEncoding())"
    }
}

///
public struct DescribeRouteInput: Swift.Equatable {
    /// The name of the service mesh that the route resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the route to describe.
    /// This member is required.
    public var routeName: Swift.String?
    /// The name of the virtual router that the route is associated with.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init (
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        routeName: Swift.String? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.routeName = routeName
        self.virtualRouterName = virtualRouterName
    }
}

struct DescribeRouteInputBody: Swift.Equatable {
}

extension DescribeRouteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRouteOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.RouteData = try responseDecoder.decode(responseBody: data)
                self.route = output
            } else {
                self.route = nil
            }
        } else {
            self.route = nil
        }
    }
}

///
public struct DescribeRouteOutputResponse: Swift.Equatable {
    /// The full description of your route.
    /// This member is required.
    public var route: AppMeshClientTypes.RouteData?

    public init (
        route: AppMeshClientTypes.RouteData? = nil
    )
    {
        self.route = route
    }
}

struct DescribeRouteOutputResponseBody: Swift.Equatable {
    let route: AppMeshClientTypes.RouteData?
}

extension DescribeRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case route
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.RouteData.self, forKey: .route)
        route = routeDecoded
    }
}

extension DescribeVirtualGatewayInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension DescribeVirtualGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualGatewayName = virtualGatewayName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateways/\(virtualGatewayName.urlPercentEncoding())"
    }
}

public struct DescribeVirtualGatewayInput: Swift.Equatable {
    /// The name of the service mesh that the gateway route resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual gateway to describe.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init (
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualGatewayName = virtualGatewayName
    }
}

struct DescribeVirtualGatewayInputBody: Swift.Equatable {
}

extension DescribeVirtualGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVirtualGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeVirtualGatewayOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualGatewayData = try responseDecoder.decode(responseBody: data)
                self.virtualGateway = output
            } else {
                self.virtualGateway = nil
            }
        } else {
            self.virtualGateway = nil
        }
    }
}

public struct DescribeVirtualGatewayOutputResponse: Swift.Equatable {
    /// The full description of your virtual gateway.
    /// This member is required.
    public var virtualGateway: AppMeshClientTypes.VirtualGatewayData?

    public init (
        virtualGateway: AppMeshClientTypes.VirtualGatewayData? = nil
    )
    {
        self.virtualGateway = virtualGateway
    }
}

struct DescribeVirtualGatewayOutputResponseBody: Swift.Equatable {
    let virtualGateway: AppMeshClientTypes.VirtualGatewayData?
}

extension DescribeVirtualGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualGateway
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewayDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayData.self, forKey: .virtualGateway)
        virtualGateway = virtualGatewayDecoded
    }
}

extension DescribeVirtualNodeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension DescribeVirtualNodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualNodeName = virtualNodeName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualNodes/\(virtualNodeName.urlPercentEncoding())"
    }
}

///
public struct DescribeVirtualNodeInput: Swift.Equatable {
    /// The name of the service mesh that the virtual node resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual node to describe.
    /// This member is required.
    public var virtualNodeName: Swift.String?

    public init (
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualNodeName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualNodeName = virtualNodeName
    }
}

struct DescribeVirtualNodeInputBody: Swift.Equatable {
}

extension DescribeVirtualNodeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVirtualNodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualNodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeVirtualNodeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualNodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualNodeData = try responseDecoder.decode(responseBody: data)
                self.virtualNode = output
            } else {
                self.virtualNode = nil
            }
        } else {
            self.virtualNode = nil
        }
    }
}

///
public struct DescribeVirtualNodeOutputResponse: Swift.Equatable {
    /// The full description of your virtual node.
    /// This member is required.
    public var virtualNode: AppMeshClientTypes.VirtualNodeData?

    public init (
        virtualNode: AppMeshClientTypes.VirtualNodeData? = nil
    )
    {
        self.virtualNode = virtualNode
    }
}

struct DescribeVirtualNodeOutputResponseBody: Swift.Equatable {
    let virtualNode: AppMeshClientTypes.VirtualNodeData?
}

extension DescribeVirtualNodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualNode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualNodeData.self, forKey: .virtualNode)
        virtualNode = virtualNodeDecoded
    }
}

extension DescribeVirtualRouterInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension DescribeVirtualRouterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualRouterName = virtualRouterName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouters/\(virtualRouterName.urlPercentEncoding())"
    }
}

///
public struct DescribeVirtualRouterInput: Swift.Equatable {
    /// The name of the service mesh that the virtual router resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual router to describe.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init (
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualRouterName = virtualRouterName
    }
}

struct DescribeVirtualRouterInputBody: Swift.Equatable {
}

extension DescribeVirtualRouterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVirtualRouterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualRouterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeVirtualRouterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualRouterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualRouterData = try responseDecoder.decode(responseBody: data)
                self.virtualRouter = output
            } else {
                self.virtualRouter = nil
            }
        } else {
            self.virtualRouter = nil
        }
    }
}

///
public struct DescribeVirtualRouterOutputResponse: Swift.Equatable {
    /// The full description of your virtual router.
    /// This member is required.
    public var virtualRouter: AppMeshClientTypes.VirtualRouterData?

    public init (
        virtualRouter: AppMeshClientTypes.VirtualRouterData? = nil
    )
    {
        self.virtualRouter = virtualRouter
    }
}

struct DescribeVirtualRouterOutputResponseBody: Swift.Equatable {
    let virtualRouter: AppMeshClientTypes.VirtualRouterData?
}

extension DescribeVirtualRouterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualRouter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualRouterDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualRouterData.self, forKey: .virtualRouter)
        virtualRouter = virtualRouterDecoded
    }
}

extension DescribeVirtualServiceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension DescribeVirtualServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualServiceName = virtualServiceName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualServices/\(virtualServiceName.urlPercentEncoding())"
    }
}

///
public struct DescribeVirtualServiceInput: Swift.Equatable {
    /// The name of the service mesh that the virtual service resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the virtual service to describe.
    /// This member is required.
    public var virtualServiceName: Swift.String?

    public init (
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        virtualServiceName: Swift.String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualServiceName = virtualServiceName
    }
}

struct DescribeVirtualServiceInputBody: Swift.Equatable {
}

extension DescribeVirtualServiceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVirtualServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeVirtualServiceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualServiceData = try responseDecoder.decode(responseBody: data)
                self.virtualService = output
            } else {
                self.virtualService = nil
            }
        } else {
            self.virtualService = nil
        }
    }
}

///
public struct DescribeVirtualServiceOutputResponse: Swift.Equatable {
    /// The full description of your virtual service.
    /// This member is required.
    public var virtualService: AppMeshClientTypes.VirtualServiceData?

    public init (
        virtualService: AppMeshClientTypes.VirtualServiceData? = nil
    )
    {
        self.virtualService = virtualService
    }
}

struct DescribeVirtualServiceOutputResponseBody: Swift.Equatable {
    let virtualService: AppMeshClientTypes.VirtualServiceData?
}

extension DescribeVirtualServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualService
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualServiceData.self, forKey: .virtualService)
        virtualService = virtualServiceDecoded
    }
}

extension AppMeshClientTypes {
    public enum DnsResponseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case endpoints
        case loadbalancer
        case sdkUnknown(Swift.String)

        public static var allCases: [DnsResponseType] {
            return [
                .endpoints,
                .loadbalancer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .endpoints: return "ENDPOINTS"
            case .loadbalancer: return "LOADBALANCER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DnsResponseType(rawValue: rawValue) ?? DnsResponseType.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.DnsServiceDiscovery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname
        case ipPreference
        case responseType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let ipPreference = self.ipPreference {
            try encodeContainer.encode(ipPreference.rawValue, forKey: .ipPreference)
        }
        if let responseType = self.responseType {
            try encodeContainer.encode(responseType.rawValue, forKey: .responseType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let responseTypeDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.DnsResponseType.self, forKey: .responseType)
        responseType = responseTypeDecoded
        let ipPreferenceDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.IpPreference.self, forKey: .ipPreference)
        ipPreference = ipPreferenceDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the DNS service discovery information for your virtual node.
    public struct DnsServiceDiscovery: Swift.Equatable {
        /// Specifies the DNS service discovery hostname for the virtual node.
        /// This member is required.
        public var hostname: Swift.String?
        /// The preferred IP version that this virtual node uses. Setting the IP preference on the virtual node only overrides the IP preference set for the mesh on this specific node.
        public var ipPreference: AppMeshClientTypes.IpPreference?
        /// Specifies the DNS response type for the virtual node.
        public var responseType: AppMeshClientTypes.DnsResponseType?

        public init (
            hostname: Swift.String? = nil,
            ipPreference: AppMeshClientTypes.IpPreference? = nil,
            responseType: AppMeshClientTypes.DnsResponseType? = nil
        )
        {
            self.hostname = hostname
            self.ipPreference = ipPreference
            self.responseType = responseType
        }
    }

}

extension AppMeshClientTypes.Duration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unit
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.DurationUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a duration of time.
    public struct Duration: Swift.Equatable {
        /// A unit of time.
        public var unit: AppMeshClientTypes.DurationUnit?
        /// A number of time units.
        public var value: Swift.Int?

        public init (
            unit: AppMeshClientTypes.DurationUnit? = nil,
            value: Swift.Int? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension AppMeshClientTypes {
    public enum DurationUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ms
        case s
        case sdkUnknown(Swift.String)

        public static var allCases: [DurationUnit] {
            return [
                .ms,
                .s,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ms: return "ms"
            case .s: return "s"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DurationUnit(rawValue: rawValue) ?? DurationUnit.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.EgressFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.EgressFilterType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the egress filter rules for a service mesh.
    public struct EgressFilter: Swift.Equatable {
        /// The egress filter type. By default, the type is DROP_ALL, which allows egress only from virtual nodes to other defined resources in the service mesh (and any traffic to *.amazonaws.com for Amazon Web Services API calls). You can set the egress filter type to ALLOW_ALL to allow egress to any endpoint inside or outside of the service mesh.
        /// This member is required.
        public var type: AppMeshClientTypes.EgressFilterType?

        public init (
            type: AppMeshClientTypes.EgressFilterType? = nil
        )
        {
            self.type = type
        }
    }

}

extension AppMeshClientTypes {
    public enum EgressFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allowAll
        case dropAll
        case sdkUnknown(Swift.String)

        public static var allCases: [EgressFilterType] {
            return [
                .allowAll,
                .dropAll,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allowAll: return "ALLOW_ALL"
            case .dropAll: return "DROP_ALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EgressFilterType(rawValue: rawValue) ?? EgressFilterType.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.FileAccessLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.LoggingFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents an access log file.
    public struct FileAccessLog: Swift.Equatable {
        /// The specified format for the logs. The format is either json_format or text_format.
        public var format: AppMeshClientTypes.LoggingFormat?
        /// The file path to write access logs to. You can use /dev/stdout to send access logs to standard out and configure your Envoy container to use a log driver, such as awslogs, to export the access logs to a log storage service such as Amazon CloudWatch Logs. You can also specify a path in the Envoy container's file system to write the files to disk. The Envoy process must have write permissions to the path that you specify here. Otherwise, Envoy fails to bootstrap properly.
        /// This member is required.
        public var path: Swift.String?

        public init (
            format: AppMeshClientTypes.LoggingFormat? = nil,
            path: Swift.String? = nil
        )
        {
            self.format = format
            self.path = path
        }
    }

}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have permissions to perform this action.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppMeshClientTypes.GatewayRouteData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayRouteName
        case meshName
        case metadata
        case spec
        case status
        case virtualGatewayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayRouteName = self.gatewayRouteName {
            try encodeContainer.encode(gatewayRouteName, forKey: .gatewayRouteName)
        }
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let virtualGatewayName = self.virtualGatewayName {
            try encodeContainer.encode(virtualGatewayName, forKey: .virtualGatewayName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let gatewayRouteNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayRouteName)
        gatewayRouteName = gatewayRouteNameDecoded
        let virtualGatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayName)
        virtualGatewayName = virtualGatewayNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteSpec.self, forKey: .spec)
        spec = specDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ResourceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a gateway route returned by a describe operation.
    public struct GatewayRouteData: Swift.Equatable {
        /// The name of the gateway route.
        /// This member is required.
        public var gatewayRouteName: Swift.String?
        /// The name of the service mesh that the resource resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// An object that represents metadata for a resource.
        /// This member is required.
        public var metadata: AppMeshClientTypes.ResourceMetadata?
        /// The specifications of the gateway route.
        /// This member is required.
        public var spec: AppMeshClientTypes.GatewayRouteSpec?
        /// The status of the gateway route.
        /// This member is required.
        public var status: AppMeshClientTypes.GatewayRouteStatus?
        /// The virtual gateway that the gateway route is associated with.
        /// This member is required.
        public var virtualGatewayName: Swift.String?

        public init (
            gatewayRouteName: Swift.String? = nil,
            meshName: Swift.String? = nil,
            metadata: AppMeshClientTypes.ResourceMetadata? = nil,
            spec: AppMeshClientTypes.GatewayRouteSpec? = nil,
            status: AppMeshClientTypes.GatewayRouteStatus? = nil,
            virtualGatewayName: Swift.String? = nil
        )
        {
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualGatewayName = virtualGatewayName
        }
    }

}

extension AppMeshClientTypes.GatewayRouteHostnameMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exact
        case suffix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exact = self.exact {
            try encodeContainer.encode(exact, forKey: .exact)
        }
        if let suffix = self.suffix {
            try encodeContainer.encode(suffix, forKey: .suffix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exactDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exact)
        exact = exactDecoded
        let suffixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suffix)
        suffix = suffixDecoded
    }
}

extension AppMeshClientTypes {
    /// An object representing the gateway route host name to match.
    public struct GatewayRouteHostnameMatch: Swift.Equatable {
        /// The exact host name to match on.
        public var exact: Swift.String?
        /// The specified ending characters of the host name to match on.
        public var suffix: Swift.String?

        public init (
            exact: Swift.String? = nil,
            suffix: Swift.String? = nil
        )
        {
            self.exact = exact
            self.suffix = suffix
        }
    }

}

extension AppMeshClientTypes.GatewayRouteHostnameRewrite: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultTargetHostname
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultTargetHostname = self.defaultTargetHostname {
            try encodeContainer.encode(defaultTargetHostname.rawValue, forKey: .defaultTargetHostname)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultTargetHostnameDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.DefaultGatewayRouteRewrite.self, forKey: .defaultTargetHostname)
        defaultTargetHostname = defaultTargetHostnameDecoded
    }
}

extension AppMeshClientTypes {
    /// An object representing the gateway route host name to rewrite.
    public struct GatewayRouteHostnameRewrite: Swift.Equatable {
        /// The default target host name to write to.
        public var defaultTargetHostname: AppMeshClientTypes.DefaultGatewayRouteRewrite?

        public init (
            defaultTargetHostname: AppMeshClientTypes.DefaultGatewayRouteRewrite? = nil
        )
        {
            self.defaultTargetHostname = defaultTargetHostname
        }
    }

}

extension AppMeshClientTypes.GatewayRouteRef: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case gatewayRouteName
        case lastUpdatedAt
        case meshName
        case meshOwner
        case resourceOwner
        case version
        case virtualGatewayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let gatewayRouteName = self.gatewayRouteName {
            try encodeContainer.encode(gatewayRouteName, forKey: .gatewayRouteName)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let meshOwner = self.meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let virtualGatewayName = self.virtualGatewayName {
            try encodeContainer.encode(virtualGatewayName, forKey: .virtualGatewayName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let gatewayRouteNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayRouteName)
        gatewayRouteName = gatewayRouteNameDecoded
        let virtualGatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayName)
        virtualGatewayName = virtualGatewayNameDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a gateway route returned by a list operation.
    public struct GatewayRouteRef: Swift.Equatable {
        /// The full Amazon Resource Name (ARN) for the gateway route.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The name of the gateway route.
        /// This member is required.
        public var gatewayRouteName: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the service mesh that the resource resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?
        /// The virtual gateway that the gateway route is associated with.
        /// This member is required.
        public var virtualGatewayName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            gatewayRouteName: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            meshName: Swift.String? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            version: Swift.Int? = nil,
            virtualGatewayName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.gatewayRouteName = gatewayRouteName
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualGatewayName = virtualGatewayName
        }
    }

}

extension AppMeshClientTypes.GatewayRouteSpec: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grpcRoute
        case http2Route
        case httpRoute
        case priority
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grpcRoute = self.grpcRoute {
            try encodeContainer.encode(grpcRoute, forKey: .grpcRoute)
        }
        if let http2Route = self.http2Route {
            try encodeContainer.encode(http2Route, forKey: .http2Route)
        }
        if let httpRoute = self.httpRoute {
            try encodeContainer.encode(httpRoute, forKey: .httpRoute)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let httpRouteDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpGatewayRoute.self, forKey: .httpRoute)
        httpRoute = httpRouteDecoded
        let http2RouteDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpGatewayRoute.self, forKey: .http2Route)
        http2Route = http2RouteDecoded
        let grpcRouteDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GrpcGatewayRoute.self, forKey: .grpcRoute)
        grpcRoute = grpcRouteDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a gateway route specification. Specify one gateway route type.
    public struct GatewayRouteSpec: Swift.Equatable {
        /// An object that represents the specification of a gRPC gateway route.
        public var grpcRoute: AppMeshClientTypes.GrpcGatewayRoute?
        /// An object that represents the specification of an HTTP/2 gateway route.
        public var http2Route: AppMeshClientTypes.HttpGatewayRoute?
        /// An object that represents the specification of an HTTP gateway route.
        public var httpRoute: AppMeshClientTypes.HttpGatewayRoute?
        /// The ordering of the gateway routes spec.
        public var priority: Swift.Int?

        public init (
            grpcRoute: AppMeshClientTypes.GrpcGatewayRoute? = nil,
            http2Route: AppMeshClientTypes.HttpGatewayRoute? = nil,
            httpRoute: AppMeshClientTypes.HttpGatewayRoute? = nil,
            priority: Swift.Int? = nil
        )
        {
            self.grpcRoute = grpcRoute
            self.http2Route = http2Route
            self.httpRoute = httpRoute
            self.priority = priority
        }
    }

}

extension AppMeshClientTypes.GatewayRouteStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteStatusCode.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the current status of a gateway route.
    public struct GatewayRouteStatus: Swift.Equatable {
        /// The current status for the gateway route.
        /// This member is required.
        public var status: AppMeshClientTypes.GatewayRouteStatusCode?

        public init (
            status: AppMeshClientTypes.GatewayRouteStatusCode? = nil
        )
        {
            self.status = status
        }
    }

}

extension AppMeshClientTypes {
    public enum GatewayRouteStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayRouteStatusCode] {
            return [
                .active,
                .deleted,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GatewayRouteStatusCode(rawValue: rawValue) ?? GatewayRouteStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.GatewayRouteTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port
        case virtualService
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let virtualService = self.virtualService {
            try encodeContainer.encode(virtualService, forKey: .virtualService)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteVirtualService.self, forKey: .virtualService)
        virtualService = virtualServiceDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a gateway route target.
    public struct GatewayRouteTarget: Swift.Equatable {
        /// The port number of the gateway route target.
        public var port: Swift.Int?
        /// An object that represents a virtual service gateway route target.
        /// This member is required.
        public var virtualService: AppMeshClientTypes.GatewayRouteVirtualService?

        public init (
            port: Swift.Int? = nil,
            virtualService: AppMeshClientTypes.GatewayRouteVirtualService? = nil
        )
        {
            self.port = port
            self.virtualService = virtualService
        }
    }

}

extension AppMeshClientTypes.GatewayRouteVirtualService: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualServiceName = self.virtualServiceName {
            try encodeContainer.encode(virtualServiceName, forKey: .virtualServiceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualServiceName)
        virtualServiceName = virtualServiceNameDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the virtual service that traffic is routed to.
    public struct GatewayRouteVirtualService: Swift.Equatable {
        /// The name of the virtual service that traffic is routed to.
        /// This member is required.
        public var virtualServiceName: Swift.String?

        public init (
            virtualServiceName: Swift.String? = nil
        )
        {
            self.virtualServiceName = virtualServiceName
        }
    }

}

extension AppMeshClientTypes.GrpcGatewayRoute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case match
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GrpcGatewayRouteMatch.self, forKey: .match)
        match = matchDecoded
        let actionDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GrpcGatewayRouteAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a gRPC gateway route.
    public struct GrpcGatewayRoute: Swift.Equatable {
        /// An object that represents the action to take if a match is determined.
        /// This member is required.
        public var action: AppMeshClientTypes.GrpcGatewayRouteAction?
        /// An object that represents the criteria for determining a request match.
        /// This member is required.
        public var match: AppMeshClientTypes.GrpcGatewayRouteMatch?

        public init (
            action: AppMeshClientTypes.GrpcGatewayRouteAction? = nil,
            match: AppMeshClientTypes.GrpcGatewayRouteMatch? = nil
        )
        {
            self.action = action
            self.match = match
        }
    }

}

extension AppMeshClientTypes.GrpcGatewayRouteAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rewrite
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rewrite = self.rewrite {
            try encodeContainer.encode(rewrite, forKey: .rewrite)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteTarget.self, forKey: .target)
        target = targetDecoded
        let rewriteDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GrpcGatewayRouteRewrite.self, forKey: .rewrite)
        rewrite = rewriteDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the action to take if a match is determined.
    public struct GrpcGatewayRouteAction: Swift.Equatable {
        /// The gateway route action to rewrite.
        public var rewrite: AppMeshClientTypes.GrpcGatewayRouteRewrite?
        /// An object that represents the target that traffic is routed to when a request matches the gateway route.
        /// This member is required.
        public var target: AppMeshClientTypes.GatewayRouteTarget?

        public init (
            rewrite: AppMeshClientTypes.GrpcGatewayRouteRewrite? = nil,
            target: AppMeshClientTypes.GatewayRouteTarget? = nil
        )
        {
            self.rewrite = rewrite
            self.target = target
        }
    }

}

extension AppMeshClientTypes.GrpcGatewayRouteMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname
        case metadata
        case port
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metadata)
            for grpcgatewayroutemetadata0 in metadata {
                try metadataContainer.encode(grpcgatewayroutemetadata0)
            }
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteHostnameMatch.self, forKey: .hostname)
        hostname = hostnameDecoded
        let metadataContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.GrpcGatewayRouteMetadata?].self, forKey: .metadata)
        var metadataDecoded0:[AppMeshClientTypes.GrpcGatewayRouteMetadata]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [AppMeshClientTypes.GrpcGatewayRouteMetadata]()
            for structure0 in metadataContainer {
                if let structure0 = structure0 {
                    metadataDecoded0?.append(structure0)
                }
            }
        }
        metadata = metadataDecoded0
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the criteria for determining a request match.
    public struct GrpcGatewayRouteMatch: Swift.Equatable {
        /// The gateway route host name to be matched on.
        public var hostname: AppMeshClientTypes.GatewayRouteHostnameMatch?
        /// The gateway route metadata to be matched on.
        public var metadata: [AppMeshClientTypes.GrpcGatewayRouteMetadata]?
        /// The port number to match from the request.
        public var port: Swift.Int?
        /// The fully qualified domain name for the service to match from the request.
        public var serviceName: Swift.String?

        public init (
            hostname: AppMeshClientTypes.GatewayRouteHostnameMatch? = nil,
            metadata: [AppMeshClientTypes.GrpcGatewayRouteMetadata]? = nil,
            port: Swift.Int? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.hostname = hostname
            self.metadata = metadata
            self.port = port
            self.serviceName = serviceName
        }
    }

}

extension AppMeshClientTypes.GrpcGatewayRouteMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invert
        case match
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invert = self.invert {
            try encodeContainer.encode(invert, forKey: .invert)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let invertDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .invert)
        invert = invertDecoded
        let matchDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GrpcMetadataMatchMethod.self, forKey: .match)
        match = matchDecoded
    }
}

extension AppMeshClientTypes {
    /// An object representing the metadata of the gateway route.
    public struct GrpcGatewayRouteMetadata: Swift.Equatable {
        /// Specify True to match anything except the match criteria. The default value is False.
        public var invert: Swift.Bool?
        /// The criteria for determining a metadata match.
        public var match: AppMeshClientTypes.GrpcMetadataMatchMethod?
        /// A name for the gateway route metadata.
        /// This member is required.
        public var name: Swift.String?

        public init (
            invert: Swift.Bool? = nil,
            match: AppMeshClientTypes.GrpcMetadataMatchMethod? = nil,
            name: Swift.String? = nil
        )
        {
            self.invert = invert
            self.match = match
            self.name = name
        }
    }

}

extension AppMeshClientTypes.GrpcGatewayRouteRewrite: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostnameDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteHostnameRewrite.self, forKey: .hostname)
        hostname = hostnameDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the gateway route to rewrite.
    public struct GrpcGatewayRouteRewrite: Swift.Equatable {
        /// The host name of the gateway route to rewrite.
        public var hostname: AppMeshClientTypes.GatewayRouteHostnameRewrite?

        public init (
            hostname: AppMeshClientTypes.GatewayRouteHostnameRewrite? = nil
        )
        {
            self.hostname = hostname
        }
    }

}

extension AppMeshClientTypes.GrpcMetadataMatchMethod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exact
        case `prefix` = "prefix"
        case range
        case regex
        case sdkUnknown
        case suffix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .exact(exact):
                try container.encode(exact, forKey: .exact)
            case let .`prefix`(`prefix`):
                try container.encode(`prefix`, forKey: .`prefix`)
            case let .range(range):
                try container.encode(range, forKey: .range)
            case let .regex(regex):
                try container.encode(regex, forKey: .regex)
            case let .suffix(suffix):
                try container.encode(suffix, forKey: .suffix)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let exactDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .exact)
        if let exact = exactDecoded {
            self = .exact(exact)
            return
        }
        let regexDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .regex)
        if let regex = regexDecoded {
            self = .regex(regex)
            return
        }
        let rangeDecoded = try values.decodeIfPresent(AppMeshClientTypes.MatchRange.self, forKey: .range)
        if let range = rangeDecoded {
            self = .range(range)
            return
        }
        let prefixDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .prefix)
        if let `prefix` = prefixDecoded {
            self = .`prefix`(`prefix`)
            return
        }
        let suffixDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .suffix)
        if let suffix = suffixDecoded {
            self = .suffix(suffix)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object representing the method header to be matched.
    public enum GrpcMetadataMatchMethod: Swift.Equatable {
        /// The exact method header to be matched on.
        case exact(Swift.String)
        /// The regex used to match the method header.
        case regex(Swift.String)
        /// An object that represents the range of values to match on. The first character of the range is included in the range, though the last character is not. For example, if the range specified were 1-100, only values 1-99 would be matched.
        case range(AppMeshClientTypes.MatchRange)
        /// The specified beginning characters of the method header to be matched on.
        case `prefix`(Swift.String)
        /// The specified ending characters of the method header to match on.
        case suffix(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.GrpcRetryPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grpcRetryEvents
        case httpRetryEvents
        case maxRetries
        case perRetryTimeout
        case tcpRetryEvents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grpcRetryEvents = grpcRetryEvents {
            var grpcRetryEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grpcRetryEvents)
            for grpcretrypolicyevent0 in grpcRetryEvents {
                try grpcRetryEventsContainer.encode(grpcretrypolicyevent0.rawValue)
            }
        }
        if let httpRetryEvents = httpRetryEvents {
            var httpRetryEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpRetryEvents)
            for httpretrypolicyevent0 in httpRetryEvents {
                try httpRetryEventsContainer.encode(httpretrypolicyevent0)
            }
        }
        if let maxRetries = self.maxRetries {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let perRetryTimeout = self.perRetryTimeout {
            try encodeContainer.encode(perRetryTimeout, forKey: .perRetryTimeout)
        }
        if let tcpRetryEvents = tcpRetryEvents {
            var tcpRetryEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tcpRetryEvents)
            for tcpretrypolicyevent0 in tcpRetryEvents {
                try tcpRetryEventsContainer.encode(tcpretrypolicyevent0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let perRetryTimeoutDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.Duration.self, forKey: .perRetryTimeout)
        perRetryTimeout = perRetryTimeoutDecoded
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let httpRetryEventsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .httpRetryEvents)
        var httpRetryEventsDecoded0:[Swift.String]? = nil
        if let httpRetryEventsContainer = httpRetryEventsContainer {
            httpRetryEventsDecoded0 = [Swift.String]()
            for string0 in httpRetryEventsContainer {
                if let string0 = string0 {
                    httpRetryEventsDecoded0?.append(string0)
                }
            }
        }
        httpRetryEvents = httpRetryEventsDecoded0
        let tcpRetryEventsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.TcpRetryPolicyEvent?].self, forKey: .tcpRetryEvents)
        var tcpRetryEventsDecoded0:[AppMeshClientTypes.TcpRetryPolicyEvent]? = nil
        if let tcpRetryEventsContainer = tcpRetryEventsContainer {
            tcpRetryEventsDecoded0 = [AppMeshClientTypes.TcpRetryPolicyEvent]()
            for string0 in tcpRetryEventsContainer {
                if let string0 = string0 {
                    tcpRetryEventsDecoded0?.append(string0)
                }
            }
        }
        tcpRetryEvents = tcpRetryEventsDecoded0
        let grpcRetryEventsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.GrpcRetryPolicyEvent?].self, forKey: .grpcRetryEvents)
        var grpcRetryEventsDecoded0:[AppMeshClientTypes.GrpcRetryPolicyEvent]? = nil
        if let grpcRetryEventsContainer = grpcRetryEventsContainer {
            grpcRetryEventsDecoded0 = [AppMeshClientTypes.GrpcRetryPolicyEvent]()
            for string0 in grpcRetryEventsContainer {
                if let string0 = string0 {
                    grpcRetryEventsDecoded0?.append(string0)
                }
            }
        }
        grpcRetryEvents = grpcRetryEventsDecoded0
    }
}

extension AppMeshClientTypes {
    /// An object that represents a retry policy. Specify at least one value for at least one of the types of RetryEvents, a value for maxRetries, and a value for perRetryTimeout. Both server-error and gateway-error under httpRetryEvents include the Envoy reset policy. For more information on the reset policy, see the [Envoy documentation](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on).
    public struct GrpcRetryPolicy: Swift.Equatable {
        /// Specify at least one of the valid values.
        public var grpcRetryEvents: [AppMeshClientTypes.GrpcRetryPolicyEvent]?
        /// Specify at least one of the following values.
        ///
        /// * server-error – HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511
        ///
        /// * gateway-error – HTTP status codes 502, 503, and 504
        ///
        /// * client-error – HTTP status code 409
        ///
        /// * stream-error – Retry on refused stream
        public var httpRetryEvents: [Swift.String]?
        /// The maximum number of retry attempts.
        /// This member is required.
        public var maxRetries: Swift.Int?
        /// The timeout for each retry attempt.
        /// This member is required.
        public var perRetryTimeout: AppMeshClientTypes.Duration?
        /// Specify a valid value. The event occurs before any processing of a request has started and is encountered when the upstream is temporarily or permanently unavailable.
        public var tcpRetryEvents: [AppMeshClientTypes.TcpRetryPolicyEvent]?

        public init (
            grpcRetryEvents: [AppMeshClientTypes.GrpcRetryPolicyEvent]? = nil,
            httpRetryEvents: [Swift.String]? = nil,
            maxRetries: Swift.Int? = nil,
            perRetryTimeout: AppMeshClientTypes.Duration? = nil,
            tcpRetryEvents: [AppMeshClientTypes.TcpRetryPolicyEvent]? = nil
        )
        {
            self.grpcRetryEvents = grpcRetryEvents
            self.httpRetryEvents = httpRetryEvents
            self.maxRetries = maxRetries
            self.perRetryTimeout = perRetryTimeout
            self.tcpRetryEvents = tcpRetryEvents
        }
    }

}

extension AppMeshClientTypes {
    public enum GrpcRetryPolicyEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case deadlineExceeded
        case `internal`
        case resourceExhausted
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [GrpcRetryPolicyEvent] {
            return [
                .cancelled,
                .deadlineExceeded,
                .internal,
                .resourceExhausted,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "cancelled"
            case .deadlineExceeded: return "deadline-exceeded"
            case .internal: return "internal"
            case .resourceExhausted: return "resource-exhausted"
            case .unavailable: return "unavailable"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GrpcRetryPolicyEvent(rawValue: rawValue) ?? GrpcRetryPolicyEvent.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.GrpcRoute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case match
        case retryPolicy
        case timeout
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let retryPolicy = self.retryPolicy {
            try encodeContainer.encode(retryPolicy, forKey: .retryPolicy)
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GrpcRouteAction.self, forKey: .action)
        action = actionDecoded
        let matchDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GrpcRouteMatch.self, forKey: .match)
        match = matchDecoded
        let retryPolicyDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GrpcRetryPolicy.self, forKey: .retryPolicy)
        retryPolicy = retryPolicyDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GrpcTimeout.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a gRPC route type.
    public struct GrpcRoute: Swift.Equatable {
        /// An object that represents the action to take if a match is determined.
        /// This member is required.
        public var action: AppMeshClientTypes.GrpcRouteAction?
        /// An object that represents the criteria for determining a request match.
        /// This member is required.
        public var match: AppMeshClientTypes.GrpcRouteMatch?
        /// An object that represents a retry policy.
        public var retryPolicy: AppMeshClientTypes.GrpcRetryPolicy?
        /// An object that represents types of timeouts.
        public var timeout: AppMeshClientTypes.GrpcTimeout?

        public init (
            action: AppMeshClientTypes.GrpcRouteAction? = nil,
            match: AppMeshClientTypes.GrpcRouteMatch? = nil,
            retryPolicy: AppMeshClientTypes.GrpcRetryPolicy? = nil,
            timeout: AppMeshClientTypes.GrpcTimeout? = nil
        )
        {
            self.action = action
            self.match = match
            self.retryPolicy = retryPolicy
            self.timeout = timeout
        }
    }

}

extension AppMeshClientTypes.GrpcRouteAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case weightedTargets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let weightedTargets = weightedTargets {
            var weightedTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .weightedTargets)
            for weightedtarget0 in weightedTargets {
                try weightedTargetsContainer.encode(weightedtarget0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weightedTargetsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.WeightedTarget?].self, forKey: .weightedTargets)
        var weightedTargetsDecoded0:[AppMeshClientTypes.WeightedTarget]? = nil
        if let weightedTargetsContainer = weightedTargetsContainer {
            weightedTargetsDecoded0 = [AppMeshClientTypes.WeightedTarget]()
            for structure0 in weightedTargetsContainer {
                if let structure0 = structure0 {
                    weightedTargetsDecoded0?.append(structure0)
                }
            }
        }
        weightedTargets = weightedTargetsDecoded0
    }
}

extension AppMeshClientTypes {
    /// An object that represents the action to take if a match is determined.
    public struct GrpcRouteAction: Swift.Equatable {
        /// An object that represents the targets that traffic is routed to when a request matches the route.
        /// This member is required.
        public var weightedTargets: [AppMeshClientTypes.WeightedTarget]?

        public init (
            weightedTargets: [AppMeshClientTypes.WeightedTarget]? = nil
        )
        {
            self.weightedTargets = weightedTargets
        }
    }

}

extension AppMeshClientTypes.GrpcRouteMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata
        case methodName
        case port
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metadata)
            for grpcroutemetadata0 in metadata {
                try metadataContainer.encode(grpcroutemetadata0)
            }
        }
        if let methodName = self.methodName {
            try encodeContainer.encode(methodName, forKey: .methodName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let methodNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .methodName)
        methodName = methodNameDecoded
        let metadataContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.GrpcRouteMetadata?].self, forKey: .metadata)
        var metadataDecoded0:[AppMeshClientTypes.GrpcRouteMetadata]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [AppMeshClientTypes.GrpcRouteMetadata]()
            for structure0 in metadataContainer {
                if let structure0 = structure0 {
                    metadataDecoded0?.append(structure0)
                }
            }
        }
        metadata = metadataDecoded0
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the criteria for determining a request match.
    public struct GrpcRouteMatch: Swift.Equatable {
        /// An object that represents the data to match from the request.
        public var metadata: [AppMeshClientTypes.GrpcRouteMetadata]?
        /// The method name to match from the request. If you specify a name, you must also specify a serviceName.
        public var methodName: Swift.String?
        /// The port number to match on.
        public var port: Swift.Int?
        /// The fully qualified domain name for the service to match from the request.
        public var serviceName: Swift.String?

        public init (
            metadata: [AppMeshClientTypes.GrpcRouteMetadata]? = nil,
            methodName: Swift.String? = nil,
            port: Swift.Int? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.metadata = metadata
            self.methodName = methodName
            self.port = port
            self.serviceName = serviceName
        }
    }

}

extension AppMeshClientTypes.GrpcRouteMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invert
        case match
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invert = self.invert {
            try encodeContainer.encode(invert, forKey: .invert)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let invertDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .invert)
        invert = invertDecoded
        let matchDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GrpcRouteMetadataMatchMethod.self, forKey: .match)
        match = matchDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the match metadata for the route.
    public struct GrpcRouteMetadata: Swift.Equatable {
        /// Specify True to match anything except the match criteria. The default value is False.
        public var invert: Swift.Bool?
        /// An object that represents the data to match from the request.
        public var match: AppMeshClientTypes.GrpcRouteMetadataMatchMethod?
        /// The name of the route.
        /// This member is required.
        public var name: Swift.String?

        public init (
            invert: Swift.Bool? = nil,
            match: AppMeshClientTypes.GrpcRouteMetadataMatchMethod? = nil,
            name: Swift.String? = nil
        )
        {
            self.invert = invert
            self.match = match
            self.name = name
        }
    }

}

extension AppMeshClientTypes.GrpcRouteMetadataMatchMethod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exact
        case `prefix` = "prefix"
        case range
        case regex
        case sdkUnknown
        case suffix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .exact(exact):
                try container.encode(exact, forKey: .exact)
            case let .`prefix`(`prefix`):
                try container.encode(`prefix`, forKey: .`prefix`)
            case let .range(range):
                try container.encode(range, forKey: .range)
            case let .regex(regex):
                try container.encode(regex, forKey: .regex)
            case let .suffix(suffix):
                try container.encode(suffix, forKey: .suffix)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let exactDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .exact)
        if let exact = exactDecoded {
            self = .exact(exact)
            return
        }
        let regexDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .regex)
        if let regex = regexDecoded {
            self = .regex(regex)
            return
        }
        let rangeDecoded = try values.decodeIfPresent(AppMeshClientTypes.MatchRange.self, forKey: .range)
        if let range = rangeDecoded {
            self = .range(range)
            return
        }
        let prefixDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .prefix)
        if let `prefix` = prefixDecoded {
            self = .`prefix`(`prefix`)
            return
        }
        let suffixDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .suffix)
        if let suffix = suffixDecoded {
            self = .suffix(suffix)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents the match method. Specify one of the match values.
    public enum GrpcRouteMetadataMatchMethod: Swift.Equatable {
        /// The value sent by the client must match the specified value exactly.
        case exact(Swift.String)
        /// The value sent by the client must include the specified characters.
        case regex(Swift.String)
        /// An object that represents the range of values to match on.
        case range(AppMeshClientTypes.MatchRange)
        /// The value sent by the client must begin with the specified characters.
        case `prefix`(Swift.String)
        /// The value sent by the client must end with the specified characters.
        case suffix(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.GrpcTimeout: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idle
        case perRequest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idle = self.idle {
            try encodeContainer.encode(idle, forKey: .idle)
        }
        if let perRequest = self.perRequest {
            try encodeContainer.encode(perRequest, forKey: .perRequest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let perRequestDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.Duration.self, forKey: .perRequest)
        perRequest = perRequestDecoded
        let idleDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.Duration.self, forKey: .idle)
        idle = idleDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents types of timeouts.
    public struct GrpcTimeout: Swift.Equatable {
        /// An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.
        public var idle: AppMeshClientTypes.Duration?
        /// An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15 seconds for the source and destination virtual node and the route.
        public var perRequest: AppMeshClientTypes.Duration?

        public init (
            idle: AppMeshClientTypes.Duration? = nil,
            perRequest: AppMeshClientTypes.Duration? = nil
        )
        {
            self.idle = idle
            self.perRequest = perRequest
        }
    }

}

extension AppMeshClientTypes.HeaderMatchMethod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exact
        case `prefix` = "prefix"
        case range
        case regex
        case sdkUnknown
        case suffix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .exact(exact):
                try container.encode(exact, forKey: .exact)
            case let .`prefix`(`prefix`):
                try container.encode(`prefix`, forKey: .`prefix`)
            case let .range(range):
                try container.encode(range, forKey: .range)
            case let .regex(regex):
                try container.encode(regex, forKey: .regex)
            case let .suffix(suffix):
                try container.encode(suffix, forKey: .suffix)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let exactDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .exact)
        if let exact = exactDecoded {
            self = .exact(exact)
            return
        }
        let regexDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .regex)
        if let regex = regexDecoded {
            self = .regex(regex)
            return
        }
        let rangeDecoded = try values.decodeIfPresent(AppMeshClientTypes.MatchRange.self, forKey: .range)
        if let range = rangeDecoded {
            self = .range(range)
            return
        }
        let prefixDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .prefix)
        if let `prefix` = prefixDecoded {
            self = .`prefix`(`prefix`)
            return
        }
        let suffixDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .suffix)
        if let suffix = suffixDecoded {
            self = .suffix(suffix)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents the method and value to match with the header value sent in a request. Specify one match method.
    public enum HeaderMatchMethod: Swift.Equatable {
        /// The value sent by the client must match the specified value exactly.
        case exact(Swift.String)
        /// The value sent by the client must include the specified characters.
        case regex(Swift.String)
        /// An object that represents the range of values to match on.
        case range(AppMeshClientTypes.MatchRange)
        /// The value sent by the client must begin with the specified characters.
        case `prefix`(Swift.String)
        /// The value sent by the client must end with the specified characters.
        case suffix(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.HealthCheckPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthyThreshold
        case intervalMillis
        case path
        case port
        case `protocol` = "protocol"
        case timeoutMillis
        case unhealthyThreshold
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if healthyThreshold != 0 {
            try encodeContainer.encode(healthyThreshold, forKey: .healthyThreshold)
        }
        if let intervalMillis = self.intervalMillis {
            try encodeContainer.encode(intervalMillis, forKey: .intervalMillis)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let timeoutMillis = self.timeoutMillis {
            try encodeContainer.encode(timeoutMillis, forKey: .timeoutMillis)
        }
        if unhealthyThreshold != 0 {
            try encodeContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutMillis)
        timeoutMillis = timeoutMillisDecoded
        let intervalMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .intervalMillis)
        intervalMillis = intervalMillisDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.PortProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let healthyThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyThreshold) ?? 0
        healthyThreshold = healthyThresholdDecoded
        let unhealthyThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyThreshold) ?? 0
        unhealthyThreshold = unhealthyThresholdDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the health check policy for a virtual node's listener.
    public struct HealthCheckPolicy: Swift.Equatable {
        /// The number of consecutive successful health checks that must occur before declaring listener healthy.
        /// This member is required.
        public var healthyThreshold: Swift.Int
        /// The time period in milliseconds between each health check execution.
        /// This member is required.
        public var intervalMillis: Swift.Int?
        /// The destination path for the health check request. This value is only used if the specified protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.
        public var path: Swift.String?
        /// The destination port for the health check request. This port must match the port defined in the [PortMapping] for the listener.
        public var port: Swift.Int
        /// The protocol for the health check request. If you specify grpc, then your service must conform to the [GRPC Health Checking Protocol](https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
        /// This member is required.
        public var `protocol`: AppMeshClientTypes.PortProtocol?
        /// The amount of time to wait when receiving a response from the health check, in milliseconds.
        /// This member is required.
        public var timeoutMillis: Swift.Int?
        /// The number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
        /// This member is required.
        public var unhealthyThreshold: Swift.Int

        public init (
            healthyThreshold: Swift.Int = 0,
            intervalMillis: Swift.Int? = nil,
            path: Swift.String? = nil,
            port: Swift.Int = 0,
            `protocol`: AppMeshClientTypes.PortProtocol? = nil,
            timeoutMillis: Swift.Int? = nil,
            unhealthyThreshold: Swift.Int = 0
        )
        {
            self.healthyThreshold = healthyThreshold
            self.intervalMillis = intervalMillis
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.timeoutMillis = timeoutMillis
            self.unhealthyThreshold = unhealthyThreshold
        }
    }

}

extension AppMeshClientTypes.HttpGatewayRoute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case match
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpGatewayRouteMatch.self, forKey: .match)
        match = matchDecoded
        let actionDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpGatewayRouteAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents an HTTP gateway route.
    public struct HttpGatewayRoute: Swift.Equatable {
        /// An object that represents the action to take if a match is determined.
        /// This member is required.
        public var action: AppMeshClientTypes.HttpGatewayRouteAction?
        /// An object that represents the criteria for determining a request match.
        /// This member is required.
        public var match: AppMeshClientTypes.HttpGatewayRouteMatch?

        public init (
            action: AppMeshClientTypes.HttpGatewayRouteAction? = nil,
            match: AppMeshClientTypes.HttpGatewayRouteMatch? = nil
        )
        {
            self.action = action
            self.match = match
        }
    }

}

extension AppMeshClientTypes.HttpGatewayRouteAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rewrite
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rewrite = self.rewrite {
            try encodeContainer.encode(rewrite, forKey: .rewrite)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteTarget.self, forKey: .target)
        target = targetDecoded
        let rewriteDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpGatewayRouteRewrite.self, forKey: .rewrite)
        rewrite = rewriteDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the action to take if a match is determined.
    public struct HttpGatewayRouteAction: Swift.Equatable {
        /// The gateway route action to rewrite.
        public var rewrite: AppMeshClientTypes.HttpGatewayRouteRewrite?
        /// An object that represents the target that traffic is routed to when a request matches the gateway route.
        /// This member is required.
        public var target: AppMeshClientTypes.GatewayRouteTarget?

        public init (
            rewrite: AppMeshClientTypes.HttpGatewayRouteRewrite? = nil,
            target: AppMeshClientTypes.GatewayRouteTarget? = nil
        )
        {
            self.rewrite = rewrite
            self.target = target
        }
    }

}

extension AppMeshClientTypes.HttpGatewayRouteHeader: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invert
        case match
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invert = self.invert {
            try encodeContainer.encode(invert, forKey: .invert)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let invertDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .invert)
        invert = invertDecoded
        let matchDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HeaderMatchMethod.self, forKey: .match)
        match = matchDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the HTTP header in the gateway route.
    public struct HttpGatewayRouteHeader: Swift.Equatable {
        /// Specify True to match anything except the match criteria. The default value is False.
        public var invert: Swift.Bool?
        /// An object that represents the method and value to match with the header value sent in a request. Specify one match method.
        public var match: AppMeshClientTypes.HeaderMatchMethod?
        /// A name for the HTTP header in the gateway route that will be matched on.
        /// This member is required.
        public var name: Swift.String?

        public init (
            invert: Swift.Bool? = nil,
            match: AppMeshClientTypes.HeaderMatchMethod? = nil,
            name: Swift.String? = nil
        )
        {
            self.invert = invert
            self.match = match
            self.name = name
        }
    }

}

extension AppMeshClientTypes.HttpGatewayRouteMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headers
        case hostname
        case method
        case path
        case port
        case `prefix` = "prefix"
        case queryParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headers = headers {
            var headersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headers)
            for httpgatewayrouteheader0 in headers {
                try headersContainer.encode(httpgatewayrouteheader0)
            }
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let method = self.method {
            try encodeContainer.encode(method.rawValue, forKey: .method)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let queryParameters = queryParameters {
            var queryParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queryParameters)
            for httpqueryparameter0 in queryParameters {
                try queryParametersContainer.encode(httpqueryparameter0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let pathDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpPathMatch.self, forKey: .path)
        path = pathDecoded
        let queryParametersContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.HttpQueryParameter?].self, forKey: .queryParameters)
        var queryParametersDecoded0:[AppMeshClientTypes.HttpQueryParameter]? = nil
        if let queryParametersContainer = queryParametersContainer {
            queryParametersDecoded0 = [AppMeshClientTypes.HttpQueryParameter]()
            for structure0 in queryParametersContainer {
                if let structure0 = structure0 {
                    queryParametersDecoded0?.append(structure0)
                }
            }
        }
        queryParameters = queryParametersDecoded0
        let methodDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpMethod.self, forKey: .method)
        method = methodDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteHostnameMatch.self, forKey: .hostname)
        hostname = hostnameDecoded
        let headersContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.HttpGatewayRouteHeader?].self, forKey: .headers)
        var headersDecoded0:[AppMeshClientTypes.HttpGatewayRouteHeader]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [AppMeshClientTypes.HttpGatewayRouteHeader]()
            for structure0 in headersContainer {
                if let structure0 = structure0 {
                    headersDecoded0?.append(structure0)
                }
            }
        }
        headers = headersDecoded0
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the criteria for determining a request match.
    public struct HttpGatewayRouteMatch: Swift.Equatable {
        /// The client request headers to match on.
        public var headers: [AppMeshClientTypes.HttpGatewayRouteHeader]?
        /// The host name to match on.
        public var hostname: AppMeshClientTypes.GatewayRouteHostnameMatch?
        /// The method to match on.
        public var method: AppMeshClientTypes.HttpMethod?
        /// The path to match on.
        public var path: AppMeshClientTypes.HttpPathMatch?
        /// The port number to match on.
        public var port: Swift.Int?
        /// Specifies the path to match requests with. This parameter must always start with /, which by itself matches all requests to the virtual service name. You can also match for path-based routing of requests. For example, if your virtual service name is my-service.local and you want the route to match requests to my-service.local/metrics, your prefix should be /metrics.
        public var `prefix`: Swift.String?
        /// The query parameter to match on.
        public var queryParameters: [AppMeshClientTypes.HttpQueryParameter]?

        public init (
            headers: [AppMeshClientTypes.HttpGatewayRouteHeader]? = nil,
            hostname: AppMeshClientTypes.GatewayRouteHostnameMatch? = nil,
            method: AppMeshClientTypes.HttpMethod? = nil,
            path: AppMeshClientTypes.HttpPathMatch? = nil,
            port: Swift.Int? = nil,
            `prefix`: Swift.String? = nil,
            queryParameters: [AppMeshClientTypes.HttpQueryParameter]? = nil
        )
        {
            self.headers = headers
            self.hostname = hostname
            self.method = method
            self.path = path
            self.port = port
            self.`prefix` = `prefix`
            self.queryParameters = queryParameters
        }
    }

}

extension AppMeshClientTypes.HttpGatewayRoutePathRewrite: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exact
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exact = self.exact {
            try encodeContainer.encode(exact, forKey: .exact)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exactDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exact)
        exact = exactDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the path to rewrite.
    public struct HttpGatewayRoutePathRewrite: Swift.Equatable {
        /// The exact path to rewrite.
        public var exact: Swift.String?

        public init (
            exact: Swift.String? = nil
        )
        {
            self.exact = exact
        }
    }

}

extension AppMeshClientTypes.HttpGatewayRoutePrefixRewrite: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultPrefix
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultPrefix = self.defaultPrefix {
            try encodeContainer.encode(defaultPrefix.rawValue, forKey: .defaultPrefix)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultPrefixDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.DefaultGatewayRouteRewrite.self, forKey: .defaultPrefix)
        defaultPrefix = defaultPrefixDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AppMeshClientTypes {
    /// An object representing the beginning characters of the route to rewrite.
    public struct HttpGatewayRoutePrefixRewrite: Swift.Equatable {
        /// The default prefix used to replace the incoming route prefix when rewritten.
        public var defaultPrefix: AppMeshClientTypes.DefaultGatewayRouteRewrite?
        /// The value used to replace the incoming route prefix when rewritten.
        public var value: Swift.String?

        public init (
            defaultPrefix: AppMeshClientTypes.DefaultGatewayRouteRewrite? = nil,
            value: Swift.String? = nil
        )
        {
            self.defaultPrefix = defaultPrefix
            self.value = value
        }
    }

}

extension AppMeshClientTypes.HttpGatewayRouteRewrite: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname
        case path
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpGatewayRoutePrefixRewrite.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let pathDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpGatewayRoutePathRewrite.self, forKey: .path)
        path = pathDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteHostnameRewrite.self, forKey: .hostname)
        hostname = hostnameDecoded
    }
}

extension AppMeshClientTypes {
    /// An object representing the gateway route to rewrite.
    public struct HttpGatewayRouteRewrite: Swift.Equatable {
        /// The host name to rewrite.
        public var hostname: AppMeshClientTypes.GatewayRouteHostnameRewrite?
        /// The path to rewrite.
        public var path: AppMeshClientTypes.HttpGatewayRoutePathRewrite?
        /// The specified beginning characters to rewrite.
        public var `prefix`: AppMeshClientTypes.HttpGatewayRoutePrefixRewrite?

        public init (
            hostname: AppMeshClientTypes.GatewayRouteHostnameRewrite? = nil,
            path: AppMeshClientTypes.HttpGatewayRoutePathRewrite? = nil,
            `prefix`: AppMeshClientTypes.HttpGatewayRoutePrefixRewrite? = nil
        )
        {
            self.hostname = hostname
            self.path = path
            self.`prefix` = `prefix`
        }
    }

}

extension AppMeshClientTypes {
    public enum HttpMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connect
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case trace
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpMethod] {
            return [
                .connect,
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put,
                .trace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connect: return "CONNECT"
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case .trace: return "TRACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HttpMethod(rawValue: rawValue) ?? HttpMethod.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.HttpPathMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exact
        case regex
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exact = self.exact {
            try encodeContainer.encode(exact, forKey: .exact)
        }
        if let regex = self.regex {
            try encodeContainer.encode(regex, forKey: .regex)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exactDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exact)
        exact = exactDecoded
        let regexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regex)
        regex = regexDecoded
    }
}

extension AppMeshClientTypes {
    /// An object representing the path to match in the request.
    public struct HttpPathMatch: Swift.Equatable {
        /// The exact path to match on.
        public var exact: Swift.String?
        /// The regex used to match the path.
        public var regex: Swift.String?

        public init (
            exact: Swift.String? = nil,
            regex: Swift.String? = nil
        )
        {
            self.exact = exact
            self.regex = regex
        }
    }

}

extension AppMeshClientTypes.HttpQueryParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case match
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let matchDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.QueryParameterMatch.self, forKey: .match)
        match = matchDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the query parameter in the request.
    public struct HttpQueryParameter: Swift.Equatable {
        /// The query parameter to match on.
        public var match: AppMeshClientTypes.QueryParameterMatch?
        /// A name for the query parameter that will be matched on.
        /// This member is required.
        public var name: Swift.String?

        public init (
            match: AppMeshClientTypes.QueryParameterMatch? = nil,
            name: Swift.String? = nil
        )
        {
            self.match = match
            self.name = name
        }
    }

}

extension AppMeshClientTypes.HttpRetryPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpRetryEvents
        case maxRetries
        case perRetryTimeout
        case tcpRetryEvents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpRetryEvents = httpRetryEvents {
            var httpRetryEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpRetryEvents)
            for httpretrypolicyevent0 in httpRetryEvents {
                try httpRetryEventsContainer.encode(httpretrypolicyevent0)
            }
        }
        if let maxRetries = self.maxRetries {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let perRetryTimeout = self.perRetryTimeout {
            try encodeContainer.encode(perRetryTimeout, forKey: .perRetryTimeout)
        }
        if let tcpRetryEvents = tcpRetryEvents {
            var tcpRetryEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tcpRetryEvents)
            for tcpretrypolicyevent0 in tcpRetryEvents {
                try tcpRetryEventsContainer.encode(tcpretrypolicyevent0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let perRetryTimeoutDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.Duration.self, forKey: .perRetryTimeout)
        perRetryTimeout = perRetryTimeoutDecoded
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let httpRetryEventsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .httpRetryEvents)
        var httpRetryEventsDecoded0:[Swift.String]? = nil
        if let httpRetryEventsContainer = httpRetryEventsContainer {
            httpRetryEventsDecoded0 = [Swift.String]()
            for string0 in httpRetryEventsContainer {
                if let string0 = string0 {
                    httpRetryEventsDecoded0?.append(string0)
                }
            }
        }
        httpRetryEvents = httpRetryEventsDecoded0
        let tcpRetryEventsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.TcpRetryPolicyEvent?].self, forKey: .tcpRetryEvents)
        var tcpRetryEventsDecoded0:[AppMeshClientTypes.TcpRetryPolicyEvent]? = nil
        if let tcpRetryEventsContainer = tcpRetryEventsContainer {
            tcpRetryEventsDecoded0 = [AppMeshClientTypes.TcpRetryPolicyEvent]()
            for string0 in tcpRetryEventsContainer {
                if let string0 = string0 {
                    tcpRetryEventsDecoded0?.append(string0)
                }
            }
        }
        tcpRetryEvents = tcpRetryEventsDecoded0
    }
}

extension AppMeshClientTypes {
    /// An object that represents a retry policy. Specify at least one value for at least one of the types of RetryEvents, a value for maxRetries, and a value for perRetryTimeout. Both server-error and gateway-error under httpRetryEvents include the Envoy reset policy. For more information on the reset policy, see the [Envoy documentation](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on).
    public struct HttpRetryPolicy: Swift.Equatable {
        /// Specify at least one of the following values.
        ///
        /// * server-error – HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511
        ///
        /// * gateway-error – HTTP status codes 502, 503, and 504
        ///
        /// * client-error – HTTP status code 409
        ///
        /// * stream-error – Retry on refused stream
        public var httpRetryEvents: [Swift.String]?
        /// The maximum number of retry attempts.
        /// This member is required.
        public var maxRetries: Swift.Int?
        /// The timeout for each retry attempt.
        /// This member is required.
        public var perRetryTimeout: AppMeshClientTypes.Duration?
        /// Specify a valid value. The event occurs before any processing of a request has started and is encountered when the upstream is temporarily or permanently unavailable.
        public var tcpRetryEvents: [AppMeshClientTypes.TcpRetryPolicyEvent]?

        public init (
            httpRetryEvents: [Swift.String]? = nil,
            maxRetries: Swift.Int? = nil,
            perRetryTimeout: AppMeshClientTypes.Duration? = nil,
            tcpRetryEvents: [AppMeshClientTypes.TcpRetryPolicyEvent]? = nil
        )
        {
            self.httpRetryEvents = httpRetryEvents
            self.maxRetries = maxRetries
            self.perRetryTimeout = perRetryTimeout
            self.tcpRetryEvents = tcpRetryEvents
        }
    }

}

extension AppMeshClientTypes.HttpRoute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case match
        case retryPolicy
        case timeout
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let retryPolicy = self.retryPolicy {
            try encodeContainer.encode(retryPolicy, forKey: .retryPolicy)
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpRouteMatch.self, forKey: .match)
        match = matchDecoded
        let actionDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpRouteAction.self, forKey: .action)
        action = actionDecoded
        let retryPolicyDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpRetryPolicy.self, forKey: .retryPolicy)
        retryPolicy = retryPolicyDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpTimeout.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents an HTTP or HTTP/2 route type.
    public struct HttpRoute: Swift.Equatable {
        /// An object that represents the action to take if a match is determined.
        /// This member is required.
        public var action: AppMeshClientTypes.HttpRouteAction?
        /// An object that represents the criteria for determining a request match.
        /// This member is required.
        public var match: AppMeshClientTypes.HttpRouteMatch?
        /// An object that represents a retry policy.
        public var retryPolicy: AppMeshClientTypes.HttpRetryPolicy?
        /// An object that represents types of timeouts.
        public var timeout: AppMeshClientTypes.HttpTimeout?

        public init (
            action: AppMeshClientTypes.HttpRouteAction? = nil,
            match: AppMeshClientTypes.HttpRouteMatch? = nil,
            retryPolicy: AppMeshClientTypes.HttpRetryPolicy? = nil,
            timeout: AppMeshClientTypes.HttpTimeout? = nil
        )
        {
            self.action = action
            self.match = match
            self.retryPolicy = retryPolicy
            self.timeout = timeout
        }
    }

}

extension AppMeshClientTypes.HttpRouteAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case weightedTargets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let weightedTargets = weightedTargets {
            var weightedTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .weightedTargets)
            for weightedtarget0 in weightedTargets {
                try weightedTargetsContainer.encode(weightedtarget0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weightedTargetsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.WeightedTarget?].self, forKey: .weightedTargets)
        var weightedTargetsDecoded0:[AppMeshClientTypes.WeightedTarget]? = nil
        if let weightedTargetsContainer = weightedTargetsContainer {
            weightedTargetsDecoded0 = [AppMeshClientTypes.WeightedTarget]()
            for structure0 in weightedTargetsContainer {
                if let structure0 = structure0 {
                    weightedTargetsDecoded0?.append(structure0)
                }
            }
        }
        weightedTargets = weightedTargetsDecoded0
    }
}

extension AppMeshClientTypes {
    /// An object that represents the action to take if a match is determined.
    public struct HttpRouteAction: Swift.Equatable {
        /// An object that represents the targets that traffic is routed to when a request matches the route.
        /// This member is required.
        public var weightedTargets: [AppMeshClientTypes.WeightedTarget]?

        public init (
            weightedTargets: [AppMeshClientTypes.WeightedTarget]? = nil
        )
        {
            self.weightedTargets = weightedTargets
        }
    }

}

extension AppMeshClientTypes.HttpRouteHeader: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invert
        case match
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invert = self.invert {
            try encodeContainer.encode(invert, forKey: .invert)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let invertDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .invert)
        invert = invertDecoded
        let matchDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HeaderMatchMethod.self, forKey: .match)
        match = matchDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the HTTP header in the request.
    public struct HttpRouteHeader: Swift.Equatable {
        /// Specify True to match anything except the match criteria. The default value is False.
        public var invert: Swift.Bool?
        /// The HeaderMatchMethod object.
        public var match: AppMeshClientTypes.HeaderMatchMethod?
        /// A name for the HTTP header in the client request that will be matched on.
        /// This member is required.
        public var name: Swift.String?

        public init (
            invert: Swift.Bool? = nil,
            match: AppMeshClientTypes.HeaderMatchMethod? = nil,
            name: Swift.String? = nil
        )
        {
            self.invert = invert
            self.match = match
            self.name = name
        }
    }

}

extension AppMeshClientTypes.HttpRouteMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headers
        case method
        case path
        case port
        case `prefix` = "prefix"
        case queryParameters
        case scheme
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headers = headers {
            var headersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headers)
            for httprouteheader0 in headers {
                try headersContainer.encode(httprouteheader0)
            }
        }
        if let method = self.method {
            try encodeContainer.encode(method.rawValue, forKey: .method)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let queryParameters = queryParameters {
            var queryParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queryParameters)
            for httpqueryparameter0 in queryParameters {
                try queryParametersContainer.encode(httpqueryparameter0)
            }
        }
        if let scheme = self.scheme {
            try encodeContainer.encode(scheme.rawValue, forKey: .scheme)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let pathDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpPathMatch.self, forKey: .path)
        path = pathDecoded
        let queryParametersContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.HttpQueryParameter?].self, forKey: .queryParameters)
        var queryParametersDecoded0:[AppMeshClientTypes.HttpQueryParameter]? = nil
        if let queryParametersContainer = queryParametersContainer {
            queryParametersDecoded0 = [AppMeshClientTypes.HttpQueryParameter]()
            for structure0 in queryParametersContainer {
                if let structure0 = structure0 {
                    queryParametersDecoded0?.append(structure0)
                }
            }
        }
        queryParameters = queryParametersDecoded0
        let methodDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpMethod.self, forKey: .method)
        method = methodDecoded
        let schemeDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpScheme.self, forKey: .scheme)
        scheme = schemeDecoded
        let headersContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.HttpRouteHeader?].self, forKey: .headers)
        var headersDecoded0:[AppMeshClientTypes.HttpRouteHeader]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [AppMeshClientTypes.HttpRouteHeader]()
            for structure0 in headersContainer {
                if let structure0 = structure0 {
                    headersDecoded0?.append(structure0)
                }
            }
        }
        headers = headersDecoded0
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the requirements for a route to match HTTP requests for a virtual router.
    public struct HttpRouteMatch: Swift.Equatable {
        /// The client request headers to match on.
        public var headers: [AppMeshClientTypes.HttpRouteHeader]?
        /// The client request method to match on. Specify only one.
        public var method: AppMeshClientTypes.HttpMethod?
        /// The client request path to match on.
        public var path: AppMeshClientTypes.HttpPathMatch?
        /// The port number to match on.
        public var port: Swift.Int?
        /// Specifies the path to match requests with. This parameter must always start with /, which by itself matches all requests to the virtual service name. You can also match for path-based routing of requests. For example, if your virtual service name is my-service.local and you want the route to match requests to my-service.local/metrics, your prefix should be /metrics.
        public var `prefix`: Swift.String?
        /// The client request query parameters to match on.
        public var queryParameters: [AppMeshClientTypes.HttpQueryParameter]?
        /// The client request scheme to match on. Specify only one. Applicable only for HTTP2 routes.
        public var scheme: AppMeshClientTypes.HttpScheme?

        public init (
            headers: [AppMeshClientTypes.HttpRouteHeader]? = nil,
            method: AppMeshClientTypes.HttpMethod? = nil,
            path: AppMeshClientTypes.HttpPathMatch? = nil,
            port: Swift.Int? = nil,
            `prefix`: Swift.String? = nil,
            queryParameters: [AppMeshClientTypes.HttpQueryParameter]? = nil,
            scheme: AppMeshClientTypes.HttpScheme? = nil
        )
        {
            self.headers = headers
            self.method = method
            self.path = path
            self.port = port
            self.`prefix` = `prefix`
            self.queryParameters = queryParameters
            self.scheme = scheme
        }
    }

}

extension AppMeshClientTypes {
    public enum HttpScheme: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case https
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpScheme] {
            return [
                .http,
                .https,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "http"
            case .https: return "https"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HttpScheme(rawValue: rawValue) ?? HttpScheme.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.HttpTimeout: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idle
        case perRequest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idle = self.idle {
            try encodeContainer.encode(idle, forKey: .idle)
        }
        if let perRequest = self.perRequest {
            try encodeContainer.encode(perRequest, forKey: .perRequest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let perRequestDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.Duration.self, forKey: .perRequest)
        perRequest = perRequestDecoded
        let idleDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.Duration.self, forKey: .idle)
        idle = idleDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents types of timeouts.
    public struct HttpTimeout: Swift.Equatable {
        /// An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.
        public var idle: AppMeshClientTypes.Duration?
        /// An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15 seconds for the source and destination virtual node and the route.
        public var perRequest: AppMeshClientTypes.Duration?

        public init (
            idle: AppMeshClientTypes.Duration? = nil,
            perRequest: AppMeshClientTypes.Duration? = nil
        )
        {
            self.idle = idle
            self.perRequest = perRequest
        }
    }

}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception, or failure.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppMeshClientTypes {
    public enum IpPreference: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ipv4Only
        case ipv4Preferred
        case ipv6Only
        case ipv6Preferred
        case sdkUnknown(Swift.String)

        public static var allCases: [IpPreference] {
            return [
                .ipv4Only,
                .ipv4Preferred,
                .ipv6Only,
                .ipv6Preferred,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ipv4Only: return "IPv4_ONLY"
            case .ipv4Preferred: return "IPv4_PREFERRED"
            case .ipv6Only: return "IPv6_ONLY"
            case .ipv6Preferred: return "IPv6_PREFERRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpPreference(rawValue: rawValue) ?? IpPreference.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.JsonFormatRef: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the key value pairs for the JSON.
    public struct JsonFormatRef: Swift.Equatable {
        /// The specified key for the JSON.
        /// This member is required.
        public var key: Swift.String?
        /// The specified value for the JSON.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded a service limit for your account. For more information, see [Service Limits](https://docs.aws.amazon.com/app-mesh/latest/userguide/service-quotas.html) in the App Mesh User Guide.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListGatewayRoutesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension ListGatewayRoutesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualGatewayName = virtualGatewayName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateway/\(virtualGatewayName.urlPercentEncoding())/gatewayRoutes"
    }
}

public struct ListGatewayRoutesInput: Swift.Equatable {
    /// The maximum number of results returned by ListGatewayRoutes in paginated output. When you use this parameter, ListGatewayRoutes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListGatewayRoutes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListGatewayRoutes returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The name of the service mesh to list gateway routes in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The nextToken value returned from a previous paginated ListGatewayRoutes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    public var nextToken: Swift.String?
    /// The name of the virtual gateway to list gateway routes in.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
        self.virtualGatewayName = virtualGatewayName
    }
}

struct ListGatewayRoutesInputBody: Swift.Equatable {
}

extension ListGatewayRoutesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGatewayRoutesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGatewayRoutesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGatewayRoutesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGatewayRoutesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGatewayRoutesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayRoutes = output.gatewayRoutes
            self.nextToken = output.nextToken
        } else {
            self.gatewayRoutes = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewayRoutesOutputResponse: Swift.Equatable {
    /// The list of existing gateway routes for the specified service mesh and virtual gateway.
    /// This member is required.
    public var gatewayRoutes: [AppMeshClientTypes.GatewayRouteRef]?
    /// The nextToken value to include in a future ListGatewayRoutes request. When the results of a ListGatewayRoutes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        gatewayRoutes: [AppMeshClientTypes.GatewayRouteRef]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gatewayRoutes = gatewayRoutes
        self.nextToken = nextToken
    }
}

struct ListGatewayRoutesOutputResponseBody: Swift.Equatable {
    let gatewayRoutes: [AppMeshClientTypes.GatewayRouteRef]?
    let nextToken: Swift.String?
}

extension ListGatewayRoutesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayRoutes
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayRoutesContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.GatewayRouteRef?].self, forKey: .gatewayRoutes)
        var gatewayRoutesDecoded0:[AppMeshClientTypes.GatewayRouteRef]? = nil
        if let gatewayRoutesContainer = gatewayRoutesContainer {
            gatewayRoutesDecoded0 = [AppMeshClientTypes.GatewayRouteRef]()
            for structure0 in gatewayRoutesContainer {
                if let structure0 = structure0 {
                    gatewayRoutesDecoded0?.append(structure0)
                }
            }
        }
        gatewayRoutes = gatewayRoutesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMeshesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension ListMeshesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20190125/meshes"
    }
}

///
public struct ListMeshesInput: Swift.Equatable {
    /// The maximum number of results returned by ListMeshes in paginated output. When you use this parameter, ListMeshes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListMeshes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListMeshes returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The nextToken value returned from a previous paginated ListMeshes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This token should be treated as an opaque identifier that is used only to retrieve the next items in a list and not for other programmatic purposes.
    public var nextToken: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListMeshesInputBody: Swift.Equatable {
}

extension ListMeshesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMeshesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMeshesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMeshesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMeshesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMeshesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.meshes = output.meshes
            self.nextToken = output.nextToken
        } else {
            self.meshes = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListMeshesOutputResponse: Swift.Equatable {
    /// The list of existing service meshes.
    /// This member is required.
    public var meshes: [AppMeshClientTypes.MeshRef]?
    /// The nextToken value to include in a future ListMeshes request. When the results of a ListMeshes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        meshes: [AppMeshClientTypes.MeshRef]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.meshes = meshes
        self.nextToken = nextToken
    }
}

struct ListMeshesOutputResponseBody: Swift.Equatable {
    let meshes: [AppMeshClientTypes.MeshRef]?
    let nextToken: Swift.String?
}

extension ListMeshesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meshes
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshesContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.MeshRef?].self, forKey: .meshes)
        var meshesDecoded0:[AppMeshClientTypes.MeshRef]? = nil
        if let meshesContainer = meshesContainer {
            meshesDecoded0 = [AppMeshClientTypes.MeshRef]()
            for structure0 in meshesContainer {
                if let structure0 = structure0 {
                    meshesDecoded0?.append(structure0)
                }
            }
        }
        meshes = meshesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRoutesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension ListRoutesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualRouterName = virtualRouterName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouter/\(virtualRouterName.urlPercentEncoding())/routes"
    }
}

///
public struct ListRoutesInput: Swift.Equatable {
    /// The maximum number of results returned by ListRoutes in paginated output. When you use this parameter, ListRoutes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListRoutes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListRoutes returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The name of the service mesh to list routes in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The nextToken value returned from a previous paginated ListRoutes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    public var nextToken: Swift.String?
    /// The name of the virtual router to list routes in.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
        self.virtualRouterName = virtualRouterName
    }
}

struct ListRoutesInputBody: Swift.Equatable {
}

extension ListRoutesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRoutesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRoutesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRoutesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoutesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRoutesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.routes = output.routes
        } else {
            self.nextToken = nil
            self.routes = nil
        }
    }
}

///
public struct ListRoutesOutputResponse: Swift.Equatable {
    /// The nextToken value to include in a future ListRoutes request. When the results of a ListRoutes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of existing routes for the specified service mesh and virtual router.
    /// This member is required.
    public var routes: [AppMeshClientTypes.RouteRef]?

    public init (
        nextToken: Swift.String? = nil,
        routes: [AppMeshClientTypes.RouteRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.routes = routes
    }
}

struct ListRoutesOutputResponseBody: Swift.Equatable {
    let routes: [AppMeshClientTypes.RouteRef]?
    let nextToken: Swift.String?
}

extension ListRoutesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case routes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routesContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.RouteRef?].self, forKey: .routes)
        var routesDecoded0:[AppMeshClientTypes.RouteRef]? = nil
        if let routesContainer = routesContainer {
            routesDecoded0 = [AppMeshClientTypes.RouteRef]()
            for structure0 in routesContainer {
                if let structure0 = structure0 {
                    routesDecoded0?.append(structure0)
                }
            }
        }
        routes = routesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20190125/tags"
    }
}

///
public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of tag results returned by ListTagsForResource in paginated output. When this parameter is used, ListTagsForResource returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListTagsForResource request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListTagsForResource returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The nextToken value returned from a previous paginated ListTagsForResource request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the resource to list the tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

///
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The nextToken value to include in a future ListTagsForResource request. When the results of a ListTagsForResource request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [AppMeshClientTypes.TagRef]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [AppMeshClientTypes.TagRef]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.TagRef?].self, forKey: .tags)
        var tagsDecoded0:[AppMeshClientTypes.TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppMeshClientTypes.TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVirtualGatewaysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension ListVirtualGatewaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateways"
    }
}

public struct ListVirtualGatewaysInput: Swift.Equatable {
    /// The maximum number of results returned by ListVirtualGateways in paginated output. When you use this parameter, ListVirtualGateways returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualGateways request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualGateways returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The name of the service mesh to list virtual gateways in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The nextToken value returned from a previous paginated ListVirtualGateways request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    public var nextToken: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
    }
}

struct ListVirtualGatewaysInputBody: Swift.Equatable {
}

extension ListVirtualGatewaysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVirtualGatewaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVirtualGatewaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVirtualGatewaysOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualGatewaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVirtualGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.virtualGateways = output.virtualGateways
        } else {
            self.nextToken = nil
            self.virtualGateways = nil
        }
    }
}

public struct ListVirtualGatewaysOutputResponse: Swift.Equatable {
    /// The nextToken value to include in a future ListVirtualGateways request. When the results of a ListVirtualGateways request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of existing virtual gateways for the specified service mesh.
    /// This member is required.
    public var virtualGateways: [AppMeshClientTypes.VirtualGatewayRef]?

    public init (
        nextToken: Swift.String? = nil,
        virtualGateways: [AppMeshClientTypes.VirtualGatewayRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualGateways = virtualGateways
    }
}

struct ListVirtualGatewaysOutputResponseBody: Swift.Equatable {
    let virtualGateways: [AppMeshClientTypes.VirtualGatewayRef]?
    let nextToken: Swift.String?
}

extension ListVirtualGatewaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case virtualGateways
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewaysContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.VirtualGatewayRef?].self, forKey: .virtualGateways)
        var virtualGatewaysDecoded0:[AppMeshClientTypes.VirtualGatewayRef]? = nil
        if let virtualGatewaysContainer = virtualGatewaysContainer {
            virtualGatewaysDecoded0 = [AppMeshClientTypes.VirtualGatewayRef]()
            for structure0 in virtualGatewaysContainer {
                if let structure0 = structure0 {
                    virtualGatewaysDecoded0?.append(structure0)
                }
            }
        }
        virtualGateways = virtualGatewaysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVirtualNodesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension ListVirtualNodesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualNodes"
    }
}

///
public struct ListVirtualNodesInput: Swift.Equatable {
    /// The maximum number of results returned by ListVirtualNodes in paginated output. When you use this parameter, ListVirtualNodes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualNodes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualNodes returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The name of the service mesh to list virtual nodes in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The nextToken value returned from a previous paginated ListVirtualNodes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    public var nextToken: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
    }
}

struct ListVirtualNodesInputBody: Swift.Equatable {
}

extension ListVirtualNodesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVirtualNodesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVirtualNodesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVirtualNodesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualNodesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVirtualNodesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.virtualNodes = output.virtualNodes
        } else {
            self.nextToken = nil
            self.virtualNodes = nil
        }
    }
}

///
public struct ListVirtualNodesOutputResponse: Swift.Equatable {
    /// The nextToken value to include in a future ListVirtualNodes request. When the results of a ListVirtualNodes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of existing virtual nodes for the specified service mesh.
    /// This member is required.
    public var virtualNodes: [AppMeshClientTypes.VirtualNodeRef]?

    public init (
        nextToken: Swift.String? = nil,
        virtualNodes: [AppMeshClientTypes.VirtualNodeRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualNodes = virtualNodes
    }
}

struct ListVirtualNodesOutputResponseBody: Swift.Equatable {
    let virtualNodes: [AppMeshClientTypes.VirtualNodeRef]?
    let nextToken: Swift.String?
}

extension ListVirtualNodesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case virtualNodes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodesContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.VirtualNodeRef?].self, forKey: .virtualNodes)
        var virtualNodesDecoded0:[AppMeshClientTypes.VirtualNodeRef]? = nil
        if let virtualNodesContainer = virtualNodesContainer {
            virtualNodesDecoded0 = [AppMeshClientTypes.VirtualNodeRef]()
            for structure0 in virtualNodesContainer {
                if let structure0 = structure0 {
                    virtualNodesDecoded0?.append(structure0)
                }
            }
        }
        virtualNodes = virtualNodesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVirtualRoutersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension ListVirtualRoutersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouters"
    }
}

///
public struct ListVirtualRoutersInput: Swift.Equatable {
    /// The maximum number of results returned by ListVirtualRouters in paginated output. When you use this parameter, ListVirtualRouters returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualRouters request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualRouters returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The name of the service mesh to list virtual routers in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The nextToken value returned from a previous paginated ListVirtualRouters request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    public var nextToken: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
    }
}

struct ListVirtualRoutersInputBody: Swift.Equatable {
}

extension ListVirtualRoutersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVirtualRoutersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVirtualRoutersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVirtualRoutersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualRoutersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVirtualRoutersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.virtualRouters = output.virtualRouters
        } else {
            self.nextToken = nil
            self.virtualRouters = nil
        }
    }
}

///
public struct ListVirtualRoutersOutputResponse: Swift.Equatable {
    /// The nextToken value to include in a future ListVirtualRouters request. When the results of a ListVirtualRouters request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of existing virtual routers for the specified service mesh.
    /// This member is required.
    public var virtualRouters: [AppMeshClientTypes.VirtualRouterRef]?

    public init (
        nextToken: Swift.String? = nil,
        virtualRouters: [AppMeshClientTypes.VirtualRouterRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualRouters = virtualRouters
    }
}

struct ListVirtualRoutersOutputResponseBody: Swift.Equatable {
    let virtualRouters: [AppMeshClientTypes.VirtualRouterRef]?
    let nextToken: Swift.String?
}

extension ListVirtualRoutersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case virtualRouters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualRoutersContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.VirtualRouterRef?].self, forKey: .virtualRouters)
        var virtualRoutersDecoded0:[AppMeshClientTypes.VirtualRouterRef]? = nil
        if let virtualRoutersContainer = virtualRoutersContainer {
            virtualRoutersDecoded0 = [AppMeshClientTypes.VirtualRouterRef]()
            for structure0 in virtualRoutersContainer {
                if let structure0 = structure0 {
                    virtualRoutersDecoded0?.append(structure0)
                }
            }
        }
        virtualRouters = virtualRoutersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVirtualServicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension ListVirtualServicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualServices"
    }
}

///
public struct ListVirtualServicesInput: Swift.Equatable {
    /// The maximum number of results returned by ListVirtualServices in paginated output. When you use this parameter, ListVirtualServices returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualServices request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualServices returns up to 100 results and a nextToken value if applicable.
    public var limit: Swift.Int?
    /// The name of the service mesh to list virtual services in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The nextToken value returned from a previous paginated ListVirtualServices request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    public var nextToken: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
    }
}

struct ListVirtualServicesInputBody: Swift.Equatable {
}

extension ListVirtualServicesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVirtualServicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVirtualServicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVirtualServicesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVirtualServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.virtualServices = output.virtualServices
        } else {
            self.nextToken = nil
            self.virtualServices = nil
        }
    }
}

///
public struct ListVirtualServicesOutputResponse: Swift.Equatable {
    /// The nextToken value to include in a future ListVirtualServices request. When the results of a ListVirtualServices request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of existing virtual services for the specified service mesh.
    /// This member is required.
    public var virtualServices: [AppMeshClientTypes.VirtualServiceRef]?

    public init (
        nextToken: Swift.String? = nil,
        virtualServices: [AppMeshClientTypes.VirtualServiceRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualServices = virtualServices
    }
}

struct ListVirtualServicesOutputResponseBody: Swift.Equatable {
    let virtualServices: [AppMeshClientTypes.VirtualServiceRef]?
    let nextToken: Swift.String?
}

extension ListVirtualServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case virtualServices
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServicesContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.VirtualServiceRef?].self, forKey: .virtualServices)
        var virtualServicesDecoded0:[AppMeshClientTypes.VirtualServiceRef]? = nil
        if let virtualServicesContainer = virtualServicesContainer {
            virtualServicesDecoded0 = [AppMeshClientTypes.VirtualServiceRef]()
            for structure0 in virtualServicesContainer {
                if let structure0 = structure0 {
                    virtualServicesDecoded0?.append(structure0)
                }
            }
        }
        virtualServices = virtualServicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AppMeshClientTypes.Listener: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionPool
        case healthCheck
        case outlierDetection
        case portMapping
        case timeout
        case tls
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionPool = self.connectionPool {
            try encodeContainer.encode(connectionPool, forKey: .connectionPool)
        }
        if let healthCheck = self.healthCheck {
            try encodeContainer.encode(healthCheck, forKey: .healthCheck)
        }
        if let outlierDetection = self.outlierDetection {
            try encodeContainer.encode(outlierDetection, forKey: .outlierDetection)
        }
        if let portMapping = self.portMapping {
            try encodeContainer.encode(portMapping, forKey: .portMapping)
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tls = self.tls {
            try encodeContainer.encode(tls, forKey: .tls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portMappingDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.PortMapping.self, forKey: .portMapping)
        portMapping = portMappingDecoded
        let tlsDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ListenerTls.self, forKey: .tls)
        tls = tlsDecoded
        let healthCheckDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HealthCheckPolicy.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ListenerTimeout.self, forKey: .timeout)
        timeout = timeoutDecoded
        let outlierDetectionDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.OutlierDetection.self, forKey: .outlierDetection)
        outlierDetection = outlierDetectionDecoded
        let connectionPoolDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualNodeConnectionPool.self, forKey: .connectionPool)
        connectionPool = connectionPoolDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a listener for a virtual node.
    public struct Listener: Swift.Equatable {
        /// The connection pool information for the listener.
        public var connectionPool: AppMeshClientTypes.VirtualNodeConnectionPool?
        /// The health check information for the listener.
        public var healthCheck: AppMeshClientTypes.HealthCheckPolicy?
        /// The outlier detection information for the listener.
        public var outlierDetection: AppMeshClientTypes.OutlierDetection?
        /// The port mapping information for the listener.
        /// This member is required.
        public var portMapping: AppMeshClientTypes.PortMapping?
        /// An object that represents timeouts for different protocols.
        public var timeout: AppMeshClientTypes.ListenerTimeout?
        /// A reference to an object that represents the Transport Layer Security (TLS) properties for a listener.
        public var tls: AppMeshClientTypes.ListenerTls?

        public init (
            connectionPool: AppMeshClientTypes.VirtualNodeConnectionPool? = nil,
            healthCheck: AppMeshClientTypes.HealthCheckPolicy? = nil,
            outlierDetection: AppMeshClientTypes.OutlierDetection? = nil,
            portMapping: AppMeshClientTypes.PortMapping? = nil,
            timeout: AppMeshClientTypes.ListenerTimeout? = nil,
            tls: AppMeshClientTypes.ListenerTls? = nil
        )
        {
            self.connectionPool = connectionPool
            self.healthCheck = healthCheck
            self.outlierDetection = outlierDetection
            self.portMapping = portMapping
            self.timeout = timeout
            self.tls = tls
        }
    }

}

extension AppMeshClientTypes.ListenerTimeout: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grpc
        case http
        case http2
        case sdkUnknown
        case tcp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .grpc(grpc):
                try container.encode(grpc, forKey: .grpc)
            case let .http(http):
                try container.encode(http, forKey: .http)
            case let .http2(http2):
                try container.encode(http2, forKey: .http2)
            case let .tcp(tcp):
                try container.encode(tcp, forKey: .tcp)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tcpDecoded = try values.decodeIfPresent(AppMeshClientTypes.TcpTimeout.self, forKey: .tcp)
        if let tcp = tcpDecoded {
            self = .tcp(tcp)
            return
        }
        let httpDecoded = try values.decodeIfPresent(AppMeshClientTypes.HttpTimeout.self, forKey: .http)
        if let http = httpDecoded {
            self = .http(http)
            return
        }
        let http2Decoded = try values.decodeIfPresent(AppMeshClientTypes.HttpTimeout.self, forKey: .http2)
        if let http2 = http2Decoded {
            self = .http2(http2)
            return
        }
        let grpcDecoded = try values.decodeIfPresent(AppMeshClientTypes.GrpcTimeout.self, forKey: .grpc)
        if let grpc = grpcDecoded {
            self = .grpc(grpc)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents timeouts for different protocols.
    public enum ListenerTimeout: Swift.Equatable {
        /// An object that represents types of timeouts.
        case tcp(AppMeshClientTypes.TcpTimeout)
        /// An object that represents types of timeouts.
        case http(AppMeshClientTypes.HttpTimeout)
        /// An object that represents types of timeouts.
        case http2(AppMeshClientTypes.HttpTimeout)
        /// An object that represents types of timeouts.
        case grpc(AppMeshClientTypes.GrpcTimeout)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.ListenerTls: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate
        case mode
        case validation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let validation = self.validation {
            try encodeContainer.encode(validation, forKey: .validation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ListenerTlsMode.self, forKey: .mode)
        mode = modeDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ListenerTlsCertificate.self, forKey: .certificate)
        certificate = certificateDecoded
        let validationDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ListenerTlsValidationContext.self, forKey: .validation)
        validation = validationDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the Transport Layer Security (TLS) properties for a listener.
    public struct ListenerTls: Swift.Equatable {
        /// A reference to an object that represents a listener's Transport Layer Security (TLS) certificate.
        /// This member is required.
        public var certificate: AppMeshClientTypes.ListenerTlsCertificate?
        /// Specify one of the following modes.
        ///
        /// * STRICT – Listener only accepts connections with TLS enabled.
        ///
        /// * PERMISSIVE – Listener accepts connections with or without TLS enabled.
        ///
        /// * DISABLED – Listener only accepts connections without TLS.
        /// This member is required.
        public var mode: AppMeshClientTypes.ListenerTlsMode?
        /// A reference to an object that represents a listener's Transport Layer Security (TLS) validation context.
        public var validation: AppMeshClientTypes.ListenerTlsValidationContext?

        public init (
            certificate: AppMeshClientTypes.ListenerTlsCertificate? = nil,
            mode: AppMeshClientTypes.ListenerTlsMode? = nil,
            validation: AppMeshClientTypes.ListenerTlsValidationContext? = nil
        )
        {
            self.certificate = certificate
            self.mode = mode
            self.validation = validation
        }
    }

}

extension AppMeshClientTypes.ListenerTlsAcmCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents an Certificate Manager certificate.
    public struct ListenerTlsAcmCertificate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see [Transport Layer Security (TLS)](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites).
        /// This member is required.
        public var certificateArn: Swift.String?

        public init (
            certificateArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
        }
    }

}

extension AppMeshClientTypes.ListenerTlsCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acm
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .acm(acm):
                try container.encode(acm, forKey: .acm)
            case let .file(file):
                try container.encode(file, forKey: .file)
            case let .sds(sds):
                try container.encode(sds, forKey: .sds)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let acmDecoded = try values.decodeIfPresent(AppMeshClientTypes.ListenerTlsAcmCertificate.self, forKey: .acm)
        if let acm = acmDecoded {
            self = .acm(acm)
            return
        }
        let fileDecoded = try values.decodeIfPresent(AppMeshClientTypes.ListenerTlsFileCertificate.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(AppMeshClientTypes.ListenerTlsSdsCertificate.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents a listener's Transport Layer Security (TLS) certificate.
    public enum ListenerTlsCertificate: Swift.Equatable {
        /// A reference to an object that represents an Certificate Manager certificate.
        case acm(AppMeshClientTypes.ListenerTlsAcmCertificate)
        /// A reference to an object that represents a local file certificate.
        case file(AppMeshClientTypes.ListenerTlsFileCertificate)
        /// A reference to an object that represents a listener's Secret Discovery Service certificate.
        case sds(AppMeshClientTypes.ListenerTlsSdsCertificate)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.ListenerTlsFileCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateChain
        case privateKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateChain = self.certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
        if let privateKey = self.privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see [Transport Layer Security (TLS)](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites).
    public struct ListenerTlsFileCertificate: Swift.Equatable {
        /// The certificate chain for the certificate.
        /// This member is required.
        public var certificateChain: Swift.String?
        /// The private key for a certificate stored on the file system of the virtual node that the proxy is running on.
        /// This member is required.
        public var privateKey: Swift.String?

        public init (
            certificateChain: Swift.String? = nil,
            privateKey: Swift.String? = nil
        )
        {
            self.certificateChain = certificateChain
            self.privateKey = privateKey
        }
    }

}

extension AppMeshClientTypes {
    public enum ListenerTlsMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case permissive
        case strict
        case sdkUnknown(Swift.String)

        public static var allCases: [ListenerTlsMode] {
            return [
                .disabled,
                .permissive,
                .strict,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .permissive: return "PERMISSIVE"
            case .strict: return "STRICT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListenerTlsMode(rawValue: rawValue) ?? ListenerTlsMode.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.ListenerTlsSdsCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretName = self.secretName {
            try encodeContainer.encode(secretName, forKey: .secretName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretName)
        secretName = secretNameDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the listener's Secret Discovery Service certificate. The proxy must be configured with a local SDS provider via a Unix Domain Socket. See App Mesh [TLS documentation](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html) for more info.
    public struct ListenerTlsSdsCertificate: Swift.Equatable {
        /// A reference to an object that represents the name of the secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
        /// This member is required.
        public var secretName: Swift.String?

        public init (
            secretName: Swift.String? = nil
        )
        {
            self.secretName = secretName
        }
    }

}

extension AppMeshClientTypes.ListenerTlsValidationContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subjectAlternativeNames
        case trust
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subjectAlternativeNames = self.subjectAlternativeNames {
            try encodeContainer.encode(subjectAlternativeNames, forKey: .subjectAlternativeNames)
        }
        if let trust = self.trust {
            try encodeContainer.encode(trust, forKey: .trust)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ListenerTlsValidationContextTrust.self, forKey: .trust)
        trust = trustDecoded
        let subjectAlternativeNamesDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.SubjectAlternativeNames.self, forKey: .subjectAlternativeNames)
        subjectAlternativeNames = subjectAlternativeNamesDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a listener's Transport Layer Security (TLS) validation context.
    public struct ListenerTlsValidationContext: Swift.Equatable {
        /// A reference to an object that represents the SANs for a listener's Transport Layer Security (TLS) validation context.
        public var subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS) certificate.
        /// This member is required.
        public var trust: AppMeshClientTypes.ListenerTlsValidationContextTrust?

        public init (
            subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames? = nil,
            trust: AppMeshClientTypes.ListenerTlsValidationContextTrust? = nil
        )
        {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }
    }

}

extension AppMeshClientTypes.ListenerTlsValidationContextTrust: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .file(file):
                try container.encode(file, forKey: .file)
            case let .sds(sds):
                try container.encode(sds, forKey: .sds)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try values.decodeIfPresent(AppMeshClientTypes.TlsValidationContextFileTrust.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(AppMeshClientTypes.TlsValidationContextSdsTrust.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents a listener's Transport Layer Security (TLS) validation context trust.
    public enum ListenerTlsValidationContextTrust: Swift.Equatable {
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        case file(AppMeshClientTypes.TlsValidationContextFileTrust)
        /// A reference to an object that represents a listener's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        case sds(AppMeshClientTypes.TlsValidationContextSdsTrust)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.Logging: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLog
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLog = self.accessLog {
            try encodeContainer.encode(accessLog, forKey: .accessLog)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.AccessLog.self, forKey: .accessLog)
        accessLog = accessLogDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the logging information for a virtual node.
    public struct Logging: Swift.Equatable {
        /// The access log configuration for a virtual node.
        public var accessLog: AppMeshClientTypes.AccessLog?

        public init (
            accessLog: AppMeshClientTypes.AccessLog? = nil
        )
        {
            self.accessLog = accessLog
        }
    }

}

extension AppMeshClientTypes.LoggingFormat: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case json
        case sdkUnknown
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .json(json):
                var jsonContainer = container.nestedUnkeyedContainer(forKey: .json)
                for jsonformatref0 in json {
                    try jsonContainer.encode(jsonformatref0)
                }
            case let .text(text):
                try container.encode(text, forKey: .text)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .text)
        if let text = textDecoded {
            self = .text(text)
            return
        }
        let jsonContainer = try values.decodeIfPresent([AppMeshClientTypes.JsonFormatRef?].self, forKey: .json)
        var jsonDecoded0:[AppMeshClientTypes.JsonFormatRef]? = nil
        if let jsonContainer = jsonContainer {
            jsonDecoded0 = [AppMeshClientTypes.JsonFormatRef]()
            for structure0 in jsonContainer {
                if let structure0 = structure0 {
                    jsonDecoded0?.append(structure0)
                }
            }
        }
        if let json = jsonDecoded0 {
            self = .json(json)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents the format for the logs.
    public enum LoggingFormat: Swift.Equatable {
        ///
        case text(Swift.String)
        ///
        case json([AppMeshClientTypes.JsonFormatRef])
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.MatchRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end
        case start
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = self.end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = self.start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .end)
        end = endDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the range of values to match on. The first character of the range is included in the range, though the last character is not. For example, if the range specified were 1-100, only values 1-99 would be matched.
    public struct MatchRange: Swift.Equatable {
        /// The end of the range.
        /// This member is required.
        public var end: Swift.Int?
        /// The start of the range.
        /// This member is required.
        public var start: Swift.Int?

        public init (
            end: Swift.Int? = nil,
            start: Swift.Int? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension AppMeshClientTypes.MeshData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meshName
        case metadata
        case spec
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.MeshSpec.self, forKey: .spec)
        spec = specDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ResourceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.MeshStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a service mesh returned by a describe operation.
    public struct MeshData: Swift.Equatable {
        /// The name of the service mesh.
        /// This member is required.
        public var meshName: Swift.String?
        /// The associated metadata for the service mesh.
        /// This member is required.
        public var metadata: AppMeshClientTypes.ResourceMetadata?
        /// The associated specification for the service mesh.
        /// This member is required.
        public var spec: AppMeshClientTypes.MeshSpec?
        /// The status of the service mesh.
        /// This member is required.
        public var status: AppMeshClientTypes.MeshStatus?

        public init (
            meshName: Swift.String? = nil,
            metadata: AppMeshClientTypes.ResourceMetadata? = nil,
            spec: AppMeshClientTypes.MeshSpec? = nil,
            status: AppMeshClientTypes.MeshStatus? = nil
        )
        {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
        }
    }

}

extension AppMeshClientTypes.MeshRef: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case meshName
        case meshOwner
        case resourceOwner
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let meshOwner = self.meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a service mesh returned by a list operation.
    public struct MeshRef: Swift.Equatable {
        /// The full Amazon Resource Name (ARN) of the service mesh.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the service mesh.
        /// This member is required.
        public var meshName: Swift.String?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            meshName: Swift.String? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
        }
    }

}

extension AppMeshClientTypes.MeshServiceDiscovery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipPreference
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipPreference = self.ipPreference {
            try encodeContainer.encode(ipPreference.rawValue, forKey: .ipPreference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipPreferenceDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.IpPreference.self, forKey: .ipPreference)
        ipPreference = ipPreferenceDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the service discovery information for a service mesh.
    public struct MeshServiceDiscovery: Swift.Equatable {
        /// The IP version to use to control traffic within the mesh.
        public var ipPreference: AppMeshClientTypes.IpPreference?

        public init (
            ipPreference: AppMeshClientTypes.IpPreference? = nil
        )
        {
            self.ipPreference = ipPreference
        }
    }

}

extension AppMeshClientTypes.MeshSpec: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressFilter
        case serviceDiscovery
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let egressFilter = self.egressFilter {
            try encodeContainer.encode(egressFilter, forKey: .egressFilter)
        }
        if let serviceDiscovery = self.serviceDiscovery {
            try encodeContainer.encode(serviceDiscovery, forKey: .serviceDiscovery)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let egressFilterDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.EgressFilter.self, forKey: .egressFilter)
        egressFilter = egressFilterDecoded
        let serviceDiscoveryDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.MeshServiceDiscovery.self, forKey: .serviceDiscovery)
        serviceDiscovery = serviceDiscoveryDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the specification of a service mesh.
    public struct MeshSpec: Swift.Equatable {
        /// The egress filter rules for the service mesh.
        public var egressFilter: AppMeshClientTypes.EgressFilter?
        /// An object that represents the service discovery information for a service mesh.
        public var serviceDiscovery: AppMeshClientTypes.MeshServiceDiscovery?

        public init (
            egressFilter: AppMeshClientTypes.EgressFilter? = nil,
            serviceDiscovery: AppMeshClientTypes.MeshServiceDiscovery? = nil
        )
        {
            self.egressFilter = egressFilter
            self.serviceDiscovery = serviceDiscovery
        }
    }

}

extension AppMeshClientTypes.MeshStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.MeshStatusCode.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the status of a service mesh.
    public struct MeshStatus: Swift.Equatable {
        /// The current mesh status.
        public var status: AppMeshClientTypes.MeshStatusCode?

        public init (
            status: AppMeshClientTypes.MeshStatusCode? = nil
        )
        {
            self.status = status
        }
    }

}

extension AppMeshClientTypes {
    public enum MeshStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [MeshStatusCode] {
            return [
                .active,
                .deleted,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MeshStatusCode(rawValue: rawValue) ?? MeshStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource doesn't exist. Check your request syntax and try again.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppMeshClientTypes.OutlierDetection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseEjectionDuration
        case interval
        case maxEjectionPercent
        case maxServerErrors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseEjectionDuration = self.baseEjectionDuration {
            try encodeContainer.encode(baseEjectionDuration, forKey: .baseEjectionDuration)
        }
        if let interval = self.interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let maxEjectionPercent = self.maxEjectionPercent {
            try encodeContainer.encode(maxEjectionPercent, forKey: .maxEjectionPercent)
        }
        if let maxServerErrors = self.maxServerErrors {
            try encodeContainer.encode(maxServerErrors, forKey: .maxServerErrors)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxServerErrorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxServerErrors)
        maxServerErrors = maxServerErrorsDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.Duration.self, forKey: .interval)
        interval = intervalDecoded
        let baseEjectionDurationDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.Duration.self, forKey: .baseEjectionDuration)
        baseEjectionDuration = baseEjectionDurationDecoded
        let maxEjectionPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxEjectionPercent)
        maxEjectionPercent = maxEjectionPercentDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the outlier detection for a virtual node's listener.
    public struct OutlierDetection: Swift.Equatable {
        /// The base amount of time for which a host is ejected.
        /// This member is required.
        public var baseEjectionDuration: AppMeshClientTypes.Duration?
        /// The time interval between ejection sweep analysis.
        /// This member is required.
        public var interval: AppMeshClientTypes.Duration?
        /// Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
        /// This member is required.
        public var maxEjectionPercent: Swift.Int?
        /// Number of consecutive 5xx errors required for ejection.
        /// This member is required.
        public var maxServerErrors: Swift.Int?

        public init (
            baseEjectionDuration: AppMeshClientTypes.Duration? = nil,
            interval: AppMeshClientTypes.Duration? = nil,
            maxEjectionPercent: Swift.Int? = nil,
            maxServerErrors: Swift.Int? = nil
        )
        {
            self.baseEjectionDuration = baseEjectionDuration
            self.interval = interval
            self.maxEjectionPercent = maxEjectionPercent
            self.maxServerErrors = maxServerErrors
        }
    }

}

extension AppMeshClientTypes.PortMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port
        case `protocol` = "protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.PortProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a port mapping.
    public struct PortMapping: Swift.Equatable {
        /// The port used for the port mapping.
        /// This member is required.
        public var port: Swift.Int
        /// The protocol used for the port mapping. Specify one protocol.
        /// This member is required.
        public var `protocol`: AppMeshClientTypes.PortProtocol?

        public init (
            port: Swift.Int = 0,
            `protocol`: AppMeshClientTypes.PortProtocol? = nil
        )
        {
            self.port = port
            self.`protocol` = `protocol`
        }
    }

}

extension AppMeshClientTypes {
    public enum PortProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case grpc
        case http
        case http2
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [PortProtocol] {
            return [
                .grpc,
                .http,
                .http2,
                .tcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .grpc: return "grpc"
            case .http: return "http"
            case .http2: return "http2"
            case .tcp: return "tcp"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PortProtocol(rawValue: rawValue) ?? PortProtocol.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.QueryParameterMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exact
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exact = self.exact {
            try encodeContainer.encode(exact, forKey: .exact)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exactDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exact)
        exact = exactDecoded
    }
}

extension AppMeshClientTypes {
    /// An object representing the query parameter to match.
    public struct QueryParameterMatch: Swift.Equatable {
        /// The exact query parameter to match on.
        public var exact: Swift.String?

        public init (
            exact: Swift.String? = nil
        )
        {
            self.exact = exact
        }
    }

}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't delete the specified resource because it's in use or required by another resource.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppMeshClientTypes.ResourceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case meshOwner
        case resourceOwner
        case uid
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let meshOwner = self.meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let uid = self.uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let uidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uid)
        uid = uidDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents metadata for a resource.
    public struct ResourceMetadata: Swift.Equatable {
        /// The full Amazon Resource Name (ARN) for the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The unique identifier for the resource.
        /// This member is required.
        public var uid: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            uid: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.uid = uid
            self.version = version
        }
    }

}

extension AppMeshClientTypes.RouteData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meshName
        case metadata
        case routeName
        case spec
        case status
        case virtualRouterName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let routeName = self.routeName {
            try encodeContainer.encode(routeName, forKey: .routeName)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let virtualRouterName = self.virtualRouterName {
            try encodeContainer.encode(virtualRouterName, forKey: .virtualRouterName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualRouterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualRouterName)
        virtualRouterName = virtualRouterNameDecoded
        let routeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeName)
        routeName = routeNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.RouteSpec.self, forKey: .spec)
        spec = specDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ResourceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.RouteStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a route returned by a describe operation.
    public struct RouteData: Swift.Equatable {
        /// The name of the service mesh that the route resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The associated metadata for the route.
        /// This member is required.
        public var metadata: AppMeshClientTypes.ResourceMetadata?
        /// The name of the route.
        /// This member is required.
        public var routeName: Swift.String?
        /// The specifications of the route.
        /// This member is required.
        public var spec: AppMeshClientTypes.RouteSpec?
        /// The status of the route.
        /// This member is required.
        public var status: AppMeshClientTypes.RouteStatus?
        /// The virtual router that the route is associated with.
        /// This member is required.
        public var virtualRouterName: Swift.String?

        public init (
            meshName: Swift.String? = nil,
            metadata: AppMeshClientTypes.ResourceMetadata? = nil,
            routeName: Swift.String? = nil,
            spec: AppMeshClientTypes.RouteSpec? = nil,
            status: AppMeshClientTypes.RouteStatus? = nil,
            virtualRouterName: Swift.String? = nil
        )
        {
            self.meshName = meshName
            self.metadata = metadata
            self.routeName = routeName
            self.spec = spec
            self.status = status
            self.virtualRouterName = virtualRouterName
        }
    }

}

extension AppMeshClientTypes.RouteRef: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case meshName
        case meshOwner
        case resourceOwner
        case routeName
        case version
        case virtualRouterName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let meshOwner = self.meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let routeName = self.routeName {
            try encodeContainer.encode(routeName, forKey: .routeName)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let virtualRouterName = self.virtualRouterName {
            try encodeContainer.encode(virtualRouterName, forKey: .virtualRouterName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualRouterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualRouterName)
        virtualRouterName = virtualRouterNameDecoded
        let routeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeName)
        routeName = routeNameDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a route returned by a list operation.
    public struct RouteRef: Swift.Equatable {
        /// The full Amazon Resource Name (ARN) for the route.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the service mesh that the route resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The name of the route.
        /// This member is required.
        public var routeName: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?
        /// The virtual router that the route is associated with.
        /// This member is required.
        public var virtualRouterName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            meshName: Swift.String? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            routeName: Swift.String? = nil,
            version: Swift.Int? = nil,
            virtualRouterName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.routeName = routeName
            self.version = version
            self.virtualRouterName = virtualRouterName
        }
    }

}

extension AppMeshClientTypes.RouteSpec: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grpcRoute
        case http2Route
        case httpRoute
        case priority
        case tcpRoute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grpcRoute = self.grpcRoute {
            try encodeContainer.encode(grpcRoute, forKey: .grpcRoute)
        }
        if let http2Route = self.http2Route {
            try encodeContainer.encode(http2Route, forKey: .http2Route)
        }
        if let httpRoute = self.httpRoute {
            try encodeContainer.encode(httpRoute, forKey: .httpRoute)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let tcpRoute = self.tcpRoute {
            try encodeContainer.encode(tcpRoute, forKey: .tcpRoute)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let httpRouteDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpRoute.self, forKey: .httpRoute)
        httpRoute = httpRouteDecoded
        let tcpRouteDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.TcpRoute.self, forKey: .tcpRoute)
        tcpRoute = tcpRouteDecoded
        let http2RouteDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.HttpRoute.self, forKey: .http2Route)
        http2Route = http2RouteDecoded
        let grpcRouteDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GrpcRoute.self, forKey: .grpcRoute)
        grpcRoute = grpcRouteDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a route specification. Specify one route type.
    public struct RouteSpec: Swift.Equatable {
        /// An object that represents the specification of a gRPC route.
        public var grpcRoute: AppMeshClientTypes.GrpcRoute?
        /// An object that represents the specification of an HTTP/2 route.
        public var http2Route: AppMeshClientTypes.HttpRoute?
        /// An object that represents the specification of an HTTP route.
        public var httpRoute: AppMeshClientTypes.HttpRoute?
        /// The priority for the route. Routes are matched based on the specified value, where 0 is the highest priority.
        public var priority: Swift.Int?
        /// An object that represents the specification of a TCP route.
        public var tcpRoute: AppMeshClientTypes.TcpRoute?

        public init (
            grpcRoute: AppMeshClientTypes.GrpcRoute? = nil,
            http2Route: AppMeshClientTypes.HttpRoute? = nil,
            httpRoute: AppMeshClientTypes.HttpRoute? = nil,
            priority: Swift.Int? = nil,
            tcpRoute: AppMeshClientTypes.TcpRoute? = nil
        )
        {
            self.grpcRoute = grpcRoute
            self.http2Route = http2Route
            self.httpRoute = httpRoute
            self.priority = priority
            self.tcpRoute = tcpRoute
        }
    }

}

extension AppMeshClientTypes.RouteStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.RouteStatusCode.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the current status of a route.
    public struct RouteStatus: Swift.Equatable {
        /// The current status for the route.
        /// This member is required.
        public var status: AppMeshClientTypes.RouteStatusCode?

        public init (
            status: AppMeshClientTypes.RouteStatusCode? = nil
        )
        {
            self.status = status
        }
    }

}

extension AppMeshClientTypes {
    public enum RouteStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteStatusCode] {
            return [
                .active,
                .deleted,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteStatusCode(rawValue: rawValue) ?? RouteStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.ServiceDiscovery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awscloudmap = "awsCloudMap"
        case dns
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .awscloudmap(awscloudmap):
                try container.encode(awscloudmap, forKey: .awscloudmap)
            case let .dns(dns):
                try container.encode(dns, forKey: .dns)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let dnsDecoded = try values.decodeIfPresent(AppMeshClientTypes.DnsServiceDiscovery.self, forKey: .dns)
        if let dns = dnsDecoded {
            self = .dns(dns)
            return
        }
        let awscloudmapDecoded = try values.decodeIfPresent(AppMeshClientTypes.AwsCloudMapServiceDiscovery.self, forKey: .awscloudmap)
        if let awscloudmap = awscloudmapDecoded {
            self = .awscloudmap(awscloudmap)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents the service discovery information for a virtual node.
    public enum ServiceDiscovery: Swift.Equatable {
        /// Specifies the DNS information for the virtual node.
        case dns(AppMeshClientTypes.DnsServiceDiscovery)
        /// Specifies any Cloud Map information for the virtual node.
        case awscloudmap(AppMeshClientTypes.AwsCloudMapServiceDiscovery)
        case sdkUnknown(Swift.String)
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has failed due to a temporary failure of the service.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppMeshClientTypes.SubjectAlternativeNameMatchers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exact
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exact = exact {
            var exactContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exact)
            for subjectalternativename0 in exact {
                try exactContainer.encode(subjectalternativename0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exactContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exact)
        var exactDecoded0:[Swift.String]? = nil
        if let exactContainer = exactContainer {
            exactDecoded0 = [Swift.String]()
            for string0 in exactContainer {
                if let string0 = string0 {
                    exactDecoded0?.append(string0)
                }
            }
        }
        exact = exactDecoded0
    }
}

extension AppMeshClientTypes {
    /// An object that represents the methods by which a subject alternative name on a peer Transport Layer Security (TLS) certificate can be matched.
    public struct SubjectAlternativeNameMatchers: Swift.Equatable {
        /// The values sent must match the specified values exactly.
        /// This member is required.
        public var exact: [Swift.String]?

        public init (
            exact: [Swift.String]? = nil
        )
        {
            self.exact = exact
        }
    }

}

extension AppMeshClientTypes.SubjectAlternativeNames: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case match
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.SubjectAlternativeNameMatchers.self, forKey: .match)
        match = matchDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the subject alternative names secured by the certificate.
    public struct SubjectAlternativeNames: Swift.Equatable {
        /// An object that represents the criteria for determining a SANs match.
        /// This member is required.
        public var match: AppMeshClientTypes.SubjectAlternativeNameMatchers?

        public init (
            match: AppMeshClientTypes.SubjectAlternativeNameMatchers? = nil
        )
        {
            self.match = match
        }
    }

}

extension AppMeshClientTypes.TagRef: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AppMeshClientTypes {
    /// Optional metadata that you apply to a resource to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public struct TagRef: Swift.Equatable {
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        /// This member is required.
        public var key: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagref0 in tags {
                try tagsContainer.encode(tagref0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20190125/tag"
    }
}

///
public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to add tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    /// This member is required.
    public var tags: [AppMeshClientTypes.TagRef]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [AppMeshClientTypes.TagRef]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [AppMeshClientTypes.TagRef]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.TagRef?].self, forKey: .tags)
        var tagsDecoded0:[AppMeshClientTypes.TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppMeshClientTypes.TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension AppMeshClientTypes {
    public enum TcpRetryPolicyEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectionError
        case sdkUnknown(Swift.String)

        public static var allCases: [TcpRetryPolicyEvent] {
            return [
                .connectionError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectionError: return "connection-error"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TcpRetryPolicyEvent(rawValue: rawValue) ?? TcpRetryPolicyEvent.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.TcpRoute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case match
        case timeout
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.TcpRouteAction.self, forKey: .action)
        action = actionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.TcpTimeout.self, forKey: .timeout)
        timeout = timeoutDecoded
        let matchDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.TcpRouteMatch.self, forKey: .match)
        match = matchDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a TCP route type.
    public struct TcpRoute: Swift.Equatable {
        /// The action to take if a match is determined.
        /// This member is required.
        public var action: AppMeshClientTypes.TcpRouteAction?
        /// An object that represents the criteria for determining a request match.
        public var match: AppMeshClientTypes.TcpRouteMatch?
        /// An object that represents types of timeouts.
        public var timeout: AppMeshClientTypes.TcpTimeout?

        public init (
            action: AppMeshClientTypes.TcpRouteAction? = nil,
            match: AppMeshClientTypes.TcpRouteMatch? = nil,
            timeout: AppMeshClientTypes.TcpTimeout? = nil
        )
        {
            self.action = action
            self.match = match
            self.timeout = timeout
        }
    }

}

extension AppMeshClientTypes.TcpRouteAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case weightedTargets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let weightedTargets = weightedTargets {
            var weightedTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .weightedTargets)
            for weightedtarget0 in weightedTargets {
                try weightedTargetsContainer.encode(weightedtarget0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weightedTargetsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.WeightedTarget?].self, forKey: .weightedTargets)
        var weightedTargetsDecoded0:[AppMeshClientTypes.WeightedTarget]? = nil
        if let weightedTargetsContainer = weightedTargetsContainer {
            weightedTargetsDecoded0 = [AppMeshClientTypes.WeightedTarget]()
            for structure0 in weightedTargetsContainer {
                if let structure0 = structure0 {
                    weightedTargetsDecoded0?.append(structure0)
                }
            }
        }
        weightedTargets = weightedTargetsDecoded0
    }
}

extension AppMeshClientTypes {
    /// An object that represents the action to take if a match is determined.
    public struct TcpRouteAction: Swift.Equatable {
        /// An object that represents the targets that traffic is routed to when a request matches the route.
        /// This member is required.
        public var weightedTargets: [AppMeshClientTypes.WeightedTarget]?

        public init (
            weightedTargets: [AppMeshClientTypes.WeightedTarget]? = nil
        )
        {
            self.weightedTargets = weightedTargets
        }
    }

}

extension AppMeshClientTypes.TcpRouteMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension AppMeshClientTypes {
    /// An object representing the TCP route to match.
    public struct TcpRouteMatch: Swift.Equatable {
        /// The port number to match on.
        public var port: Swift.Int?

        public init (
            port: Swift.Int? = nil
        )
        {
            self.port = port
        }
    }

}

extension AppMeshClientTypes.TcpTimeout: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idle
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idle = self.idle {
            try encodeContainer.encode(idle, forKey: .idle)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idleDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.Duration.self, forKey: .idle)
        idle = idleDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents types of timeouts.
    public struct TcpTimeout: Swift.Equatable {
        /// An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.
        public var idle: AppMeshClientTypes.Duration?

        public init (
            idle: AppMeshClientTypes.Duration? = nil
        )
        {
            self.idle = idle
        }
    }

}

extension AppMeshClientTypes.TlsValidationContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subjectAlternativeNames
        case trust
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subjectAlternativeNames = self.subjectAlternativeNames {
            try encodeContainer.encode(subjectAlternativeNames, forKey: .subjectAlternativeNames)
        }
        if let trust = self.trust {
            try encodeContainer.encode(trust, forKey: .trust)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.TlsValidationContextTrust.self, forKey: .trust)
        trust = trustDecoded
        let subjectAlternativeNamesDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.SubjectAlternativeNames.self, forKey: .subjectAlternativeNames)
        subjectAlternativeNames = subjectAlternativeNamesDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents how the proxy will validate its peer during Transport Layer Security (TLS) negotiation.
    public struct TlsValidationContext: Swift.Equatable {
        /// A reference to an object that represents the SANs for a Transport Layer Security (TLS) validation context. If you don't specify SANs on the terminating mesh endpoint, the Envoy proxy for that node doesn't verify the SAN on a peer client certificate. If you don't specify SANs on the originating mesh endpoint, the SAN on the certificate provided by the terminating endpoint must match the mesh endpoint service discovery configuration. Since SPIRE vended certificates have a SPIFFE ID as a name, you must set the SAN since the name doesn't match the service discovery name.
        public var subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS) certificate.
        /// This member is required.
        public var trust: AppMeshClientTypes.TlsValidationContextTrust?

        public init (
            subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames? = nil,
            trust: AppMeshClientTypes.TlsValidationContextTrust? = nil
        )
        {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }
    }

}

extension AppMeshClientTypes.TlsValidationContextAcmTrust: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArns = certificateAuthorityArns {
            var certificateAuthorityArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateAuthorityArns)
            for arn0 in certificateAuthorityArns {
                try certificateAuthorityArnsContainer.encode(arn0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .certificateAuthorityArns)
        var certificateAuthorityArnsDecoded0:[Swift.String]? = nil
        if let certificateAuthorityArnsContainer = certificateAuthorityArnsContainer {
            certificateAuthorityArnsDecoded0 = [Swift.String]()
            for string0 in certificateAuthorityArnsContainer {
                if let string0 = string0 {
                    certificateAuthorityArnsDecoded0?.append(string0)
                }
            }
        }
        certificateAuthorityArns = certificateAuthorityArnsDecoded0
    }
}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) validation context trust for an Certificate Manager certificate.
    public struct TlsValidationContextAcmTrust: Swift.Equatable {
        /// One or more ACM Amazon Resource Name (ARN)s.
        /// This member is required.
        public var certificateAuthorityArns: [Swift.String]?

        public init (
            certificateAuthorityArns: [Swift.String]? = nil
        )
        {
            self.certificateAuthorityArns = certificateAuthorityArns
        }
    }

}

extension AppMeshClientTypes.TlsValidationContextFileTrust: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateChain
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateChain = self.certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
    public struct TlsValidationContextFileTrust: Swift.Equatable {
        /// The certificate trust chain for a certificate stored on the file system of the virtual node that the proxy is running on.
        /// This member is required.
        public var certificateChain: Swift.String?

        public init (
            certificateChain: Swift.String? = nil
        )
        {
            self.certificateChain = certificateChain
        }
    }

}

extension AppMeshClientTypes.TlsValidationContextSdsTrust: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretName = self.secretName {
            try encodeContainer.encode(secretName, forKey: .secretName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretName)
        secretName = secretNameDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) Secret Discovery Service validation context trust. The proxy must be configured with a local SDS provider via a Unix Domain Socket. See App Mesh [TLS documentation](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html) for more info.
    public struct TlsValidationContextSdsTrust: Swift.Equatable {
        /// A reference to an object that represents the name of the secret for a Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        /// This member is required.
        public var secretName: Swift.String?

        public init (
            secretName: Swift.String? = nil
        )
        {
            self.secretName = secretName
        }
    }

}

extension AppMeshClientTypes.TlsValidationContextTrust: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acm
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .acm(acm):
                try container.encode(acm, forKey: .acm)
            case let .file(file):
                try container.encode(file, forKey: .file)
            case let .sds(sds):
                try container.encode(sds, forKey: .sds)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let acmDecoded = try values.decodeIfPresent(AppMeshClientTypes.TlsValidationContextAcmTrust.self, forKey: .acm)
        if let acm = acmDecoded {
            self = .acm(acm)
            return
        }
        let fileDecoded = try values.decodeIfPresent(AppMeshClientTypes.TlsValidationContextFileTrust.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(AppMeshClientTypes.TlsValidationContextSdsTrust.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) validation context trust.
    public enum TlsValidationContextTrust: Swift.Equatable {
        /// A reference to an object that represents a Transport Layer Security (TLS) validation context trust for an Certificate Manager certificate.
        case acm(AppMeshClientTypes.TlsValidationContextAcmTrust)
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        case file(AppMeshClientTypes.TlsValidationContextFileTrust)
        /// A reference to an object that represents a Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        case sds(AppMeshClientTypes.TlsValidationContextSdsTrust)
        case sdkUnknown(Swift.String)
    }

}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum request rate permitted by the App Mesh APIs has been exceeded for your account. For best results, use an increasing or variable sleep interval between requests.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeds the maximum allowed number of tags allowed per resource. The current limit is 50 user tags per resource. You must reduce the number of tags in the request. None of the tags in this request were applied.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20190125/untag"
    }
}

///
public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to delete tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateGatewayRouteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

extension UpdateGatewayRouteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension UpdateGatewayRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualGatewayName = virtualGatewayName else {
            return nil
        }
        guard let gatewayRouteName = gatewayRouteName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateway/\(virtualGatewayName.urlPercentEncoding())/gatewayRoutes/\(gatewayRouteName.urlPercentEncoding())"
    }
}

public struct UpdateGatewayRouteInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the gateway route to update.
    /// This member is required.
    public var gatewayRouteName: Swift.String?
    /// The name of the service mesh that the gateway route resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The new gateway route specification to apply. This overwrites the existing data.
    /// This member is required.
    public var spec: AppMeshClientTypes.GatewayRouteSpec?
    /// The name of the virtual gateway that the gateway route is associated with.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        gatewayRouteName: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.GatewayRouteSpec? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.gatewayRouteName = gatewayRouteName
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualGatewayName = virtualGatewayName
    }
}

struct UpdateGatewayRouteInputBody: Swift.Equatable {
    let spec: AppMeshClientTypes.GatewayRouteSpec?
    let clientToken: Swift.String?
}

extension UpdateGatewayRouteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteSpec.self, forKey: .spec)
        spec = specDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateGatewayRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGatewayRouteOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.GatewayRouteData = try responseDecoder.decode(responseBody: data)
                self.gatewayRoute = output
            } else {
                self.gatewayRoute = nil
            }
        } else {
            self.gatewayRoute = nil
        }
    }
}

public struct UpdateGatewayRouteOutputResponse: Swift.Equatable {
    /// A full description of the gateway route that was updated.
    /// This member is required.
    public var gatewayRoute: AppMeshClientTypes.GatewayRouteData?

    public init (
        gatewayRoute: AppMeshClientTypes.GatewayRouteData? = nil
    )
    {
        self.gatewayRoute = gatewayRoute
    }
}

struct UpdateGatewayRouteOutputResponseBody: Swift.Equatable {
    let gatewayRoute: AppMeshClientTypes.GatewayRouteData?
}

extension UpdateGatewayRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayRoute
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayRouteDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.GatewayRouteData.self, forKey: .gatewayRoute)
        gatewayRoute = gatewayRouteDecoded
    }
}

extension UpdateMeshInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

extension UpdateMeshInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())"
    }
}

///
public struct UpdateMeshInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh to update.
    /// This member is required.
    public var meshName: Swift.String?
    /// The service mesh specification to apply.
    public var spec: AppMeshClientTypes.MeshSpec?

    public init (
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        spec: AppMeshClientTypes.MeshSpec? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.spec = spec
    }
}

struct UpdateMeshInputBody: Swift.Equatable {
    let spec: AppMeshClientTypes.MeshSpec?
    let clientToken: Swift.String?
}

extension UpdateMeshInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.MeshSpec.self, forKey: .spec)
        spec = specDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateMeshOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMeshOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateMeshOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMeshOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.MeshData = try responseDecoder.decode(responseBody: data)
                self.mesh = output
            } else {
                self.mesh = nil
            }
        } else {
            self.mesh = nil
        }
    }
}

///
public struct UpdateMeshOutputResponse: Swift.Equatable {
    /// An object that represents a service mesh returned by a describe operation.
    /// This member is required.
    public var mesh: AppMeshClientTypes.MeshData?

    public init (
        mesh: AppMeshClientTypes.MeshData? = nil
    )
    {
        self.mesh = mesh
    }
}

struct UpdateMeshOutputResponseBody: Swift.Equatable {
    let mesh: AppMeshClientTypes.MeshData?
}

extension UpdateMeshOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mesh
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.MeshData.self, forKey: .mesh)
        mesh = meshDecoded
    }
}

extension UpdateRouteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

extension UpdateRouteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension UpdateRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualRouterName = virtualRouterName else {
            return nil
        }
        guard let routeName = routeName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouter/\(virtualRouterName.urlPercentEncoding())/routes/\(routeName.urlPercentEncoding())"
    }
}

///
public struct UpdateRouteInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh that the route resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The name of the route to update.
    /// This member is required.
    public var routeName: Swift.String?
    /// The new route specification to apply. This overwrites the existing data.
    /// This member is required.
    public var spec: AppMeshClientTypes.RouteSpec?
    /// The name of the virtual router that the route is associated with.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        routeName: Swift.String? = nil,
        spec: AppMeshClientTypes.RouteSpec? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.routeName = routeName
        self.spec = spec
        self.virtualRouterName = virtualRouterName
    }
}

struct UpdateRouteInputBody: Swift.Equatable {
    let spec: AppMeshClientTypes.RouteSpec?
    let clientToken: Swift.String?
}

extension UpdateRouteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.RouteSpec.self, forKey: .spec)
        spec = specDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRouteOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.RouteData = try responseDecoder.decode(responseBody: data)
                self.route = output
            } else {
                self.route = nil
            }
        } else {
            self.route = nil
        }
    }
}

///
public struct UpdateRouteOutputResponse: Swift.Equatable {
    /// A full description of the route that was updated.
    /// This member is required.
    public var route: AppMeshClientTypes.RouteData?

    public init (
        route: AppMeshClientTypes.RouteData? = nil
    )
    {
        self.route = route
    }
}

struct UpdateRouteOutputResponseBody: Swift.Equatable {
    let route: AppMeshClientTypes.RouteData?
}

extension UpdateRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case route
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.RouteData.self, forKey: .route)
        route = routeDecoded
    }
}

extension UpdateVirtualGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

extension UpdateVirtualGatewayInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension UpdateVirtualGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualGatewayName = virtualGatewayName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualGateways/\(virtualGatewayName.urlPercentEncoding())"
    }
}

public struct UpdateVirtualGatewayInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh that the virtual gateway resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The new virtual gateway specification to apply. This overwrites the existing data.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualGatewaySpec?
    /// The name of the virtual gateway to update.
    /// This member is required.
    public var virtualGatewayName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualGatewaySpec? = nil,
        virtualGatewayName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualGatewayName = virtualGatewayName
    }
}

struct UpdateVirtualGatewayInputBody: Swift.Equatable {
    let spec: AppMeshClientTypes.VirtualGatewaySpec?
    let clientToken: Swift.String?
}

extension UpdateVirtualGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewaySpec.self, forKey: .spec)
        spec = specDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateVirtualGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVirtualGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVirtualGatewayOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVirtualGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualGatewayData = try responseDecoder.decode(responseBody: data)
                self.virtualGateway = output
            } else {
                self.virtualGateway = nil
            }
        } else {
            self.virtualGateway = nil
        }
    }
}

public struct UpdateVirtualGatewayOutputResponse: Swift.Equatable {
    /// A full description of the virtual gateway that was updated.
    /// This member is required.
    public var virtualGateway: AppMeshClientTypes.VirtualGatewayData?

    public init (
        virtualGateway: AppMeshClientTypes.VirtualGatewayData? = nil
    )
    {
        self.virtualGateway = virtualGateway
    }
}

struct UpdateVirtualGatewayOutputResponseBody: Swift.Equatable {
    let virtualGateway: AppMeshClientTypes.VirtualGatewayData?
}

extension UpdateVirtualGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualGateway
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewayDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayData.self, forKey: .virtualGateway)
        virtualGateway = virtualGatewayDecoded
    }
}

extension UpdateVirtualNodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

extension UpdateVirtualNodeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension UpdateVirtualNodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualNodeName = virtualNodeName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualNodes/\(virtualNodeName.urlPercentEncoding())"
    }
}

///
public struct UpdateVirtualNodeInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh that the virtual node resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The new virtual node specification to apply. This overwrites the existing data.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualNodeSpec?
    /// The name of the virtual node to update.
    /// This member is required.
    public var virtualNodeName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualNodeSpec? = nil,
        virtualNodeName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualNodeName = virtualNodeName
    }
}

struct UpdateVirtualNodeInputBody: Swift.Equatable {
    let spec: AppMeshClientTypes.VirtualNodeSpec?
    let clientToken: Swift.String?
}

extension UpdateVirtualNodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualNodeSpec.self, forKey: .spec)
        spec = specDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateVirtualNodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVirtualNodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVirtualNodeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVirtualNodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualNodeData = try responseDecoder.decode(responseBody: data)
                self.virtualNode = output
            } else {
                self.virtualNode = nil
            }
        } else {
            self.virtualNode = nil
        }
    }
}

///
public struct UpdateVirtualNodeOutputResponse: Swift.Equatable {
    /// A full description of the virtual node that was updated.
    /// This member is required.
    public var virtualNode: AppMeshClientTypes.VirtualNodeData?

    public init (
        virtualNode: AppMeshClientTypes.VirtualNodeData? = nil
    )
    {
        self.virtualNode = virtualNode
    }
}

struct UpdateVirtualNodeOutputResponseBody: Swift.Equatable {
    let virtualNode: AppMeshClientTypes.VirtualNodeData?
}

extension UpdateVirtualNodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualNode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualNodeData.self, forKey: .virtualNode)
        virtualNode = virtualNodeDecoded
    }
}

extension UpdateVirtualRouterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

extension UpdateVirtualRouterInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension UpdateVirtualRouterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualRouterName = virtualRouterName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualRouters/\(virtualRouterName.urlPercentEncoding())"
    }
}

///
public struct UpdateVirtualRouterInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh that the virtual router resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The new virtual router specification to apply. This overwrites the existing data.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualRouterSpec?
    /// The name of the virtual router to update.
    /// This member is required.
    public var virtualRouterName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualRouterSpec? = nil,
        virtualRouterName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualRouterName = virtualRouterName
    }
}

struct UpdateVirtualRouterInputBody: Swift.Equatable {
    let spec: AppMeshClientTypes.VirtualRouterSpec?
    let clientToken: Swift.String?
}

extension UpdateVirtualRouterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualRouterSpec.self, forKey: .spec)
        spec = specDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateVirtualRouterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVirtualRouterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVirtualRouterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVirtualRouterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualRouterData = try responseDecoder.decode(responseBody: data)
                self.virtualRouter = output
            } else {
                self.virtualRouter = nil
            }
        } else {
            self.virtualRouter = nil
        }
    }
}

///
public struct UpdateVirtualRouterOutputResponse: Swift.Equatable {
    /// A full description of the virtual router that was updated.
    /// This member is required.
    public var virtualRouter: AppMeshClientTypes.VirtualRouterData?

    public init (
        virtualRouter: AppMeshClientTypes.VirtualRouterData? = nil
    )
    {
        self.virtualRouter = virtualRouter
    }
}

struct UpdateVirtualRouterOutputResponseBody: Swift.Equatable {
    let virtualRouter: AppMeshClientTypes.VirtualRouterData?
}

extension UpdateVirtualRouterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualRouter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualRouterDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualRouterData.self, forKey: .virtualRouter)
        virtualRouter = virtualRouterDecoded
    }
}

extension UpdateVirtualServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

extension UpdateVirtualServiceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let meshOwner = meshOwner {
                let meshOwnerQueryItem = ClientRuntime.URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: Swift.String(meshOwner).urlPercentEncoding())
                items.append(meshOwnerQueryItem)
            }
            return items
        }
    }
}

extension UpdateVirtualServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meshName = meshName else {
            return nil
        }
        guard let virtualServiceName = virtualServiceName else {
            return nil
        }
        return "/v20190125/meshes/\(meshName.urlPercentEncoding())/virtualServices/\(virtualServiceName.urlPercentEncoding())"
    }
}

///
public struct UpdateVirtualServiceInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
    public var clientToken: Swift.String?
    /// The name of the service mesh that the virtual service resides in.
    /// This member is required.
    public var meshName: Swift.String?
    /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
    public var meshOwner: Swift.String?
    /// The new virtual service specification to apply. This overwrites the existing data.
    /// This member is required.
    public var spec: AppMeshClientTypes.VirtualServiceSpec?
    /// The name of the virtual service to update.
    /// This member is required.
    public var virtualServiceName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        meshName: Swift.String? = nil,
        meshOwner: Swift.String? = nil,
        spec: AppMeshClientTypes.VirtualServiceSpec? = nil,
        virtualServiceName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualServiceName = virtualServiceName
    }
}

struct UpdateVirtualServiceInputBody: Swift.Equatable {
    let spec: AppMeshClientTypes.VirtualServiceSpec?
    let clientToken: Swift.String?
}

extension UpdateVirtualServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case spec
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualServiceSpec.self, forKey: .spec)
        spec = specDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateVirtualServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVirtualServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVirtualServiceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVirtualServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AppMeshClientTypes.VirtualServiceData = try responseDecoder.decode(responseBody: data)
                self.virtualService = output
            } else {
                self.virtualService = nil
            }
        } else {
            self.virtualService = nil
        }
    }
}

///
public struct UpdateVirtualServiceOutputResponse: Swift.Equatable {
    /// A full description of the virtual service that was updated.
    /// This member is required.
    public var virtualService: AppMeshClientTypes.VirtualServiceData?

    public init (
        virtualService: AppMeshClientTypes.VirtualServiceData? = nil
    )
    {
        self.virtualService = virtualService
    }
}

struct UpdateVirtualServiceOutputResponseBody: Swift.Equatable {
    let virtualService: AppMeshClientTypes.VirtualServiceData?
}

extension UpdateVirtualServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualService
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualServiceData.self, forKey: .virtualService)
        virtualService = virtualServiceDecoded
    }
}

extension AppMeshClientTypes.VirtualGatewayAccessLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .file(file):
                try container.encode(file, forKey: .file)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualGatewayFileAccessLog.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// The access log configuration for a virtual gateway.
    public enum VirtualGatewayAccessLog: Swift.Equatable {
        /// The file object to send virtual gateway access logs to.
        case file(AppMeshClientTypes.VirtualGatewayFileAccessLog)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.VirtualGatewayBackendDefaults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientPolicy = self.clientPolicy {
            try encodeContainer.encode(clientPolicy, forKey: .clientPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientPolicyDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayClientPolicy.self, forKey: .clientPolicy)
        clientPolicy = clientPolicyDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the default properties for a backend.
    public struct VirtualGatewayBackendDefaults: Swift.Equatable {
        /// A reference to an object that represents a client policy.
        public var clientPolicy: AppMeshClientTypes.VirtualGatewayClientPolicy?

        public init (
            clientPolicy: AppMeshClientTypes.VirtualGatewayClientPolicy? = nil
        )
        {
            self.clientPolicy = clientPolicy
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayClientPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tls
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tls = self.tls {
            try encodeContainer.encode(tls, forKey: .tls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tlsDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayClientPolicyTls.self, forKey: .tls)
        tls = tlsDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a client policy.
    public struct VirtualGatewayClientPolicy: Swift.Equatable {
        /// A reference to an object that represents a Transport Layer Security (TLS) client policy.
        public var tls: AppMeshClientTypes.VirtualGatewayClientPolicyTls?

        public init (
            tls: AppMeshClientTypes.VirtualGatewayClientPolicyTls? = nil
        )
        {
            self.tls = tls
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayClientPolicyTls: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate
        case enforce
        case ports
        case validation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let enforce = self.enforce {
            try encodeContainer.encode(enforce, forKey: .enforce)
        }
        if let ports = ports {
            var portsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ports)
            for portnumber0 in ports {
                try portsContainer.encode(portnumber0)
            }
        }
        if let validation = self.validation {
            try encodeContainer.encode(validation, forKey: .validation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforce)
        enforce = enforceDecoded
        let portsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .ports)
        var portsDecoded0:[Swift.Int]? = nil
        if let portsContainer = portsContainer {
            portsDecoded0 = [Swift.Int]()
            for integer0 in portsContainer {
                if let integer0 = integer0 {
                    portsDecoded0?.append(integer0)
                }
            }
        }
        ports = portsDecoded0
        let certificateDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayClientTlsCertificate.self, forKey: .certificate)
        certificate = certificateDecoded
        let validationDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayTlsValidationContext.self, forKey: .validation)
        validation = validationDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) client policy.
    public struct VirtualGatewayClientPolicyTls: Swift.Equatable {
        /// A reference to an object that represents a virtual gateway's client's Transport Layer Security (TLS) certificate.
        public var certificate: AppMeshClientTypes.VirtualGatewayClientTlsCertificate?
        /// Whether the policy is enforced. The default is True, if a value isn't specified.
        public var enforce: Swift.Bool?
        /// One or more ports that the policy is enforced for.
        public var ports: [Swift.Int]?
        /// A reference to an object that represents a Transport Layer Security (TLS) validation context.
        /// This member is required.
        public var validation: AppMeshClientTypes.VirtualGatewayTlsValidationContext?

        public init (
            certificate: AppMeshClientTypes.VirtualGatewayClientTlsCertificate? = nil,
            enforce: Swift.Bool? = nil,
            ports: [Swift.Int]? = nil,
            validation: AppMeshClientTypes.VirtualGatewayTlsValidationContext? = nil
        )
        {
            self.certificate = certificate
            self.enforce = enforce
            self.ports = ports
            self.validation = validation
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayClientTlsCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .file(file):
                try container.encode(file, forKey: .file)
            case let .sds(sds):
                try container.encode(sds, forKey: .sds)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents the virtual gateway's client's Transport Layer Security (TLS) certificate.
    public enum VirtualGatewayClientTlsCertificate: Swift.Equatable {
        /// An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see [ Transport Layer Security (TLS) ](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html).
        case file(AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate)
        /// A reference to an object that represents a virtual gateway's client's Secret Discovery Service certificate.
        case sds(AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.VirtualGatewayConnectionPool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grpc
        case http
        case http2
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .grpc(grpc):
                try container.encode(grpc, forKey: .grpc)
            case let .http(http):
                try container.encode(http, forKey: .http)
            case let .http2(http2):
                try container.encode(http2, forKey: .http2)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let httpDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualGatewayHttpConnectionPool.self, forKey: .http)
        if let http = httpDecoded {
            self = .http(http)
            return
        }
        let http2Decoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualGatewayHttp2ConnectionPool.self, forKey: .http2)
        if let http2 = http2Decoded {
            self = .http2(http2)
            return
        }
        let grpcDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualGatewayGrpcConnectionPool.self, forKey: .grpc)
        if let grpc = grpcDecoded {
            self = .grpc(grpc)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents the type of virtual gateway connection pool. Only one protocol is used at a time and should be the same protocol as the one chosen under port mapping. If not present the default value for maxPendingRequests is 2147483647.
    public enum VirtualGatewayConnectionPool: Swift.Equatable {
        /// An object that represents a type of connection pool.
        case http(AppMeshClientTypes.VirtualGatewayHttpConnectionPool)
        /// An object that represents a type of connection pool.
        case http2(AppMeshClientTypes.VirtualGatewayHttp2ConnectionPool)
        /// An object that represents a type of connection pool.
        case grpc(AppMeshClientTypes.VirtualGatewayGrpcConnectionPool)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.VirtualGatewayData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meshName
        case metadata
        case spec
        case status
        case virtualGatewayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let virtualGatewayName = self.virtualGatewayName {
            try encodeContainer.encode(virtualGatewayName, forKey: .virtualGatewayName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualGatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayName)
        virtualGatewayName = virtualGatewayNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewaySpec.self, forKey: .spec)
        spec = specDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ResourceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual gateway returned by a describe operation.
    public struct VirtualGatewayData: Swift.Equatable {
        /// The name of the service mesh that the virtual gateway resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// An object that represents metadata for a resource.
        /// This member is required.
        public var metadata: AppMeshClientTypes.ResourceMetadata?
        /// The specifications of the virtual gateway.
        /// This member is required.
        public var spec: AppMeshClientTypes.VirtualGatewaySpec?
        /// The current status of the virtual gateway.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualGatewayStatus?
        /// The name of the virtual gateway.
        /// This member is required.
        public var virtualGatewayName: Swift.String?

        public init (
            meshName: Swift.String? = nil,
            metadata: AppMeshClientTypes.ResourceMetadata? = nil,
            spec: AppMeshClientTypes.VirtualGatewaySpec? = nil,
            status: AppMeshClientTypes.VirtualGatewayStatus? = nil,
            virtualGatewayName: Swift.String? = nil
        )
        {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualGatewayName = virtualGatewayName
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayFileAccessLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.LoggingFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents an access log file.
    public struct VirtualGatewayFileAccessLog: Swift.Equatable {
        /// The specified format for the virtual gateway access logs. It can be either json_format or text_format.
        public var format: AppMeshClientTypes.LoggingFormat?
        /// The file path to write access logs to. You can use /dev/stdout to send access logs to standard out and configure your Envoy container to use a log driver, such as awslogs, to export the access logs to a log storage service such as Amazon CloudWatch Logs. You can also specify a path in the Envoy container's file system to write the files to disk.
        /// This member is required.
        public var path: Swift.String?

        public init (
            format: AppMeshClientTypes.LoggingFormat? = nil,
            path: Swift.String? = nil
        )
        {
            self.format = format
            self.path = path
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayGrpcConnectionPool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxRequests != 0 {
            try encodeContainer.encode(maxRequests, forKey: .maxRequests)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRequestsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRequests) ?? 0
        maxRequests = maxRequestsDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a type of connection pool.
    public struct VirtualGatewayGrpcConnectionPool: Swift.Equatable {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        /// This member is required.
        public var maxRequests: Swift.Int

        public init (
            maxRequests: Swift.Int = 0
        )
        {
            self.maxRequests = maxRequests
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayHealthCheckPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthyThreshold
        case intervalMillis
        case path
        case port
        case `protocol` = "protocol"
        case timeoutMillis
        case unhealthyThreshold
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if healthyThreshold != 0 {
            try encodeContainer.encode(healthyThreshold, forKey: .healthyThreshold)
        }
        if let intervalMillis = self.intervalMillis {
            try encodeContainer.encode(intervalMillis, forKey: .intervalMillis)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let timeoutMillis = self.timeoutMillis {
            try encodeContainer.encode(timeoutMillis, forKey: .timeoutMillis)
        }
        if unhealthyThreshold != 0 {
            try encodeContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutMillis)
        timeoutMillis = timeoutMillisDecoded
        let intervalMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .intervalMillis)
        intervalMillis = intervalMillisDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayPortProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let healthyThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyThreshold) ?? 0
        healthyThreshold = healthyThresholdDecoded
        let unhealthyThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyThreshold) ?? 0
        unhealthyThreshold = unhealthyThresholdDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the health check policy for a virtual gateway's listener.
    public struct VirtualGatewayHealthCheckPolicy: Swift.Equatable {
        /// The number of consecutive successful health checks that must occur before declaring the listener healthy.
        /// This member is required.
        public var healthyThreshold: Swift.Int
        /// The time period in milliseconds between each health check execution.
        /// This member is required.
        public var intervalMillis: Swift.Int?
        /// The destination path for the health check request. This value is only used if the specified protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.
        public var path: Swift.String?
        /// The destination port for the health check request. This port must match the port defined in the [PortMapping] for the listener.
        public var port: Swift.Int
        /// The protocol for the health check request. If you specify grpc, then your service must conform to the [GRPC Health Checking Protocol](https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
        /// This member is required.
        public var `protocol`: AppMeshClientTypes.VirtualGatewayPortProtocol?
        /// The amount of time to wait when receiving a response from the health check, in milliseconds.
        /// This member is required.
        public var timeoutMillis: Swift.Int?
        /// The number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
        /// This member is required.
        public var unhealthyThreshold: Swift.Int

        public init (
            healthyThreshold: Swift.Int = 0,
            intervalMillis: Swift.Int? = nil,
            path: Swift.String? = nil,
            port: Swift.Int = 0,
            `protocol`: AppMeshClientTypes.VirtualGatewayPortProtocol? = nil,
            timeoutMillis: Swift.Int? = nil,
            unhealthyThreshold: Swift.Int = 0
        )
        {
            self.healthyThreshold = healthyThreshold
            self.intervalMillis = intervalMillis
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.timeoutMillis = timeoutMillis
            self.unhealthyThreshold = unhealthyThreshold
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayHttp2ConnectionPool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxRequests != 0 {
            try encodeContainer.encode(maxRequests, forKey: .maxRequests)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRequestsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRequests) ?? 0
        maxRequests = maxRequestsDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a type of connection pool.
    public struct VirtualGatewayHttp2ConnectionPool: Swift.Equatable {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        /// This member is required.
        public var maxRequests: Swift.Int

        public init (
            maxRequests: Swift.Int = 0
        )
        {
            self.maxRequests = maxRequests
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayHttpConnectionPool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxConnections
        case maxPendingRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxConnections != 0 {
            try encodeContainer.encode(maxConnections, forKey: .maxConnections)
        }
        if let maxPendingRequests = self.maxPendingRequests {
            try encodeContainer.encode(maxPendingRequests, forKey: .maxPendingRequests)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxConnectionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConnections) ?? 0
        maxConnections = maxConnectionsDecoded
        let maxPendingRequestsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxPendingRequests)
        maxPendingRequests = maxPendingRequestsDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a type of connection pool.
    public struct VirtualGatewayHttpConnectionPool: Swift.Equatable {
        /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.
        /// This member is required.
        public var maxConnections: Swift.Int
        /// Number of overflowing requests after max_connections Envoy will queue to upstream cluster.
        public var maxPendingRequests: Swift.Int?

        public init (
            maxConnections: Swift.Int = 0,
            maxPendingRequests: Swift.Int? = nil
        )
        {
            self.maxConnections = maxConnections
            self.maxPendingRequests = maxPendingRequests
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayListener: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionPool
        case healthCheck
        case portMapping
        case tls
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionPool = self.connectionPool {
            try encodeContainer.encode(connectionPool, forKey: .connectionPool)
        }
        if let healthCheck = self.healthCheck {
            try encodeContainer.encode(healthCheck, forKey: .healthCheck)
        }
        if let portMapping = self.portMapping {
            try encodeContainer.encode(portMapping, forKey: .portMapping)
        }
        if let tls = self.tls {
            try encodeContainer.encode(tls, forKey: .tls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let healthCheckDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayHealthCheckPolicy.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
        let portMappingDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayPortMapping.self, forKey: .portMapping)
        portMapping = portMappingDecoded
        let tlsDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayListenerTls.self, forKey: .tls)
        tls = tlsDecoded
        let connectionPoolDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayConnectionPool.self, forKey: .connectionPool)
        connectionPool = connectionPoolDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a listener for a virtual gateway.
    public struct VirtualGatewayListener: Swift.Equatable {
        /// The connection pool information for the virtual gateway listener.
        public var connectionPool: AppMeshClientTypes.VirtualGatewayConnectionPool?
        /// The health check information for the listener.
        public var healthCheck: AppMeshClientTypes.VirtualGatewayHealthCheckPolicy?
        /// The port mapping information for the listener.
        /// This member is required.
        public var portMapping: AppMeshClientTypes.VirtualGatewayPortMapping?
        /// A reference to an object that represents the Transport Layer Security (TLS) properties for the listener.
        public var tls: AppMeshClientTypes.VirtualGatewayListenerTls?

        public init (
            connectionPool: AppMeshClientTypes.VirtualGatewayConnectionPool? = nil,
            healthCheck: AppMeshClientTypes.VirtualGatewayHealthCheckPolicy? = nil,
            portMapping: AppMeshClientTypes.VirtualGatewayPortMapping? = nil,
            tls: AppMeshClientTypes.VirtualGatewayListenerTls? = nil
        )
        {
            self.connectionPool = connectionPool
            self.healthCheck = healthCheck
            self.portMapping = portMapping
            self.tls = tls
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayListenerTls: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate
        case mode
        case validation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let validation = self.validation {
            try encodeContainer.encode(validation, forKey: .validation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayListenerTlsMode.self, forKey: .mode)
        mode = modeDecoded
        let validationDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayListenerTlsValidationContext.self, forKey: .validation)
        validation = validationDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayListenerTlsCertificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the Transport Layer Security (TLS) properties for a listener.
    public struct VirtualGatewayListenerTls: Swift.Equatable {
        /// An object that represents a Transport Layer Security (TLS) certificate.
        /// This member is required.
        public var certificate: AppMeshClientTypes.VirtualGatewayListenerTlsCertificate?
        /// Specify one of the following modes.
        ///
        /// * STRICT – Listener only accepts connections with TLS enabled.
        ///
        /// * PERMISSIVE – Listener accepts connections with or without TLS enabled.
        ///
        /// * DISABLED – Listener only accepts connections without TLS.
        /// This member is required.
        public var mode: AppMeshClientTypes.VirtualGatewayListenerTlsMode?
        /// A reference to an object that represents a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        public var validation: AppMeshClientTypes.VirtualGatewayListenerTlsValidationContext?

        public init (
            certificate: AppMeshClientTypes.VirtualGatewayListenerTlsCertificate? = nil,
            mode: AppMeshClientTypes.VirtualGatewayListenerTlsMode? = nil,
            validation: AppMeshClientTypes.VirtualGatewayListenerTlsValidationContext? = nil
        )
        {
            self.certificate = certificate
            self.mode = mode
            self.validation = validation
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayListenerTlsAcmCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents an Certificate Manager certificate.
    public struct VirtualGatewayListenerTlsAcmCertificate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see [Transport Layer Security (TLS)](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites).
        /// This member is required.
        public var certificateArn: Swift.String?

        public init (
            certificateArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayListenerTlsCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acm
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .acm(acm):
                try container.encode(acm, forKey: .acm)
            case let .file(file):
                try container.encode(file, forKey: .file)
            case let .sds(sds):
                try container.encode(sds, forKey: .sds)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let acmDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualGatewayListenerTlsAcmCertificate.self, forKey: .acm)
        if let acm = acmDecoded {
            self = .acm(acm)
            return
        }
        let fileDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents a listener's Transport Layer Security (TLS) certificate.
    public enum VirtualGatewayListenerTlsCertificate: Swift.Equatable {
        /// A reference to an object that represents an Certificate Manager certificate.
        case acm(AppMeshClientTypes.VirtualGatewayListenerTlsAcmCertificate)
        /// A reference to an object that represents a local file certificate.
        case file(AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate)
        /// A reference to an object that represents a virtual gateway's listener's Secret Discovery Service certificate.
        case sds(AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.VirtualGatewayListenerTlsFileCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateChain
        case privateKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateChain = self.certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
        if let privateKey = self.privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see [Transport Layer Security (TLS)](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites).
    public struct VirtualGatewayListenerTlsFileCertificate: Swift.Equatable {
        /// The certificate chain for the certificate.
        /// This member is required.
        public var certificateChain: Swift.String?
        /// The private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
        /// This member is required.
        public var privateKey: Swift.String?

        public init (
            certificateChain: Swift.String? = nil,
            privateKey: Swift.String? = nil
        )
        {
            self.certificateChain = certificateChain
            self.privateKey = privateKey
        }
    }

}

extension AppMeshClientTypes {
    public enum VirtualGatewayListenerTlsMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case permissive
        case strict
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualGatewayListenerTlsMode] {
            return [
                .disabled,
                .permissive,
                .strict,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .permissive: return "PERMISSIVE"
            case .strict: return "STRICT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VirtualGatewayListenerTlsMode(rawValue: rawValue) ?? VirtualGatewayListenerTlsMode.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.VirtualGatewayListenerTlsSdsCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretName = self.secretName {
            try encodeContainer.encode(secretName, forKey: .secretName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretName)
        secretName = secretNameDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the virtual gateway's listener's Secret Discovery Service certificate.The proxy must be configured with a local SDS provider via a Unix Domain Socket. See App Mesh[TLS documentation](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html) for more info.
    public struct VirtualGatewayListenerTlsSdsCertificate: Swift.Equatable {
        /// A reference to an object that represents the name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
        /// This member is required.
        public var secretName: Swift.String?

        public init (
            secretName: Swift.String? = nil
        )
        {
            self.secretName = secretName
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayListenerTlsValidationContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subjectAlternativeNames
        case trust
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subjectAlternativeNames = self.subjectAlternativeNames {
            try encodeContainer.encode(subjectAlternativeNames, forKey: .subjectAlternativeNames)
        }
        if let trust = self.trust {
            try encodeContainer.encode(trust, forKey: .trust)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayListenerTlsValidationContextTrust.self, forKey: .trust)
        trust = trustDecoded
        let subjectAlternativeNamesDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.SubjectAlternativeNames.self, forKey: .subjectAlternativeNames)
        subjectAlternativeNames = subjectAlternativeNamesDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual gateway's listener's Transport Layer Security (TLS) validation context.
    public struct VirtualGatewayListenerTlsValidationContext: Swift.Equatable {
        /// A reference to an object that represents the SANs for a virtual gateway listener's Transport Layer Security (TLS) validation context.
        public var subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS) certificate.
        /// This member is required.
        public var trust: AppMeshClientTypes.VirtualGatewayListenerTlsValidationContextTrust?

        public init (
            subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames? = nil,
            trust: AppMeshClientTypes.VirtualGatewayListenerTlsValidationContextTrust? = nil
        )
        {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayListenerTlsValidationContextTrust: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .file(file):
                try container.encode(file, forKey: .file)
            case let .sds(sds):
                try container.encode(sds, forKey: .sds)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual gateway's listener's Transport Layer Security (TLS) validation context trust.
    public enum VirtualGatewayListenerTlsValidationContextTrust: Swift.Equatable {
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        case file(AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust)
        /// A reference to an object that represents a virtual gateway's listener's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        case sds(AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.VirtualGatewayLogging: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLog
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLog = self.accessLog {
            try encodeContainer.encode(accessLog, forKey: .accessLog)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayAccessLog.self, forKey: .accessLog)
        accessLog = accessLogDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents logging information.
    public struct VirtualGatewayLogging: Swift.Equatable {
        /// The access log configuration.
        public var accessLog: AppMeshClientTypes.VirtualGatewayAccessLog?

        public init (
            accessLog: AppMeshClientTypes.VirtualGatewayAccessLog? = nil
        )
        {
            self.accessLog = accessLog
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayPortMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port
        case `protocol` = "protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayPortProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a port mapping.
    public struct VirtualGatewayPortMapping: Swift.Equatable {
        /// The port used for the port mapping. Specify one protocol.
        /// This member is required.
        public var port: Swift.Int
        /// The protocol used for the port mapping.
        /// This member is required.
        public var `protocol`: AppMeshClientTypes.VirtualGatewayPortProtocol?

        public init (
            port: Swift.Int = 0,
            `protocol`: AppMeshClientTypes.VirtualGatewayPortProtocol? = nil
        )
        {
            self.port = port
            self.`protocol` = `protocol`
        }
    }

}

extension AppMeshClientTypes {
    public enum VirtualGatewayPortProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case grpc
        case http
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualGatewayPortProtocol] {
            return [
                .grpc,
                .http,
                .http2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .grpc: return "grpc"
            case .http: return "http"
            case .http2: return "http2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VirtualGatewayPortProtocol(rawValue: rawValue) ?? VirtualGatewayPortProtocol.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.VirtualGatewayRef: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case meshName
        case meshOwner
        case resourceOwner
        case version
        case virtualGatewayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let meshOwner = self.meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let virtualGatewayName = self.virtualGatewayName {
            try encodeContainer.encode(virtualGatewayName, forKey: .virtualGatewayName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualGatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayName)
        virtualGatewayName = virtualGatewayNameDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual gateway returned by a list operation.
    public struct VirtualGatewayRef: Swift.Equatable {
        /// The full Amazon Resource Name (ARN) for the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the service mesh that the resource resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?
        /// The name of the resource.
        /// This member is required.
        public var virtualGatewayName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            meshName: Swift.String? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            version: Swift.Int? = nil,
            virtualGatewayName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualGatewayName = virtualGatewayName
        }
    }

}

extension AppMeshClientTypes.VirtualGatewaySpec: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendDefaults
        case listeners
        case logging
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendDefaults = self.backendDefaults {
            try encodeContainer.encode(backendDefaults, forKey: .backendDefaults)
        }
        if let listeners = listeners {
            var listenersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listeners)
            for virtualgatewaylistener0 in listeners {
                try listenersContainer.encode(virtualgatewaylistener0)
            }
        }
        if let logging = self.logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendDefaultsDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayBackendDefaults.self, forKey: .backendDefaults)
        backendDefaults = backendDefaultsDecoded
        let listenersContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.VirtualGatewayListener?].self, forKey: .listeners)
        var listenersDecoded0:[AppMeshClientTypes.VirtualGatewayListener]? = nil
        if let listenersContainer = listenersContainer {
            listenersDecoded0 = [AppMeshClientTypes.VirtualGatewayListener]()
            for structure0 in listenersContainer {
                if let structure0 = structure0 {
                    listenersDecoded0?.append(structure0)
                }
            }
        }
        listeners = listenersDecoded0
        let loggingDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayLogging.self, forKey: .logging)
        logging = loggingDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the specification of a service mesh resource.
    public struct VirtualGatewaySpec: Swift.Equatable {
        /// A reference to an object that represents the defaults for backends.
        public var backendDefaults: AppMeshClientTypes.VirtualGatewayBackendDefaults?
        /// The listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
        /// This member is required.
        public var listeners: [AppMeshClientTypes.VirtualGatewayListener]?
        /// An object that represents logging information.
        public var logging: AppMeshClientTypes.VirtualGatewayLogging?

        public init (
            backendDefaults: AppMeshClientTypes.VirtualGatewayBackendDefaults? = nil,
            listeners: [AppMeshClientTypes.VirtualGatewayListener]? = nil,
            logging: AppMeshClientTypes.VirtualGatewayLogging? = nil
        )
        {
            self.backendDefaults = backendDefaults
            self.listeners = listeners
            self.logging = logging
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayStatusCode.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the status of the mesh resource.
    public struct VirtualGatewayStatus: Swift.Equatable {
        /// The current status.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualGatewayStatusCode?

        public init (
            status: AppMeshClientTypes.VirtualGatewayStatusCode? = nil
        )
        {
            self.status = status
        }
    }

}

extension AppMeshClientTypes {
    public enum VirtualGatewayStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualGatewayStatusCode] {
            return [
                .active,
                .deleted,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VirtualGatewayStatusCode(rawValue: rawValue) ?? VirtualGatewayStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.VirtualGatewayTlsValidationContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subjectAlternativeNames
        case trust
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subjectAlternativeNames = self.subjectAlternativeNames {
            try encodeContainer.encode(subjectAlternativeNames, forKey: .subjectAlternativeNames)
        }
        if let trust = self.trust {
            try encodeContainer.encode(trust, forKey: .trust)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualGatewayTlsValidationContextTrust.self, forKey: .trust)
        trust = trustDecoded
        let subjectAlternativeNamesDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.SubjectAlternativeNames.self, forKey: .subjectAlternativeNames)
        subjectAlternativeNames = subjectAlternativeNamesDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) validation context.
    public struct VirtualGatewayTlsValidationContext: Swift.Equatable {
        /// A reference to an object that represents the SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        public var subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS) certificate.
        /// This member is required.
        public var trust: AppMeshClientTypes.VirtualGatewayTlsValidationContextTrust?

        public init (
            subjectAlternativeNames: AppMeshClientTypes.SubjectAlternativeNames? = nil,
            trust: AppMeshClientTypes.VirtualGatewayTlsValidationContextTrust? = nil
        )
        {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayTlsValidationContextAcmTrust: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArns = certificateAuthorityArns {
            var certificateAuthorityArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateAuthorityArns)
            for arn0 in certificateAuthorityArns {
                try certificateAuthorityArnsContainer.encode(arn0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .certificateAuthorityArns)
        var certificateAuthorityArnsDecoded0:[Swift.String]? = nil
        if let certificateAuthorityArnsContainer = certificateAuthorityArnsContainer {
            certificateAuthorityArnsDecoded0 = [Swift.String]()
            for string0 in certificateAuthorityArnsContainer {
                if let string0 = string0 {
                    certificateAuthorityArnsDecoded0?.append(string0)
                }
            }
        }
        certificateAuthorityArns = certificateAuthorityArnsDecoded0
    }
}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) validation context trust for an Certificate Manager certificate.
    public struct VirtualGatewayTlsValidationContextAcmTrust: Swift.Equatable {
        /// One or more ACM Amazon Resource Name (ARN)s.
        /// This member is required.
        public var certificateAuthorityArns: [Swift.String]?

        public init (
            certificateAuthorityArns: [Swift.String]? = nil
        )
        {
            self.certificateAuthorityArns = certificateAuthorityArns
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateChain
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateChain = self.certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
    public struct VirtualGatewayTlsValidationContextFileTrust: Swift.Equatable {
        /// The certificate trust chain for a certificate stored on the file system of the virtual node that the proxy is running on.
        /// This member is required.
        public var certificateChain: Swift.String?

        public init (
            certificateChain: Swift.String? = nil
        )
        {
            self.certificateChain = certificateChain
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretName = self.secretName {
            try encodeContainer.encode(secretName, forKey: .secretName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretName)
        secretName = secretNameDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual gateway's listener's Transport Layer Security (TLS) Secret Discovery Service validation context trust. The proxy must be configured with a local SDS provider via a Unix Domain Socket. See App Mesh [TLS documentation](https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html) for more info.
    public struct VirtualGatewayTlsValidationContextSdsTrust: Swift.Equatable {
        /// A reference to an object that represents the name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        /// This member is required.
        public var secretName: Swift.String?

        public init (
            secretName: Swift.String? = nil
        )
        {
            self.secretName = secretName
        }
    }

}

extension AppMeshClientTypes.VirtualGatewayTlsValidationContextTrust: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acm
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .acm(acm):
                try container.encode(acm, forKey: .acm)
            case let .file(file):
                try container.encode(file, forKey: .file)
            case let .sds(sds):
                try container.encode(sds, forKey: .sds)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let acmDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualGatewayTlsValidationContextAcmTrust.self, forKey: .acm)
        if let acm = acmDecoded {
            self = .acm(acm)
            return
        }
        let fileDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents a Transport Layer Security (TLS) validation context trust.
    public enum VirtualGatewayTlsValidationContextTrust: Swift.Equatable {
        /// A reference to an object that represents a Transport Layer Security (TLS) validation context trust for an Certificate Manager certificate.
        case acm(AppMeshClientTypes.VirtualGatewayTlsValidationContextAcmTrust)
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        case file(AppMeshClientTypes.VirtualGatewayTlsValidationContextFileTrust)
        /// A reference to an object that represents a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        case sds(AppMeshClientTypes.VirtualGatewayTlsValidationContextSdsTrust)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.VirtualNodeConnectionPool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grpc
        case http
        case http2
        case sdkUnknown
        case tcp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .grpc(grpc):
                try container.encode(grpc, forKey: .grpc)
            case let .http(http):
                try container.encode(http, forKey: .http)
            case let .http2(http2):
                try container.encode(http2, forKey: .http2)
            case let .tcp(tcp):
                try container.encode(tcp, forKey: .tcp)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tcpDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualNodeTcpConnectionPool.self, forKey: .tcp)
        if let tcp = tcpDecoded {
            self = .tcp(tcp)
            return
        }
        let httpDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualNodeHttpConnectionPool.self, forKey: .http)
        if let http = httpDecoded {
            self = .http(http)
            return
        }
        let http2Decoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualNodeHttp2ConnectionPool.self, forKey: .http2)
        if let http2 = http2Decoded {
            self = .http2(http2)
            return
        }
        let grpcDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualNodeGrpcConnectionPool.self, forKey: .grpc)
        if let grpc = grpcDecoded {
            self = .grpc(grpc)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents the type of virtual node connection pool. Only one protocol is used at a time and should be the same protocol as the one chosen under port mapping. If not present the default value for maxPendingRequests is 2147483647.
    public enum VirtualNodeConnectionPool: Swift.Equatable {
        /// An object that represents a type of connection pool.
        case tcp(AppMeshClientTypes.VirtualNodeTcpConnectionPool)
        /// An object that represents a type of connection pool.
        case http(AppMeshClientTypes.VirtualNodeHttpConnectionPool)
        /// An object that represents a type of connection pool.
        case http2(AppMeshClientTypes.VirtualNodeHttp2ConnectionPool)
        /// An object that represents a type of connection pool.
        case grpc(AppMeshClientTypes.VirtualNodeGrpcConnectionPool)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.VirtualNodeData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meshName
        case metadata
        case spec
        case status
        case virtualNodeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let virtualNodeName = self.virtualNodeName {
            try encodeContainer.encode(virtualNodeName, forKey: .virtualNodeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualNodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualNodeName)
        virtualNodeName = virtualNodeNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualNodeSpec.self, forKey: .spec)
        spec = specDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ResourceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualNodeStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual node returned by a describe operation.
    public struct VirtualNodeData: Swift.Equatable {
        /// The name of the service mesh that the virtual node resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The associated metadata for the virtual node.
        /// This member is required.
        public var metadata: AppMeshClientTypes.ResourceMetadata?
        /// The specifications of the virtual node.
        /// This member is required.
        public var spec: AppMeshClientTypes.VirtualNodeSpec?
        /// The current status for the virtual node.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualNodeStatus?
        /// The name of the virtual node.
        /// This member is required.
        public var virtualNodeName: Swift.String?

        public init (
            meshName: Swift.String? = nil,
            metadata: AppMeshClientTypes.ResourceMetadata? = nil,
            spec: AppMeshClientTypes.VirtualNodeSpec? = nil,
            status: AppMeshClientTypes.VirtualNodeStatus? = nil,
            virtualNodeName: Swift.String? = nil
        )
        {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualNodeName = virtualNodeName
        }
    }

}

extension AppMeshClientTypes.VirtualNodeGrpcConnectionPool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxRequests != 0 {
            try encodeContainer.encode(maxRequests, forKey: .maxRequests)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRequestsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRequests) ?? 0
        maxRequests = maxRequestsDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a type of connection pool.
    public struct VirtualNodeGrpcConnectionPool: Swift.Equatable {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        /// This member is required.
        public var maxRequests: Swift.Int

        public init (
            maxRequests: Swift.Int = 0
        )
        {
            self.maxRequests = maxRequests
        }
    }

}

extension AppMeshClientTypes.VirtualNodeHttp2ConnectionPool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxRequests != 0 {
            try encodeContainer.encode(maxRequests, forKey: .maxRequests)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRequestsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRequests) ?? 0
        maxRequests = maxRequestsDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a type of connection pool.
    public struct VirtualNodeHttp2ConnectionPool: Swift.Equatable {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        /// This member is required.
        public var maxRequests: Swift.Int

        public init (
            maxRequests: Swift.Int = 0
        )
        {
            self.maxRequests = maxRequests
        }
    }

}

extension AppMeshClientTypes.VirtualNodeHttpConnectionPool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxConnections
        case maxPendingRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxConnections != 0 {
            try encodeContainer.encode(maxConnections, forKey: .maxConnections)
        }
        if let maxPendingRequests = self.maxPendingRequests {
            try encodeContainer.encode(maxPendingRequests, forKey: .maxPendingRequests)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxConnectionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConnections) ?? 0
        maxConnections = maxConnectionsDecoded
        let maxPendingRequestsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxPendingRequests)
        maxPendingRequests = maxPendingRequestsDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a type of connection pool.
    public struct VirtualNodeHttpConnectionPool: Swift.Equatable {
        /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.
        /// This member is required.
        public var maxConnections: Swift.Int
        /// Number of overflowing requests after max_connections Envoy will queue to upstream cluster.
        public var maxPendingRequests: Swift.Int?

        public init (
            maxConnections: Swift.Int = 0,
            maxPendingRequests: Swift.Int? = nil
        )
        {
            self.maxConnections = maxConnections
            self.maxPendingRequests = maxPendingRequests
        }
    }

}

extension AppMeshClientTypes.VirtualNodeRef: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case meshName
        case meshOwner
        case resourceOwner
        case version
        case virtualNodeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let meshOwner = self.meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let virtualNodeName = self.virtualNodeName {
            try encodeContainer.encode(virtualNodeName, forKey: .virtualNodeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualNodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualNodeName)
        virtualNodeName = virtualNodeNameDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual node returned by a list operation.
    public struct VirtualNodeRef: Swift.Equatable {
        /// The full Amazon Resource Name (ARN) for the virtual node.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the service mesh that the virtual node resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?
        /// The name of the virtual node.
        /// This member is required.
        public var virtualNodeName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            meshName: Swift.String? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            version: Swift.Int? = nil,
            virtualNodeName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualNodeName = virtualNodeName
        }
    }

}

extension AppMeshClientTypes.VirtualNodeServiceProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualNodeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualNodeName = self.virtualNodeName {
            try encodeContainer.encode(virtualNodeName, forKey: .virtualNodeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualNodeName)
        virtualNodeName = virtualNodeNameDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual node service provider.
    public struct VirtualNodeServiceProvider: Swift.Equatable {
        /// The name of the virtual node that is acting as a service provider.
        /// This member is required.
        public var virtualNodeName: Swift.String?

        public init (
            virtualNodeName: Swift.String? = nil
        )
        {
            self.virtualNodeName = virtualNodeName
        }
    }

}

extension AppMeshClientTypes.VirtualNodeSpec: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendDefaults
        case backends
        case listeners
        case logging
        case serviceDiscovery
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendDefaults = self.backendDefaults {
            try encodeContainer.encode(backendDefaults, forKey: .backendDefaults)
        }
        if let backends = backends {
            var backendsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .backends)
            for backend0 in backends {
                try backendsContainer.encode(backend0)
            }
        }
        if let listeners = listeners {
            var listenersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listeners)
            for listener0 in listeners {
                try listenersContainer.encode(listener0)
            }
        }
        if let logging = self.logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let serviceDiscovery = self.serviceDiscovery {
            try encodeContainer.encode(serviceDiscovery, forKey: .serviceDiscovery)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDiscoveryDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ServiceDiscovery.self, forKey: .serviceDiscovery)
        serviceDiscovery = serviceDiscoveryDecoded
        let listenersContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.Listener?].self, forKey: .listeners)
        var listenersDecoded0:[AppMeshClientTypes.Listener]? = nil
        if let listenersContainer = listenersContainer {
            listenersDecoded0 = [AppMeshClientTypes.Listener]()
            for structure0 in listenersContainer {
                if let structure0 = structure0 {
                    listenersDecoded0?.append(structure0)
                }
            }
        }
        listeners = listenersDecoded0
        let backendsContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.Backend?].self, forKey: .backends)
        var backendsDecoded0:[AppMeshClientTypes.Backend]? = nil
        if let backendsContainer = backendsContainer {
            backendsDecoded0 = [AppMeshClientTypes.Backend]()
            for union0 in backendsContainer {
                if let union0 = union0 {
                    backendsDecoded0?.append(union0)
                }
            }
        }
        backends = backendsDecoded0
        let backendDefaultsDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.BackendDefaults.self, forKey: .backendDefaults)
        backendDefaults = backendDefaultsDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the specification of a virtual node.
    public struct VirtualNodeSpec: Swift.Equatable {
        /// A reference to an object that represents the defaults for backends.
        public var backendDefaults: AppMeshClientTypes.BackendDefaults?
        /// The backends that the virtual node is expected to send outbound traffic to.
        public var backends: [AppMeshClientTypes.Backend]?
        /// The listener that the virtual node is expected to receive inbound traffic from. You can specify one listener.
        public var listeners: [AppMeshClientTypes.Listener]?
        /// The inbound and outbound access logging information for the virtual node.
        public var logging: AppMeshClientTypes.Logging?
        /// The service discovery information for the virtual node. If your virtual node does not expect ingress traffic, you can omit this parameter. If you specify a listener, then you must specify service discovery information.
        public var serviceDiscovery: AppMeshClientTypes.ServiceDiscovery?

        public init (
            backendDefaults: AppMeshClientTypes.BackendDefaults? = nil,
            backends: [AppMeshClientTypes.Backend]? = nil,
            listeners: [AppMeshClientTypes.Listener]? = nil,
            logging: AppMeshClientTypes.Logging? = nil,
            serviceDiscovery: AppMeshClientTypes.ServiceDiscovery? = nil
        )
        {
            self.backendDefaults = backendDefaults
            self.backends = backends
            self.listeners = listeners
            self.logging = logging
            self.serviceDiscovery = serviceDiscovery
        }
    }

}

extension AppMeshClientTypes.VirtualNodeStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualNodeStatusCode.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the current status of the virtual node.
    public struct VirtualNodeStatus: Swift.Equatable {
        /// The current status of the virtual node.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualNodeStatusCode?

        public init (
            status: AppMeshClientTypes.VirtualNodeStatusCode? = nil
        )
        {
            self.status = status
        }
    }

}

extension AppMeshClientTypes {
    public enum VirtualNodeStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualNodeStatusCode] {
            return [
                .active,
                .deleted,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VirtualNodeStatusCode(rawValue: rawValue) ?? VirtualNodeStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.VirtualNodeTcpConnectionPool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxConnections
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxConnections != 0 {
            try encodeContainer.encode(maxConnections, forKey: .maxConnections)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxConnectionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConnections) ?? 0
        maxConnections = maxConnectionsDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a type of connection pool.
    public struct VirtualNodeTcpConnectionPool: Swift.Equatable {
        /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.
        /// This member is required.
        public var maxConnections: Swift.Int

        public init (
            maxConnections: Swift.Int = 0
        )
        {
            self.maxConnections = maxConnections
        }
    }

}

extension AppMeshClientTypes.VirtualRouterData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meshName
        case metadata
        case spec
        case status
        case virtualRouterName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let virtualRouterName = self.virtualRouterName {
            try encodeContainer.encode(virtualRouterName, forKey: .virtualRouterName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualRouterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualRouterName)
        virtualRouterName = virtualRouterNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualRouterSpec.self, forKey: .spec)
        spec = specDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ResourceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualRouterStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual router returned by a describe operation.
    public struct VirtualRouterData: Swift.Equatable {
        /// The name of the service mesh that the virtual router resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The associated metadata for the virtual router.
        /// This member is required.
        public var metadata: AppMeshClientTypes.ResourceMetadata?
        /// The specifications of the virtual router.
        /// This member is required.
        public var spec: AppMeshClientTypes.VirtualRouterSpec?
        /// The current status of the virtual router.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualRouterStatus?
        /// The name of the virtual router.
        /// This member is required.
        public var virtualRouterName: Swift.String?

        public init (
            meshName: Swift.String? = nil,
            metadata: AppMeshClientTypes.ResourceMetadata? = nil,
            spec: AppMeshClientTypes.VirtualRouterSpec? = nil,
            status: AppMeshClientTypes.VirtualRouterStatus? = nil,
            virtualRouterName: Swift.String? = nil
        )
        {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualRouterName = virtualRouterName
        }
    }

}

extension AppMeshClientTypes.VirtualRouterListener: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portMapping
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let portMapping = self.portMapping {
            try encodeContainer.encode(portMapping, forKey: .portMapping)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portMappingDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.PortMapping.self, forKey: .portMapping)
        portMapping = portMappingDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual router listener.
    public struct VirtualRouterListener: Swift.Equatable {
        /// An object that represents a port mapping.
        /// This member is required.
        public var portMapping: AppMeshClientTypes.PortMapping?

        public init (
            portMapping: AppMeshClientTypes.PortMapping? = nil
        )
        {
            self.portMapping = portMapping
        }
    }

}

extension AppMeshClientTypes.VirtualRouterRef: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case meshName
        case meshOwner
        case resourceOwner
        case version
        case virtualRouterName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let meshOwner = self.meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let virtualRouterName = self.virtualRouterName {
            try encodeContainer.encode(virtualRouterName, forKey: .virtualRouterName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualRouterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualRouterName)
        virtualRouterName = virtualRouterNameDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual router returned by a list operation.
    public struct VirtualRouterRef: Swift.Equatable {
        /// The full Amazon Resource Name (ARN) for the virtual router.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the service mesh that the virtual router resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?
        /// The name of the virtual router.
        /// This member is required.
        public var virtualRouterName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            meshName: Swift.String? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            version: Swift.Int? = nil,
            virtualRouterName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualRouterName = virtualRouterName
        }
    }

}

extension AppMeshClientTypes.VirtualRouterServiceProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualRouterName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualRouterName = self.virtualRouterName {
            try encodeContainer.encode(virtualRouterName, forKey: .virtualRouterName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualRouterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualRouterName)
        virtualRouterName = virtualRouterNameDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual node service provider.
    public struct VirtualRouterServiceProvider: Swift.Equatable {
        /// The name of the virtual router that is acting as a service provider.
        /// This member is required.
        public var virtualRouterName: Swift.String?

        public init (
            virtualRouterName: Swift.String? = nil
        )
        {
            self.virtualRouterName = virtualRouterName
        }
    }

}

extension AppMeshClientTypes.VirtualRouterSpec: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listeners
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listeners = listeners {
            var listenersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listeners)
            for virtualrouterlistener0 in listeners {
                try listenersContainer.encode(virtualrouterlistener0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenersContainer = try containerValues.decodeIfPresent([AppMeshClientTypes.VirtualRouterListener?].self, forKey: .listeners)
        var listenersDecoded0:[AppMeshClientTypes.VirtualRouterListener]? = nil
        if let listenersContainer = listenersContainer {
            listenersDecoded0 = [AppMeshClientTypes.VirtualRouterListener]()
            for structure0 in listenersContainer {
                if let structure0 = structure0 {
                    listenersDecoded0?.append(structure0)
                }
            }
        }
        listeners = listenersDecoded0
    }
}

extension AppMeshClientTypes {
    /// An object that represents the specification of a virtual router.
    public struct VirtualRouterSpec: Swift.Equatable {
        /// The listeners that the virtual router is expected to receive inbound traffic from. You can specify one listener.
        public var listeners: [AppMeshClientTypes.VirtualRouterListener]?

        public init (
            listeners: [AppMeshClientTypes.VirtualRouterListener]? = nil
        )
        {
            self.listeners = listeners
        }
    }

}

extension AppMeshClientTypes.VirtualRouterStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualRouterStatusCode.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the status of a virtual router.
    public struct VirtualRouterStatus: Swift.Equatable {
        /// The current status of the virtual router.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualRouterStatusCode?

        public init (
            status: AppMeshClientTypes.VirtualRouterStatusCode? = nil
        )
        {
            self.status = status
        }
    }

}

extension AppMeshClientTypes {
    public enum VirtualRouterStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualRouterStatusCode] {
            return [
                .active,
                .deleted,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VirtualRouterStatusCode(rawValue: rawValue) ?? VirtualRouterStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.VirtualServiceBackend: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientPolicy
        case virtualServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientPolicy = self.clientPolicy {
            try encodeContainer.encode(clientPolicy, forKey: .clientPolicy)
        }
        if let virtualServiceName = self.virtualServiceName {
            try encodeContainer.encode(virtualServiceName, forKey: .virtualServiceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualServiceName)
        virtualServiceName = virtualServiceNameDecoded
        let clientPolicyDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ClientPolicy.self, forKey: .clientPolicy)
        clientPolicy = clientPolicyDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual service backend for a virtual node.
    public struct VirtualServiceBackend: Swift.Equatable {
        /// A reference to an object that represents the client policy for a backend.
        public var clientPolicy: AppMeshClientTypes.ClientPolicy?
        /// The name of the virtual service that is acting as a virtual node backend.
        /// This member is required.
        public var virtualServiceName: Swift.String?

        public init (
            clientPolicy: AppMeshClientTypes.ClientPolicy? = nil,
            virtualServiceName: Swift.String? = nil
        )
        {
            self.clientPolicy = clientPolicy
            self.virtualServiceName = virtualServiceName
        }
    }

}

extension AppMeshClientTypes.VirtualServiceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meshName
        case metadata
        case spec
        case status
        case virtualServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let virtualServiceName = self.virtualServiceName {
            try encodeContainer.encode(virtualServiceName, forKey: .virtualServiceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualServiceName)
        virtualServiceName = virtualServiceNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualServiceSpec.self, forKey: .spec)
        spec = specDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.ResourceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualServiceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual service returned by a describe operation.
    public struct VirtualServiceData: Swift.Equatable {
        /// The name of the service mesh that the virtual service resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// An object that represents metadata for a resource.
        /// This member is required.
        public var metadata: AppMeshClientTypes.ResourceMetadata?
        /// The specifications of the virtual service.
        /// This member is required.
        public var spec: AppMeshClientTypes.VirtualServiceSpec?
        /// The current status of the virtual service.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualServiceStatus?
        /// The name of the virtual service.
        /// This member is required.
        public var virtualServiceName: Swift.String?

        public init (
            meshName: Swift.String? = nil,
            metadata: AppMeshClientTypes.ResourceMetadata? = nil,
            spec: AppMeshClientTypes.VirtualServiceSpec? = nil,
            status: AppMeshClientTypes.VirtualServiceStatus? = nil,
            virtualServiceName: Swift.String? = nil
        )
        {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualServiceName = virtualServiceName
        }
    }

}

extension AppMeshClientTypes.VirtualServiceProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case virtualnode = "virtualNode"
        case virtualrouter = "virtualRouter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .virtualnode(virtualnode):
                try container.encode(virtualnode, forKey: .virtualnode)
            case let .virtualrouter(virtualrouter):
                try container.encode(virtualrouter, forKey: .virtualrouter)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let virtualnodeDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualNodeServiceProvider.self, forKey: .virtualnode)
        if let virtualnode = virtualnodeDecoded {
            self = .virtualnode(virtualnode)
            return
        }
        let virtualrouterDecoded = try values.decodeIfPresent(AppMeshClientTypes.VirtualRouterServiceProvider.self, forKey: .virtualrouter)
        if let virtualrouter = virtualrouterDecoded {
            self = .virtualrouter(virtualrouter)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppMeshClientTypes {
    /// An object that represents the provider for a virtual service.
    public enum VirtualServiceProvider: Swift.Equatable {
        /// The virtual node associated with a virtual service.
        case virtualnode(AppMeshClientTypes.VirtualNodeServiceProvider)
        /// The virtual router associated with a virtual service.
        case virtualrouter(AppMeshClientTypes.VirtualRouterServiceProvider)
        case sdkUnknown(Swift.String)
    }

}

extension AppMeshClientTypes.VirtualServiceRef: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case meshName
        case meshOwner
        case resourceOwner
        case version
        case virtualServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let meshName = self.meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let meshOwner = self.meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let virtualServiceName = self.virtualServiceName {
            try encodeContainer.encode(virtualServiceName, forKey: .virtualServiceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualServiceName)
        virtualServiceName = virtualServiceNameDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a virtual service returned by a list operation.
    public struct VirtualServiceRef: Swift.Equatable {
        /// The full Amazon Resource Name (ARN) for the virtual service.
        /// This member is required.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the service mesh that the virtual service resides in.
        /// This member is required.
        public var meshName: Swift.String?
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var meshOwner: Swift.String?
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see [Working with shared meshes](https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html).
        /// This member is required.
        public var resourceOwner: Swift.String?
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        /// This member is required.
        public var version: Swift.Int?
        /// The name of the virtual service.
        /// This member is required.
        public var virtualServiceName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            meshName: Swift.String? = nil,
            meshOwner: Swift.String? = nil,
            resourceOwner: Swift.String? = nil,
            version: Swift.Int? = nil,
            virtualServiceName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualServiceName = virtualServiceName
        }
    }

}

extension AppMeshClientTypes.VirtualServiceSpec: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let provider = self.provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualServiceProvider.self, forKey: .provider)
        provider = providerDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the specification of a virtual service.
    public struct VirtualServiceSpec: Swift.Equatable {
        /// The App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
        public var provider: AppMeshClientTypes.VirtualServiceProvider?

        public init (
            provider: AppMeshClientTypes.VirtualServiceProvider? = nil
        )
        {
            self.provider = provider
        }
    }

}

extension AppMeshClientTypes.VirtualServiceStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppMeshClientTypes.VirtualServiceStatusCode.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents the status of a virtual service.
    public struct VirtualServiceStatus: Swift.Equatable {
        /// The current status of the virtual service.
        /// This member is required.
        public var status: AppMeshClientTypes.VirtualServiceStatusCode?

        public init (
            status: AppMeshClientTypes.VirtualServiceStatusCode? = nil
        )
        {
            self.status = status
        }
    }

}

extension AppMeshClientTypes {
    public enum VirtualServiceStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualServiceStatusCode] {
            return [
                .active,
                .deleted,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VirtualServiceStatusCode(rawValue: rawValue) ?? VirtualServiceStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension AppMeshClientTypes.WeightedTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port
        case virtualNode
        case weight
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let virtualNode = self.virtualNode {
            try encodeContainer.encode(virtualNode, forKey: .virtualNode)
        }
        if weight != 0 {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualNode)
        virtualNode = virtualNodeDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight) ?? 0
        weight = weightDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension AppMeshClientTypes {
    /// An object that represents a target and its relative weight. Traffic is distributed across targets according to their relative weight. For example, a weighted target with a relative weight of 50 receives five times as much traffic as one with a relative weight of 10. The total weight for all targets combined must be less than or equal to 100.
    public struct WeightedTarget: Swift.Equatable {
        /// The targeted port of the weighted object.
        public var port: Swift.Int?
        /// The virtual node to associate with the weighted target.
        /// This member is required.
        public var virtualNode: Swift.String?
        /// The relative weight of the weighted target.
        /// This member is required.
        public var weight: Swift.Int

        public init (
            port: Swift.Int? = nil,
            virtualNode: Swift.String? = nil,
            weight: Swift.Int = 0
        )
        {
            self.port = port
            self.virtualNode = virtualNode
            self.weight = weight
        }
    }

}
