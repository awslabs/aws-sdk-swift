// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FinspaceClientTypes.AutoScalingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingMetric
        case maxNodeCount
        case metricTarget
        case minNodeCount
        case scaleInCooldownSeconds
        case scaleOutCooldownSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingMetric = self.autoScalingMetric {
            try encodeContainer.encode(autoScalingMetric.rawValue, forKey: .autoScalingMetric)
        }
        if let maxNodeCount = self.maxNodeCount {
            try encodeContainer.encode(maxNodeCount, forKey: .maxNodeCount)
        }
        if let metricTarget = self.metricTarget {
            try encodeContainer.encode(metricTarget, forKey: .metricTarget)
        }
        if let minNodeCount = self.minNodeCount {
            try encodeContainer.encode(minNodeCount, forKey: .minNodeCount)
        }
        if let scaleInCooldownSeconds = self.scaleInCooldownSeconds {
            try encodeContainer.encode(scaleInCooldownSeconds, forKey: .scaleInCooldownSeconds)
        }
        if let scaleOutCooldownSeconds = self.scaleOutCooldownSeconds {
            try encodeContainer.encode(scaleOutCooldownSeconds, forKey: .scaleOutCooldownSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minNodeCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minNodeCount)
        minNodeCount = minNodeCountDecoded
        let maxNodeCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxNodeCount)
        maxNodeCount = maxNodeCountDecoded
        let autoScalingMetricDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.AutoScalingMetric.self, forKey: .autoScalingMetric)
        autoScalingMetric = autoScalingMetricDecoded
        let metricTargetDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .metricTarget)
        metricTarget = metricTargetDecoded
        let scaleInCooldownSecondsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .scaleInCooldownSeconds)
        scaleInCooldownSeconds = scaleInCooldownSecondsDecoded
        let scaleOutCooldownSecondsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .scaleOutCooldownSeconds)
        scaleOutCooldownSeconds = scaleOutCooldownSecondsDecoded
    }
}

extension FinspaceClientTypes {
    /// The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
    public struct AutoScalingConfiguration: Swift.Equatable {
        /// The metric your cluster will track in order to scale in and out. For example, CPU_UTILIZATION_PERCENTAGE is the average CPU usage across all the nodes in a cluster.
        public var autoScalingMetric: FinspaceClientTypes.AutoScalingMetric?
        /// The highest number of nodes to scale. This value cannot be greater than 5.
        public var maxNodeCount: Swift.Int?
        /// The desired value of the chosen autoScalingMetric. When the metric drops below this value, the cluster will scale in. When the metric goes above this value, the cluster will scale out. You can set the target value between 1 and 100 percent.
        public var metricTarget: Swift.Double?
        /// The lowest number of nodes to scale. This value must be at least 1 and less than the maxNodeCount. If the nodes in a cluster belong to multiple availability zones, then minNodeCount must be at least 3.
        public var minNodeCount: Swift.Int?
        /// The duration in seconds that FinSpace will wait after a scale in event before initiating another scaling event.
        public var scaleInCooldownSeconds: Swift.Double?
        /// The duration in seconds that FinSpace will wait after a scale out event before initiating another scaling event.
        public var scaleOutCooldownSeconds: Swift.Double?

        public init(
            autoScalingMetric: FinspaceClientTypes.AutoScalingMetric? = nil,
            maxNodeCount: Swift.Int? = nil,
            metricTarget: Swift.Double? = nil,
            minNodeCount: Swift.Int? = nil,
            scaleInCooldownSeconds: Swift.Double? = nil,
            scaleOutCooldownSeconds: Swift.Double? = nil
        )
        {
            self.autoScalingMetric = autoScalingMetric
            self.maxNodeCount = maxNodeCount
            self.metricTarget = metricTarget
            self.minNodeCount = minNodeCount
            self.scaleInCooldownSeconds = scaleInCooldownSeconds
            self.scaleOutCooldownSeconds = scaleOutCooldownSeconds
        }
    }

}

extension FinspaceClientTypes {
    public enum AutoScalingMetric: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cpuUtilizationPercentage
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoScalingMetric] {
            return [
                .cpuUtilizationPercentage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cpuUtilizationPercentage: return "CPU_UTILIZATION_PERCENTAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoScalingMetric(rawValue: rawValue) ?? AutoScalingMetric.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.CapacityConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeCount
        case nodeType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeCount = self.nodeCount {
            try encodeContainer.encode(nodeCount, forKey: .nodeCount)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let nodeCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nodeCount)
        nodeCount = nodeCountDecoded
    }
}

extension FinspaceClientTypes {
    /// A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, and number of instances.
    public struct CapacityConfiguration: Swift.Equatable {
        /// The number of instances running in a cluster.
        public var nodeCount: Swift.Int?
        /// The type that determines the hardware of the host computer used for your cluster instance. Each node type offers different memory and storage capabilities. Choose a node type based on the requirements of the application or software that you plan to run on your instance. You can only specify one of the following values:
        ///
        /// * kx.s.large – The node type with a configuration of 12 GiB memory and 2 vCPUs.
        ///
        /// * kx.s.xlarge – The node type with a configuration of 27 GiB memory and 4 vCPUs.
        ///
        /// * kx.s.2xlarge – The node type with a configuration of 54 GiB memory and 8 vCPUs.
        ///
        /// * kx.s.4xlarge – The node type with a configuration of 108 GiB memory and 16 vCPUs.
        ///
        /// * kx.s.8xlarge – The node type with a configuration of 216 GiB memory and 32 vCPUs.
        ///
        /// * kx.s.16xlarge – The node type with a configuration of 432 GiB memory and 64 vCPUs.
        ///
        /// * kx.s.32xlarge – The node type with a configuration of 864 GiB memory and 128 vCPUs.
        public var nodeType: Swift.String?

        public init(
            nodeCount: Swift.Int? = nil,
            nodeType: Swift.String? = nil
        )
        {
            self.nodeCount = nodeCount
            self.nodeType = nodeType
        }
    }

}

extension FinspaceClientTypes.ChangeRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeType
        case dbPath
        case s3Path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeType = self.changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let dbPath = self.dbPath {
            try encodeContainer.encode(dbPath, forKey: .dbPath)
        }
        if let s3Path = self.s3Path {
            try encodeContainer.encode(s3Path, forKey: .s3Path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTypeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let dbPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbPath)
        dbPath = dbPathDecoded
    }
}

extension FinspaceClientTypes {
    /// A list of change request objects.
    public struct ChangeRequest: Swift.Equatable {
        /// Defines the type of change request. A changeType can have the following values:
        ///
        /// * PUT – Adds or updates files in a database.
        ///
        /// * DELETE – Deletes files in a database.
        /// This member is required.
        public var changeType: FinspaceClientTypes.ChangeType?
        /// Defines the path within the database directory.
        /// This member is required.
        public var dbPath: Swift.String?
        /// Defines the S3 path of the source file that is required to add or update files in a database.
        public var s3Path: Swift.String?

        public init(
            changeType: FinspaceClientTypes.ChangeType? = nil,
            dbPath: Swift.String? = nil,
            s3Path: Swift.String? = nil
        )
        {
            self.changeType = changeType
            self.dbPath = dbPath
            self.s3Path = s3Path
        }
    }

}

extension FinspaceClientTypes {
    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .delete,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes {
    public enum ChangesetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case pending
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangesetStatus] {
            return [
                .completed,
                .failed,
                .pending,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangesetStatus(rawValue: rawValue) ?? ChangesetStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.CodeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3Key
        case s3ObjectVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = self.s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
    }
}

extension FinspaceClientTypes {
    /// The structure of the customer code available within the running cluster.
    public struct CodeConfiguration: Swift.Equatable {
        /// A unique name for the S3 bucket.
        public var s3Bucket: Swift.String?
        /// The full S3 path (excluding bucket) to the .zip file. This file contains the code that is loaded onto the cluster when it's started.
        public var s3Key: Swift.String?
        /// The version of an S3 object.
        public var s3ObjectVersion: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3ObjectVersion: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was a conflict with this action, and it could not be completed.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the conflict exception.
        public internal(set) var reason: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CreateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataBundles
        case description
        case federationMode
        case federationParameters
        case kmsKeyId
        case name
        case superuserParameters
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataBundles = dataBundles {
            var dataBundlesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataBundles)
            for databundlearn0 in dataBundles {
                try dataBundlesContainer.encode(databundlearn0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let federationMode = self.federationMode {
            try encodeContainer.encode(federationMode.rawValue, forKey: .federationMode)
        }
        if let federationParameters = self.federationParameters {
            try encodeContainer.encode(federationParameters, forKey: .federationParameters)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let superuserParameters = self.superuserParameters {
            try encodeContainer.encode(superuserParameters, forKey: .superuserParameters)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateEnvironmentInput {

    static func urlPathProvider(_ value: CreateEnvironmentInput) -> Swift.String? {
        return "/environment"
    }
}

public struct CreateEnvironmentInput: Swift.Equatable {
    /// The list of Amazon Resource Names (ARN) of the data bundles to install. Currently supported data bundle ARNs:
    ///
    /// * arn:aws:finspace:${Region}::data-bundle/capital-markets-sample - Contains sample Capital Markets datasets, categories and controlled vocabularies.
    ///
    /// * arn:aws:finspace:${Region}::data-bundle/taq (default) - Contains trades and quotes data in addition to sample Capital Markets data.
    public var dataBundles: [Swift.String]?
    /// The description of the FinSpace environment to be created.
    public var description: Swift.String?
    /// Authentication mode for the environment.
    ///
    /// * FEDERATED - Users access FinSpace through Single Sign On (SSO) via your Identity provider.
    ///
    /// * LOCAL - Users access FinSpace via email and password managed within the FinSpace environment.
    public var federationMode: FinspaceClientTypes.FederationMode?
    /// Configuration information when authentication mode is FEDERATED.
    public var federationParameters: FinspaceClientTypes.FederationParameters?
    /// The KMS key id to encrypt your data in the FinSpace environment.
    public var kmsKeyId: Swift.String?
    /// The name of the FinSpace environment to be created.
    /// This member is required.
    public var name: Swift.String?
    /// Configuration information for the superuser.
    public var superuserParameters: FinspaceClientTypes.SuperuserParameters?
    /// Add tags to your FinSpace environment.
    public var tags: [Swift.String:Swift.String]?

    public init(
        dataBundles: [Swift.String]? = nil,
        description: Swift.String? = nil,
        federationMode: FinspaceClientTypes.FederationMode? = nil,
        federationParameters: FinspaceClientTypes.FederationParameters? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        superuserParameters: FinspaceClientTypes.SuperuserParameters? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dataBundles = dataBundles
        self.description = description
        self.federationMode = federationMode
        self.federationParameters = federationParameters
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.superuserParameters = superuserParameters
        self.tags = tags
    }
}

struct CreateEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let kmsKeyId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let federationMode: FinspaceClientTypes.FederationMode?
    let federationParameters: FinspaceClientTypes.FederationParameters?
    let superuserParameters: FinspaceClientTypes.SuperuserParameters?
    let dataBundles: [Swift.String]?
}

extension CreateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataBundles
        case description
        case federationMode
        case federationParameters
        case kmsKeyId
        case name
        case superuserParameters
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let federationModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.FederationMode.self, forKey: .federationMode)
        federationMode = federationModeDecoded
        let federationParametersDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.FederationParameters.self, forKey: .federationParameters)
        federationParameters = federationParametersDecoded
        let superuserParametersDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.SuperuserParameters.self, forKey: .superuserParameters)
        superuserParameters = superuserParametersDecoded
        let dataBundlesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataBundles)
        var dataBundlesDecoded0:[Swift.String]? = nil
        if let dataBundlesContainer = dataBundlesContainer {
            dataBundlesDecoded0 = [Swift.String]()
            for string0 in dataBundlesContainer {
                if let string0 = string0 {
                    dataBundlesDecoded0?.append(string0)
                }
            }
        }
        dataBundles = dataBundlesDecoded0
    }
}

extension CreateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentArn = output.environmentArn
            self.environmentId = output.environmentId
            self.environmentUrl = output.environmentUrl
        } else {
            self.environmentArn = nil
            self.environmentId = nil
            self.environmentUrl = nil
        }
    }
}

public struct CreateEnvironmentOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the FinSpace environment that you created.
    public var environmentArn: Swift.String?
    /// The unique identifier for FinSpace environment that you created.
    public var environmentId: Swift.String?
    /// The sign-in URL for the web application of the FinSpace environment you created.
    public var environmentUrl: Swift.String?

    public init(
        environmentArn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        environmentUrl: Swift.String? = nil
    )
    {
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.environmentUrl = environmentUrl
    }
}

struct CreateEnvironmentOutputBody: Swift.Equatable {
    let environmentId: Swift.String?
    let environmentArn: Swift.String?
    let environmentUrl: Swift.String?
}

extension CreateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentArn
        case environmentId
        case environmentUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let environmentUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentUrl)
        environmentUrl = environmentUrlDecoded
    }
}

enum CreateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateKxChangesetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeRequests
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeRequests = changeRequests {
            var changeRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .changeRequests)
            for changerequest0 in changeRequests {
                try changeRequestsContainer.encode(changerequest0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension CreateKxChangesetInput {

    static func urlPathProvider(_ value: CreateKxChangesetInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/changesets"
    }
}

public struct CreateKxChangesetInput: Swift.Equatable {
    /// A list of change request objects that are run in order. A change request object consists of changeType , s3Path, and dbPath. A changeType can has the following values:
    ///
    /// * PUT – Adds or updates files in a database.
    ///
    /// * DELETE – Deletes files in a database.
    ///
    ///
    /// All the change requests require a mandatory dbPath attribute that defines the path within the database directory. All database paths must start with a leading / and end with a trailing /. The s3Path attribute defines the s3 source file path and is required for a PUT change type. The s3path must end with a trailing / if it is a directory and must end without a trailing / if it is a file. Here are few examples of how you can use the change request object:
    ///
    /// * This request adds a single sym file at database root location. { "changeType": "PUT", "s3Path":"s3://bucket/db/sym", "dbPath":"/"}
    ///
    /// * This request adds files in the given s3Path under the 2020.01.02 partition of the database. { "changeType": "PUT", "s3Path":"s3://bucket/db/2020.01.02/", "dbPath":"/2020.01.02/"}
    ///
    /// * This request adds files in the given s3Path under the taq table partition of the database. [ { "changeType": "PUT", "s3Path":"s3://bucket/db/2020.01.02/taq/", "dbPath":"/2020.01.02/taq/"}]
    ///
    /// * This request deletes the 2020.01.02 partition of the database. [{ "changeType": "DELETE", "dbPath": "/2020.01.02/"} ]
    ///
    /// * The DELETE request allows you to delete the existing files under the 2020.01.02 partition of the database, and the PUT request adds a new taq table under it. [ {"changeType": "DELETE", "dbPath":"/2020.01.02/"}, {"changeType": "PUT", "s3Path":"s3://bucket/db/2020.01.02/taq/", "dbPath":"/2020.01.02/taq/"}]
    /// This member is required.
    public var changeRequests: [FinspaceClientTypes.ChangeRequest]?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The name of the kdb database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier of the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        changeRequests: [FinspaceClientTypes.ChangeRequest]? = nil,
        clientToken: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.changeRequests = changeRequests
        self.clientToken = clientToken
        self.databaseName = databaseName
        self.environmentId = environmentId
    }
}

struct CreateKxChangesetInputBody: Swift.Equatable {
    let changeRequests: [FinspaceClientTypes.ChangeRequest]?
    let clientToken: Swift.String?
}

extension CreateKxChangesetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeRequests
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeRequestsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.ChangeRequest?].self, forKey: .changeRequests)
        var changeRequestsDecoded0:[FinspaceClientTypes.ChangeRequest]? = nil
        if let changeRequestsContainer = changeRequestsContainer {
            changeRequestsDecoded0 = [FinspaceClientTypes.ChangeRequest]()
            for structure0 in changeRequestsContainer {
                if let structure0 = structure0 {
                    changeRequestsDecoded0?.append(structure0)
                }
            }
        }
        changeRequests = changeRequestsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateKxChangesetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateKxChangesetOutputBody = try responseDecoder.decode(responseBody: data)
            self.changeRequests = output.changeRequests
            self.changesetId = output.changesetId
            self.createdTimestamp = output.createdTimestamp
            self.databaseName = output.databaseName
            self.environmentId = output.environmentId
            self.errorInfo = output.errorInfo
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.status = output.status
        } else {
            self.changeRequests = nil
            self.changesetId = nil
            self.createdTimestamp = nil
            self.databaseName = nil
            self.environmentId = nil
            self.errorInfo = nil
            self.lastModifiedTimestamp = nil
            self.status = nil
        }
    }
}

public struct CreateKxChangesetOutput: Swift.Equatable {
    /// A list of change requests.
    public var changeRequests: [FinspaceClientTypes.ChangeRequest]?
    /// A unique identifier for the changeset.
    public var changesetId: Swift.String?
    /// The timestamp at which the changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: ClientRuntime.Date?
    /// The name of the kdb database.
    public var databaseName: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// The details of the error that you receive when creating a changeset. It consists of the type of error and the error message.
    public var errorInfo: FinspaceClientTypes.ErrorInfo?
    /// The timestamp at which the changeset was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// Status of the changeset creation process.
    ///
    /// * Pending – Changeset creation is pending.
    ///
    /// * Processing – Changeset creation is running.
    ///
    /// * Failed – Changeset creation has failed.
    ///
    /// * Complete – Changeset creation has succeeded.
    public var status: FinspaceClientTypes.ChangesetStatus?

    public init(
        changeRequests: [FinspaceClientTypes.ChangeRequest]? = nil,
        changesetId: Swift.String? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        errorInfo: FinspaceClientTypes.ErrorInfo? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        status: FinspaceClientTypes.ChangesetStatus? = nil
    )
    {
        self.changeRequests = changeRequests
        self.changesetId = changesetId
        self.createdTimestamp = createdTimestamp
        self.databaseName = databaseName
        self.environmentId = environmentId
        self.errorInfo = errorInfo
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.status = status
    }
}

struct CreateKxChangesetOutputBody: Swift.Equatable {
    let changesetId: Swift.String?
    let databaseName: Swift.String?
    let environmentId: Swift.String?
    let changeRequests: [FinspaceClientTypes.ChangeRequest]?
    let createdTimestamp: ClientRuntime.Date?
    let lastModifiedTimestamp: ClientRuntime.Date?
    let status: FinspaceClientTypes.ChangesetStatus?
    let errorInfo: FinspaceClientTypes.ErrorInfo?
}

extension CreateKxChangesetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeRequests
        case changesetId
        case createdTimestamp
        case databaseName
        case environmentId
        case errorInfo
        case lastModifiedTimestamp
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let changeRequestsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.ChangeRequest?].self, forKey: .changeRequests)
        var changeRequestsDecoded0:[FinspaceClientTypes.ChangeRequest]? = nil
        if let changeRequestsContainer = changeRequestsContainer {
            changeRequestsDecoded0 = [FinspaceClientTypes.ChangeRequest]()
            for structure0 in changeRequestsContainer {
                if let structure0 = structure0 {
                    changeRequestsDecoded0?.append(structure0)
                }
            }
        }
        changeRequests = changeRequestsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.ChangesetStatus.self, forKey: .status)
        status = statusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
    }
}

enum CreateKxChangesetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateKxClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfiguration
        case availabilityZoneId
        case azMode
        case cacheStorageConfigurations
        case capacityConfiguration
        case clientToken
        case clusterDescription
        case clusterName
        case clusterType
        case code
        case commandLineArguments
        case databases
        case executionRole
        case initializationScript
        case releaseLabel
        case savedownStorageConfiguration
        case scalingGroupConfiguration
        case tags
        case tickerplantLogConfiguration
        case vpcConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfiguration = self.autoScalingConfiguration {
            try encodeContainer.encode(autoScalingConfiguration, forKey: .autoScalingConfiguration)
        }
        if let availabilityZoneId = self.availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let azMode = self.azMode {
            try encodeContainer.encode(azMode.rawValue, forKey: .azMode)
        }
        if let cacheStorageConfigurations = cacheStorageConfigurations {
            var cacheStorageConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cacheStorageConfigurations)
            for kxcachestorageconfiguration0 in cacheStorageConfigurations {
                try cacheStorageConfigurationsContainer.encode(kxcachestorageconfiguration0)
            }
        }
        if let capacityConfiguration = self.capacityConfiguration {
            try encodeContainer.encode(capacityConfiguration, forKey: .capacityConfiguration)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let clusterDescription = self.clusterDescription {
            try encodeContainer.encode(clusterDescription, forKey: .clusterDescription)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let clusterType = self.clusterType {
            try encodeContainer.encode(clusterType.rawValue, forKey: .clusterType)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let commandLineArguments = commandLineArguments {
            var commandLineArgumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .commandLineArguments)
            for kxcommandlineargument0 in commandLineArguments {
                try commandLineArgumentsContainer.encode(kxcommandlineargument0)
            }
        }
        if let databases = databases {
            var databasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .databases)
            for kxdatabaseconfiguration0 in databases {
                try databasesContainer.encode(kxdatabaseconfiguration0)
            }
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let initializationScript = self.initializationScript {
            try encodeContainer.encode(initializationScript, forKey: .initializationScript)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let savedownStorageConfiguration = self.savedownStorageConfiguration {
            try encodeContainer.encode(savedownStorageConfiguration, forKey: .savedownStorageConfiguration)
        }
        if let scalingGroupConfiguration = self.scalingGroupConfiguration {
            try encodeContainer.encode(scalingGroupConfiguration, forKey: .scalingGroupConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tickerplantLogConfiguration = self.tickerplantLogConfiguration {
            try encodeContainer.encode(tickerplantLogConfiguration, forKey: .tickerplantLogConfiguration)
        }
        if let vpcConfiguration = self.vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }
}

extension CreateKxClusterInput {

    static func urlPathProvider(_ value: CreateKxClusterInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters"
    }
}

public struct CreateKxClusterInput: Swift.Equatable {
    /// The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
    public var autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration?
    /// The availability zone identifiers for the requested regions.
    public var availabilityZoneId: Swift.String?
    /// The number of availability zones you want to assign per cluster. This can be one of the following
    ///
    /// * SINGLE – Assigns one availability zone per cluster.
    ///
    /// * MULTI – Assigns all the availability zones per cluster.
    /// This member is required.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store.
    public var cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]?
    /// A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, and number of instances.
    public var capacityConfiguration: FinspaceClientTypes.CapacityConfiguration?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A description of the cluster.
    public var clusterDescription: Swift.String?
    /// A unique name for the cluster that you want to create.
    /// This member is required.
    public var clusterName: Swift.String?
    /// Specifies the type of KDB database that is being created. The following types are available:
    ///
    /// * HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.
    ///
    /// * RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.
    ///
    /// * GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.
    ///
    /// * GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.
    ///
    /// * Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
    /// This member is required.
    public var clusterType: FinspaceClientTypes.KxClusterType?
    /// The details of the custom code that you want to use inside a cluster when analyzing a data. It consists of the S3 source bucket, location, S3 object version, and the relative path from where the custom code is loaded into the cluster.
    public var code: FinspaceClientTypes.CodeConfiguration?
    /// Defines the key-value pairs to make them available inside the cluster.
    public var commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]?
    /// A list of databases that will be available for querying.
    public var databases: [FinspaceClientTypes.KxDatabaseConfiguration]?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
    public var executionRole: Swift.String?
    /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
    public var initializationScript: Swift.String?
    /// The version of FinSpace managed kdb to run.
    /// This member is required.
    public var releaseLabel: Swift.String?
    /// The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted.
    public var savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration?
    /// The structure that stores the configuration details of a scaling group.
    public var scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration?
    /// A list of key-value pairs to label the cluster. You can add up to 50 tags to a cluster.
    public var tags: [Swift.String:Swift.String]?
    /// A configuration to store Tickerplant logs. It consists of a list of volumes that will be mounted to your cluster. For the cluster type Tickerplant, the location of the TP volume on the cluster will be available by using the global variable .aws.tp_log_path.
    public var tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration?
    /// Configuration details about the network where the Privatelink endpoint of the cluster resides.
    /// This member is required.
    public var vpcConfiguration: FinspaceClientTypes.VpcConfiguration?

    public init(
        autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration? = nil,
        availabilityZoneId: Swift.String? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]? = nil,
        capacityConfiguration: FinspaceClientTypes.CapacityConfiguration? = nil,
        clientToken: Swift.String? = nil,
        clusterDescription: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        clusterType: FinspaceClientTypes.KxClusterType? = nil,
        code: FinspaceClientTypes.CodeConfiguration? = nil,
        commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]? = nil,
        databases: [FinspaceClientTypes.KxDatabaseConfiguration]? = nil,
        environmentId: Swift.String? = nil,
        executionRole: Swift.String? = nil,
        initializationScript: Swift.String? = nil,
        releaseLabel: Swift.String? = nil,
        savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration? = nil,
        scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration? = nil,
        vpcConfiguration: FinspaceClientTypes.VpcConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
        self.availabilityZoneId = availabilityZoneId
        self.azMode = azMode
        self.cacheStorageConfigurations = cacheStorageConfigurations
        self.capacityConfiguration = capacityConfiguration
        self.clientToken = clientToken
        self.clusterDescription = clusterDescription
        self.clusterName = clusterName
        self.clusterType = clusterType
        self.code = code
        self.commandLineArguments = commandLineArguments
        self.databases = databases
        self.environmentId = environmentId
        self.executionRole = executionRole
        self.initializationScript = initializationScript
        self.releaseLabel = releaseLabel
        self.savedownStorageConfiguration = savedownStorageConfiguration
        self.scalingGroupConfiguration = scalingGroupConfiguration
        self.tags = tags
        self.tickerplantLogConfiguration = tickerplantLogConfiguration
        self.vpcConfiguration = vpcConfiguration
    }
}

struct CreateKxClusterInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let clusterName: Swift.String?
    let clusterType: FinspaceClientTypes.KxClusterType?
    let tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration?
    let databases: [FinspaceClientTypes.KxDatabaseConfiguration]?
    let cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]?
    let autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration?
    let clusterDescription: Swift.String?
    let capacityConfiguration: FinspaceClientTypes.CapacityConfiguration?
    let releaseLabel: Swift.String?
    let vpcConfiguration: FinspaceClientTypes.VpcConfiguration?
    let initializationScript: Swift.String?
    let commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]?
    let code: FinspaceClientTypes.CodeConfiguration?
    let executionRole: Swift.String?
    let savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration?
    let azMode: FinspaceClientTypes.KxAzMode?
    let availabilityZoneId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration?
}

extension CreateKxClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfiguration
        case availabilityZoneId
        case azMode
        case cacheStorageConfigurations
        case capacityConfiguration
        case clientToken
        case clusterDescription
        case clusterName
        case clusterType
        case code
        case commandLineArguments
        case databases
        case executionRole
        case initializationScript
        case releaseLabel
        case savedownStorageConfiguration
        case scalingGroupConfiguration
        case tags
        case tickerplantLogConfiguration
        case vpcConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxClusterType.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let tickerplantLogConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.TickerplantLogConfiguration.self, forKey: .tickerplantLogConfiguration)
        tickerplantLogConfiguration = tickerplantLogConfigurationDecoded
        let databasesContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDatabaseConfiguration?].self, forKey: .databases)
        var databasesDecoded0:[FinspaceClientTypes.KxDatabaseConfiguration]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [FinspaceClientTypes.KxDatabaseConfiguration]()
            for structure0 in databasesContainer {
                if let structure0 = structure0 {
                    databasesDecoded0?.append(structure0)
                }
            }
        }
        databases = databasesDecoded0
        let cacheStorageConfigurationsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxCacheStorageConfiguration?].self, forKey: .cacheStorageConfigurations)
        var cacheStorageConfigurationsDecoded0:[FinspaceClientTypes.KxCacheStorageConfiguration]? = nil
        if let cacheStorageConfigurationsContainer = cacheStorageConfigurationsContainer {
            cacheStorageConfigurationsDecoded0 = [FinspaceClientTypes.KxCacheStorageConfiguration]()
            for structure0 in cacheStorageConfigurationsContainer {
                if let structure0 = structure0 {
                    cacheStorageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        cacheStorageConfigurations = cacheStorageConfigurationsDecoded0
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
        let clusterDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterDescription)
        clusterDescription = clusterDescriptionDecoded
        let capacityConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.CapacityConfiguration.self, forKey: .capacityConfiguration)
        capacityConfiguration = capacityConfigurationDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let initializationScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initializationScript)
        initializationScript = initializationScriptDecoded
        let commandLineArgumentsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxCommandLineArgument?].self, forKey: .commandLineArguments)
        var commandLineArgumentsDecoded0:[FinspaceClientTypes.KxCommandLineArgument]? = nil
        if let commandLineArgumentsContainer = commandLineArgumentsContainer {
            commandLineArgumentsDecoded0 = [FinspaceClientTypes.KxCommandLineArgument]()
            for structure0 in commandLineArgumentsContainer {
                if let structure0 = structure0 {
                    commandLineArgumentsDecoded0?.append(structure0)
                }
            }
        }
        commandLineArguments = commandLineArgumentsDecoded0
        let codeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.CodeConfiguration.self, forKey: .code)
        code = codeDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let savedownStorageConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxSavedownStorageConfiguration.self, forKey: .savedownStorageConfiguration)
        savedownStorageConfiguration = savedownStorageConfigurationDecoded
        let azModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxAzMode.self, forKey: .azMode)
        azMode = azModeDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let scalingGroupConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxScalingGroupConfiguration.self, forKey: .scalingGroupConfiguration)
        scalingGroupConfiguration = scalingGroupConfigurationDecoded
    }
}

extension CreateKxClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateKxClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingConfiguration = output.autoScalingConfiguration
            self.availabilityZoneId = output.availabilityZoneId
            self.azMode = output.azMode
            self.cacheStorageConfigurations = output.cacheStorageConfigurations
            self.capacityConfiguration = output.capacityConfiguration
            self.clusterDescription = output.clusterDescription
            self.clusterName = output.clusterName
            self.clusterType = output.clusterType
            self.code = output.code
            self.commandLineArguments = output.commandLineArguments
            self.createdTimestamp = output.createdTimestamp
            self.databases = output.databases
            self.environmentId = output.environmentId
            self.executionRole = output.executionRole
            self.initializationScript = output.initializationScript
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.releaseLabel = output.releaseLabel
            self.savedownStorageConfiguration = output.savedownStorageConfiguration
            self.scalingGroupConfiguration = output.scalingGroupConfiguration
            self.status = output.status
            self.statusReason = output.statusReason
            self.tickerplantLogConfiguration = output.tickerplantLogConfiguration
            self.volumes = output.volumes
            self.vpcConfiguration = output.vpcConfiguration
        } else {
            self.autoScalingConfiguration = nil
            self.availabilityZoneId = nil
            self.azMode = nil
            self.cacheStorageConfigurations = nil
            self.capacityConfiguration = nil
            self.clusterDescription = nil
            self.clusterName = nil
            self.clusterType = nil
            self.code = nil
            self.commandLineArguments = nil
            self.createdTimestamp = nil
            self.databases = nil
            self.environmentId = nil
            self.executionRole = nil
            self.initializationScript = nil
            self.lastModifiedTimestamp = nil
            self.releaseLabel = nil
            self.savedownStorageConfiguration = nil
            self.scalingGroupConfiguration = nil
            self.status = nil
            self.statusReason = nil
            self.tickerplantLogConfiguration = nil
            self.volumes = nil
            self.vpcConfiguration = nil
        }
    }
}

public struct CreateKxClusterOutput: Swift.Equatable {
    /// The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
    public var autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration?
    /// The availability zone identifiers for the requested regions.
    public var availabilityZoneId: Swift.String?
    /// The number of availability zones you want to assign per cluster. This can be one of the following
    ///
    /// * SINGLE – Assigns one availability zone per cluster.
    ///
    /// * MULTI – Assigns all the availability zones per cluster.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store.
    public var cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]?
    /// A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, and number of instances.
    public var capacityConfiguration: FinspaceClientTypes.CapacityConfiguration?
    /// A description of the cluster.
    public var clusterDescription: Swift.String?
    /// A unique name for the cluster.
    public var clusterName: Swift.String?
    /// Specifies the type of KDB database that is being created. The following types are available:
    ///
    /// * HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.
    ///
    /// * RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.
    ///
    /// * GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.
    ///
    /// * GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.
    ///
    /// * Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
    public var clusterType: FinspaceClientTypes.KxClusterType?
    /// The details of the custom code that you want to use inside a cluster when analyzing a data. It consists of the S3 source bucket, location, S3 object version, and the relative path from where the custom code is loaded into the cluster.
    public var code: FinspaceClientTypes.CodeConfiguration?
    /// Defines the key-value pairs to make them available inside the cluster.
    public var commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]?
    /// The timestamp at which the cluster was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: ClientRuntime.Date?
    /// A list of databases that will be available for querying.
    public var databases: [FinspaceClientTypes.KxDatabaseConfiguration]?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
    public var executionRole: Swift.String?
    /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
    public var initializationScript: Swift.String?
    /// The last time that the cluster was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// A version of the FinSpace managed kdb to run.
    public var releaseLabel: Swift.String?
    /// The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted.
    public var savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration?
    /// The structure that stores the configuration details of a scaling group.
    public var scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration?
    /// The status of cluster creation.
    ///
    /// * PENDING – The cluster is pending creation.
    ///
    /// * CREATING – The cluster creation process is in progress.
    ///
    /// * CREATE_FAILED – The cluster creation process has failed.
    ///
    /// * RUNNING – The cluster creation process is running.
    ///
    /// * UPDATING – The cluster is in the process of being updated.
    ///
    /// * DELETING – The cluster is in the process of being deleted.
    ///
    /// * DELETED – The cluster has been deleted.
    ///
    /// * DELETE_FAILED – The cluster failed to delete.
    public var status: FinspaceClientTypes.KxClusterStatus?
    /// The error message when a failed state occurs.
    public var statusReason: Swift.String?
    /// A configuration to store the Tickerplant logs. It consists of a list of volumes that will be mounted to your cluster. For the cluster type Tickerplant, the location of the TP volume on the cluster will be available by using the global variable .aws.tp_log_path.
    public var tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration?
    /// A list of volumes mounted on the cluster.
    public var volumes: [FinspaceClientTypes.Volume]?
    /// Configuration details about the network where the Privatelink endpoint of the cluster resides.
    public var vpcConfiguration: FinspaceClientTypes.VpcConfiguration?

    public init(
        autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration? = nil,
        availabilityZoneId: Swift.String? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]? = nil,
        capacityConfiguration: FinspaceClientTypes.CapacityConfiguration? = nil,
        clusterDescription: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        clusterType: FinspaceClientTypes.KxClusterType? = nil,
        code: FinspaceClientTypes.CodeConfiguration? = nil,
        commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        databases: [FinspaceClientTypes.KxDatabaseConfiguration]? = nil,
        environmentId: Swift.String? = nil,
        executionRole: Swift.String? = nil,
        initializationScript: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        releaseLabel: Swift.String? = nil,
        savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration? = nil,
        scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration? = nil,
        status: FinspaceClientTypes.KxClusterStatus? = nil,
        statusReason: Swift.String? = nil,
        tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration? = nil,
        volumes: [FinspaceClientTypes.Volume]? = nil,
        vpcConfiguration: FinspaceClientTypes.VpcConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
        self.availabilityZoneId = availabilityZoneId
        self.azMode = azMode
        self.cacheStorageConfigurations = cacheStorageConfigurations
        self.capacityConfiguration = capacityConfiguration
        self.clusterDescription = clusterDescription
        self.clusterName = clusterName
        self.clusterType = clusterType
        self.code = code
        self.commandLineArguments = commandLineArguments
        self.createdTimestamp = createdTimestamp
        self.databases = databases
        self.environmentId = environmentId
        self.executionRole = executionRole
        self.initializationScript = initializationScript
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.releaseLabel = releaseLabel
        self.savedownStorageConfiguration = savedownStorageConfiguration
        self.scalingGroupConfiguration = scalingGroupConfiguration
        self.status = status
        self.statusReason = statusReason
        self.tickerplantLogConfiguration = tickerplantLogConfiguration
        self.volumes = volumes
        self.vpcConfiguration = vpcConfiguration
    }
}

struct CreateKxClusterOutputBody: Swift.Equatable {
    let environmentId: Swift.String?
    let status: FinspaceClientTypes.KxClusterStatus?
    let statusReason: Swift.String?
    let clusterName: Swift.String?
    let clusterType: FinspaceClientTypes.KxClusterType?
    let tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration?
    let volumes: [FinspaceClientTypes.Volume]?
    let databases: [FinspaceClientTypes.KxDatabaseConfiguration]?
    let cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]?
    let autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration?
    let clusterDescription: Swift.String?
    let capacityConfiguration: FinspaceClientTypes.CapacityConfiguration?
    let releaseLabel: Swift.String?
    let vpcConfiguration: FinspaceClientTypes.VpcConfiguration?
    let initializationScript: Swift.String?
    let commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]?
    let code: FinspaceClientTypes.CodeConfiguration?
    let executionRole: Swift.String?
    let lastModifiedTimestamp: ClientRuntime.Date?
    let savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration?
    let azMode: FinspaceClientTypes.KxAzMode?
    let availabilityZoneId: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
    let scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration?
}

extension CreateKxClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfiguration
        case availabilityZoneId
        case azMode
        case cacheStorageConfigurations
        case capacityConfiguration
        case clusterDescription
        case clusterName
        case clusterType
        case code
        case commandLineArguments
        case createdTimestamp
        case databases
        case environmentId
        case executionRole
        case initializationScript
        case lastModifiedTimestamp
        case releaseLabel
        case savedownStorageConfiguration
        case scalingGroupConfiguration
        case status
        case statusReason
        case tickerplantLogConfiguration
        case volumes
        case vpcConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxClusterStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxClusterType.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let tickerplantLogConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.TickerplantLogConfiguration.self, forKey: .tickerplantLogConfiguration)
        tickerplantLogConfiguration = tickerplantLogConfigurationDecoded
        let volumesContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.Volume?].self, forKey: .volumes)
        var volumesDecoded0:[FinspaceClientTypes.Volume]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [FinspaceClientTypes.Volume]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
        let databasesContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDatabaseConfiguration?].self, forKey: .databases)
        var databasesDecoded0:[FinspaceClientTypes.KxDatabaseConfiguration]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [FinspaceClientTypes.KxDatabaseConfiguration]()
            for structure0 in databasesContainer {
                if let structure0 = structure0 {
                    databasesDecoded0?.append(structure0)
                }
            }
        }
        databases = databasesDecoded0
        let cacheStorageConfigurationsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxCacheStorageConfiguration?].self, forKey: .cacheStorageConfigurations)
        var cacheStorageConfigurationsDecoded0:[FinspaceClientTypes.KxCacheStorageConfiguration]? = nil
        if let cacheStorageConfigurationsContainer = cacheStorageConfigurationsContainer {
            cacheStorageConfigurationsDecoded0 = [FinspaceClientTypes.KxCacheStorageConfiguration]()
            for structure0 in cacheStorageConfigurationsContainer {
                if let structure0 = structure0 {
                    cacheStorageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        cacheStorageConfigurations = cacheStorageConfigurationsDecoded0
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
        let clusterDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterDescription)
        clusterDescription = clusterDescriptionDecoded
        let capacityConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.CapacityConfiguration.self, forKey: .capacityConfiguration)
        capacityConfiguration = capacityConfigurationDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let initializationScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initializationScript)
        initializationScript = initializationScriptDecoded
        let commandLineArgumentsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxCommandLineArgument?].self, forKey: .commandLineArguments)
        var commandLineArgumentsDecoded0:[FinspaceClientTypes.KxCommandLineArgument]? = nil
        if let commandLineArgumentsContainer = commandLineArgumentsContainer {
            commandLineArgumentsDecoded0 = [FinspaceClientTypes.KxCommandLineArgument]()
            for structure0 in commandLineArgumentsContainer {
                if let structure0 = structure0 {
                    commandLineArgumentsDecoded0?.append(structure0)
                }
            }
        }
        commandLineArguments = commandLineArgumentsDecoded0
        let codeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.CodeConfiguration.self, forKey: .code)
        code = codeDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let savedownStorageConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxSavedownStorageConfiguration.self, forKey: .savedownStorageConfiguration)
        savedownStorageConfiguration = savedownStorageConfigurationDecoded
        let azModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxAzMode.self, forKey: .azMode)
        azMode = azModeDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let scalingGroupConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxScalingGroupConfiguration.self, forKey: .scalingGroupConfiguration)
        scalingGroupConfiguration = scalingGroupConfigurationDecoded
    }
}

enum CreateKxClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateKxDatabaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case databaseName
        case description
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateKxDatabaseInput {

    static func urlPathProvider(_ value: CreateKxDatabaseInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases"
    }
}

public struct CreateKxDatabaseInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The name of the kdb database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A description of the database.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// A list of key-value pairs to label the kdb database. You can add up to 50 tags to your kdb database
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.databaseName = databaseName
        self.description = description
        self.environmentId = environmentId
        self.tags = tags
    }
}

struct CreateKxDatabaseInputBody: Swift.Equatable {
    let databaseName: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateKxDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case databaseName
        case description
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateKxDatabaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateKxDatabaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.databaseArn = output.databaseArn
            self.databaseName = output.databaseName
            self.description = output.description
            self.environmentId = output.environmentId
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
        } else {
            self.createdTimestamp = nil
            self.databaseArn = nil
            self.databaseName = nil
            self.description = nil
            self.environmentId = nil
            self.lastModifiedTimestamp = nil
        }
    }
}

public struct CreateKxDatabaseOutput: Swift.Equatable {
    /// The timestamp at which the database is created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: ClientRuntime.Date?
    /// The ARN identifier of the database.
    public var databaseArn: Swift.String?
    /// The name of the kdb database.
    public var databaseName: Swift.String?
    /// A description of the database.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// The last time that the database was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: ClientRuntime.Date?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        databaseArn: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.databaseArn = databaseArn
        self.databaseName = databaseName
        self.description = description
        self.environmentId = environmentId
        self.lastModifiedTimestamp = lastModifiedTimestamp
    }
}

struct CreateKxDatabaseOutputBody: Swift.Equatable {
    let databaseName: Swift.String?
    let databaseArn: Swift.String?
    let environmentId: Swift.String?
    let description: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
    let lastModifiedTimestamp: ClientRuntime.Date?
}

extension CreateKxDatabaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp
        case databaseArn
        case databaseName
        case description
        case environmentId
        case lastModifiedTimestamp
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let databaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseArn)
        databaseArn = databaseArnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

enum CreateKxDatabaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateKxDataviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoUpdate
        case availabilityZoneId
        case azMode
        case changesetId
        case clientToken
        case dataviewName
        case description
        case segmentConfigurations
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoUpdate = self.autoUpdate {
            try encodeContainer.encode(autoUpdate, forKey: .autoUpdate)
        }
        if let availabilityZoneId = self.availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let azMode = self.azMode {
            try encodeContainer.encode(azMode.rawValue, forKey: .azMode)
        }
        if let changesetId = self.changesetId {
            try encodeContainer.encode(changesetId, forKey: .changesetId)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataviewName = self.dataviewName {
            try encodeContainer.encode(dataviewName, forKey: .dataviewName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let segmentConfigurations = segmentConfigurations {
            var segmentConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segmentConfigurations)
            for kxdataviewsegmentconfiguration0 in segmentConfigurations {
                try segmentConfigurationsContainer.encode(kxdataviewsegmentconfiguration0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateKxDataviewInput {

    static func urlPathProvider(_ value: CreateKxDataviewInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/dataviews"
    }
}

public struct CreateKxDataviewInput: Swift.Equatable {
    /// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview, when you ingest new changesets. The default value is false.
    public var autoUpdate: Swift.Bool?
    /// The identifier of the availability zones.
    public var availabilityZoneId: Swift.String?
    /// The number of availability zones you want to assign per cluster. This can be one of the following
    ///
    /// * SINGLE – Assigns one availability zone per cluster.
    ///
    /// * MULTI – Assigns all the availability zones per cluster.
    /// This member is required.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// A unique identifier of the changeset that you want to use to ingest data.
    public var changesetId: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The name of the database where you want to create a dataview.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier for the dataview.
    /// This member is required.
    public var dataviewName: Swift.String?
    /// A description of the dataview.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, where you want to create the dataview.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
    public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
    /// A list of key-value pairs to label the dataview. You can add up to 50 tags to a dataview.
    public var tags: [Swift.String:Swift.String]?

    public init(
        autoUpdate: Swift.Bool? = nil,
        availabilityZoneId: Swift.String? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        changesetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        dataviewName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.autoUpdate = autoUpdate
        self.availabilityZoneId = availabilityZoneId
        self.azMode = azMode
        self.changesetId = changesetId
        self.clientToken = clientToken
        self.databaseName = databaseName
        self.dataviewName = dataviewName
        self.description = description
        self.environmentId = environmentId
        self.segmentConfigurations = segmentConfigurations
        self.tags = tags
    }
}

struct CreateKxDataviewInputBody: Swift.Equatable {
    let dataviewName: Swift.String?
    let azMode: FinspaceClientTypes.KxAzMode?
    let availabilityZoneId: Swift.String?
    let changesetId: Swift.String?
    let segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
    let autoUpdate: Swift.Bool?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateKxDataviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoUpdate
        case availabilityZoneId
        case azMode
        case changesetId
        case clientToken
        case dataviewName
        case description
        case segmentConfigurations
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataviewNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataviewName)
        dataviewName = dataviewNameDecoded
        let azModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxAzMode.self, forKey: .azMode)
        azMode = azModeDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let segmentConfigurationsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDataviewSegmentConfiguration?].self, forKey: .segmentConfigurations)
        var segmentConfigurationsDecoded0:[FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil
        if let segmentConfigurationsContainer = segmentConfigurationsContainer {
            segmentConfigurationsDecoded0 = [FinspaceClientTypes.KxDataviewSegmentConfiguration]()
            for structure0 in segmentConfigurationsContainer {
                if let structure0 = structure0 {
                    segmentConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        segmentConfigurations = segmentConfigurationsDecoded0
        let autoUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoUpdate)
        autoUpdate = autoUpdateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateKxDataviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateKxDataviewOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoUpdate = output.autoUpdate
            self.availabilityZoneId = output.availabilityZoneId
            self.azMode = output.azMode
            self.changesetId = output.changesetId
            self.createdTimestamp = output.createdTimestamp
            self.databaseName = output.databaseName
            self.dataviewName = output.dataviewName
            self.description = output.description
            self.environmentId = output.environmentId
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.segmentConfigurations = output.segmentConfigurations
            self.status = output.status
        } else {
            self.autoUpdate = false
            self.availabilityZoneId = nil
            self.azMode = nil
            self.changesetId = nil
            self.createdTimestamp = nil
            self.databaseName = nil
            self.dataviewName = nil
            self.description = nil
            self.environmentId = nil
            self.lastModifiedTimestamp = nil
            self.segmentConfigurations = nil
            self.status = nil
        }
    }
}

public struct CreateKxDataviewOutput: Swift.Equatable {
    /// The option to select whether you want to apply all the future additions and corrections automatically to the dataview when you ingest new changesets. The default value is false.
    public var autoUpdate: Swift.Bool
    /// The identifier of the availability zones.
    public var availabilityZoneId: Swift.String?
    /// The number of availability zones you want to assign per cluster. This can be one of the following
    ///
    /// * SINGLE – Assigns one availability zone per cluster.
    ///
    /// * MULTI – Assigns all the availability zones per cluster.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// A unique identifier for the changeset.
    public var changesetId: Swift.String?
    /// The timestamp at which the dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: ClientRuntime.Date?
    /// The name of the database where you want to create a dataview.
    public var databaseName: Swift.String?
    /// A unique identifier for the dataview.
    public var dataviewName: Swift.String?
    /// A description of the dataview.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, where you want to create the dataview.
    public var environmentId: Swift.String?
    /// The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
    public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
    /// The status of dataview creation.
    ///
    /// * CREATING – The dataview creation is in progress.
    ///
    /// * UPDATING – The dataview is in the process of being updated.
    ///
    /// * ACTIVE – The dataview is active.
    public var status: FinspaceClientTypes.KxDataviewStatus?

    public init(
        autoUpdate: Swift.Bool = false,
        availabilityZoneId: Swift.String? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        changesetId: Swift.String? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        databaseName: Swift.String? = nil,
        dataviewName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil,
        status: FinspaceClientTypes.KxDataviewStatus? = nil
    )
    {
        self.autoUpdate = autoUpdate
        self.availabilityZoneId = availabilityZoneId
        self.azMode = azMode
        self.changesetId = changesetId
        self.createdTimestamp = createdTimestamp
        self.databaseName = databaseName
        self.dataviewName = dataviewName
        self.description = description
        self.environmentId = environmentId
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.segmentConfigurations = segmentConfigurations
        self.status = status
    }
}

struct CreateKxDataviewOutputBody: Swift.Equatable {
    let dataviewName: Swift.String?
    let databaseName: Swift.String?
    let environmentId: Swift.String?
    let azMode: FinspaceClientTypes.KxAzMode?
    let availabilityZoneId: Swift.String?
    let changesetId: Swift.String?
    let segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
    let description: Swift.String?
    let autoUpdate: Swift.Bool
    let createdTimestamp: ClientRuntime.Date?
    let lastModifiedTimestamp: ClientRuntime.Date?
    let status: FinspaceClientTypes.KxDataviewStatus?
}

extension CreateKxDataviewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoUpdate
        case availabilityZoneId
        case azMode
        case changesetId
        case createdTimestamp
        case databaseName
        case dataviewName
        case description
        case environmentId
        case lastModifiedTimestamp
        case segmentConfigurations
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataviewNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataviewName)
        dataviewName = dataviewNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let azModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxAzMode.self, forKey: .azMode)
        azMode = azModeDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let segmentConfigurationsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDataviewSegmentConfiguration?].self, forKey: .segmentConfigurations)
        var segmentConfigurationsDecoded0:[FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil
        if let segmentConfigurationsContainer = segmentConfigurationsContainer {
            segmentConfigurationsDecoded0 = [FinspaceClientTypes.KxDataviewSegmentConfiguration]()
            for structure0 in segmentConfigurationsContainer {
                if let structure0 = structure0 {
                    segmentConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        segmentConfigurations = segmentConfigurationsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let autoUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoUpdate) ?? false
        autoUpdate = autoUpdateDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxDataviewStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateKxDataviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateKxEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case kmsKeyId
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateKxEnvironmentInput {

    static func urlPathProvider(_ value: CreateKxEnvironmentInput) -> Swift.String? {
        return "/kx/environments"
    }
}

public struct CreateKxEnvironmentInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A description for the kdb environment.
    public var description: Swift.String?
    /// The KMS key ID to encrypt your data in the FinSpace environment.
    /// This member is required.
    public var kmsKeyId: Swift.String?
    /// The name of the kdb environment that you want to create.
    /// This member is required.
    public var name: Swift.String?
    /// A list of key-value pairs to label the kdb environment. You can add up to 50 tags to your kdb environment.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.tags = tags
    }
}

struct CreateKxEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let kmsKeyId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateKxEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case kmsKeyId
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateKxEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateKxEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTimestamp = output.creationTimestamp
            self.description = output.description
            self.environmentArn = output.environmentArn
            self.environmentId = output.environmentId
            self.kmsKeyId = output.kmsKeyId
            self.name = output.name
            self.status = output.status
        } else {
            self.creationTimestamp = nil
            self.description = nil
            self.environmentArn = nil
            self.environmentId = nil
            self.kmsKeyId = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct CreateKxEnvironmentOutput: Swift.Equatable {
    /// The timestamp at which the kdb environment was created in FinSpace.
    public var creationTimestamp: ClientRuntime.Date?
    /// A description for the kdb environment.
    public var description: Swift.String?
    /// The ARN identifier of the environment.
    public var environmentArn: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// The KMS key ID to encrypt your data in the FinSpace environment.
    public var kmsKeyId: Swift.String?
    /// The name of the kdb environment.
    public var name: Swift.String?
    /// The status of the kdb environment.
    public var status: FinspaceClientTypes.EnvironmentStatus?

    public init(
        creationTimestamp: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        environmentArn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: FinspaceClientTypes.EnvironmentStatus? = nil
    )
    {
        self.creationTimestamp = creationTimestamp
        self.description = description
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.status = status
    }
}

struct CreateKxEnvironmentOutputBody: Swift.Equatable {
    let name: Swift.String?
    let status: FinspaceClientTypes.EnvironmentStatus?
    let environmentId: Swift.String?
    let description: Swift.String?
    let environmentArn: Swift.String?
    let kmsKeyId: Swift.String?
    let creationTimestamp: ClientRuntime.Date?
}

extension CreateKxEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp
        case description
        case environmentArn
        case environmentId
        case kmsKeyId
        case name
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
    }
}

enum CreateKxEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateKxScalingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId
        case clientToken
        case hostType
        case scalingGroupName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneId = self.availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let hostType = self.hostType {
            try encodeContainer.encode(hostType, forKey: .hostType)
        }
        if let scalingGroupName = self.scalingGroupName {
            try encodeContainer.encode(scalingGroupName, forKey: .scalingGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateKxScalingGroupInput {

    static func urlPathProvider(_ value: CreateKxScalingGroupInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/scalingGroups"
    }
}

public struct CreateKxScalingGroupInput: Swift.Equatable {
    /// The identifier of the availability zones.
    /// This member is required.
    public var availabilityZoneId: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A unique identifier for the kdb environment, where you want to create the scaling group.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The memory and CPU capabilities of the scaling group host on which FinSpace Managed kdb clusters will be placed.
    /// This member is required.
    public var hostType: Swift.String?
    /// A unique identifier for the kdb scaling group.
    /// This member is required.
    public var scalingGroupName: Swift.String?
    /// A list of key-value pairs to label the scaling group. You can add up to 50 tags to a scaling group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        availabilityZoneId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        hostType: Swift.String? = nil,
        scalingGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.hostType = hostType
        self.scalingGroupName = scalingGroupName
        self.tags = tags
    }
}

struct CreateKxScalingGroupInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let scalingGroupName: Swift.String?
    let hostType: Swift.String?
    let availabilityZoneId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateKxScalingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId
        case clientToken
        case hostType
        case scalingGroupName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let scalingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scalingGroupName)
        scalingGroupName = scalingGroupNameDecoded
        let hostTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostType)
        hostType = hostTypeDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateKxScalingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateKxScalingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZoneId = output.availabilityZoneId
            self.createdTimestamp = output.createdTimestamp
            self.environmentId = output.environmentId
            self.hostType = output.hostType
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.scalingGroupName = output.scalingGroupName
            self.status = output.status
        } else {
            self.availabilityZoneId = nil
            self.createdTimestamp = nil
            self.environmentId = nil
            self.hostType = nil
            self.lastModifiedTimestamp = nil
            self.scalingGroupName = nil
            self.status = nil
        }
    }
}

public struct CreateKxScalingGroupOutput: Swift.Equatable {
    /// The identifier of the availability zones.
    public var availabilityZoneId: Swift.String?
    /// The timestamp at which the scaling group was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: ClientRuntime.Date?
    /// A unique identifier for the kdb environment, where you create the scaling group.
    public var environmentId: Swift.String?
    /// The memory and CPU capabilities of the scaling group host on which FinSpace Managed kdb clusters will be placed.
    public var hostType: Swift.String?
    /// The last time that the scaling group was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// A unique identifier for the kdb scaling group.
    public var scalingGroupName: Swift.String?
    /// The status of scaling group.
    ///
    /// * CREATING – The scaling group creation is in progress.
    ///
    /// * CREATE_FAILED – The scaling group creation has failed.
    ///
    /// * ACTIVE – The scaling group is active.
    ///
    /// * UPDATING – The scaling group is in the process of being updated.
    ///
    /// * UPDATE_FAILED – The update action failed.
    ///
    /// * DELETING – The scaling group is in the process of being deleted.
    ///
    /// * DELETE_FAILED – The system failed to delete the scaling group.
    ///
    /// * DELETED – The scaling group is successfully deleted.
    public var status: FinspaceClientTypes.KxScalingGroupStatus?

    public init(
        availabilityZoneId: Swift.String? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        environmentId: Swift.String? = nil,
        hostType: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        scalingGroupName: Swift.String? = nil,
        status: FinspaceClientTypes.KxScalingGroupStatus? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.createdTimestamp = createdTimestamp
        self.environmentId = environmentId
        self.hostType = hostType
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.scalingGroupName = scalingGroupName
        self.status = status
    }
}

struct CreateKxScalingGroupOutputBody: Swift.Equatable {
    let environmentId: Swift.String?
    let scalingGroupName: Swift.String?
    let hostType: Swift.String?
    let availabilityZoneId: Swift.String?
    let status: FinspaceClientTypes.KxScalingGroupStatus?
    let lastModifiedTimestamp: ClientRuntime.Date?
    let createdTimestamp: ClientRuntime.Date?
}

extension CreateKxScalingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId
        case createdTimestamp
        case environmentId
        case hostType
        case lastModifiedTimestamp
        case scalingGroupName
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let scalingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scalingGroupName)
        scalingGroupName = scalingGroupNameDecoded
        let hostTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostType)
        hostType = hostTypeDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxScalingGroupStatus.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum CreateKxScalingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateKxUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case iamRole
        case tags
        case userName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let iamRole = self.iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension CreateKxUserInput {

    static func urlPathProvider(_ value: CreateKxUserInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/users"
    }
}

public struct CreateKxUserInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A unique identifier for the kdb environment where you want to create a user.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The IAM role ARN that will be associated with the user.
    /// This member is required.
    public var iamRole: Swift.String?
    /// A list of key-value pairs to label the user. You can add up to 50 tags to a user.
    public var tags: [Swift.String:Swift.String]?
    /// A unique identifier for the user.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.iamRole = iamRole
        self.tags = tags
        self.userName = userName
    }
}

struct CreateKxUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let iamRole: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateKxUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case iamRole
        case tags
        case userName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateKxUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateKxUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentId = output.environmentId
            self.iamRole = output.iamRole
            self.userArn = output.userArn
            self.userName = output.userName
        } else {
            self.environmentId = nil
            self.iamRole = nil
            self.userArn = nil
            self.userName = nil
        }
    }
}

public struct CreateKxUserOutput: Swift.Equatable {
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// The IAM role ARN that will be associated with the user.
    public var iamRole: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    public var userArn: Swift.String?
    /// A unique identifier for the user.
    public var userName: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        userArn: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.iamRole = iamRole
        self.userArn = userArn
        self.userName = userName
    }
}

struct CreateKxUserOutputBody: Swift.Equatable {
    let userName: Swift.String?
    let userArn: Swift.String?
    let environmentId: Swift.String?
    let iamRole: Swift.String?
}

extension CreateKxUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
        case iamRole
        case userArn
        case userName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
    }
}

enum CreateKxUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateKxVolumeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneIds
        case azMode
        case clientToken
        case description
        case nas1Configuration
        case tags
        case volumeName
        case volumeType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneIds = availabilityZoneIds {
            var availabilityZoneIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZoneIds)
            for availabilityzoneid0 in availabilityZoneIds {
                try availabilityZoneIdsContainer.encode(availabilityzoneid0)
            }
        }
        if let azMode = self.azMode {
            try encodeContainer.encode(azMode.rawValue, forKey: .azMode)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let nas1Configuration = self.nas1Configuration {
            try encodeContainer.encode(nas1Configuration, forKey: .nas1Configuration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let volumeName = self.volumeName {
            try encodeContainer.encode(volumeName, forKey: .volumeName)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType.rawValue, forKey: .volumeType)
        }
    }
}

extension CreateKxVolumeInput {

    static func urlPathProvider(_ value: CreateKxVolumeInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/kxvolumes"
    }
}

public struct CreateKxVolumeInput: Swift.Equatable {
    /// The identifier of the availability zones.
    /// This member is required.
    public var availabilityZoneIds: [Swift.String]?
    /// The number of availability zones you want to assign per cluster. Currently, FinSpace only support SINGLE for volumes.
    /// This member is required.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A description of the volume.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the configuration for the Network attached storage (NAS_1) file system volume. This parameter is required when you choose volumeType as NAS_1.
    public var nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
    /// A list of key-value pairs to label the volume. You can add up to 50 tags to a volume.
    public var tags: [Swift.String:Swift.String]?
    /// A unique identifier for the volume.
    /// This member is required.
    public var volumeName: Swift.String?
    /// The type of file system volume. Currently, FinSpace only supports NAS_1 volume type. When you select NAS_1 volume type, you must also provide nas1Configuration.
    /// This member is required.
    public var volumeType: FinspaceClientTypes.KxVolumeType?

    public init(
        availabilityZoneIds: [Swift.String]? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        nas1Configuration: FinspaceClientTypes.KxNAS1Configuration? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        volumeName: Swift.String? = nil,
        volumeType: FinspaceClientTypes.KxVolumeType? = nil
    )
    {
        self.availabilityZoneIds = availabilityZoneIds
        self.azMode = azMode
        self.clientToken = clientToken
        self.description = description
        self.environmentId = environmentId
        self.nas1Configuration = nas1Configuration
        self.tags = tags
        self.volumeName = volumeName
        self.volumeType = volumeType
    }
}

struct CreateKxVolumeInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let volumeType: FinspaceClientTypes.KxVolumeType?
    let volumeName: Swift.String?
    let description: Swift.String?
    let nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
    let azMode: FinspaceClientTypes.KxAzMode?
    let availabilityZoneIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateKxVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneIds
        case azMode
        case clientToken
        case description
        case nas1Configuration
        case tags
        case volumeName
        case volumeType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxVolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeName)
        volumeName = volumeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nas1ConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxNAS1Configuration.self, forKey: .nas1Configuration)
        nas1Configuration = nas1ConfigurationDecoded
        let azModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxAzMode.self, forKey: .azMode)
        azMode = azModeDecoded
        let availabilityZoneIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZoneIds)
        var availabilityZoneIdsDecoded0:[Swift.String]? = nil
        if let availabilityZoneIdsContainer = availabilityZoneIdsContainer {
            availabilityZoneIdsDecoded0 = [Swift.String]()
            for string0 in availabilityZoneIdsContainer {
                if let string0 = string0 {
                    availabilityZoneIdsDecoded0?.append(string0)
                }
            }
        }
        availabilityZoneIds = availabilityZoneIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateKxVolumeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateKxVolumeOutputBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZoneIds = output.availabilityZoneIds
            self.azMode = output.azMode
            self.createdTimestamp = output.createdTimestamp
            self.description = output.description
            self.environmentId = output.environmentId
            self.nas1Configuration = output.nas1Configuration
            self.status = output.status
            self.statusReason = output.statusReason
            self.volumeArn = output.volumeArn
            self.volumeName = output.volumeName
            self.volumeType = output.volumeType
        } else {
            self.availabilityZoneIds = nil
            self.azMode = nil
            self.createdTimestamp = nil
            self.description = nil
            self.environmentId = nil
            self.nas1Configuration = nil
            self.status = nil
            self.statusReason = nil
            self.volumeArn = nil
            self.volumeName = nil
            self.volumeType = nil
        }
    }
}

public struct CreateKxVolumeOutput: Swift.Equatable {
    /// The identifier of the availability zones.
    public var availabilityZoneIds: [Swift.String]?
    /// The number of availability zones you want to assign per cluster. Currently, FinSpace only support SINGLE for volumes.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// The timestamp at which the volume was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: ClientRuntime.Date?
    /// A description of the volume.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
    public var environmentId: Swift.String?
    /// Specifies the configuration for the Network attached storage (NAS_1) file system volume.
    public var nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
    /// The status of volume creation.
    ///
    /// * CREATING – The volume creation is in progress.
    ///
    /// * CREATE_FAILED – The volume creation has failed.
    ///
    /// * ACTIVE – The volume is active.
    ///
    /// * UPDATING – The volume is in the process of being updated.
    ///
    /// * UPDATE_FAILED – The update action failed.
    ///
    /// * UPDATED – The volume is successfully updated.
    ///
    /// * DELETING – The volume is in the process of being deleted.
    ///
    /// * DELETE_FAILED – The system failed to delete the volume.
    ///
    /// * DELETED – The volume is successfully deleted.
    public var status: FinspaceClientTypes.KxVolumeStatus?
    /// The error message when a failed state occurs.
    public var statusReason: Swift.String?
    /// The ARN identifier of the volume.
    public var volumeArn: Swift.String?
    /// A unique identifier for the volume.
    public var volumeName: Swift.String?
    /// The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
    public var volumeType: FinspaceClientTypes.KxVolumeType?

    public init(
        availabilityZoneIds: [Swift.String]? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        nas1Configuration: FinspaceClientTypes.KxNAS1Configuration? = nil,
        status: FinspaceClientTypes.KxVolumeStatus? = nil,
        statusReason: Swift.String? = nil,
        volumeArn: Swift.String? = nil,
        volumeName: Swift.String? = nil,
        volumeType: FinspaceClientTypes.KxVolumeType? = nil
    )
    {
        self.availabilityZoneIds = availabilityZoneIds
        self.azMode = azMode
        self.createdTimestamp = createdTimestamp
        self.description = description
        self.environmentId = environmentId
        self.nas1Configuration = nas1Configuration
        self.status = status
        self.statusReason = statusReason
        self.volumeArn = volumeArn
        self.volumeName = volumeName
        self.volumeType = volumeType
    }
}

struct CreateKxVolumeOutputBody: Swift.Equatable {
    let environmentId: Swift.String?
    let volumeName: Swift.String?
    let volumeType: FinspaceClientTypes.KxVolumeType?
    let volumeArn: Swift.String?
    let nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
    let status: FinspaceClientTypes.KxVolumeStatus?
    let statusReason: Swift.String?
    let azMode: FinspaceClientTypes.KxAzMode?
    let description: Swift.String?
    let availabilityZoneIds: [Swift.String]?
    let createdTimestamp: ClientRuntime.Date?
}

extension CreateKxVolumeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneIds
        case azMode
        case createdTimestamp
        case description
        case environmentId
        case nas1Configuration
        case status
        case statusReason
        case volumeArn
        case volumeName
        case volumeType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let volumeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeName)
        volumeName = volumeNameDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxVolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeArn)
        volumeArn = volumeArnDecoded
        let nas1ConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxNAS1Configuration.self, forKey: .nas1Configuration)
        nas1Configuration = nas1ConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxVolumeStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let azModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxAzMode.self, forKey: .azMode)
        azMode = azModeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let availabilityZoneIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZoneIds)
        var availabilityZoneIdsDecoded0:[Swift.String]? = nil
        if let availabilityZoneIdsContainer = availabilityZoneIdsContainer {
            availabilityZoneIdsDecoded0 = [Swift.String]()
            for string0 in availabilityZoneIdsContainer {
                if let string0 = string0 {
                    availabilityZoneIdsDecoded0?.append(string0)
                }
            }
        }
        availabilityZoneIds = availabilityZoneIdsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum CreateKxVolumeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FinspaceClientTypes.CustomDNSServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDNSServerIP
        case customDNSServerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customDNSServerIP = self.customDNSServerIP {
            try encodeContainer.encode(customDNSServerIP, forKey: .customDNSServerIP)
        }
        if let customDNSServerName = self.customDNSServerName {
            try encodeContainer.encode(customDNSServerName, forKey: .customDNSServerName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDNSServerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDNSServerName)
        customDNSServerName = customDNSServerNameDecoded
        let customDNSServerIPDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDNSServerIP)
        customDNSServerIP = customDNSServerIPDecoded
    }
}

extension FinspaceClientTypes {
    /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
    public struct CustomDNSServer: Swift.Equatable {
        /// The IP address of the DNS server.
        /// This member is required.
        public var customDNSServerIP: Swift.String?
        /// The name of the DNS server.
        /// This member is required.
        public var customDNSServerName: Swift.String?

        public init(
            customDNSServerIP: Swift.String? = nil,
            customDNSServerName: Swift.String? = nil
        )
        {
            self.customDNSServerIP = customDNSServerIP
            self.customDNSServerName = customDNSServerName
        }
    }

}

extension DeleteEnvironmentInput {

    static func urlPathProvider(_ value: DeleteEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/environment/\(environmentId.urlPercentEncoding())"
    }
}

public struct DeleteEnvironmentInput: Swift.Equatable {
    /// The identifier for the FinSpace environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct DeleteEnvironmentInputBody: Swift.Equatable {
}

extension DeleteEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEnvironmentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteKxClusterInput {

    static func queryItemProvider(_ value: DeleteKxClusterInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteKxClusterInput {

    static func urlPathProvider(_ value: DeleteKxClusterInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let clusterName = value.clusterName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters/\(clusterName.urlPercentEncoding())"
    }
}

public struct DeleteKxClusterInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The name of the cluster that you want to delete.
    /// This member is required.
    public var clusterName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.clusterName = clusterName
        self.environmentId = environmentId
    }
}

struct DeleteKxClusterInputBody: Swift.Equatable {
}

extension DeleteKxClusterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKxClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteKxClusterOutput: Swift.Equatable {

    public init() { }
}

enum DeleteKxClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteKxDatabaseInput {

    static func queryItemProvider(_ value: DeleteKxDatabaseInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let clientToken = value.clientToken else {
            let message = "Creating a URL Query Item failed. clientToken is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
        items.append(clientTokenQueryItem)
        return items
    }
}

extension DeleteKxDatabaseInput {

    static func urlPathProvider(_ value: DeleteKxDatabaseInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())"
    }
}

public struct DeleteKxDatabaseInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The name of the kdb database that you want to delete.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.databaseName = databaseName
        self.environmentId = environmentId
    }
}

struct DeleteKxDatabaseInputBody: Swift.Equatable {
}

extension DeleteKxDatabaseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKxDatabaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteKxDatabaseOutput: Swift.Equatable {

    public init() { }
}

enum DeleteKxDatabaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteKxDataviewInput {

    static func queryItemProvider(_ value: DeleteKxDataviewInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let clientToken = value.clientToken else {
            let message = "Creating a URL Query Item failed. clientToken is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
        items.append(clientTokenQueryItem)
        return items
    }
}

extension DeleteKxDataviewInput {

    static func urlPathProvider(_ value: DeleteKxDataviewInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        guard let dataviewName = value.dataviewName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/dataviews/\(dataviewName.urlPercentEncoding())"
    }
}

public struct DeleteKxDataviewInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The name of the database whose dataview you want to delete.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the dataview that you want to delete.
    /// This member is required.
    public var dataviewName: Swift.String?
    /// A unique identifier for the kdb environment, from where you want to delete the dataview.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        dataviewName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.databaseName = databaseName
        self.dataviewName = dataviewName
        self.environmentId = environmentId
    }
}

struct DeleteKxDataviewInputBody: Swift.Equatable {
}

extension DeleteKxDataviewInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKxDataviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteKxDataviewOutput: Swift.Equatable {

    public init() { }
}

enum DeleteKxDataviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteKxEnvironmentInput {

    static func queryItemProvider(_ value: DeleteKxEnvironmentInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteKxEnvironmentInput {

    static func urlPathProvider(_ value: DeleteKxEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())"
    }
}

public struct DeleteKxEnvironmentInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.environmentId = environmentId
    }
}

struct DeleteKxEnvironmentInputBody: Swift.Equatable {
}

extension DeleteKxEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKxEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteKxEnvironmentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteKxEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteKxScalingGroupInput {

    static func queryItemProvider(_ value: DeleteKxScalingGroupInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteKxScalingGroupInput {

    static func urlPathProvider(_ value: DeleteKxScalingGroupInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let scalingGroupName = value.scalingGroupName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/scalingGroups/\(scalingGroupName.urlPercentEncoding())"
    }
}

public struct DeleteKxScalingGroupInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A unique identifier for the kdb environment, from where you want to delete the dataview.
    /// This member is required.
    public var environmentId: Swift.String?
    /// A unique identifier for the kdb scaling group.
    /// This member is required.
    public var scalingGroupName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        scalingGroupName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.scalingGroupName = scalingGroupName
    }
}

struct DeleteKxScalingGroupInputBody: Swift.Equatable {
}

extension DeleteKxScalingGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKxScalingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteKxScalingGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteKxScalingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteKxUserInput {

    static func queryItemProvider(_ value: DeleteKxUserInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteKxUserInput {

    static func urlPathProvider(_ value: DeleteKxUserInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let userName = value.userName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

public struct DeleteKxUserInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// A unique identifier for the user that you want to delete.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.userName = userName
    }
}

struct DeleteKxUserInputBody: Swift.Equatable {
}

extension DeleteKxUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKxUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteKxUserOutput: Swift.Equatable {

    public init() { }
}

enum DeleteKxUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteKxVolumeInput {

    static func queryItemProvider(_ value: DeleteKxVolumeInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteKxVolumeInput {

    static func urlPathProvider(_ value: DeleteKxVolumeInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let volumeName = value.volumeName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/kxvolumes/\(volumeName.urlPercentEncoding())"
    }
}

public struct DeleteKxVolumeInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The name of the volume that you want to delete.
    /// This member is required.
    public var volumeName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        volumeName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.volumeName = volumeName
    }
}

struct DeleteKxVolumeInputBody: Swift.Equatable {
}

extension DeleteKxVolumeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKxVolumeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteKxVolumeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteKxVolumeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FinspaceClientTypes {
    public enum DnsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failedUpdate
        case `none`
        case successfullyUpdated
        case updateRequested
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DnsStatus] {
            return [
                .failedUpdate,
                .none,
                .successfullyUpdated,
                .updateRequested,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failedUpdate: return "FAILED_UPDATE"
            case .none: return "NONE"
            case .successfullyUpdated: return "SUCCESSFULLY_UPDATED"
            case .updateRequested: return "UPDATE_REQUESTED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DnsStatus(rawValue: rawValue) ?? DnsStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.Environment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case dedicatedServiceAccountId
        case description
        case environmentArn
        case environmentId
        case environmentUrl
        case federationMode
        case federationParameters
        case kmsKeyId
        case name
        case sageMakerStudioDomainUrl
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let dedicatedServiceAccountId = self.dedicatedServiceAccountId {
            try encodeContainer.encode(dedicatedServiceAccountId, forKey: .dedicatedServiceAccountId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentArn = self.environmentArn {
            try encodeContainer.encode(environmentArn, forKey: .environmentArn)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let environmentUrl = self.environmentUrl {
            try encodeContainer.encode(environmentUrl, forKey: .environmentUrl)
        }
        if let federationMode = self.federationMode {
            try encodeContainer.encode(federationMode.rawValue, forKey: .federationMode)
        }
        if let federationParameters = self.federationParameters {
            try encodeContainer.encode(federationParameters, forKey: .federationParameters)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sageMakerStudioDomainUrl = self.sageMakerStudioDomainUrl {
            try encodeContainer.encode(sageMakerStudioDomainUrl, forKey: .sageMakerStudioDomainUrl)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let environmentUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentUrl)
        environmentUrl = environmentUrlDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let sageMakerStudioDomainUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sageMakerStudioDomainUrl)
        sageMakerStudioDomainUrl = sageMakerStudioDomainUrlDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dedicatedServiceAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedServiceAccountId)
        dedicatedServiceAccountId = dedicatedServiceAccountIdDecoded
        let federationModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.FederationMode.self, forKey: .federationMode)
        federationMode = federationModeDecoded
        let federationParametersDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.FederationParameters.self, forKey: .federationParameters)
        federationParameters = federationParametersDecoded
    }
}

extension FinspaceClientTypes {
    /// Represents an FinSpace environment.
    public struct Environment: Swift.Equatable {
        /// The ID of the AWS account in which the FinSpace environment is created.
        public var awsAccountId: Swift.String?
        /// The AWS account ID of the dedicated service account associated with your FinSpace environment.
        public var dedicatedServiceAccountId: Swift.String?
        /// The description of the FinSpace environment.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of your FinSpace environment.
        public var environmentArn: Swift.String?
        /// The identifier of the FinSpace environment.
        public var environmentId: Swift.String?
        /// The sign-in URL for the web application of your FinSpace environment.
        public var environmentUrl: Swift.String?
        /// The authentication mode for the environment.
        public var federationMode: FinspaceClientTypes.FederationMode?
        /// Configuration information when authentication mode is FEDERATED.
        public var federationParameters: FinspaceClientTypes.FederationParameters?
        /// The KMS key id used to encrypt in the FinSpace environment.
        public var kmsKeyId: Swift.String?
        /// The name of the FinSpace environment.
        public var name: Swift.String?
        /// The URL of the integrated FinSpace notebook environment in your web application.
        public var sageMakerStudioDomainUrl: Swift.String?
        /// The current status of creation of the FinSpace environment.
        public var status: FinspaceClientTypes.EnvironmentStatus?

        public init(
            awsAccountId: Swift.String? = nil,
            dedicatedServiceAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            environmentArn: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            environmentUrl: Swift.String? = nil,
            federationMode: FinspaceClientTypes.FederationMode? = nil,
            federationParameters: FinspaceClientTypes.FederationParameters? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            sageMakerStudioDomainUrl: Swift.String? = nil,
            status: FinspaceClientTypes.EnvironmentStatus? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentUrl = environmentUrl
            self.federationMode = federationMode
            self.federationParameters = federationParameters
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.sageMakerStudioDomainUrl = sageMakerStudioDomainUrl
            self.status = status
        }
    }

}

extension FinspaceClientTypes {
    public enum EnvironmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case createRequested
        case creating
        case deleted
        case deleteRequested
        case deleting
        case failedCreation
        case failedDeletion
        case failedUpdatingNetwork
        case retryDeletion
        case suspended
        case updateNetworkRequested
        case updatingNetwork
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentStatus] {
            return [
                .created,
                .createRequested,
                .creating,
                .deleted,
                .deleteRequested,
                .deleting,
                .failedCreation,
                .failedDeletion,
                .failedUpdatingNetwork,
                .retryDeletion,
                .suspended,
                .updateNetworkRequested,
                .updatingNetwork,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .createRequested: return "CREATE_REQUESTED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteRequested: return "DELETE_REQUESTED"
            case .deleting: return "DELETING"
            case .failedCreation: return "FAILED_CREATION"
            case .failedDeletion: return "FAILED_DELETION"
            case .failedUpdatingNetwork: return "FAILED_UPDATING_NETWORK"
            case .retryDeletion: return "RETRY_DELETION"
            case .suspended: return "SUSPENDED"
            case .updateNetworkRequested: return "UPDATE_NETWORK_REQUESTED"
            case .updatingNetwork: return "UPDATING_NETWORK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentStatus(rawValue: rawValue) ?? EnvironmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes {
    public enum ErrorDetails: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case cancelled
        case internalServiceException
        case resourceNotFound
        case serviceQuotaExceeded
        case throttling
        case userRecoverable
        case validation
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorDetails] {
            return [
                .accessDenied,
                .cancelled,
                .internalServiceException,
                .resourceNotFound,
                .serviceQuotaExceeded,
                .throttling,
                .userRecoverable,
                .validation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "Missing required permission to perform this request."
            case .cancelled: return "Cancelled"
            case .internalServiceException: return "An internal error has occurred."
            case .resourceNotFound: return "One or more inputs to this request were not found."
            case .serviceQuotaExceeded: return "Service limits have been exceeded."
            case .throttling: return "The system temporarily lacks sufficient resources to process the request."
            case .userRecoverable: return "A user recoverable error has occurred"
            case .validation: return "The inputs to this request are invalid."
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorDetails(rawValue: rawValue) ?? ErrorDetails.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.ErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
        case errorType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorType = self.errorType {
            try encodeContainer.encode(errorType.rawValue, forKey: .errorType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorTypeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.ErrorDetails.self, forKey: .errorType)
        errorType = errorTypeDecoded
    }
}

extension FinspaceClientTypes {
    /// Provides details in the event of a failed flow, including the error type and the related error message.
    public struct ErrorInfo: Swift.Equatable {
        /// Specifies the error message that appears if a flow fails.
        public var errorMessage: Swift.String?
        /// Specifies the type of error.
        public var errorType: FinspaceClientTypes.ErrorDetails?

        public init(
            errorMessage: Swift.String? = nil,
            errorType: FinspaceClientTypes.ErrorDetails? = nil
        )
        {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }
    }

}

extension FinspaceClientTypes {
    public enum FederationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case federated
        case local
        case sdkUnknown(Swift.String)

        public static var allCases: [FederationMode] {
            return [
                .federated,
                .local,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .federated: return "FEDERATED"
            case .local: return "LOCAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FederationMode(rawValue: rawValue) ?? FederationMode.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.FederationParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationCallBackURL
        case attributeMap
        case federationProviderName
        case federationURN
        case samlMetadataDocument
        case samlMetadataURL
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationCallBackURL = self.applicationCallBackURL {
            try encodeContainer.encode(applicationCallBackURL, forKey: .applicationCallBackURL)
        }
        if let attributeMap = attributeMap {
            var attributeMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributeMap)
            for (dictKey0, attributeMap0) in attributeMap {
                try attributeMapContainer.encode(attributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let federationProviderName = self.federationProviderName {
            try encodeContainer.encode(federationProviderName, forKey: .federationProviderName)
        }
        if let federationURN = self.federationURN {
            try encodeContainer.encode(federationURN, forKey: .federationURN)
        }
        if let samlMetadataDocument = self.samlMetadataDocument {
            try encodeContainer.encode(samlMetadataDocument, forKey: .samlMetadataDocument)
        }
        if let samlMetadataURL = self.samlMetadataURL {
            try encodeContainer.encode(samlMetadataURL, forKey: .samlMetadataURL)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlMetadataDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlMetadataDocument)
        samlMetadataDocument = samlMetadataDocumentDecoded
        let samlMetadataURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlMetadataURL)
        samlMetadataURL = samlMetadataURLDecoded
        let applicationCallBackURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationCallBackURL)
        applicationCallBackURL = applicationCallBackURLDecoded
        let federationURNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .federationURN)
        federationURN = federationURNDecoded
        let federationProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .federationProviderName)
        federationProviderName = federationProviderNameDecoded
        let attributeMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributeMap)
        var attributeMapDecoded0: [Swift.String:Swift.String]? = nil
        if let attributeMapContainer = attributeMapContainer {
            attributeMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, federationattributevalue0) in attributeMapContainer {
                if let federationattributevalue0 = federationattributevalue0 {
                    attributeMapDecoded0?[key0] = federationattributevalue0
                }
            }
        }
        attributeMap = attributeMapDecoded0
    }
}

extension FinspaceClientTypes {
    /// Configuration information when authentication mode is FEDERATED.
    public struct FederationParameters: Swift.Equatable {
        /// The redirect or sign-in URL that should be entered into the SAML 2.0 compliant identity provider configuration (IdP).
        public var applicationCallBackURL: Swift.String?
        /// SAML attribute name and value. The name must always be Email and the value should be set to the attribute definition in which user email is set. For example, name would be Email and value http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress. Please check your SAML 2.0 compliant identity provider (IdP) documentation for details.
        public var attributeMap: [Swift.String:Swift.String]?
        /// Name of the identity provider (IdP).
        public var federationProviderName: Swift.String?
        /// The Uniform Resource Name (URN). Also referred as Service Provider URN or Audience URI or Service Provider Entity ID.
        public var federationURN: Swift.String?
        /// SAML 2.0 Metadata document from identity provider (IdP).
        public var samlMetadataDocument: Swift.String?
        /// Provide the metadata URL from your SAML 2.0 compliant identity provider (IdP).
        public var samlMetadataURL: Swift.String?

        public init(
            applicationCallBackURL: Swift.String? = nil,
            attributeMap: [Swift.String:Swift.String]? = nil,
            federationProviderName: Swift.String? = nil,
            federationURN: Swift.String? = nil,
            samlMetadataDocument: Swift.String? = nil,
            samlMetadataURL: Swift.String? = nil
        )
        {
            self.applicationCallBackURL = applicationCallBackURL
            self.attributeMap = attributeMap
            self.federationProviderName = federationProviderName
            self.federationURN = federationURN
            self.samlMetadataDocument = samlMetadataDocument
            self.samlMetadataURL = samlMetadataURL
        }
    }

}

extension GetEnvironmentInput {

    static func urlPathProvider(_ value: GetEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/environment/\(environmentId.urlPercentEncoding())"
    }
}

public struct GetEnvironmentInput: Swift.Equatable {
    /// The identifier of the FinSpace environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct GetEnvironmentInputBody: Swift.Equatable {
}

extension GetEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct GetEnvironmentOutput: Swift.Equatable {
    /// The name of the FinSpace environment.
    public var environment: FinspaceClientTypes.Environment?

    public init(
        environment: FinspaceClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct GetEnvironmentOutputBody: Swift.Equatable {
    let environment: FinspaceClientTypes.Environment?
}

extension GetEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum GetEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetKxChangesetInput {

    static func urlPathProvider(_ value: GetKxChangesetInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        guard let changesetId = value.changesetId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/changesets/\(changesetId.urlPercentEncoding())"
    }
}

public struct GetKxChangesetInput: Swift.Equatable {
    /// A unique identifier of the changeset for which you want to retrieve data.
    /// This member is required.
    public var changesetId: Swift.String?
    /// The name of the kdb database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        changesetId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.changesetId = changesetId
        self.databaseName = databaseName
        self.environmentId = environmentId
    }
}

struct GetKxChangesetInputBody: Swift.Equatable {
}

extension GetKxChangesetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKxChangesetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKxChangesetOutputBody = try responseDecoder.decode(responseBody: data)
            self.activeFromTimestamp = output.activeFromTimestamp
            self.changeRequests = output.changeRequests
            self.changesetId = output.changesetId
            self.createdTimestamp = output.createdTimestamp
            self.databaseName = output.databaseName
            self.environmentId = output.environmentId
            self.errorInfo = output.errorInfo
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.status = output.status
        } else {
            self.activeFromTimestamp = nil
            self.changeRequests = nil
            self.changesetId = nil
            self.createdTimestamp = nil
            self.databaseName = nil
            self.environmentId = nil
            self.errorInfo = nil
            self.lastModifiedTimestamp = nil
            self.status = nil
        }
    }
}

public struct GetKxChangesetOutput: Swift.Equatable {
    /// Beginning time from which the changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var activeFromTimestamp: ClientRuntime.Date?
    /// A list of change request objects that are run in order.
    public var changeRequests: [FinspaceClientTypes.ChangeRequest]?
    /// A unique identifier for the changeset.
    public var changesetId: Swift.String?
    /// The timestamp at which the changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: ClientRuntime.Date?
    /// The name of the kdb database.
    public var databaseName: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// Provides details in the event of a failed flow, including the error type and the related error message.
    public var errorInfo: FinspaceClientTypes.ErrorInfo?
    /// The timestamp at which the changeset was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// Status of the changeset creation process.
    ///
    /// * Pending – Changeset creation is pending.
    ///
    /// * Processing – Changeset creation is running.
    ///
    /// * Failed – Changeset creation has failed.
    ///
    /// * Complete – Changeset creation has succeeded.
    public var status: FinspaceClientTypes.ChangesetStatus?

    public init(
        activeFromTimestamp: ClientRuntime.Date? = nil,
        changeRequests: [FinspaceClientTypes.ChangeRequest]? = nil,
        changesetId: Swift.String? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        errorInfo: FinspaceClientTypes.ErrorInfo? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        status: FinspaceClientTypes.ChangesetStatus? = nil
    )
    {
        self.activeFromTimestamp = activeFromTimestamp
        self.changeRequests = changeRequests
        self.changesetId = changesetId
        self.createdTimestamp = createdTimestamp
        self.databaseName = databaseName
        self.environmentId = environmentId
        self.errorInfo = errorInfo
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.status = status
    }
}

struct GetKxChangesetOutputBody: Swift.Equatable {
    let changesetId: Swift.String?
    let databaseName: Swift.String?
    let environmentId: Swift.String?
    let changeRequests: [FinspaceClientTypes.ChangeRequest]?
    let createdTimestamp: ClientRuntime.Date?
    let activeFromTimestamp: ClientRuntime.Date?
    let lastModifiedTimestamp: ClientRuntime.Date?
    let status: FinspaceClientTypes.ChangesetStatus?
    let errorInfo: FinspaceClientTypes.ErrorInfo?
}

extension GetKxChangesetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeFromTimestamp
        case changeRequests
        case changesetId
        case createdTimestamp
        case databaseName
        case environmentId
        case errorInfo
        case lastModifiedTimestamp
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let changeRequestsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.ChangeRequest?].self, forKey: .changeRequests)
        var changeRequestsDecoded0:[FinspaceClientTypes.ChangeRequest]? = nil
        if let changeRequestsContainer = changeRequestsContainer {
            changeRequestsDecoded0 = [FinspaceClientTypes.ChangeRequest]()
            for structure0 in changeRequestsContainer {
                if let structure0 = structure0 {
                    changeRequestsDecoded0?.append(structure0)
                }
            }
        }
        changeRequests = changeRequestsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let activeFromTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .activeFromTimestamp)
        activeFromTimestamp = activeFromTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.ChangesetStatus.self, forKey: .status)
        status = statusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
    }
}

enum GetKxChangesetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetKxClusterInput {

    static func urlPathProvider(_ value: GetKxClusterInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let clusterName = value.clusterName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters/\(clusterName.urlPercentEncoding())"
    }
}

public struct GetKxClusterInput: Swift.Equatable {
    /// The name of the cluster that you want to retrieve.
    /// This member is required.
    public var clusterName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clusterName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.environmentId = environmentId
    }
}

struct GetKxClusterInputBody: Swift.Equatable {
}

extension GetKxClusterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKxClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKxClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingConfiguration = output.autoScalingConfiguration
            self.availabilityZoneId = output.availabilityZoneId
            self.azMode = output.azMode
            self.cacheStorageConfigurations = output.cacheStorageConfigurations
            self.capacityConfiguration = output.capacityConfiguration
            self.clusterDescription = output.clusterDescription
            self.clusterName = output.clusterName
            self.clusterType = output.clusterType
            self.code = output.code
            self.commandLineArguments = output.commandLineArguments
            self.createdTimestamp = output.createdTimestamp
            self.databases = output.databases
            self.executionRole = output.executionRole
            self.initializationScript = output.initializationScript
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.releaseLabel = output.releaseLabel
            self.savedownStorageConfiguration = output.savedownStorageConfiguration
            self.scalingGroupConfiguration = output.scalingGroupConfiguration
            self.status = output.status
            self.statusReason = output.statusReason
            self.tickerplantLogConfiguration = output.tickerplantLogConfiguration
            self.volumes = output.volumes
            self.vpcConfiguration = output.vpcConfiguration
        } else {
            self.autoScalingConfiguration = nil
            self.availabilityZoneId = nil
            self.azMode = nil
            self.cacheStorageConfigurations = nil
            self.capacityConfiguration = nil
            self.clusterDescription = nil
            self.clusterName = nil
            self.clusterType = nil
            self.code = nil
            self.commandLineArguments = nil
            self.createdTimestamp = nil
            self.databases = nil
            self.executionRole = nil
            self.initializationScript = nil
            self.lastModifiedTimestamp = nil
            self.releaseLabel = nil
            self.savedownStorageConfiguration = nil
            self.scalingGroupConfiguration = nil
            self.status = nil
            self.statusReason = nil
            self.tickerplantLogConfiguration = nil
            self.volumes = nil
            self.vpcConfiguration = nil
        }
    }
}

public struct GetKxClusterOutput: Swift.Equatable {
    /// The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
    public var autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration?
    /// The availability zone identifiers for the requested regions.
    public var availabilityZoneId: Swift.String?
    /// The number of availability zones you want to assign per cluster. This can be one of the following
    ///
    /// * SINGLE – Assigns one availability zone per cluster.
    ///
    /// * MULTI – Assigns all the availability zones per cluster.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store.
    public var cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]?
    /// A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, and number of instances.
    public var capacityConfiguration: FinspaceClientTypes.CapacityConfiguration?
    /// A description of the cluster.
    public var clusterDescription: Swift.String?
    /// A unique name for the cluster.
    public var clusterName: Swift.String?
    /// Specifies the type of KDB database that is being created. The following types are available:
    ///
    /// * HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.
    ///
    /// * RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.
    ///
    /// * GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.
    ///
    /// * GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.
    ///
    /// * Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
    public var clusterType: FinspaceClientTypes.KxClusterType?
    /// The details of the custom code that you want to use inside a cluster when analyzing a data. It consists of the S3 source bucket, location, S3 object version, and the relative path from where the custom code is loaded into the cluster.
    public var code: FinspaceClientTypes.CodeConfiguration?
    /// Defines key-value pairs to make them available inside the cluster.
    public var commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]?
    /// The timestamp at which the cluster was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: ClientRuntime.Date?
    /// A list of databases mounted on the cluster.
    public var databases: [FinspaceClientTypes.KxDatabaseConfiguration]?
    /// An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
    public var executionRole: Swift.String?
    /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
    public var initializationScript: Swift.String?
    /// The last time that the cluster was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The version of FinSpace managed kdb to run.
    public var releaseLabel: Swift.String?
    /// The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted.
    public var savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration?
    /// The structure that stores the capacity configuration details of a scaling group.
    public var scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration?
    /// The status of cluster creation.
    ///
    /// * PENDING – The cluster is pending creation.
    ///
    /// * CREATING – The cluster creation process is in progress.
    ///
    /// * CREATE_FAILED – The cluster creation process has failed.
    ///
    /// * RUNNING – The cluster creation process is running.
    ///
    /// * UPDATING – The cluster is in the process of being updated.
    ///
    /// * DELETING – The cluster is in the process of being deleted.
    ///
    /// * DELETED – The cluster has been deleted.
    ///
    /// * DELETE_FAILED – The cluster failed to delete.
    public var status: FinspaceClientTypes.KxClusterStatus?
    /// The error message when a failed state occurs.
    public var statusReason: Swift.String?
    /// A configuration to store the Tickerplant logs. It consists of a list of volumes that will be mounted to your cluster. For the cluster type Tickerplant, the location of the TP volume on the cluster will be available by using the global variable .aws.tp_log_path.
    public var tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration?
    /// A list of volumes attached to the cluster.
    public var volumes: [FinspaceClientTypes.Volume]?
    /// Configuration details about the network where the Privatelink endpoint of the cluster resides.
    public var vpcConfiguration: FinspaceClientTypes.VpcConfiguration?

    public init(
        autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration? = nil,
        availabilityZoneId: Swift.String? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]? = nil,
        capacityConfiguration: FinspaceClientTypes.CapacityConfiguration? = nil,
        clusterDescription: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        clusterType: FinspaceClientTypes.KxClusterType? = nil,
        code: FinspaceClientTypes.CodeConfiguration? = nil,
        commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        databases: [FinspaceClientTypes.KxDatabaseConfiguration]? = nil,
        executionRole: Swift.String? = nil,
        initializationScript: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        releaseLabel: Swift.String? = nil,
        savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration? = nil,
        scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration? = nil,
        status: FinspaceClientTypes.KxClusterStatus? = nil,
        statusReason: Swift.String? = nil,
        tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration? = nil,
        volumes: [FinspaceClientTypes.Volume]? = nil,
        vpcConfiguration: FinspaceClientTypes.VpcConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
        self.availabilityZoneId = availabilityZoneId
        self.azMode = azMode
        self.cacheStorageConfigurations = cacheStorageConfigurations
        self.capacityConfiguration = capacityConfiguration
        self.clusterDescription = clusterDescription
        self.clusterName = clusterName
        self.clusterType = clusterType
        self.code = code
        self.commandLineArguments = commandLineArguments
        self.createdTimestamp = createdTimestamp
        self.databases = databases
        self.executionRole = executionRole
        self.initializationScript = initializationScript
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.releaseLabel = releaseLabel
        self.savedownStorageConfiguration = savedownStorageConfiguration
        self.scalingGroupConfiguration = scalingGroupConfiguration
        self.status = status
        self.statusReason = statusReason
        self.tickerplantLogConfiguration = tickerplantLogConfiguration
        self.volumes = volumes
        self.vpcConfiguration = vpcConfiguration
    }
}

struct GetKxClusterOutputBody: Swift.Equatable {
    let status: FinspaceClientTypes.KxClusterStatus?
    let statusReason: Swift.String?
    let clusterName: Swift.String?
    let clusterType: FinspaceClientTypes.KxClusterType?
    let tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration?
    let volumes: [FinspaceClientTypes.Volume]?
    let databases: [FinspaceClientTypes.KxDatabaseConfiguration]?
    let cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]?
    let autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration?
    let clusterDescription: Swift.String?
    let capacityConfiguration: FinspaceClientTypes.CapacityConfiguration?
    let releaseLabel: Swift.String?
    let vpcConfiguration: FinspaceClientTypes.VpcConfiguration?
    let initializationScript: Swift.String?
    let commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]?
    let code: FinspaceClientTypes.CodeConfiguration?
    let executionRole: Swift.String?
    let lastModifiedTimestamp: ClientRuntime.Date?
    let savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration?
    let azMode: FinspaceClientTypes.KxAzMode?
    let availabilityZoneId: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
    let scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration?
}

extension GetKxClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfiguration
        case availabilityZoneId
        case azMode
        case cacheStorageConfigurations
        case capacityConfiguration
        case clusterDescription
        case clusterName
        case clusterType
        case code
        case commandLineArguments
        case createdTimestamp
        case databases
        case executionRole
        case initializationScript
        case lastModifiedTimestamp
        case releaseLabel
        case savedownStorageConfiguration
        case scalingGroupConfiguration
        case status
        case statusReason
        case tickerplantLogConfiguration
        case volumes
        case vpcConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxClusterStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxClusterType.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let tickerplantLogConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.TickerplantLogConfiguration.self, forKey: .tickerplantLogConfiguration)
        tickerplantLogConfiguration = tickerplantLogConfigurationDecoded
        let volumesContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.Volume?].self, forKey: .volumes)
        var volumesDecoded0:[FinspaceClientTypes.Volume]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [FinspaceClientTypes.Volume]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
        let databasesContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDatabaseConfiguration?].self, forKey: .databases)
        var databasesDecoded0:[FinspaceClientTypes.KxDatabaseConfiguration]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [FinspaceClientTypes.KxDatabaseConfiguration]()
            for structure0 in databasesContainer {
                if let structure0 = structure0 {
                    databasesDecoded0?.append(structure0)
                }
            }
        }
        databases = databasesDecoded0
        let cacheStorageConfigurationsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxCacheStorageConfiguration?].self, forKey: .cacheStorageConfigurations)
        var cacheStorageConfigurationsDecoded0:[FinspaceClientTypes.KxCacheStorageConfiguration]? = nil
        if let cacheStorageConfigurationsContainer = cacheStorageConfigurationsContainer {
            cacheStorageConfigurationsDecoded0 = [FinspaceClientTypes.KxCacheStorageConfiguration]()
            for structure0 in cacheStorageConfigurationsContainer {
                if let structure0 = structure0 {
                    cacheStorageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        cacheStorageConfigurations = cacheStorageConfigurationsDecoded0
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
        let clusterDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterDescription)
        clusterDescription = clusterDescriptionDecoded
        let capacityConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.CapacityConfiguration.self, forKey: .capacityConfiguration)
        capacityConfiguration = capacityConfigurationDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let initializationScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initializationScript)
        initializationScript = initializationScriptDecoded
        let commandLineArgumentsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxCommandLineArgument?].self, forKey: .commandLineArguments)
        var commandLineArgumentsDecoded0:[FinspaceClientTypes.KxCommandLineArgument]? = nil
        if let commandLineArgumentsContainer = commandLineArgumentsContainer {
            commandLineArgumentsDecoded0 = [FinspaceClientTypes.KxCommandLineArgument]()
            for structure0 in commandLineArgumentsContainer {
                if let structure0 = structure0 {
                    commandLineArgumentsDecoded0?.append(structure0)
                }
            }
        }
        commandLineArguments = commandLineArgumentsDecoded0
        let codeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.CodeConfiguration.self, forKey: .code)
        code = codeDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let savedownStorageConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxSavedownStorageConfiguration.self, forKey: .savedownStorageConfiguration)
        savedownStorageConfiguration = savedownStorageConfigurationDecoded
        let azModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxAzMode.self, forKey: .azMode)
        azMode = azModeDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let scalingGroupConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxScalingGroupConfiguration.self, forKey: .scalingGroupConfiguration)
        scalingGroupConfiguration = scalingGroupConfigurationDecoded
    }
}

enum GetKxClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetKxConnectionStringInput {

    static func queryItemProvider(_ value: GetKxConnectionStringInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let clusterName = value.clusterName else {
            let message = "Creating a URL Query Item failed. clusterName is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let clusterNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "clusterName".urlPercentEncoding(), value: Swift.String(clusterName).urlPercentEncoding())
        items.append(clusterNameQueryItem)
        guard let userArn = value.userArn else {
            let message = "Creating a URL Query Item failed. userArn is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let userArnQueryItem = ClientRuntime.SDKURLQueryItem(name: "userArn".urlPercentEncoding(), value: Swift.String(userArn).urlPercentEncoding())
        items.append(userArnQueryItem)
        return items
    }
}

extension GetKxConnectionStringInput {

    static func urlPathProvider(_ value: GetKxConnectionStringInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/connectionString"
    }
}

public struct GetKxConnectionStringInput: Swift.Equatable {
    /// A name of the kdb cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        clusterName: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.environmentId = environmentId
        self.userArn = userArn
    }
}

struct GetKxConnectionStringInputBody: Swift.Equatable {
}

extension GetKxConnectionStringInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKxConnectionStringOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKxConnectionStringOutput(signedConnectionString: \"CONTENT_REDACTED\")"}
}

extension GetKxConnectionStringOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKxConnectionStringOutputBody = try responseDecoder.decode(responseBody: data)
            self.signedConnectionString = output.signedConnectionString
        } else {
            self.signedConnectionString = nil
        }
    }
}

public struct GetKxConnectionStringOutput: Swift.Equatable {
    /// The signed connection string that you can use to connect to clusters.
    public var signedConnectionString: Swift.String?

    public init(
        signedConnectionString: Swift.String? = nil
    )
    {
        self.signedConnectionString = signedConnectionString
    }
}

struct GetKxConnectionStringOutputBody: Swift.Equatable {
    let signedConnectionString: Swift.String?
}

extension GetKxConnectionStringOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signedConnectionString
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signedConnectionStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signedConnectionString)
        signedConnectionString = signedConnectionStringDecoded
    }
}

enum GetKxConnectionStringOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetKxDatabaseInput {

    static func urlPathProvider(_ value: GetKxDatabaseInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())"
    }
}

public struct GetKxDatabaseInput: Swift.Equatable {
    /// The name of the kdb database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.environmentId = environmentId
    }
}

struct GetKxDatabaseInputBody: Swift.Equatable {
}

extension GetKxDatabaseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKxDatabaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKxDatabaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.databaseArn = output.databaseArn
            self.databaseName = output.databaseName
            self.description = output.description
            self.environmentId = output.environmentId
            self.lastCompletedChangesetId = output.lastCompletedChangesetId
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.numBytes = output.numBytes
            self.numChangesets = output.numChangesets
            self.numFiles = output.numFiles
        } else {
            self.createdTimestamp = nil
            self.databaseArn = nil
            self.databaseName = nil
            self.description = nil
            self.environmentId = nil
            self.lastCompletedChangesetId = nil
            self.lastModifiedTimestamp = nil
            self.numBytes = 0
            self.numChangesets = 0
            self.numFiles = 0
        }
    }
}

public struct GetKxDatabaseOutput: Swift.Equatable {
    /// The timestamp at which the database is created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: ClientRuntime.Date?
    /// The ARN identifier of the database.
    public var databaseArn: Swift.String?
    /// The name of the kdb database for which the information is retrieved.
    public var databaseName: Swift.String?
    /// A description of the database.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// A unique identifier for the changeset.
    public var lastCompletedChangesetId: Swift.String?
    /// The last time that the database was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The total number of bytes in the database.
    public var numBytes: Swift.Int
    /// The total number of changesets in the database.
    public var numChangesets: Swift.Int
    /// The total number of files in the database.
    public var numFiles: Swift.Int

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        databaseArn: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastCompletedChangesetId: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        numBytes: Swift.Int = 0,
        numChangesets: Swift.Int = 0,
        numFiles: Swift.Int = 0
    )
    {
        self.createdTimestamp = createdTimestamp
        self.databaseArn = databaseArn
        self.databaseName = databaseName
        self.description = description
        self.environmentId = environmentId
        self.lastCompletedChangesetId = lastCompletedChangesetId
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.numBytes = numBytes
        self.numChangesets = numChangesets
        self.numFiles = numFiles
    }
}

struct GetKxDatabaseOutputBody: Swift.Equatable {
    let databaseName: Swift.String?
    let databaseArn: Swift.String?
    let environmentId: Swift.String?
    let description: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
    let lastModifiedTimestamp: ClientRuntime.Date?
    let lastCompletedChangesetId: Swift.String?
    let numBytes: Swift.Int
    let numChangesets: Swift.Int
    let numFiles: Swift.Int
}

extension GetKxDatabaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp
        case databaseArn
        case databaseName
        case description
        case environmentId
        case lastCompletedChangesetId
        case lastModifiedTimestamp
        case numBytes
        case numChangesets
        case numFiles
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let databaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseArn)
        databaseArn = databaseArnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let lastCompletedChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastCompletedChangesetId)
        lastCompletedChangesetId = lastCompletedChangesetIdDecoded
        let numBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numBytes) ?? 0
        numBytes = numBytesDecoded
        let numChangesetsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numChangesets) ?? 0
        numChangesets = numChangesetsDecoded
        let numFilesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numFiles) ?? 0
        numFiles = numFilesDecoded
    }
}

enum GetKxDatabaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetKxDataviewInput {

    static func urlPathProvider(_ value: GetKxDataviewInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        guard let dataviewName = value.dataviewName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/dataviews/\(dataviewName.urlPercentEncoding())"
    }
}

public struct GetKxDataviewInput: Swift.Equatable {
    /// The name of the database where you created the dataview.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier for the dataview.
    /// This member is required.
    public var dataviewName: Swift.String?
    /// A unique identifier for the kdb environment, from where you want to retrieve the dataview details.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        dataviewName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.dataviewName = dataviewName
        self.environmentId = environmentId
    }
}

struct GetKxDataviewInputBody: Swift.Equatable {
}

extension GetKxDataviewInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKxDataviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKxDataviewOutputBody = try responseDecoder.decode(responseBody: data)
            self.activeVersions = output.activeVersions
            self.autoUpdate = output.autoUpdate
            self.availabilityZoneId = output.availabilityZoneId
            self.azMode = output.azMode
            self.changesetId = output.changesetId
            self.createdTimestamp = output.createdTimestamp
            self.databaseName = output.databaseName
            self.dataviewName = output.dataviewName
            self.description = output.description
            self.environmentId = output.environmentId
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.segmentConfigurations = output.segmentConfigurations
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.activeVersions = nil
            self.autoUpdate = false
            self.availabilityZoneId = nil
            self.azMode = nil
            self.changesetId = nil
            self.createdTimestamp = nil
            self.databaseName = nil
            self.dataviewName = nil
            self.description = nil
            self.environmentId = nil
            self.lastModifiedTimestamp = nil
            self.segmentConfigurations = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct GetKxDataviewOutput: Swift.Equatable {
    /// The current active changeset versions of the database on the given dataview.
    public var activeVersions: [FinspaceClientTypes.KxDataviewActiveVersion]?
    /// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview when new changesets are ingested. The default value is false.
    public var autoUpdate: Swift.Bool
    /// The identifier of the availability zones.
    public var availabilityZoneId: Swift.String?
    /// The number of availability zones you want to assign per cluster. This can be one of the following
    ///
    /// * SINGLE – Assigns one availability zone per cluster.
    ///
    /// * MULTI – Assigns all the availability zones per cluster.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// A unique identifier of the changeset that you want to use to ingest data.
    public var changesetId: Swift.String?
    /// The timestamp at which the dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: ClientRuntime.Date?
    /// The name of the database where you created the dataview.
    public var databaseName: Swift.String?
    /// A unique identifier for the dataview.
    public var dataviewName: Swift.String?
    /// A description of the dataview.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, from where you want to retrieve the dataview details.
    public var environmentId: Swift.String?
    /// The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
    public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
    /// The status of dataview creation.
    ///
    /// * CREATING – The dataview creation is in progress.
    ///
    /// * UPDATING – The dataview is in the process of being updated.
    ///
    /// * ACTIVE – The dataview is active.
    public var status: FinspaceClientTypes.KxDataviewStatus?
    /// The error message when a failed state occurs.
    public var statusReason: Swift.String?

    public init(
        activeVersions: [FinspaceClientTypes.KxDataviewActiveVersion]? = nil,
        autoUpdate: Swift.Bool = false,
        availabilityZoneId: Swift.String? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        changesetId: Swift.String? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        databaseName: Swift.String? = nil,
        dataviewName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil,
        status: FinspaceClientTypes.KxDataviewStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.activeVersions = activeVersions
        self.autoUpdate = autoUpdate
        self.availabilityZoneId = availabilityZoneId
        self.azMode = azMode
        self.changesetId = changesetId
        self.createdTimestamp = createdTimestamp
        self.databaseName = databaseName
        self.dataviewName = dataviewName
        self.description = description
        self.environmentId = environmentId
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.segmentConfigurations = segmentConfigurations
        self.status = status
        self.statusReason = statusReason
    }
}

struct GetKxDataviewOutputBody: Swift.Equatable {
    let databaseName: Swift.String?
    let dataviewName: Swift.String?
    let azMode: FinspaceClientTypes.KxAzMode?
    let availabilityZoneId: Swift.String?
    let changesetId: Swift.String?
    let segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
    let activeVersions: [FinspaceClientTypes.KxDataviewActiveVersion]?
    let description: Swift.String?
    let autoUpdate: Swift.Bool
    let environmentId: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
    let lastModifiedTimestamp: ClientRuntime.Date?
    let status: FinspaceClientTypes.KxDataviewStatus?
    let statusReason: Swift.String?
}

extension GetKxDataviewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeVersions
        case autoUpdate
        case availabilityZoneId
        case azMode
        case changesetId
        case createdTimestamp
        case databaseName
        case dataviewName
        case description
        case environmentId
        case lastModifiedTimestamp
        case segmentConfigurations
        case status
        case statusReason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dataviewNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataviewName)
        dataviewName = dataviewNameDecoded
        let azModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxAzMode.self, forKey: .azMode)
        azMode = azModeDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let segmentConfigurationsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDataviewSegmentConfiguration?].self, forKey: .segmentConfigurations)
        var segmentConfigurationsDecoded0:[FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil
        if let segmentConfigurationsContainer = segmentConfigurationsContainer {
            segmentConfigurationsDecoded0 = [FinspaceClientTypes.KxDataviewSegmentConfiguration]()
            for structure0 in segmentConfigurationsContainer {
                if let structure0 = structure0 {
                    segmentConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        segmentConfigurations = segmentConfigurationsDecoded0
        let activeVersionsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDataviewActiveVersion?].self, forKey: .activeVersions)
        var activeVersionsDecoded0:[FinspaceClientTypes.KxDataviewActiveVersion]? = nil
        if let activeVersionsContainer = activeVersionsContainer {
            activeVersionsDecoded0 = [FinspaceClientTypes.KxDataviewActiveVersion]()
            for structure0 in activeVersionsContainer {
                if let structure0 = structure0 {
                    activeVersionsDecoded0?.append(structure0)
                }
            }
        }
        activeVersions = activeVersionsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let autoUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoUpdate) ?? false
        autoUpdate = autoUpdateDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxDataviewStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

enum GetKxDataviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetKxEnvironmentInput {

    static func urlPathProvider(_ value: GetKxEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())"
    }
}

public struct GetKxEnvironmentInput: Swift.Equatable {
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct GetKxEnvironmentInputBody: Swift.Equatable {
}

extension GetKxEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKxEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKxEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZoneIds = output.availabilityZoneIds
            self.awsAccountId = output.awsAccountId
            self.certificateAuthorityArn = output.certificateAuthorityArn
            self.creationTimestamp = output.creationTimestamp
            self.customDNSConfiguration = output.customDNSConfiguration
            self.dedicatedServiceAccountId = output.dedicatedServiceAccountId
            self.description = output.description
            self.dnsStatus = output.dnsStatus
            self.environmentArn = output.environmentArn
            self.environmentId = output.environmentId
            self.errorMessage = output.errorMessage
            self.kmsKeyId = output.kmsKeyId
            self.name = output.name
            self.status = output.status
            self.tgwStatus = output.tgwStatus
            self.transitGatewayConfiguration = output.transitGatewayConfiguration
            self.updateTimestamp = output.updateTimestamp
        } else {
            self.availabilityZoneIds = nil
            self.awsAccountId = nil
            self.certificateAuthorityArn = nil
            self.creationTimestamp = nil
            self.customDNSConfiguration = nil
            self.dedicatedServiceAccountId = nil
            self.description = nil
            self.dnsStatus = nil
            self.environmentArn = nil
            self.environmentId = nil
            self.errorMessage = nil
            self.kmsKeyId = nil
            self.name = nil
            self.status = nil
            self.tgwStatus = nil
            self.transitGatewayConfiguration = nil
            self.updateTimestamp = nil
        }
    }
}

public struct GetKxEnvironmentOutput: Swift.Equatable {
    /// The identifier of the availability zones where subnets for the environment are created.
    public var availabilityZoneIds: [Swift.String]?
    /// The unique identifier of the AWS account that is used to create the kdb environment.
    public var awsAccountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the certificate authority of the kdb environment.
    public var certificateAuthorityArn: Swift.String?
    /// The timestamp at which the kdb environment was created in FinSpace.
    public var creationTimestamp: ClientRuntime.Date?
    /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
    public var customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]?
    /// A unique identifier for the AWS environment infrastructure account.
    public var dedicatedServiceAccountId: Swift.String?
    /// A description for the kdb environment.
    public var description: Swift.String?
    /// The status of DNS configuration.
    public var dnsStatus: FinspaceClientTypes.DnsStatus?
    /// The ARN identifier of the environment.
    public var environmentArn: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// Specifies the error message that appears if a flow fails.
    public var errorMessage: Swift.String?
    /// The KMS key ID to encrypt your data in the FinSpace environment.
    public var kmsKeyId: Swift.String?
    /// The name of the kdb environment.
    public var name: Swift.String?
    /// The status of the kdb environment.
    public var status: FinspaceClientTypes.EnvironmentStatus?
    /// The status of the network configuration.
    public var tgwStatus: FinspaceClientTypes.TgwStatus?
    /// The structure of the transit gateway and network configuration that is used to connect the kdb environment to an internal network.
    public var transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration?
    /// The timestamp at which the kdb environment was updated.
    public var updateTimestamp: ClientRuntime.Date?

    public init(
        availabilityZoneIds: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        certificateAuthorityArn: Swift.String? = nil,
        creationTimestamp: ClientRuntime.Date? = nil,
        customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]? = nil,
        dedicatedServiceAccountId: Swift.String? = nil,
        description: Swift.String? = nil,
        dnsStatus: FinspaceClientTypes.DnsStatus? = nil,
        environmentArn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: FinspaceClientTypes.EnvironmentStatus? = nil,
        tgwStatus: FinspaceClientTypes.TgwStatus? = nil,
        transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration? = nil,
        updateTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.availabilityZoneIds = availabilityZoneIds
        self.awsAccountId = awsAccountId
        self.certificateAuthorityArn = certificateAuthorityArn
        self.creationTimestamp = creationTimestamp
        self.customDNSConfiguration = customDNSConfiguration
        self.dedicatedServiceAccountId = dedicatedServiceAccountId
        self.description = description
        self.dnsStatus = dnsStatus
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.status = status
        self.tgwStatus = tgwStatus
        self.transitGatewayConfiguration = transitGatewayConfiguration
        self.updateTimestamp = updateTimestamp
    }
}

struct GetKxEnvironmentOutputBody: Swift.Equatable {
    let name: Swift.String?
    let environmentId: Swift.String?
    let awsAccountId: Swift.String?
    let status: FinspaceClientTypes.EnvironmentStatus?
    let tgwStatus: FinspaceClientTypes.TgwStatus?
    let dnsStatus: FinspaceClientTypes.DnsStatus?
    let errorMessage: Swift.String?
    let description: Swift.String?
    let environmentArn: Swift.String?
    let kmsKeyId: Swift.String?
    let dedicatedServiceAccountId: Swift.String?
    let transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration?
    let customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]?
    let creationTimestamp: ClientRuntime.Date?
    let updateTimestamp: ClientRuntime.Date?
    let availabilityZoneIds: [Swift.String]?
    let certificateAuthorityArn: Swift.String?
}

extension GetKxEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneIds
        case awsAccountId
        case certificateAuthorityArn
        case creationTimestamp
        case customDNSConfiguration
        case dedicatedServiceAccountId
        case description
        case dnsStatus
        case environmentArn
        case environmentId
        case errorMessage
        case kmsKeyId
        case name
        case status
        case tgwStatus
        case transitGatewayConfiguration
        case updateTimestamp
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let tgwStatusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.TgwStatus.self, forKey: .tgwStatus)
        tgwStatus = tgwStatusDecoded
        let dnsStatusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.DnsStatus.self, forKey: .dnsStatus)
        dnsStatus = dnsStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dedicatedServiceAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedServiceAccountId)
        dedicatedServiceAccountId = dedicatedServiceAccountIdDecoded
        let transitGatewayConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.TransitGatewayConfiguration.self, forKey: .transitGatewayConfiguration)
        transitGatewayConfiguration = transitGatewayConfigurationDecoded
        let customDNSConfigurationContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.CustomDNSServer?].self, forKey: .customDNSConfiguration)
        var customDNSConfigurationDecoded0:[FinspaceClientTypes.CustomDNSServer]? = nil
        if let customDNSConfigurationContainer = customDNSConfigurationContainer {
            customDNSConfigurationDecoded0 = [FinspaceClientTypes.CustomDNSServer]()
            for structure0 in customDNSConfigurationContainer {
                if let structure0 = structure0 {
                    customDNSConfigurationDecoded0?.append(structure0)
                }
            }
        }
        customDNSConfiguration = customDNSConfigurationDecoded0
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let updateTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTimestamp)
        updateTimestamp = updateTimestampDecoded
        let availabilityZoneIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZoneIds)
        var availabilityZoneIdsDecoded0:[Swift.String]? = nil
        if let availabilityZoneIdsContainer = availabilityZoneIdsContainer {
            availabilityZoneIdsDecoded0 = [Swift.String]()
            for string0 in availabilityZoneIdsContainer {
                if let string0 = string0 {
                    availabilityZoneIdsDecoded0?.append(string0)
                }
            }
        }
        availabilityZoneIds = availabilityZoneIdsDecoded0
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

enum GetKxEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetKxScalingGroupInput {

    static func urlPathProvider(_ value: GetKxScalingGroupInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let scalingGroupName = value.scalingGroupName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/scalingGroups/\(scalingGroupName.urlPercentEncoding())"
    }
}

public struct GetKxScalingGroupInput: Swift.Equatable {
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// A unique identifier for the kdb scaling group.
    /// This member is required.
    public var scalingGroupName: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        scalingGroupName: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.scalingGroupName = scalingGroupName
    }
}

struct GetKxScalingGroupInputBody: Swift.Equatable {
}

extension GetKxScalingGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKxScalingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKxScalingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZoneId = output.availabilityZoneId
            self.clusters = output.clusters
            self.createdTimestamp = output.createdTimestamp
            self.hostType = output.hostType
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.scalingGroupArn = output.scalingGroupArn
            self.scalingGroupName = output.scalingGroupName
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.availabilityZoneId = nil
            self.clusters = nil
            self.createdTimestamp = nil
            self.hostType = nil
            self.lastModifiedTimestamp = nil
            self.scalingGroupArn = nil
            self.scalingGroupName = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct GetKxScalingGroupOutput: Swift.Equatable {
    /// The identifier of the availability zones.
    public var availabilityZoneId: Swift.String?
    /// The list of Managed kdb clusters that are currently active in the given scaling group.
    public var clusters: [Swift.String]?
    /// The timestamp at which the scaling group was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: ClientRuntime.Date?
    /// The memory and CPU capabilities of the scaling group host on which FinSpace Managed kdb clusters will be placed.
    public var hostType: Swift.String?
    /// The last time that the scaling group was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The ARN identifier for the scaling group.
    public var scalingGroupArn: Swift.String?
    /// A unique identifier for the kdb scaling group.
    public var scalingGroupName: Swift.String?
    /// The status of scaling group.
    ///
    /// * CREATING – The scaling group creation is in progress.
    ///
    /// * CREATE_FAILED – The scaling group creation has failed.
    ///
    /// * ACTIVE – The scaling group is active.
    ///
    /// * UPDATING – The scaling group is in the process of being updated.
    ///
    /// * UPDATE_FAILED – The update action failed.
    ///
    /// * DELETING – The scaling group is in the process of being deleted.
    ///
    /// * DELETE_FAILED – The system failed to delete the scaling group.
    ///
    /// * DELETED – The scaling group is successfully deleted.
    public var status: FinspaceClientTypes.KxScalingGroupStatus?
    /// The error message when a failed state occurs.
    public var statusReason: Swift.String?

    public init(
        availabilityZoneId: Swift.String? = nil,
        clusters: [Swift.String]? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        hostType: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        scalingGroupArn: Swift.String? = nil,
        scalingGroupName: Swift.String? = nil,
        status: FinspaceClientTypes.KxScalingGroupStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.clusters = clusters
        self.createdTimestamp = createdTimestamp
        self.hostType = hostType
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.scalingGroupArn = scalingGroupArn
        self.scalingGroupName = scalingGroupName
        self.status = status
        self.statusReason = statusReason
    }
}

struct GetKxScalingGroupOutputBody: Swift.Equatable {
    let scalingGroupName: Swift.String?
    let scalingGroupArn: Swift.String?
    let hostType: Swift.String?
    let clusters: [Swift.String]?
    let availabilityZoneId: Swift.String?
    let status: FinspaceClientTypes.KxScalingGroupStatus?
    let statusReason: Swift.String?
    let lastModifiedTimestamp: ClientRuntime.Date?
    let createdTimestamp: ClientRuntime.Date?
}

extension GetKxScalingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId
        case clusters
        case createdTimestamp
        case hostType
        case lastModifiedTimestamp
        case scalingGroupArn
        case scalingGroupName
        case status
        case statusReason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scalingGroupName)
        scalingGroupName = scalingGroupNameDecoded
        let scalingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scalingGroupArn)
        scalingGroupArn = scalingGroupArnDecoded
        let hostTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostType)
        hostType = hostTypeDecoded
        let clustersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clusters)
        var clustersDecoded0:[Swift.String]? = nil
        if let clustersContainer = clustersContainer {
            clustersDecoded0 = [Swift.String]()
            for string0 in clustersContainer {
                if let string0 = string0 {
                    clustersDecoded0?.append(string0)
                }
            }
        }
        clusters = clustersDecoded0
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxScalingGroupStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum GetKxScalingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetKxUserInput {

    static func urlPathProvider(_ value: GetKxUserInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let userName = value.userName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

public struct GetKxUserInput: Swift.Equatable {
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// A unique identifier for the user.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.userName = userName
    }
}

struct GetKxUserInputBody: Swift.Equatable {
}

extension GetKxUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKxUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKxUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentId = output.environmentId
            self.iamRole = output.iamRole
            self.userArn = output.userArn
            self.userName = output.userName
        } else {
            self.environmentId = nil
            self.iamRole = nil
            self.userArn = nil
            self.userName = nil
        }
    }
}

public struct GetKxUserOutput: Swift.Equatable {
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// The IAM role ARN that is associated with the user.
    public var iamRole: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    public var userArn: Swift.String?
    /// A unique identifier for the user.
    public var userName: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        userArn: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.iamRole = iamRole
        self.userArn = userArn
        self.userName = userName
    }
}

struct GetKxUserOutputBody: Swift.Equatable {
    let userName: Swift.String?
    let userArn: Swift.String?
    let environmentId: Swift.String?
    let iamRole: Swift.String?
}

extension GetKxUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
        case iamRole
        case userArn
        case userName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
    }
}

enum GetKxUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetKxVolumeInput {

    static func urlPathProvider(_ value: GetKxVolumeInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let volumeName = value.volumeName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/kxvolumes/\(volumeName.urlPercentEncoding())"
    }
}

public struct GetKxVolumeInput: Swift.Equatable {
    /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
    /// This member is required.
    public var environmentId: Swift.String?
    /// A unique identifier for the volume.
    /// This member is required.
    public var volumeName: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        volumeName: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.volumeName = volumeName
    }
}

struct GetKxVolumeInputBody: Swift.Equatable {
}

extension GetKxVolumeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKxVolumeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKxVolumeOutputBody = try responseDecoder.decode(responseBody: data)
            self.attachedClusters = output.attachedClusters
            self.availabilityZoneIds = output.availabilityZoneIds
            self.azMode = output.azMode
            self.createdTimestamp = output.createdTimestamp
            self.description = output.description
            self.environmentId = output.environmentId
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.nas1Configuration = output.nas1Configuration
            self.status = output.status
            self.statusReason = output.statusReason
            self.volumeArn = output.volumeArn
            self.volumeName = output.volumeName
            self.volumeType = output.volumeType
        } else {
            self.attachedClusters = nil
            self.availabilityZoneIds = nil
            self.azMode = nil
            self.createdTimestamp = nil
            self.description = nil
            self.environmentId = nil
            self.lastModifiedTimestamp = nil
            self.nas1Configuration = nil
            self.status = nil
            self.statusReason = nil
            self.volumeArn = nil
            self.volumeName = nil
            self.volumeType = nil
        }
    }
}

public struct GetKxVolumeOutput: Swift.Equatable {
    /// A list of cluster identifiers that a volume is attached to.
    public var attachedClusters: [FinspaceClientTypes.KxAttachedCluster]?
    /// The identifier of the availability zones.
    public var availabilityZoneIds: [Swift.String]?
    /// The number of availability zones you want to assign per cluster. Currently, FinSpace only support SINGLE for volumes.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// The timestamp at which the volume was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: ClientRuntime.Date?
    /// A description of the volume.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
    public var environmentId: Swift.String?
    /// The last time that the volume was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// Specifies the configuration for the Network attached storage (NAS_1) file system volume.
    public var nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
    /// The status of volume creation.
    ///
    /// * CREATING – The volume creation is in progress.
    ///
    /// * CREATE_FAILED – The volume creation has failed.
    ///
    /// * ACTIVE – The volume is active.
    ///
    /// * UPDATING – The volume is in the process of being updated.
    ///
    /// * UPDATE_FAILED – The update action failed.
    ///
    /// * UPDATED – The volume is successfully updated.
    ///
    /// * DELETING – The volume is in the process of being deleted.
    ///
    /// * DELETE_FAILED – The system failed to delete the volume.
    ///
    /// * DELETED – The volume is successfully deleted.
    public var status: FinspaceClientTypes.KxVolumeStatus?
    /// The error message when a failed state occurs.
    public var statusReason: Swift.String?
    /// The ARN identifier of the volume.
    public var volumeArn: Swift.String?
    /// A unique identifier for the volume.
    public var volumeName: Swift.String?
    /// The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
    public var volumeType: FinspaceClientTypes.KxVolumeType?

    public init(
        attachedClusters: [FinspaceClientTypes.KxAttachedCluster]? = nil,
        availabilityZoneIds: [Swift.String]? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        nas1Configuration: FinspaceClientTypes.KxNAS1Configuration? = nil,
        status: FinspaceClientTypes.KxVolumeStatus? = nil,
        statusReason: Swift.String? = nil,
        volumeArn: Swift.String? = nil,
        volumeName: Swift.String? = nil,
        volumeType: FinspaceClientTypes.KxVolumeType? = nil
    )
    {
        self.attachedClusters = attachedClusters
        self.availabilityZoneIds = availabilityZoneIds
        self.azMode = azMode
        self.createdTimestamp = createdTimestamp
        self.description = description
        self.environmentId = environmentId
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.nas1Configuration = nas1Configuration
        self.status = status
        self.statusReason = statusReason
        self.volumeArn = volumeArn
        self.volumeName = volumeName
        self.volumeType = volumeType
    }
}

struct GetKxVolumeOutputBody: Swift.Equatable {
    let environmentId: Swift.String?
    let volumeName: Swift.String?
    let volumeType: FinspaceClientTypes.KxVolumeType?
    let volumeArn: Swift.String?
    let nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
    let status: FinspaceClientTypes.KxVolumeStatus?
    let statusReason: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
    let description: Swift.String?
    let azMode: FinspaceClientTypes.KxAzMode?
    let availabilityZoneIds: [Swift.String]?
    let lastModifiedTimestamp: ClientRuntime.Date?
    let attachedClusters: [FinspaceClientTypes.KxAttachedCluster]?
}

extension GetKxVolumeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedClusters
        case availabilityZoneIds
        case azMode
        case createdTimestamp
        case description
        case environmentId
        case lastModifiedTimestamp
        case nas1Configuration
        case status
        case statusReason
        case volumeArn
        case volumeName
        case volumeType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let volumeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeName)
        volumeName = volumeNameDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxVolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeArn)
        volumeArn = volumeArnDecoded
        let nas1ConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxNAS1Configuration.self, forKey: .nas1Configuration)
        nas1Configuration = nas1ConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxVolumeStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let azModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxAzMode.self, forKey: .azMode)
        azMode = azModeDecoded
        let availabilityZoneIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZoneIds)
        var availabilityZoneIdsDecoded0:[Swift.String]? = nil
        if let availabilityZoneIdsContainer = availabilityZoneIdsContainer {
            availabilityZoneIdsDecoded0 = [Swift.String]()
            for string0 in availabilityZoneIdsContainer {
                if let string0 = string0 {
                    availabilityZoneIdsDecoded0?.append(string0)
                }
            }
        }
        availabilityZoneIds = availabilityZoneIdsDecoded0
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let attachedClustersContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxAttachedCluster?].self, forKey: .attachedClusters)
        var attachedClustersDecoded0:[FinspaceClientTypes.KxAttachedCluster]? = nil
        if let attachedClustersContainer = attachedClustersContainer {
            attachedClustersDecoded0 = [FinspaceClientTypes.KxAttachedCluster]()
            for structure0 in attachedClustersContainer {
                if let structure0 = structure0 {
                    attachedClustersDecoded0?.append(structure0)
                }
            }
        }
        attachedClusters = attachedClustersDecoded0
    }
}

enum GetKxVolumeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FinspaceClientTypes {
    public enum IPAddressType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ipV4
        case sdkUnknown(Swift.String)

        public static var allCases: [IPAddressType] {
            return [
                .ipV4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ipV4: return "IP_V4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IPAddressType(rawValue: rawValue) ?? IPAddressType.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.IcmpTypeCode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if code != 0 {
            try encodeContainer.encode(code, forKey: .code)
        }
        if type != 0 {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .type) ?? 0
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code) ?? 0
        code = codeDecoded
    }
}

extension FinspaceClientTypes {
    /// Defines the ICMP protocol that consists of the ICMP type and code.
    public struct IcmpTypeCode: Swift.Equatable {
        /// The ICMP code. A value of -1 means all codes for the specified ICMP type.
        /// This member is required.
        public var code: Swift.Int
        /// The ICMP type. A value of -1 means all types.
        /// This member is required.
        public var type: Swift.Int

        public init(
            code: Swift.Int = 0,
            type: Swift.Int = 0
        )
        {
            self.code = code
            self.type = type
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is invalid. Something is wrong with the input to the request.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FinspaceClientTypes.KxAttachedCluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName
        case clusterStatus
        case clusterType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let clusterStatus = self.clusterStatus {
            try encodeContainer.encode(clusterStatus.rawValue, forKey: .clusterStatus)
        }
        if let clusterType = self.clusterType {
            try encodeContainer.encode(clusterType.rawValue, forKey: .clusterType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxClusterType.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let clusterStatusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxClusterStatus.self, forKey: .clusterStatus)
        clusterStatus = clusterStatusDecoded
    }
}

extension FinspaceClientTypes {
    /// The structure containing the metadata of the attached clusters.
    public struct KxAttachedCluster: Swift.Equatable {
        /// A unique name for the attached cluster.
        public var clusterName: Swift.String?
        /// The status of the attached cluster.
        ///
        /// * PENDING – The cluster is pending creation.
        ///
        /// * CREATING – The cluster creation process is in progress.
        ///
        /// * CREATE_FAILED – The cluster creation process has failed.
        ///
        /// * RUNNING – The cluster creation process is running.
        ///
        /// * UPDATING – The cluster is in the process of being updated.
        ///
        /// * DELETING – The cluster is in the process of being deleted.
        ///
        /// * DELETED – The cluster has been deleted.
        ///
        /// * DELETE_FAILED – The cluster failed to delete.
        public var clusterStatus: FinspaceClientTypes.KxClusterStatus?
        /// Specifies the type of cluster. The volume for TP and RDB cluster types will be used for TP logs.
        public var clusterType: FinspaceClientTypes.KxClusterType?

        public init(
            clusterName: Swift.String? = nil,
            clusterStatus: FinspaceClientTypes.KxClusterStatus? = nil,
            clusterType: FinspaceClientTypes.KxClusterType? = nil
        )
        {
            self.clusterName = clusterName
            self.clusterStatus = clusterStatus
            self.clusterType = clusterType
        }
    }

}

extension FinspaceClientTypes {
    public enum KxAzMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multi
        case single
        case sdkUnknown(Swift.String)

        public static var allCases: [KxAzMode] {
            return [
                .multi,
                .single,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multi: return "MULTI"
            case .single: return "SINGLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KxAzMode(rawValue: rawValue) ?? KxAzMode.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.KxCacheStorageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case size
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension FinspaceClientTypes {
    /// The configuration for read only disk cache associated with a cluster.
    public struct KxCacheStorageConfiguration: Swift.Equatable {
        /// The size of cache in Gigabytes.
        /// This member is required.
        public var size: Swift.Int?
        /// The type of cache storage. The valid values are:
        ///
        /// * CACHE_1000 – This type provides at least 1000 MB/s disk access throughput.
        ///
        /// * CACHE_250 – This type provides at least 250 MB/s disk access throughput.
        ///
        /// * CACHE_12 – This type provides at least 12 MB/s disk access throughput.
        ///
        ///
        /// For cache type CACHE_1000 and CACHE_250 you can select cache size as 1200 GB or increments of 2400 GB. For cache type CACHE_12 you can select the cache size in increments of 6000 GB.
        /// This member is required.
        public var type: Swift.String?

        public init(
            size: Swift.Int? = nil,
            type: Swift.String? = nil
        )
        {
            self.size = size
            self.type = type
        }
    }

}

extension FinspaceClientTypes.KxChangesetListEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeFromTimestamp
        case changesetId
        case createdTimestamp
        case lastModifiedTimestamp
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeFromTimestamp = self.activeFromTimestamp {
            try encodeContainer.encodeTimestamp(activeFromTimestamp, format: .epochSeconds, forKey: .activeFromTimestamp)
        }
        if let changesetId = self.changesetId {
            try encodeContainer.encode(changesetId, forKey: .changesetId)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let lastModifiedTimestamp = self.lastModifiedTimestamp {
            try encodeContainer.encodeTimestamp(lastModifiedTimestamp, format: .epochSeconds, forKey: .lastModifiedTimestamp)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let activeFromTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .activeFromTimestamp)
        activeFromTimestamp = activeFromTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.ChangesetStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension FinspaceClientTypes {
    /// Details of changeset.
    public struct KxChangesetListEntry: Swift.Equatable {
        /// Beginning time from which the changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var activeFromTimestamp: ClientRuntime.Date?
        /// A unique identifier for the changeset.
        public var changesetId: Swift.String?
        /// The timestamp at which the changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createdTimestamp: ClientRuntime.Date?
        /// The timestamp at which the changeset was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTimestamp: ClientRuntime.Date?
        /// Status of the changeset.
        ///
        /// * Pending – Changeset creation is pending.
        ///
        /// * Processing – Changeset creation is running.
        ///
        /// * Failed – Changeset creation has failed.
        ///
        /// * Complete – Changeset creation has succeeded.
        public var status: FinspaceClientTypes.ChangesetStatus?

        public init(
            activeFromTimestamp: ClientRuntime.Date? = nil,
            changesetId: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastModifiedTimestamp: ClientRuntime.Date? = nil,
            status: FinspaceClientTypes.ChangesetStatus? = nil
        )
        {
            self.activeFromTimestamp = activeFromTimestamp
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.status = status
        }
    }

}

extension FinspaceClientTypes.KxCluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId
        case azMode
        case clusterDescription
        case clusterName
        case clusterType
        case createdTimestamp
        case executionRole
        case initializationScript
        case lastModifiedTimestamp
        case releaseLabel
        case status
        case statusReason
        case volumes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneId = self.availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let azMode = self.azMode {
            try encodeContainer.encode(azMode.rawValue, forKey: .azMode)
        }
        if let clusterDescription = self.clusterDescription {
            try encodeContainer.encode(clusterDescription, forKey: .clusterDescription)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let clusterType = self.clusterType {
            try encodeContainer.encode(clusterType.rawValue, forKey: .clusterType)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let initializationScript = self.initializationScript {
            try encodeContainer.encode(initializationScript, forKey: .initializationScript)
        }
        if let lastModifiedTimestamp = self.lastModifiedTimestamp {
            try encodeContainer.encodeTimestamp(lastModifiedTimestamp, format: .epochSeconds, forKey: .lastModifiedTimestamp)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let volumes = volumes {
            var volumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumes)
            for volume0 in volumes {
                try volumesContainer.encode(volume0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxClusterStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxClusterType.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let clusterDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterDescription)
        clusterDescription = clusterDescriptionDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let volumesContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.Volume?].self, forKey: .volumes)
        var volumesDecoded0:[FinspaceClientTypes.Volume]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [FinspaceClientTypes.Volume]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
        let initializationScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initializationScript)
        initializationScript = initializationScriptDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let azModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxAzMode.self, forKey: .azMode)
        azMode = azModeDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension FinspaceClientTypes {
    /// The details of a kdb cluster.
    public struct KxCluster: Swift.Equatable {
        /// The availability zone identifiers for the requested regions.
        public var availabilityZoneId: Swift.String?
        /// The number of availability zones assigned per cluster. This can be one of the following:
        ///
        /// * SINGLE – Assigns one availability zone per cluster.
        ///
        /// * MULTI – Assigns all the availability zones per cluster.
        public var azMode: FinspaceClientTypes.KxAzMode?
        /// A description of the cluster.
        public var clusterDescription: Swift.String?
        /// A unique name for the cluster.
        public var clusterName: Swift.String?
        /// Specifies the type of KDB database that is being created. The following types are available:
        ///
        /// * HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.
        ///
        /// * RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.
        ///
        /// * GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.
        ///
        /// * GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.
        ///
        /// * Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
        public var clusterType: FinspaceClientTypes.KxClusterType?
        /// The timestamp at which the cluster was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createdTimestamp: ClientRuntime.Date?
        /// An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
        public var executionRole: Swift.String?
        /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
        public var initializationScript: Swift.String?
        /// The last time that the cluster was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTimestamp: ClientRuntime.Date?
        /// A version of the FinSpace managed kdb to run.
        public var releaseLabel: Swift.String?
        /// The status of a cluster.
        ///
        /// * PENDING – The cluster is pending creation.
        ///
        /// * CREATING –The cluster creation process is in progress.
        ///
        /// * CREATE_FAILED– The cluster creation process has failed.
        ///
        /// * RUNNING – The cluster creation process is running.
        ///
        /// * UPDATING – The cluster is in the process of being updated.
        ///
        /// * DELETING – The cluster is in the process of being deleted.
        ///
        /// * DELETED – The cluster has been deleted.
        ///
        /// * DELETE_FAILED – The cluster failed to delete.
        public var status: FinspaceClientTypes.KxClusterStatus?
        /// The error message when a failed state occurs.
        public var statusReason: Swift.String?
        /// A list of volumes attached to the cluster.
        public var volumes: [FinspaceClientTypes.Volume]?

        public init(
            availabilityZoneId: Swift.String? = nil,
            azMode: FinspaceClientTypes.KxAzMode? = nil,
            clusterDescription: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            clusterType: FinspaceClientTypes.KxClusterType? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            executionRole: Swift.String? = nil,
            initializationScript: Swift.String? = nil,
            lastModifiedTimestamp: ClientRuntime.Date? = nil,
            releaseLabel: Swift.String? = nil,
            status: FinspaceClientTypes.KxClusterStatus? = nil,
            statusReason: Swift.String? = nil,
            volumes: [FinspaceClientTypes.Volume]? = nil
        )
        {
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.clusterDescription = clusterDescription
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.createdTimestamp = createdTimestamp
            self.executionRole = executionRole
            self.initializationScript = initializationScript
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.releaseLabel = releaseLabel
            self.status = status
            self.statusReason = statusReason
            self.volumes = volumes
        }
    }

}

extension FinspaceClientTypes.KxClusterCodeDeploymentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentStrategy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentStrategy = self.deploymentStrategy {
            try encodeContainer.encode(deploymentStrategy.rawValue, forKey: .deploymentStrategy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentStrategyDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxClusterCodeDeploymentStrategy.self, forKey: .deploymentStrategy)
        deploymentStrategy = deploymentStrategyDecoded
    }
}

extension FinspaceClientTypes {
    /// The configuration that allows you to choose how you want to update code on a cluster. Depending on the option you choose, you can reduce the time it takes to update the cluster.
    public struct KxClusterCodeDeploymentConfiguration: Swift.Equatable {
        /// The type of deployment that you want on a cluster.
        ///
        /// * ROLLING – This options updates the cluster by stopping the exiting q process and starting a new q process with updated configuration.
        ///
        /// * NO_RESTART – This option updates the cluster without stopping the running q process. It is only available for GP type cluster. This option is quicker as it reduces the turn around time to update configuration on a cluster. With this deployment mode, you cannot update the initializationScript and commandLineArguments parameters.
        ///
        /// * FORCE – This option updates the cluster by immediately stopping all the running processes before starting up new ones with the updated configuration.
        /// This member is required.
        public var deploymentStrategy: FinspaceClientTypes.KxClusterCodeDeploymentStrategy?

        public init(
            deploymentStrategy: FinspaceClientTypes.KxClusterCodeDeploymentStrategy? = nil
        )
        {
            self.deploymentStrategy = deploymentStrategy
        }
    }

}

extension FinspaceClientTypes {
    public enum KxClusterCodeDeploymentStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case force
        case noRestart
        case rolling
        case sdkUnknown(Swift.String)

        public static var allCases: [KxClusterCodeDeploymentStrategy] {
            return [
                .force,
                .noRestart,
                .rolling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .force: return "FORCE"
            case .noRestart: return "NO_RESTART"
            case .rolling: return "ROLLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KxClusterCodeDeploymentStrategy(rawValue: rawValue) ?? KxClusterCodeDeploymentStrategy.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes {
    public enum KxClusterStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case creating
        case deleted
        case deleteFailed
        case deleting
        case pending
        case running
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [KxClusterStatus] {
            return [
                .createFailed,
                .creating,
                .deleted,
                .deleteFailed,
                .deleting,
                .pending,
                .running,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KxClusterStatus(rawValue: rawValue) ?? KxClusterStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes {
    public enum KxClusterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gateway
        case gp
        case hdb
        case rdb
        case tickerplant
        case sdkUnknown(Swift.String)

        public static var allCases: [KxClusterType] {
            return [
                .gateway,
                .gp,
                .hdb,
                .rdb,
                .tickerplant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gateway: return "GATEWAY"
            case .gp: return "GP"
            case .hdb: return "HDB"
            case .rdb: return "RDB"
            case .tickerplant: return "TICKERPLANT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KxClusterType(rawValue: rawValue) ?? KxClusterType.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.KxCommandLineArgument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FinspaceClientTypes {
    /// Defines the key-value pairs to make them available inside the cluster.
    public struct KxCommandLineArgument: Swift.Equatable {
        /// The name of the key.
        public var key: Swift.String?
        /// The value of the key.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension FinspaceClientTypes.KxDatabaseCacheConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheType
        case dataviewName
        case dbPaths
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheType = self.cacheType {
            try encodeContainer.encode(cacheType, forKey: .cacheType)
        }
        if let dataviewName = self.dataviewName {
            try encodeContainer.encode(dataviewName, forKey: .dataviewName)
        }
        if let dbPaths = dbPaths {
            var dbPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dbPaths)
            for dbpath0 in dbPaths {
                try dbPathsContainer.encode(dbpath0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cacheTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheType)
        cacheType = cacheTypeDecoded
        let dbPathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dbPaths)
        var dbPathsDecoded0:[Swift.String]? = nil
        if let dbPathsContainer = dbPathsContainer {
            dbPathsDecoded0 = [Swift.String]()
            for string0 in dbPathsContainer {
                if let string0 = string0 {
                    dbPathsDecoded0?.append(string0)
                }
            }
        }
        dbPaths = dbPathsDecoded0
        let dataviewNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataviewName)
        dataviewName = dataviewNameDecoded
    }
}

extension FinspaceClientTypes {
    /// The structure of database cache configuration that is used for mapping database paths to cache types in clusters.
    public struct KxDatabaseCacheConfiguration: Swift.Equatable {
        /// The type of disk cache. This parameter is used to map the database path to cache storage. The valid values are:
        ///
        /// * CACHE_1000 – This type provides at least 1000 MB/s disk access throughput.
        /// This member is required.
        public var cacheType: Swift.String?
        /// The name of the dataview to be used for caching historical data on disk.
        public var dataviewName: Swift.String?
        /// Specifies the portions of database that will be loaded into the cache for access.
        /// This member is required.
        public var dbPaths: [Swift.String]?

        public init(
            cacheType: Swift.String? = nil,
            dataviewName: Swift.String? = nil,
            dbPaths: [Swift.String]? = nil
        )
        {
            self.cacheType = cacheType
            self.dataviewName = dataviewName
            self.dbPaths = dbPaths
        }
    }

}

extension FinspaceClientTypes.KxDatabaseConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheConfigurations
        case changesetId
        case databaseName
        case dataviewConfiguration
        case dataviewName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheConfigurations = cacheConfigurations {
            var cacheConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cacheConfigurations)
            for kxdatabasecacheconfiguration0 in cacheConfigurations {
                try cacheConfigurationsContainer.encode(kxdatabasecacheconfiguration0)
            }
        }
        if let changesetId = self.changesetId {
            try encodeContainer.encode(changesetId, forKey: .changesetId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dataviewConfiguration = self.dataviewConfiguration {
            try encodeContainer.encode(dataviewConfiguration, forKey: .dataviewConfiguration)
        }
        if let dataviewName = self.dataviewName {
            try encodeContainer.encode(dataviewName, forKey: .dataviewName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let cacheConfigurationsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDatabaseCacheConfiguration?].self, forKey: .cacheConfigurations)
        var cacheConfigurationsDecoded0:[FinspaceClientTypes.KxDatabaseCacheConfiguration]? = nil
        if let cacheConfigurationsContainer = cacheConfigurationsContainer {
            cacheConfigurationsDecoded0 = [FinspaceClientTypes.KxDatabaseCacheConfiguration]()
            for structure0 in cacheConfigurationsContainer {
                if let structure0 = structure0 {
                    cacheConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        cacheConfigurations = cacheConfigurationsDecoded0
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let dataviewNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataviewName)
        dataviewName = dataviewNameDecoded
        let dataviewConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxDataviewConfiguration.self, forKey: .dataviewConfiguration)
        dataviewConfiguration = dataviewConfigurationDecoded
    }
}

extension FinspaceClientTypes {
    /// The configuration of data that is available for querying from this database.
    public struct KxDatabaseConfiguration: Swift.Equatable {
        /// Configuration details for the disk cache used to increase performance reading from a kdb database mounted to the cluster.
        public var cacheConfigurations: [FinspaceClientTypes.KxDatabaseCacheConfiguration]?
        /// A unique identifier of the changeset that is associated with the cluster.
        public var changesetId: Swift.String?
        /// The name of the kdb database. When this parameter is specified in the structure, S3 with the whole database is included by default.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The configuration of the dataview to be used with specified cluster.
        public var dataviewConfiguration: FinspaceClientTypes.KxDataviewConfiguration?
        /// The name of the dataview to be used for caching historical data on disk.
        public var dataviewName: Swift.String?

        public init(
            cacheConfigurations: [FinspaceClientTypes.KxDatabaseCacheConfiguration]? = nil,
            changesetId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dataviewConfiguration: FinspaceClientTypes.KxDataviewConfiguration? = nil,
            dataviewName: Swift.String? = nil
        )
        {
            self.cacheConfigurations = cacheConfigurations
            self.changesetId = changesetId
            self.databaseName = databaseName
            self.dataviewConfiguration = dataviewConfiguration
            self.dataviewName = dataviewName
        }
    }

}

extension FinspaceClientTypes.KxDatabaseListEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp
        case databaseName
        case lastModifiedTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let lastModifiedTimestamp = self.lastModifiedTimestamp {
            try encodeContainer.encodeTimestamp(lastModifiedTimestamp, format: .epochSeconds, forKey: .lastModifiedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

extension FinspaceClientTypes {
    /// Details about a FinSpace managed kdb database
    public struct KxDatabaseListEntry: Swift.Equatable {
        /// The timestamp at which the database was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createdTimestamp: ClientRuntime.Date?
        /// The name of the kdb database.
        public var databaseName: Swift.String?
        /// The last time that the database was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTimestamp: ClientRuntime.Date?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            databaseName: Swift.String? = nil,
            lastModifiedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.databaseName = databaseName
            self.lastModifiedTimestamp = lastModifiedTimestamp
        }
    }

}

extension FinspaceClientTypes.KxDataviewActiveVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedClusters
        case changesetId
        case createdTimestamp
        case segmentConfigurations
        case versionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedClusters = attachedClusters {
            var attachedClustersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachedClusters)
            for kxclustername0 in attachedClusters {
                try attachedClustersContainer.encode(kxclustername0)
            }
        }
        if let changesetId = self.changesetId {
            try encodeContainer.encode(changesetId, forKey: .changesetId)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let segmentConfigurations = segmentConfigurations {
            var segmentConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segmentConfigurations)
            for kxdataviewsegmentconfiguration0 in segmentConfigurations {
                try segmentConfigurationsContainer.encode(kxdataviewsegmentconfiguration0)
            }
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let segmentConfigurationsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDataviewSegmentConfiguration?].self, forKey: .segmentConfigurations)
        var segmentConfigurationsDecoded0:[FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil
        if let segmentConfigurationsContainer = segmentConfigurationsContainer {
            segmentConfigurationsDecoded0 = [FinspaceClientTypes.KxDataviewSegmentConfiguration]()
            for structure0 in segmentConfigurationsContainer {
                if let structure0 = structure0 {
                    segmentConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        segmentConfigurations = segmentConfigurationsDecoded0
        let attachedClustersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attachedClusters)
        var attachedClustersDecoded0:[Swift.String]? = nil
        if let attachedClustersContainer = attachedClustersContainer {
            attachedClustersDecoded0 = [Swift.String]()
            for string0 in attachedClustersContainer {
                if let string0 = string0 {
                    attachedClustersDecoded0?.append(string0)
                }
            }
        }
        attachedClusters = attachedClustersDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension FinspaceClientTypes {
    /// The active version of the dataview that is currently in use by this cluster.
    public struct KxDataviewActiveVersion: Swift.Equatable {
        /// The list of clusters that are currently using this dataview.
        public var attachedClusters: [Swift.String]?
        /// A unique identifier for the changeset.
        public var changesetId: Swift.String?
        /// The timestamp at which the dataview version was active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createdTimestamp: ClientRuntime.Date?
        /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
        public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
        /// A unique identifier of the active version.
        public var versionId: Swift.String?

        public init(
            attachedClusters: [Swift.String]? = nil,
            changesetId: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.attachedClusters = attachedClusters
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.segmentConfigurations = segmentConfigurations
            self.versionId = versionId
        }
    }

}

extension FinspaceClientTypes.KxDataviewConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changesetId
        case dataviewName
        case dataviewVersionId
        case segmentConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changesetId = self.changesetId {
            try encodeContainer.encode(changesetId, forKey: .changesetId)
        }
        if let dataviewName = self.dataviewName {
            try encodeContainer.encode(dataviewName, forKey: .dataviewName)
        }
        if let dataviewVersionId = self.dataviewVersionId {
            try encodeContainer.encode(dataviewVersionId, forKey: .dataviewVersionId)
        }
        if let segmentConfigurations = segmentConfigurations {
            var segmentConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segmentConfigurations)
            for kxdataviewsegmentconfiguration0 in segmentConfigurations {
                try segmentConfigurationsContainer.encode(kxdataviewsegmentconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataviewNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataviewName)
        dataviewName = dataviewNameDecoded
        let dataviewVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataviewVersionId)
        dataviewVersionId = dataviewVersionIdDecoded
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let segmentConfigurationsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDataviewSegmentConfiguration?].self, forKey: .segmentConfigurations)
        var segmentConfigurationsDecoded0:[FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil
        if let segmentConfigurationsContainer = segmentConfigurationsContainer {
            segmentConfigurationsDecoded0 = [FinspaceClientTypes.KxDataviewSegmentConfiguration]()
            for structure0 in segmentConfigurationsContainer {
                if let structure0 = structure0 {
                    segmentConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        segmentConfigurations = segmentConfigurationsDecoded0
    }
}

extension FinspaceClientTypes {
    /// The structure that stores the configuration details of a dataview.
    public struct KxDataviewConfiguration: Swift.Equatable {
        /// A unique identifier for the changeset.
        public var changesetId: Swift.String?
        /// The unique identifier of the dataview.
        public var dataviewName: Swift.String?
        /// The version of the dataview corresponding to a given changeset.
        public var dataviewVersionId: Swift.String?
        /// The db path and volume configuration for the segmented database.
        public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?

        public init(
            changesetId: Swift.String? = nil,
            dataviewName: Swift.String? = nil,
            dataviewVersionId: Swift.String? = nil,
            segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil
        )
        {
            self.changesetId = changesetId
            self.dataviewName = dataviewName
            self.dataviewVersionId = dataviewVersionId
            self.segmentConfigurations = segmentConfigurations
        }
    }

}

extension FinspaceClientTypes.KxDataviewListEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeVersions
        case autoUpdate
        case availabilityZoneId
        case azMode
        case changesetId
        case createdTimestamp
        case databaseName
        case dataviewName
        case description
        case environmentId
        case lastModifiedTimestamp
        case segmentConfigurations
        case status
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeVersions = activeVersions {
            var activeVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .activeVersions)
            for kxdataviewactiveversion0 in activeVersions {
                try activeVersionsContainer.encode(kxdataviewactiveversion0)
            }
        }
        if autoUpdate != false {
            try encodeContainer.encode(autoUpdate, forKey: .autoUpdate)
        }
        if let availabilityZoneId = self.availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let azMode = self.azMode {
            try encodeContainer.encode(azMode.rawValue, forKey: .azMode)
        }
        if let changesetId = self.changesetId {
            try encodeContainer.encode(changesetId, forKey: .changesetId)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dataviewName = self.dataviewName {
            try encodeContainer.encode(dataviewName, forKey: .dataviewName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let lastModifiedTimestamp = self.lastModifiedTimestamp {
            try encodeContainer.encodeTimestamp(lastModifiedTimestamp, format: .epochSeconds, forKey: .lastModifiedTimestamp)
        }
        if let segmentConfigurations = segmentConfigurations {
            var segmentConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segmentConfigurations)
            for kxdataviewsegmentconfiguration0 in segmentConfigurations {
                try segmentConfigurationsContainer.encode(kxdataviewsegmentconfiguration0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dataviewNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataviewName)
        dataviewName = dataviewNameDecoded
        let azModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxAzMode.self, forKey: .azMode)
        azMode = azModeDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let segmentConfigurationsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDataviewSegmentConfiguration?].self, forKey: .segmentConfigurations)
        var segmentConfigurationsDecoded0:[FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil
        if let segmentConfigurationsContainer = segmentConfigurationsContainer {
            segmentConfigurationsDecoded0 = [FinspaceClientTypes.KxDataviewSegmentConfiguration]()
            for structure0 in segmentConfigurationsContainer {
                if let structure0 = structure0 {
                    segmentConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        segmentConfigurations = segmentConfigurationsDecoded0
        let activeVersionsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDataviewActiveVersion?].self, forKey: .activeVersions)
        var activeVersionsDecoded0:[FinspaceClientTypes.KxDataviewActiveVersion]? = nil
        if let activeVersionsContainer = activeVersionsContainer {
            activeVersionsDecoded0 = [FinspaceClientTypes.KxDataviewActiveVersion]()
            for structure0 in activeVersionsContainer {
                if let structure0 = structure0 {
                    activeVersionsDecoded0?.append(structure0)
                }
            }
        }
        activeVersions = activeVersionsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxDataviewStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let autoUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoUpdate) ?? false
        autoUpdate = autoUpdateDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension FinspaceClientTypes {
    /// A collection of kdb dataview entries.
    public struct KxDataviewListEntry: Swift.Equatable {
        /// The active changeset versions for the given dataview entry.
        public var activeVersions: [FinspaceClientTypes.KxDataviewActiveVersion]?
        /// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview when you ingest new changesets. The default value is false.
        public var autoUpdate: Swift.Bool
        /// The identifier of the availability zones.
        public var availabilityZoneId: Swift.String?
        /// The number of availability zones you want to assign per cluster. This can be one of the following
        ///
        /// * SINGLE – Assigns one availability zone per cluster.
        ///
        /// * MULTI – Assigns all the availability zones per cluster.
        public var azMode: FinspaceClientTypes.KxAzMode?
        /// A unique identifier for the changeset.
        public var changesetId: Swift.String?
        /// The timestamp at which the dataview list entry was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createdTimestamp: ClientRuntime.Date?
        /// A unique identifier of the database.
        public var databaseName: Swift.String?
        /// A unique identifier of the dataview.
        public var dataviewName: Swift.String?
        /// A description for the dataview list entry.
        public var description: Swift.String?
        /// A unique identifier for the kdb environment.
        public var environmentId: Swift.String?
        /// The last time that the dataview list was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTimestamp: ClientRuntime.Date?
        /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
        public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
        /// The status of a given dataview entry.
        public var status: FinspaceClientTypes.KxDataviewStatus?
        /// The error message when a failed state occurs.
        public var statusReason: Swift.String?

        public init(
            activeVersions: [FinspaceClientTypes.KxDataviewActiveVersion]? = nil,
            autoUpdate: Swift.Bool = false,
            availabilityZoneId: Swift.String? = nil,
            azMode: FinspaceClientTypes.KxAzMode? = nil,
            changesetId: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            databaseName: Swift.String? = nil,
            dataviewName: Swift.String? = nil,
            description: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            lastModifiedTimestamp: ClientRuntime.Date? = nil,
            segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil,
            status: FinspaceClientTypes.KxDataviewStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.activeVersions = activeVersions
            self.autoUpdate = autoUpdate
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.databaseName = databaseName
            self.dataviewName = dataviewName
            self.description = description
            self.environmentId = environmentId
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.segmentConfigurations = segmentConfigurations
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension FinspaceClientTypes.KxDataviewSegmentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbPaths
        case volumeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbPaths = dbPaths {
            var dbPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dbPaths)
            for dbpath0 in dbPaths {
                try dbPathsContainer.encode(dbpath0)
            }
        }
        if let volumeName = self.volumeName {
            try encodeContainer.encode(volumeName, forKey: .volumeName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbPathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dbPaths)
        var dbPathsDecoded0:[Swift.String]? = nil
        if let dbPathsContainer = dbPathsContainer {
            dbPathsDecoded0 = [Swift.String]()
            for string0 in dbPathsContainer {
                if let string0 = string0 {
                    dbPathsDecoded0?.append(string0)
                }
            }
        }
        dbPaths = dbPathsDecoded0
        let volumeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeName)
        volumeName = volumeNameDecoded
    }
}

extension FinspaceClientTypes {
    /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
    public struct KxDataviewSegmentConfiguration: Swift.Equatable {
        /// The database path of the data that you want to place on each selected volume for the segment. Each segment must have a unique database path for each volume.
        /// This member is required.
        public var dbPaths: [Swift.String]?
        /// The name of the volume where you want to add data.
        /// This member is required.
        public var volumeName: Swift.String?

        public init(
            dbPaths: [Swift.String]? = nil,
            volumeName: Swift.String? = nil
        )
        {
            self.dbPaths = dbPaths
            self.volumeName = volumeName
        }
    }

}

extension FinspaceClientTypes {
    public enum KxDataviewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [KxDataviewStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KxDataviewStatus(rawValue: rawValue) ?? KxDataviewStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.KxDeploymentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentStrategy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentStrategy = self.deploymentStrategy {
            try encodeContainer.encode(deploymentStrategy.rawValue, forKey: .deploymentStrategy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentStrategyDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxDeploymentStrategy.self, forKey: .deploymentStrategy)
        deploymentStrategy = deploymentStrategyDecoded
    }
}

extension FinspaceClientTypes {
    /// The configuration that allows you to choose how you want to update the databases on a cluster. Depending on the option you choose, you can reduce the time it takes to update the cluster.
    public struct KxDeploymentConfiguration: Swift.Equatable {
        /// The type of deployment that you want on a cluster.
        ///
        /// * ROLLING – This options updates the cluster by stopping the exiting q process and starting a new q process with updated configuration.
        ///
        /// * NO_RESTART – This option updates the cluster without stopping the running q process. It is only available for HDB type cluster. This option is quicker as it reduces the turn around time to update configuration on a cluster. With this deployment mode, you cannot update the initializationScript and commandLineArguments parameters.
        /// This member is required.
        public var deploymentStrategy: FinspaceClientTypes.KxDeploymentStrategy?

        public init(
            deploymentStrategy: FinspaceClientTypes.KxDeploymentStrategy? = nil
        )
        {
            self.deploymentStrategy = deploymentStrategy
        }
    }

}

extension FinspaceClientTypes {
    public enum KxDeploymentStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noRestart
        case rolling
        case sdkUnknown(Swift.String)

        public static var allCases: [KxDeploymentStrategy] {
            return [
                .noRestart,
                .rolling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noRestart: return "NO_RESTART"
            case .rolling: return "ROLLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KxDeploymentStrategy(rawValue: rawValue) ?? KxDeploymentStrategy.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.KxEnvironment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneIds
        case awsAccountId
        case certificateAuthorityArn
        case creationTimestamp
        case customDNSConfiguration
        case dedicatedServiceAccountId
        case description
        case dnsStatus
        case environmentArn
        case environmentId
        case errorMessage
        case kmsKeyId
        case name
        case status
        case tgwStatus
        case transitGatewayConfiguration
        case updateTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneIds = availabilityZoneIds {
            var availabilityZoneIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZoneIds)
            for availabilityzoneid0 in availabilityZoneIds {
                try availabilityZoneIdsContainer.encode(availabilityzoneid0)
            }
        }
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let certificateAuthorityArn = self.certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encodeTimestamp(creationTimestamp, format: .epochSeconds, forKey: .creationTimestamp)
        }
        if let customDNSConfiguration = customDNSConfiguration {
            var customDNSConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customDNSConfiguration)
            for customdnsserver0 in customDNSConfiguration {
                try customDNSConfigurationContainer.encode(customdnsserver0)
            }
        }
        if let dedicatedServiceAccountId = self.dedicatedServiceAccountId {
            try encodeContainer.encode(dedicatedServiceAccountId, forKey: .dedicatedServiceAccountId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsStatus = self.dnsStatus {
            try encodeContainer.encode(dnsStatus.rawValue, forKey: .dnsStatus)
        }
        if let environmentArn = self.environmentArn {
            try encodeContainer.encode(environmentArn, forKey: .environmentArn)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tgwStatus = self.tgwStatus {
            try encodeContainer.encode(tgwStatus.rawValue, forKey: .tgwStatus)
        }
        if let transitGatewayConfiguration = self.transitGatewayConfiguration {
            try encodeContainer.encode(transitGatewayConfiguration, forKey: .transitGatewayConfiguration)
        }
        if let updateTimestamp = self.updateTimestamp {
            try encodeContainer.encodeTimestamp(updateTimestamp, format: .epochSeconds, forKey: .updateTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let tgwStatusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.TgwStatus.self, forKey: .tgwStatus)
        tgwStatus = tgwStatusDecoded
        let dnsStatusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.DnsStatus.self, forKey: .dnsStatus)
        dnsStatus = dnsStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dedicatedServiceAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedServiceAccountId)
        dedicatedServiceAccountId = dedicatedServiceAccountIdDecoded
        let transitGatewayConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.TransitGatewayConfiguration.self, forKey: .transitGatewayConfiguration)
        transitGatewayConfiguration = transitGatewayConfigurationDecoded
        let customDNSConfigurationContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.CustomDNSServer?].self, forKey: .customDNSConfiguration)
        var customDNSConfigurationDecoded0:[FinspaceClientTypes.CustomDNSServer]? = nil
        if let customDNSConfigurationContainer = customDNSConfigurationContainer {
            customDNSConfigurationDecoded0 = [FinspaceClientTypes.CustomDNSServer]()
            for structure0 in customDNSConfigurationContainer {
                if let structure0 = structure0 {
                    customDNSConfigurationDecoded0?.append(structure0)
                }
            }
        }
        customDNSConfiguration = customDNSConfigurationDecoded0
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let updateTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTimestamp)
        updateTimestamp = updateTimestampDecoded
        let availabilityZoneIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZoneIds)
        var availabilityZoneIdsDecoded0:[Swift.String]? = nil
        if let availabilityZoneIdsContainer = availabilityZoneIdsContainer {
            availabilityZoneIdsDecoded0 = [Swift.String]()
            for string0 in availabilityZoneIdsContainer {
                if let string0 = string0 {
                    availabilityZoneIdsDecoded0?.append(string0)
                }
            }
        }
        availabilityZoneIds = availabilityZoneIdsDecoded0
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension FinspaceClientTypes {
    /// The details of a kdb environment.
    public struct KxEnvironment: Swift.Equatable {
        /// The identifier of the availability zones where subnets for the environment are created.
        public var availabilityZoneIds: [Swift.String]?
        /// The unique identifier of the AWS account in which you create the kdb environment.
        public var awsAccountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the certificate authority:
        public var certificateAuthorityArn: Swift.String?
        /// The timestamp at which the kdb environment was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var creationTimestamp: ClientRuntime.Date?
        /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
        public var customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]?
        /// A unique identifier for the AWS environment infrastructure account.
        public var dedicatedServiceAccountId: Swift.String?
        /// A description of the kdb environment.
        public var description: Swift.String?
        /// The status of DNS configuration.
        public var dnsStatus: FinspaceClientTypes.DnsStatus?
        /// The Amazon Resource Name (ARN) of your kdb environment.
        public var environmentArn: Swift.String?
        /// A unique identifier for the kdb environment.
        public var environmentId: Swift.String?
        /// Specifies the error message that appears if a flow fails.
        public var errorMessage: Swift.String?
        /// The unique identifier of the KMS key.
        public var kmsKeyId: Swift.String?
        /// The name of the kdb environment.
        public var name: Swift.String?
        /// The status of the environment creation.
        ///
        /// * CREATE_REQUESTED – Environment creation has been requested.
        ///
        /// * CREATING – Environment is in the process of being created.
        ///
        /// * FAILED_CREATION – Environment creation has failed.
        ///
        /// * CREATED – Environment is successfully created and is currently active.
        ///
        /// * DELETE REQUESTED – Environment deletion has been requested.
        ///
        /// * DELETING – Environment is in the process of being deleted.
        ///
        /// * RETRY_DELETION – Initial environment deletion failed, system is reattempting delete.
        ///
        /// * DELETED – Environment has been deleted.
        ///
        /// * FAILED_DELETION – Environment deletion has failed.
        public var status: FinspaceClientTypes.EnvironmentStatus?
        /// The status of the network configuration.
        public var tgwStatus: FinspaceClientTypes.TgwStatus?
        /// Specifies the transit gateway and network configuration to connect the kdb environment to an internal network.
        public var transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration?
        /// The timestamp at which the kdb environment was modified in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var updateTimestamp: ClientRuntime.Date?

        public init(
            availabilityZoneIds: [Swift.String]? = nil,
            awsAccountId: Swift.String? = nil,
            certificateAuthorityArn: Swift.String? = nil,
            creationTimestamp: ClientRuntime.Date? = nil,
            customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]? = nil,
            dedicatedServiceAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            dnsStatus: FinspaceClientTypes.DnsStatus? = nil,
            environmentArn: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            status: FinspaceClientTypes.EnvironmentStatus? = nil,
            tgwStatus: FinspaceClientTypes.TgwStatus? = nil,
            transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration? = nil,
            updateTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.availabilityZoneIds = availabilityZoneIds
            self.awsAccountId = awsAccountId
            self.certificateAuthorityArn = certificateAuthorityArn
            self.creationTimestamp = creationTimestamp
            self.customDNSConfiguration = customDNSConfiguration
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.dnsStatus = dnsStatus
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tgwStatus = tgwStatus
            self.transitGatewayConfiguration = transitGatewayConfiguration
            self.updateTimestamp = updateTimestamp
        }
    }

}

extension FinspaceClientTypes.KxNAS1Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case size
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxNAS1Type.self, forKey: .type)
        type = typeDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension FinspaceClientTypes {
    /// The structure containing the size and type of the network attached storage (NAS_1) file system volume.
    public struct KxNAS1Configuration: Swift.Equatable {
        /// The size of the network attached storage.
        public var size: Swift.Int?
        /// The type of the network attached storage.
        public var type: FinspaceClientTypes.KxNAS1Type?

        public init(
            size: Swift.Int? = nil,
            type: FinspaceClientTypes.KxNAS1Type? = nil
        )
        {
            self.size = size
            self.type = type
        }
    }

}

extension FinspaceClientTypes {
    public enum KxNAS1Type: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hdd12
        case ssd1000
        case ssd250
        case sdkUnknown(Swift.String)

        public static var allCases: [KxNAS1Type] {
            return [
                .hdd12,
                .ssd1000,
                .ssd250,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hdd12: return "HDD_12"
            case .ssd1000: return "SSD_1000"
            case .ssd250: return "SSD_250"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KxNAS1Type(rawValue: rawValue) ?? KxNAS1Type.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.KxNode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId
        case launchTime
        case nodeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneId = self.availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let launchTime = self.launchTime {
            try encodeContainer.encodeTimestamp(launchTime, format: .epochSeconds, forKey: .launchTime)
        }
        if let nodeId = self.nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let launchTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .launchTime)
        launchTime = launchTimeDecoded
    }
}

extension FinspaceClientTypes {
    /// A structure that stores metadata for a kdb node.
    public struct KxNode: Swift.Equatable {
        /// The identifier of the availability zones where subnets for the environment are created.
        public var availabilityZoneId: Swift.String?
        /// The time when a particular node is started. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var launchTime: ClientRuntime.Date?
        /// A unique identifier for the node.
        public var nodeId: Swift.String?

        public init(
            availabilityZoneId: Swift.String? = nil,
            launchTime: ClientRuntime.Date? = nil,
            nodeId: Swift.String? = nil
        )
        {
            self.availabilityZoneId = availabilityZoneId
            self.launchTime = launchTime
            self.nodeId = nodeId
        }
    }

}

extension FinspaceClientTypes.KxSavedownStorageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case size
        case type
        case volumeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let volumeName = self.volumeName {
            try encodeContainer.encode(volumeName, forKey: .volumeName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxSavedownStorageType.self, forKey: .type)
        type = typeDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let volumeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeName)
        volumeName = volumeNameDecoded
    }
}

extension FinspaceClientTypes {
    /// The size and type of temporary storage that is used to hold data during the savedown process. All the data written to this storage space is lost when the cluster node is restarted.
    public struct KxSavedownStorageConfiguration: Swift.Equatable {
        /// The size of temporary storage in gibibytes.
        public var size: Swift.Int?
        /// The type of writeable storage space for temporarily storing your savedown data. The valid values are:
        ///
        /// * SDS01 – This type represents 3000 IOPS and io2 ebs volume type.
        public var type: FinspaceClientTypes.KxSavedownStorageType?
        /// The name of the kdb volume that you want to use as writeable save-down storage for clusters.
        public var volumeName: Swift.String?

        public init(
            size: Swift.Int? = nil,
            type: FinspaceClientTypes.KxSavedownStorageType? = nil,
            volumeName: Swift.String? = nil
        )
        {
            self.size = size
            self.type = type
            self.volumeName = volumeName
        }
    }

}

extension FinspaceClientTypes {
    public enum KxSavedownStorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sds01
        case sdkUnknown(Swift.String)

        public static var allCases: [KxSavedownStorageType] {
            return [
                .sds01,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sds01: return "SDS01"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KxSavedownStorageType(rawValue: rawValue) ?? KxSavedownStorageType.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.KxScalingGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId
        case clusters
        case createdTimestamp
        case hostType
        case lastModifiedTimestamp
        case scalingGroupName
        case status
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneId = self.availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let clusters = clusters {
            var clustersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusters)
            for kxclustername0 in clusters {
                try clustersContainer.encode(kxclustername0)
            }
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let hostType = self.hostType {
            try encodeContainer.encode(hostType, forKey: .hostType)
        }
        if let lastModifiedTimestamp = self.lastModifiedTimestamp {
            try encodeContainer.encodeTimestamp(lastModifiedTimestamp, format: .epochSeconds, forKey: .lastModifiedTimestamp)
        }
        if let scalingGroupName = self.scalingGroupName {
            try encodeContainer.encode(scalingGroupName, forKey: .scalingGroupName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scalingGroupName)
        scalingGroupName = scalingGroupNameDecoded
        let hostTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostType)
        hostType = hostTypeDecoded
        let clustersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clusters)
        var clustersDecoded0:[Swift.String]? = nil
        if let clustersContainer = clustersContainer {
            clustersDecoded0 = [Swift.String]()
            for string0 in clustersContainer {
                if let string0 = string0 {
                    clustersDecoded0?.append(string0)
                }
            }
        }
        clusters = clustersDecoded0
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxScalingGroupStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension FinspaceClientTypes {
    /// A structure for storing metadata of scaling group.
    public struct KxScalingGroup: Swift.Equatable {
        /// The identifier of the availability zones.
        public var availabilityZoneId: Swift.String?
        /// The list of clusters currently active in a given scaling group.
        public var clusters: [Swift.String]?
        /// The timestamp at which the scaling group was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createdTimestamp: ClientRuntime.Date?
        /// The memory and CPU capabilities of the scaling group host on which FinSpace Managed kdb clusters will be placed.
        public var hostType: Swift.String?
        /// The last time that the scaling group was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTimestamp: ClientRuntime.Date?
        /// A unique identifier for the kdb scaling group.
        public var scalingGroupName: Swift.String?
        /// The status of scaling groups.
        public var status: FinspaceClientTypes.KxScalingGroupStatus?
        /// The error message when a failed state occurs.
        public var statusReason: Swift.String?

        public init(
            availabilityZoneId: Swift.String? = nil,
            clusters: [Swift.String]? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            hostType: Swift.String? = nil,
            lastModifiedTimestamp: ClientRuntime.Date? = nil,
            scalingGroupName: Swift.String? = nil,
            status: FinspaceClientTypes.KxScalingGroupStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.availabilityZoneId = availabilityZoneId
            self.clusters = clusters
            self.createdTimestamp = createdTimestamp
            self.hostType = hostType
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.scalingGroupName = scalingGroupName
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension FinspaceClientTypes.KxScalingGroupConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpu
        case memoryLimit
        case memoryReservation
        case nodeCount
        case scalingGroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpu = self.cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let memoryLimit = self.memoryLimit {
            try encodeContainer.encode(memoryLimit, forKey: .memoryLimit)
        }
        if let memoryReservation = self.memoryReservation {
            try encodeContainer.encode(memoryReservation, forKey: .memoryReservation)
        }
        if let nodeCount = self.nodeCount {
            try encodeContainer.encode(nodeCount, forKey: .nodeCount)
        }
        if let scalingGroupName = self.scalingGroupName {
            try encodeContainer.encode(scalingGroupName, forKey: .scalingGroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scalingGroupName)
        scalingGroupName = scalingGroupNameDecoded
        let memoryLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memoryLimit)
        memoryLimit = memoryLimitDecoded
        let memoryReservationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memoryReservation)
        memoryReservation = memoryReservationDecoded
        let nodeCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nodeCount)
        nodeCount = nodeCountDecoded
        let cpuDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .cpu)
        cpu = cpuDecoded
    }
}

extension FinspaceClientTypes {
    /// The structure that stores the capacity configuration details of a scaling group.
    public struct KxScalingGroupConfiguration: Swift.Equatable {
        /// The number of vCPUs that you want to reserve for each node of this kdb cluster on the scaling group host.
        public var cpu: Swift.Double?
        /// An optional hard limit on the amount of memory a kdb cluster can use.
        public var memoryLimit: Swift.Int?
        /// A reservation of the minimum amount of memory that should be available on the scaling group for a kdb cluster to be successfully placed in a scaling group.
        /// This member is required.
        public var memoryReservation: Swift.Int?
        /// The number of kdb cluster nodes.
        /// This member is required.
        public var nodeCount: Swift.Int?
        /// A unique identifier for the kdb scaling group.
        /// This member is required.
        public var scalingGroupName: Swift.String?

        public init(
            cpu: Swift.Double? = nil,
            memoryLimit: Swift.Int? = nil,
            memoryReservation: Swift.Int? = nil,
            nodeCount: Swift.Int? = nil,
            scalingGroupName: Swift.String? = nil
        )
        {
            self.cpu = cpu
            self.memoryLimit = memoryLimit
            self.memoryReservation = memoryReservation
            self.nodeCount = nodeCount
            self.scalingGroupName = scalingGroupName
        }
    }

}

extension FinspaceClientTypes {
    public enum KxScalingGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleted
        case deleteFailed
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [KxScalingGroupStatus] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleted,
                .deleteFailed,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KxScalingGroupStatus(rawValue: rawValue) ?? KxScalingGroupStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.KxUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTimestamp
        case iamRole
        case updateTimestamp
        case userArn
        case userName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTimestamp = self.createTimestamp {
            try encodeContainer.encodeTimestamp(createTimestamp, format: .epochSeconds, forKey: .createTimestamp)
        }
        if let iamRole = self.iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let updateTimestamp = self.updateTimestamp {
            try encodeContainer.encodeTimestamp(updateTimestamp, format: .epochSeconds, forKey: .updateTimestamp)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let createTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
        let updateTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTimestamp)
        updateTimestamp = updateTimestampDecoded
    }
}

extension FinspaceClientTypes {
    /// A structure that stores metadata for a kdb user.
    public struct KxUser: Swift.Equatable {
        /// The timestamp at which the kdb user was created.
        public var createTimestamp: ClientRuntime.Date?
        /// The IAM role ARN that is associated with the user.
        public var iamRole: Swift.String?
        /// The timestamp at which the kdb user was updated.
        public var updateTimestamp: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        public var userArn: Swift.String?
        /// A unique identifier for the user.
        public var userName: Swift.String?

        public init(
            createTimestamp: ClientRuntime.Date? = nil,
            iamRole: Swift.String? = nil,
            updateTimestamp: ClientRuntime.Date? = nil,
            userArn: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.createTimestamp = createTimestamp
            self.iamRole = iamRole
            self.updateTimestamp = updateTimestamp
            self.userArn = userArn
            self.userName = userName
        }
    }

}

extension FinspaceClientTypes.KxVolume: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneIds
        case azMode
        case createdTimestamp
        case description
        case lastModifiedTimestamp
        case status
        case statusReason
        case volumeName
        case volumeType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneIds = availabilityZoneIds {
            var availabilityZoneIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZoneIds)
            for availabilityzoneid0 in availabilityZoneIds {
                try availabilityZoneIdsContainer.encode(availabilityzoneid0)
            }
        }
        if let azMode = self.azMode {
            try encodeContainer.encode(azMode.rawValue, forKey: .azMode)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedTimestamp = self.lastModifiedTimestamp {
            try encodeContainer.encodeTimestamp(lastModifiedTimestamp, format: .epochSeconds, forKey: .lastModifiedTimestamp)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let volumeName = self.volumeName {
            try encodeContainer.encode(volumeName, forKey: .volumeName)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType.rawValue, forKey: .volumeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeName)
        volumeName = volumeNameDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxVolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxVolumeStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let azModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxAzMode.self, forKey: .azMode)
        azMode = azModeDecoded
        let availabilityZoneIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZoneIds)
        var availabilityZoneIdsDecoded0:[Swift.String]? = nil
        if let availabilityZoneIdsContainer = availabilityZoneIdsContainer {
            availabilityZoneIdsDecoded0 = [Swift.String]()
            for string0 in availabilityZoneIdsContainer {
                if let string0 = string0 {
                    availabilityZoneIdsDecoded0?.append(string0)
                }
            }
        }
        availabilityZoneIds = availabilityZoneIdsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

extension FinspaceClientTypes {
    /// The structure that contains the metadata of the volume.
    public struct KxVolume: Swift.Equatable {
        /// The identifier of the availability zones.
        public var availabilityZoneIds: [Swift.String]?
        /// The number of availability zones assigned to the volume. Currently, only SINGLE is supported.
        public var azMode: FinspaceClientTypes.KxAzMode?
        /// The timestamp at which the volume was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createdTimestamp: ClientRuntime.Date?
        /// A description of the volume.
        public var description: Swift.String?
        /// The last time that the volume was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTimestamp: ClientRuntime.Date?
        /// The status of volume.
        ///
        /// * CREATING – The volume creation is in progress.
        ///
        /// * CREATE_FAILED – The volume creation has failed.
        ///
        /// * ACTIVE – The volume is active.
        ///
        /// * UPDATING – The volume is in the process of being updated.
        ///
        /// * UPDATE_FAILED – The update action failed.
        ///
        /// * UPDATED – The volume is successfully updated.
        ///
        /// * DELETING – The volume is in the process of being deleted.
        ///
        /// * DELETE_FAILED – The system failed to delete the volume.
        ///
        /// * DELETED – The volume is successfully deleted.
        public var status: FinspaceClientTypes.KxVolumeStatus?
        /// The error message when a failed state occurs.
        public var statusReason: Swift.String?
        /// A unique identifier for the volume.
        public var volumeName: Swift.String?
        /// The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
        public var volumeType: FinspaceClientTypes.KxVolumeType?

        public init(
            availabilityZoneIds: [Swift.String]? = nil,
            azMode: FinspaceClientTypes.KxAzMode? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedTimestamp: ClientRuntime.Date? = nil,
            status: FinspaceClientTypes.KxVolumeStatus? = nil,
            statusReason: Swift.String? = nil,
            volumeName: Swift.String? = nil,
            volumeType: FinspaceClientTypes.KxVolumeType? = nil
        )
        {
            self.availabilityZoneIds = availabilityZoneIds
            self.azMode = azMode
            self.createdTimestamp = createdTimestamp
            self.description = description
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.status = status
            self.statusReason = statusReason
            self.volumeName = volumeName
            self.volumeType = volumeType
        }
    }

}

extension FinspaceClientTypes {
    public enum KxVolumeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleted
        case deleteFailed
        case deleting
        case updated
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [KxVolumeStatus] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleted,
                .deleteFailed,
                .deleting,
                .updated,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .updated: return "UPDATED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KxVolumeStatus(rawValue: rawValue) ?? KxVolumeStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes {
    public enum KxVolumeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nas1
        case sdkUnknown(Swift.String)

        public static var allCases: [KxVolumeType] {
            return [
                .nas1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nas1: return "NAS_1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KxVolumeType(rawValue: rawValue) ?? KxVolumeType.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A service limit or quota is exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListEnvironmentsInput {

    static func queryItemProvider(_ value: ListEnvironmentsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEnvironmentsInput {

    static func urlPathProvider(_ value: ListEnvironmentsInput) -> Swift.String? {
        return "/environment"
    }
}

public struct ListEnvironmentsInput: Swift.Equatable {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by FinSpace that specifies where to continue pagination if a previous request was truncated. To get the next set of pages, pass in the nextTokennextToken value from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Swift.Equatable {
}

extension ListEnvironmentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.environments = output.environments
            self.nextToken = output.nextToken
        } else {
            self.environments = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutput: Swift.Equatable {
    /// A list of all of your FinSpace environments.
    public var environments: [FinspaceClientTypes.Environment]?
    /// A token that you can use in a subsequent call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        environments: [FinspaceClientTypes.Environment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputBody: Swift.Equatable {
    let environments: [FinspaceClientTypes.Environment]?
    let nextToken: Swift.String?
}

extension ListEnvironmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environments
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.Environment?].self, forKey: .environments)
        var environmentsDecoded0:[FinspaceClientTypes.Environment]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [FinspaceClientTypes.Environment]()
            for structure0 in environmentsContainer {
                if let structure0 = structure0 {
                    environmentsDecoded0?.append(structure0)
                }
            }
        }
        environments = environmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnvironmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKxChangesetsInput {

    static func queryItemProvider(_ value: ListKxChangesetsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKxChangesetsInput {

    static func urlPathProvider(_ value: ListKxChangesetsInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/changesets"
    }
}

public struct ListKxChangesetsInput: Swift.Equatable {
    /// The name of the kdb database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKxChangesetsInputBody: Swift.Equatable {
}

extension ListKxChangesetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListKxChangesetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKxChangesetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.kxChangesets = output.kxChangesets
            self.nextToken = output.nextToken
        } else {
            self.kxChangesets = nil
            self.nextToken = nil
        }
    }
}

public struct ListKxChangesetsOutput: Swift.Equatable {
    /// A list of changesets for a database.
    public var kxChangesets: [FinspaceClientTypes.KxChangesetListEntry]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        kxChangesets: [FinspaceClientTypes.KxChangesetListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kxChangesets = kxChangesets
        self.nextToken = nextToken
    }
}

struct ListKxChangesetsOutputBody: Swift.Equatable {
    let kxChangesets: [FinspaceClientTypes.KxChangesetListEntry]?
    let nextToken: Swift.String?
}

extension ListKxChangesetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kxChangesets
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kxChangesetsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxChangesetListEntry?].self, forKey: .kxChangesets)
        var kxChangesetsDecoded0:[FinspaceClientTypes.KxChangesetListEntry]? = nil
        if let kxChangesetsContainer = kxChangesetsContainer {
            kxChangesetsDecoded0 = [FinspaceClientTypes.KxChangesetListEntry]()
            for structure0 in kxChangesetsContainer {
                if let structure0 = structure0 {
                    kxChangesetsDecoded0?.append(structure0)
                }
            }
        }
        kxChangesets = kxChangesetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKxChangesetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKxClusterNodesInput {

    static func queryItemProvider(_ value: ListKxClusterNodesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKxClusterNodesInput {

    static func urlPathProvider(_ value: ListKxClusterNodesInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let clusterName = value.clusterName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters/\(clusterName.urlPercentEncoding())/nodes"
    }
}

public struct ListKxClusterNodesInput: Swift.Equatable {
    /// A unique name for the cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        clusterName: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKxClusterNodesInputBody: Swift.Equatable {
}

extension ListKxClusterNodesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListKxClusterNodesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKxClusterNodesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.nodes = output.nodes
        } else {
            self.nextToken = nil
            self.nodes = nil
        }
    }
}

public struct ListKxClusterNodesOutput: Swift.Equatable {
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// A list of nodes associated with the cluster.
    public var nodes: [FinspaceClientTypes.KxNode]?

    public init(
        nextToken: Swift.String? = nil,
        nodes: [FinspaceClientTypes.KxNode]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodes = nodes
    }
}

struct ListKxClusterNodesOutputBody: Swift.Equatable {
    let nodes: [FinspaceClientTypes.KxNode]?
    let nextToken: Swift.String?
}

extension ListKxClusterNodesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case nodes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodesContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxNode?].self, forKey: .nodes)
        var nodesDecoded0:[FinspaceClientTypes.KxNode]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [FinspaceClientTypes.KxNode]()
            for structure0 in nodesContainer {
                if let structure0 = structure0 {
                    nodesDecoded0?.append(structure0)
                }
            }
        }
        nodes = nodesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKxClusterNodesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKxClustersInput {

    static func queryItemProvider(_ value: ListKxClustersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clusterType = value.clusterType {
            let clusterTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "clusterType".urlPercentEncoding(), value: Swift.String(clusterType.rawValue).urlPercentEncoding())
            items.append(clusterTypeQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListKxClustersInput {

    static func urlPathProvider(_ value: ListKxClustersInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters"
    }
}

public struct ListKxClustersInput: Swift.Equatable {
    /// Specifies the type of KDB database that is being created. The following types are available:
    ///
    /// * HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.
    ///
    /// * RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.
    ///
    /// * GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.
    ///
    /// * GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.
    ///
    /// * Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
    public var clusterType: FinspaceClientTypes.KxClusterType?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        clusterType: FinspaceClientTypes.KxClusterType? = nil,
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterType = clusterType
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKxClustersInputBody: Swift.Equatable {
}

extension ListKxClustersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListKxClustersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKxClustersOutputBody = try responseDecoder.decode(responseBody: data)
            self.kxClusterSummaries = output.kxClusterSummaries
            self.nextToken = output.nextToken
        } else {
            self.kxClusterSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListKxClustersOutput: Swift.Equatable {
    /// Lists the cluster details.
    public var kxClusterSummaries: [FinspaceClientTypes.KxCluster]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        kxClusterSummaries: [FinspaceClientTypes.KxCluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kxClusterSummaries = kxClusterSummaries
        self.nextToken = nextToken
    }
}

struct ListKxClustersOutputBody: Swift.Equatable {
    let kxClusterSummaries: [FinspaceClientTypes.KxCluster]?
    let nextToken: Swift.String?
}

extension ListKxClustersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kxClusterSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kxClusterSummariesContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxCluster?].self, forKey: .kxClusterSummaries)
        var kxClusterSummariesDecoded0:[FinspaceClientTypes.KxCluster]? = nil
        if let kxClusterSummariesContainer = kxClusterSummariesContainer {
            kxClusterSummariesDecoded0 = [FinspaceClientTypes.KxCluster]()
            for structure0 in kxClusterSummariesContainer {
                if let structure0 = structure0 {
                    kxClusterSummariesDecoded0?.append(structure0)
                }
            }
        }
        kxClusterSummaries = kxClusterSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKxClustersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKxDatabasesInput {

    static func queryItemProvider(_ value: ListKxDatabasesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKxDatabasesInput {

    static func urlPathProvider(_ value: ListKxDatabasesInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases"
    }
}

public struct ListKxDatabasesInput: Swift.Equatable {
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKxDatabasesInputBody: Swift.Equatable {
}

extension ListKxDatabasesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListKxDatabasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKxDatabasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.kxDatabases = output.kxDatabases
            self.nextToken = output.nextToken
        } else {
            self.kxDatabases = nil
            self.nextToken = nil
        }
    }
}

public struct ListKxDatabasesOutput: Swift.Equatable {
    /// A list of databases in the kdb environment.
    public var kxDatabases: [FinspaceClientTypes.KxDatabaseListEntry]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        kxDatabases: [FinspaceClientTypes.KxDatabaseListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kxDatabases = kxDatabases
        self.nextToken = nextToken
    }
}

struct ListKxDatabasesOutputBody: Swift.Equatable {
    let kxDatabases: [FinspaceClientTypes.KxDatabaseListEntry]?
    let nextToken: Swift.String?
}

extension ListKxDatabasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kxDatabases
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kxDatabasesContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDatabaseListEntry?].self, forKey: .kxDatabases)
        var kxDatabasesDecoded0:[FinspaceClientTypes.KxDatabaseListEntry]? = nil
        if let kxDatabasesContainer = kxDatabasesContainer {
            kxDatabasesDecoded0 = [FinspaceClientTypes.KxDatabaseListEntry]()
            for structure0 in kxDatabasesContainer {
                if let structure0 = structure0 {
                    kxDatabasesDecoded0?.append(structure0)
                }
            }
        }
        kxDatabases = kxDatabasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKxDatabasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKxDataviewsInput {

    static func queryItemProvider(_ value: ListKxDataviewsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKxDataviewsInput {

    static func urlPathProvider(_ value: ListKxDataviewsInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/dataviews"
    }
}

public struct ListKxDataviewsInput: Swift.Equatable {
    /// The name of the database where the dataviews were created.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier for the kdb environment, for which you want to retrieve a list of dataviews.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKxDataviewsInputBody: Swift.Equatable {
}

extension ListKxDataviewsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListKxDataviewsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKxDataviewsOutputBody = try responseDecoder.decode(responseBody: data)
            self.kxDataviews = output.kxDataviews
            self.nextToken = output.nextToken
        } else {
            self.kxDataviews = nil
            self.nextToken = nil
        }
    }
}

public struct ListKxDataviewsOutput: Swift.Equatable {
    /// The list of kdb dataviews that are currently active for the given database.
    public var kxDataviews: [FinspaceClientTypes.KxDataviewListEntry]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        kxDataviews: [FinspaceClientTypes.KxDataviewListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kxDataviews = kxDataviews
        self.nextToken = nextToken
    }
}

struct ListKxDataviewsOutputBody: Swift.Equatable {
    let kxDataviews: [FinspaceClientTypes.KxDataviewListEntry]?
    let nextToken: Swift.String?
}

extension ListKxDataviewsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kxDataviews
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kxDataviewsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDataviewListEntry?].self, forKey: .kxDataviews)
        var kxDataviewsDecoded0:[FinspaceClientTypes.KxDataviewListEntry]? = nil
        if let kxDataviewsContainer = kxDataviewsContainer {
            kxDataviewsDecoded0 = [FinspaceClientTypes.KxDataviewListEntry]()
            for structure0 in kxDataviewsContainer {
                if let structure0 = structure0 {
                    kxDataviewsDecoded0?.append(structure0)
                }
            }
        }
        kxDataviews = kxDataviewsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKxDataviewsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKxEnvironmentsInput {

    static func queryItemProvider(_ value: ListKxEnvironmentsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKxEnvironmentsInput {

    static func urlPathProvider(_ value: ListKxEnvironmentsInput) -> Swift.String? {
        return "/kx/environments"
    }
}

public struct ListKxEnvironmentsInput: Swift.Equatable {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKxEnvironmentsInputBody: Swift.Equatable {
}

extension ListKxEnvironmentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListKxEnvironmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKxEnvironmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.environments = output.environments
            self.nextToken = output.nextToken
        } else {
            self.environments = nil
            self.nextToken = nil
        }
    }
}

public struct ListKxEnvironmentsOutput: Swift.Equatable {
    /// A list of environments in an account.
    public var environments: [FinspaceClientTypes.KxEnvironment]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        environments: [FinspaceClientTypes.KxEnvironment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

struct ListKxEnvironmentsOutputBody: Swift.Equatable {
    let environments: [FinspaceClientTypes.KxEnvironment]?
    let nextToken: Swift.String?
}

extension ListKxEnvironmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environments
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxEnvironment?].self, forKey: .environments)
        var environmentsDecoded0:[FinspaceClientTypes.KxEnvironment]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [FinspaceClientTypes.KxEnvironment]()
            for structure0 in environmentsContainer {
                if let structure0 = structure0 {
                    environmentsDecoded0?.append(structure0)
                }
            }
        }
        environments = environmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKxEnvironmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKxScalingGroupsInput {

    static func queryItemProvider(_ value: ListKxScalingGroupsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListKxScalingGroupsInput {

    static func urlPathProvider(_ value: ListKxScalingGroupsInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/scalingGroups"
    }
}

public struct ListKxScalingGroupsInput: Swift.Equatable {
    /// A unique identifier for the kdb environment, for which you want to retrieve a list of scaling groups.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKxScalingGroupsInputBody: Swift.Equatable {
}

extension ListKxScalingGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListKxScalingGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKxScalingGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.scalingGroups = output.scalingGroups
        } else {
            self.nextToken = nil
            self.scalingGroups = nil
        }
    }
}

public struct ListKxScalingGroupsOutput: Swift.Equatable {
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// A list of scaling groups available in a kdb environment.
    public var scalingGroups: [FinspaceClientTypes.KxScalingGroup]?

    public init(
        nextToken: Swift.String? = nil,
        scalingGroups: [FinspaceClientTypes.KxScalingGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.scalingGroups = scalingGroups
    }
}

struct ListKxScalingGroupsOutputBody: Swift.Equatable {
    let scalingGroups: [FinspaceClientTypes.KxScalingGroup]?
    let nextToken: Swift.String?
}

extension ListKxScalingGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case scalingGroups
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingGroupsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxScalingGroup?].self, forKey: .scalingGroups)
        var scalingGroupsDecoded0:[FinspaceClientTypes.KxScalingGroup]? = nil
        if let scalingGroupsContainer = scalingGroupsContainer {
            scalingGroupsDecoded0 = [FinspaceClientTypes.KxScalingGroup]()
            for structure0 in scalingGroupsContainer {
                if let structure0 = structure0 {
                    scalingGroupsDecoded0?.append(structure0)
                }
            }
        }
        scalingGroups = scalingGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKxScalingGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKxUsersInput {

    static func queryItemProvider(_ value: ListKxUsersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKxUsersInput {

    static func urlPathProvider(_ value: ListKxUsersInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/users"
    }
}

public struct ListKxUsersInput: Swift.Equatable {
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKxUsersInputBody: Swift.Equatable {
}

extension ListKxUsersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListKxUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKxUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListKxUsersOutput: Swift.Equatable {
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// A list of users in a kdb environment.
    public var users: [FinspaceClientTypes.KxUser]?

    public init(
        nextToken: Swift.String? = nil,
        users: [FinspaceClientTypes.KxUser]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListKxUsersOutputBody: Swift.Equatable {
    let users: [FinspaceClientTypes.KxUser]?
    let nextToken: Swift.String?
}

extension ListKxUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case users
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxUser?].self, forKey: .users)
        var usersDecoded0:[FinspaceClientTypes.KxUser]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [FinspaceClientTypes.KxUser]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKxUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKxVolumesInput {

    static func queryItemProvider(_ value: ListKxVolumesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let volumeType = value.volumeType {
            let volumeTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "volumeType".urlPercentEncoding(), value: Swift.String(volumeType.rawValue).urlPercentEncoding())
            items.append(volumeTypeQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListKxVolumesInput {

    static func urlPathProvider(_ value: ListKxVolumesInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/kxvolumes"
    }
}

public struct ListKxVolumesInput: Swift.Equatable {
    /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
    public var volumeType: FinspaceClientTypes.KxVolumeType?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        volumeType: FinspaceClientTypes.KxVolumeType? = nil
    )
    {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.volumeType = volumeType
    }
}

struct ListKxVolumesInputBody: Swift.Equatable {
}

extension ListKxVolumesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListKxVolumesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKxVolumesOutputBody = try responseDecoder.decode(responseBody: data)
            self.kxVolumeSummaries = output.kxVolumeSummaries
            self.nextToken = output.nextToken
        } else {
            self.kxVolumeSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListKxVolumesOutput: Swift.Equatable {
    /// A summary of volumes.
    public var kxVolumeSummaries: [FinspaceClientTypes.KxVolume]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        kxVolumeSummaries: [FinspaceClientTypes.KxVolume]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kxVolumeSummaries = kxVolumeSummaries
        self.nextToken = nextToken
    }
}

struct ListKxVolumesOutputBody: Swift.Equatable {
    let kxVolumeSummaries: [FinspaceClientTypes.KxVolume]?
    let nextToken: Swift.String?
}

extension ListKxVolumesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kxVolumeSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kxVolumeSummariesContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxVolume?].self, forKey: .kxVolumeSummaries)
        var kxVolumeSummariesDecoded0:[FinspaceClientTypes.KxVolume]? = nil
        if let kxVolumeSummariesContainer = kxVolumeSummariesContainer {
            kxVolumeSummariesDecoded0 = [FinspaceClientTypes.KxVolume]()
            for structure0 in kxVolumeSummariesContainer {
                if let structure0 = structure0 {
                    kxVolumeSummariesDecoded0?.append(structure0)
                }
            }
        }
        kxVolumeSummaries = kxVolumeSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKxVolumesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of all tags for a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FinspaceClientTypes.NetworkACLEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrBlock
        case icmpTypeCode
        case portRange
        case `protocol` = "protocol"
        case ruleAction
        case ruleNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrBlock = self.cidrBlock {
            try encodeContainer.encode(cidrBlock, forKey: .cidrBlock)
        }
        if let icmpTypeCode = self.icmpTypeCode {
            try encodeContainer.encode(icmpTypeCode, forKey: .icmpTypeCode)
        }
        if let portRange = self.portRange {
            try encodeContainer.encode(portRange, forKey: .portRange)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let ruleAction = self.ruleAction {
            try encodeContainer.encode(ruleAction.rawValue, forKey: .ruleAction)
        }
        if let ruleNumber = self.ruleNumber {
            try encodeContainer.encode(ruleNumber, forKey: .ruleNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ruleNumber)
        ruleNumber = ruleNumberDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let ruleActionDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.RuleAction.self, forKey: .ruleAction)
        ruleAction = ruleActionDecoded
        let portRangeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.PortRange.self, forKey: .portRange)
        portRange = portRangeDecoded
        let icmpTypeCodeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.IcmpTypeCode.self, forKey: .icmpTypeCode)
        icmpTypeCode = icmpTypeCodeDecoded
        let cidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrBlock)
        cidrBlock = cidrBlockDecoded
    }
}

extension FinspaceClientTypes {
    /// The network access control list (ACL) is an optional layer of security for your VPC that acts as a firewall for controlling traffic in and out of one or more subnets. The entry is a set of numbered ingress and egress rules that determine whether a packet should be allowed in or out of a subnet associated with the ACL. We process the entries in the ACL according to the rule numbers, in ascending order.
    public struct NetworkACLEntry: Swift.Equatable {
        /// The IPv4 network range to allow or deny, in CIDR notation. For example, 172.16.0.0/24. We modify the specified CIDR block to its canonical form. For example, if you specify 100.68.0.18/18, we modify it to 100.68.0.0/18.
        /// This member is required.
        public var cidrBlock: Swift.String?
        /// Defines the ICMP protocol that consists of the ICMP type and code.
        public var icmpTypeCode: FinspaceClientTypes.IcmpTypeCode?
        /// The range of ports the rule applies to.
        public var portRange: FinspaceClientTypes.PortRange?
        /// The protocol number. A value of -1 means all the protocols.
        /// This member is required.
        public var `protocol`: Swift.String?
        /// Indicates whether to allow or deny the traffic that matches the rule.
        /// This member is required.
        public var ruleAction: FinspaceClientTypes.RuleAction?
        /// The rule number for the entry. For example 100. All the network ACL entries are processed in ascending order by rule number.
        /// This member is required.
        public var ruleNumber: Swift.Int?

        public init(
            cidrBlock: Swift.String? = nil,
            icmpTypeCode: FinspaceClientTypes.IcmpTypeCode? = nil,
            portRange: FinspaceClientTypes.PortRange? = nil,
            `protocol`: Swift.String? = nil,
            ruleAction: FinspaceClientTypes.RuleAction? = nil,
            ruleNumber: Swift.Int? = nil
        )
        {
            self.cidrBlock = cidrBlock
            self.icmpTypeCode = icmpTypeCode
            self.portRange = portRange
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
            self.ruleNumber = ruleNumber
        }
    }

}

extension FinspaceClientTypes.PortRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from
        case to
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if from != 0 {
            try encodeContainer.encode(from, forKey: .from)
        }
        if to != 0 {
            try encodeContainer.encode(to, forKey: .to)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .from) ?? 0
        from = fromDecoded
        let toDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .to) ?? 0
        to = toDecoded
    }
}

extension FinspaceClientTypes {
    /// The range of ports the rule applies to.
    public struct PortRange: Swift.Equatable {
        /// The first port in the range.
        /// This member is required.
        public var from: Swift.Int
        /// The last port in the range.
        /// This member is required.
        public var to: Swift.Int

        public init(
            from: Swift.Int = 0,
            to: Swift.Int = 0
        )
        {
            self.from = from
            self.to = to
        }
    }

}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource group already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more resources can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FinspaceClientTypes {
    public enum RuleAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleAction] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "allow"
            case .deny: return "deny"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleAction(rawValue: rawValue) ?? RuleAction.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FinspaceClientTypes.SuperuserParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailAddress
        case firstName
        case lastName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
    }
}

extension FinspaceClientTypes.SuperuserParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuperuserParameters(firstName: \(Swift.String(describing: firstName)), lastName: \(Swift.String(describing: lastName)), emailAddress: \"CONTENT_REDACTED\")"}
}

extension FinspaceClientTypes {
    /// Configuration information for the superuser.
    public struct SuperuserParameters: Swift.Equatable {
        /// The email address of the superuser.
        /// This member is required.
        public var emailAddress: Swift.String?
        /// The first name of the superuser.
        /// This member is required.
        public var firstName: Swift.String?
        /// The last name of the superuser.
        /// This member is required.
        public var lastName: Swift.String?

        public init(
            emailAddress: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil
        )
        {
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.lastName = lastName
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags to be assigned to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FinspaceClientTypes {
    public enum TgwStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failedUpdate
        case `none`
        case successfullyUpdated
        case updateRequested
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [TgwStatus] {
            return [
                .failedUpdate,
                .none,
                .successfullyUpdated,
                .updateRequested,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failedUpdate: return "FAILED_UPDATE"
            case .none: return "NONE"
            case .successfullyUpdated: return "SUCCESSFULLY_UPDATED"
            case .updateRequested: return "UPDATE_REQUESTED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TgwStatus(rawValue: rawValue) ?? TgwStatus.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FinspaceClientTypes.TickerplantLogConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tickerplantLogVolumes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tickerplantLogVolumes = tickerplantLogVolumes {
            var tickerplantLogVolumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tickerplantLogVolumes)
            for volumename0 in tickerplantLogVolumes {
                try tickerplantLogVolumesContainer.encode(volumename0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tickerplantLogVolumesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tickerplantLogVolumes)
        var tickerplantLogVolumesDecoded0:[Swift.String]? = nil
        if let tickerplantLogVolumesContainer = tickerplantLogVolumesContainer {
            tickerplantLogVolumesDecoded0 = [Swift.String]()
            for string0 in tickerplantLogVolumesContainer {
                if let string0 = string0 {
                    tickerplantLogVolumesDecoded0?.append(string0)
                }
            }
        }
        tickerplantLogVolumes = tickerplantLogVolumesDecoded0
    }
}

extension FinspaceClientTypes {
    /// A configuration to store the Tickerplant logs. It consists of a list of volumes that will be mounted to your cluster. For the cluster type Tickerplant, the location of the TP volume on the cluster will be available by using the global variable .aws.tp_log_path.
    public struct TickerplantLogConfiguration: Swift.Equatable {
        /// The name of the volumes for tickerplant logs.
        public var tickerplantLogVolumes: [Swift.String]?

        public init(
            tickerplantLogVolumes: [Swift.String]? = nil
        )
        {
            self.tickerplantLogVolumes = tickerplantLogVolumes
        }
    }

}

extension FinspaceClientTypes.TransitGatewayConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentNetworkAclConfiguration
        case routableCIDRSpace
        case transitGatewayID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentNetworkAclConfiguration = attachmentNetworkAclConfiguration {
            var attachmentNetworkAclConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachmentNetworkAclConfiguration)
            for networkaclentry0 in attachmentNetworkAclConfiguration {
                try attachmentNetworkAclConfigurationContainer.encode(networkaclentry0)
            }
        }
        if let routableCIDRSpace = self.routableCIDRSpace {
            try encodeContainer.encode(routableCIDRSpace, forKey: .routableCIDRSpace)
        }
        if let transitGatewayID = self.transitGatewayID {
            try encodeContainer.encode(transitGatewayID, forKey: .transitGatewayID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayID)
        transitGatewayID = transitGatewayIDDecoded
        let routableCIDRSpaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routableCIDRSpace)
        routableCIDRSpace = routableCIDRSpaceDecoded
        let attachmentNetworkAclConfigurationContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.NetworkACLEntry?].self, forKey: .attachmentNetworkAclConfiguration)
        var attachmentNetworkAclConfigurationDecoded0:[FinspaceClientTypes.NetworkACLEntry]? = nil
        if let attachmentNetworkAclConfigurationContainer = attachmentNetworkAclConfigurationContainer {
            attachmentNetworkAclConfigurationDecoded0 = [FinspaceClientTypes.NetworkACLEntry]()
            for structure0 in attachmentNetworkAclConfigurationContainer {
                if let structure0 = structure0 {
                    attachmentNetworkAclConfigurationDecoded0?.append(structure0)
                }
            }
        }
        attachmentNetworkAclConfiguration = attachmentNetworkAclConfigurationDecoded0
    }
}

extension FinspaceClientTypes {
    /// The structure of the transit gateway and network configuration that is used to connect the kdb environment to an internal network.
    public struct TransitGatewayConfiguration: Swift.Equatable {
        /// The rules that define how you manage the outbound traffic from kdb network to your internal network.
        public var attachmentNetworkAclConfiguration: [FinspaceClientTypes.NetworkACLEntry]?
        /// The routing CIDR on behalf of kdb environment. It could be any "/26 range in the 100.64.0.0 CIDR space. After providing, it will be added to the customer's transit gateway routing table so that the traffics could be routed to kdb network.
        /// This member is required.
        public var routableCIDRSpace: Swift.String?
        /// The identifier of the transit gateway created by the customer to connect outbound traffics from kdb network to your internal network.
        /// This member is required.
        public var transitGatewayID: Swift.String?

        public init(
            attachmentNetworkAclConfiguration: [FinspaceClientTypes.NetworkACLEntry]? = nil,
            routableCIDRSpace: Swift.String? = nil,
            transitGatewayID: Swift.String? = nil
        )
        {
            self.attachmentNetworkAclConfiguration = attachmentNetworkAclConfiguration
            self.routableCIDRSpace = routableCIDRSpace
            self.transitGatewayID = transitGatewayID
        }
    }

}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// A FinSpace resource from which you want to remove a tag or tags. The value for this parameter is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys (names) of one or more tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case federationMode
        case federationParameters
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let federationMode = self.federationMode {
            try encodeContainer.encode(federationMode.rawValue, forKey: .federationMode)
        }
        if let federationParameters = self.federationParameters {
            try encodeContainer.encode(federationParameters, forKey: .federationParameters)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateEnvironmentInput {

    static func urlPathProvider(_ value: UpdateEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/environment/\(environmentId.urlPercentEncoding())"
    }
}

public struct UpdateEnvironmentInput: Swift.Equatable {
    /// The description of the environment.
    public var description: Swift.String?
    /// The identifier of the FinSpace environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Authentication mode for the environment.
    ///
    /// * FEDERATED - Users access FinSpace through Single Sign On (SSO) via your Identity provider.
    ///
    /// * LOCAL - Users access FinSpace via email and password managed within the FinSpace environment.
    public var federationMode: FinspaceClientTypes.FederationMode?
    /// Configuration information when authentication mode is FEDERATED.
    public var federationParameters: FinspaceClientTypes.FederationParameters?
    /// The name of the environment.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        federationMode: FinspaceClientTypes.FederationMode? = nil,
        federationParameters: FinspaceClientTypes.FederationParameters? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.environmentId = environmentId
        self.federationMode = federationMode
        self.federationParameters = federationParameters
        self.name = name
    }
}

struct UpdateEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let federationMode: FinspaceClientTypes.FederationMode?
    let federationParameters: FinspaceClientTypes.FederationParameters?
}

extension UpdateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case federationMode
        case federationParameters
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let federationModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.FederationMode.self, forKey: .federationMode)
        federationMode = federationModeDecoded
        let federationParametersDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.FederationParameters.self, forKey: .federationParameters)
        federationParameters = federationParametersDecoded
    }
}

extension UpdateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct UpdateEnvironmentOutput: Swift.Equatable {
    /// Returns the FinSpace environment object.
    public var environment: FinspaceClientTypes.Environment?

    public init(
        environment: FinspaceClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct UpdateEnvironmentOutputBody: Swift.Equatable {
    let environment: FinspaceClientTypes.Environment?
}

extension UpdateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum UpdateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateKxClusterCodeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case code
        case commandLineArguments
        case deploymentConfiguration
        case initializationScript
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let commandLineArguments = commandLineArguments {
            var commandLineArgumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .commandLineArguments)
            for kxcommandlineargument0 in commandLineArguments {
                try commandLineArgumentsContainer.encode(kxcommandlineargument0)
            }
        }
        if let deploymentConfiguration = self.deploymentConfiguration {
            try encodeContainer.encode(deploymentConfiguration, forKey: .deploymentConfiguration)
        }
        if let initializationScript = self.initializationScript {
            try encodeContainer.encode(initializationScript, forKey: .initializationScript)
        }
    }
}

extension UpdateKxClusterCodeConfigurationInput {

    static func urlPathProvider(_ value: UpdateKxClusterCodeConfigurationInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let clusterName = value.clusterName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters/\(clusterName.urlPercentEncoding())/configuration/code"
    }
}

public struct UpdateKxClusterCodeConfigurationInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The name of the cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// The structure of the customer code available within the running cluster.
    /// This member is required.
    public var code: FinspaceClientTypes.CodeConfiguration?
    /// Specifies the key-value pairs to make them available inside the cluster. You cannot update this parameter for a NO_RESTART deployment.
    public var commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]?
    /// The configuration that allows you to choose how you want to update the code on a cluster.
    public var deploymentConfiguration: FinspaceClientTypes.KxClusterCodeDeploymentConfiguration?
    /// A unique identifier of the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q. You cannot update this parameter for a NO_RESTART deployment.
    public var initializationScript: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        code: FinspaceClientTypes.CodeConfiguration? = nil,
        commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]? = nil,
        deploymentConfiguration: FinspaceClientTypes.KxClusterCodeDeploymentConfiguration? = nil,
        environmentId: Swift.String? = nil,
        initializationScript: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.clusterName = clusterName
        self.code = code
        self.commandLineArguments = commandLineArguments
        self.deploymentConfiguration = deploymentConfiguration
        self.environmentId = environmentId
        self.initializationScript = initializationScript
    }
}

struct UpdateKxClusterCodeConfigurationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let code: FinspaceClientTypes.CodeConfiguration?
    let initializationScript: Swift.String?
    let commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]?
    let deploymentConfiguration: FinspaceClientTypes.KxClusterCodeDeploymentConfiguration?
}

extension UpdateKxClusterCodeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case code
        case commandLineArguments
        case deploymentConfiguration
        case initializationScript
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let codeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.CodeConfiguration.self, forKey: .code)
        code = codeDecoded
        let initializationScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initializationScript)
        initializationScript = initializationScriptDecoded
        let commandLineArgumentsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxCommandLineArgument?].self, forKey: .commandLineArguments)
        var commandLineArgumentsDecoded0:[FinspaceClientTypes.KxCommandLineArgument]? = nil
        if let commandLineArgumentsContainer = commandLineArgumentsContainer {
            commandLineArgumentsDecoded0 = [FinspaceClientTypes.KxCommandLineArgument]()
            for structure0 in commandLineArgumentsContainer {
                if let structure0 = structure0 {
                    commandLineArgumentsDecoded0?.append(structure0)
                }
            }
        }
        commandLineArguments = commandLineArgumentsDecoded0
        let deploymentConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxClusterCodeDeploymentConfiguration.self, forKey: .deploymentConfiguration)
        deploymentConfiguration = deploymentConfigurationDecoded
    }
}

extension UpdateKxClusterCodeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateKxClusterCodeConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateKxClusterCodeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateKxClusterDatabasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case databases
        case deploymentConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let databases = databases {
            var databasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .databases)
            for kxdatabaseconfiguration0 in databases {
                try databasesContainer.encode(kxdatabaseconfiguration0)
            }
        }
        if let deploymentConfiguration = self.deploymentConfiguration {
            try encodeContainer.encode(deploymentConfiguration, forKey: .deploymentConfiguration)
        }
    }
}

extension UpdateKxClusterDatabasesInput {

    static func urlPathProvider(_ value: UpdateKxClusterDatabasesInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let clusterName = value.clusterName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters/\(clusterName.urlPercentEncoding())/configuration/databases"
    }
}

public struct UpdateKxClusterDatabasesInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A unique name for the cluster that you want to modify.
    /// This member is required.
    public var clusterName: Swift.String?
    /// The structure of databases mounted on the cluster.
    /// This member is required.
    public var databases: [FinspaceClientTypes.KxDatabaseConfiguration]?
    /// The configuration that allows you to choose how you want to update the databases on a cluster.
    public var deploymentConfiguration: FinspaceClientTypes.KxDeploymentConfiguration?
    /// The unique identifier of a kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        databases: [FinspaceClientTypes.KxDatabaseConfiguration]? = nil,
        deploymentConfiguration: FinspaceClientTypes.KxDeploymentConfiguration? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.clusterName = clusterName
        self.databases = databases
        self.deploymentConfiguration = deploymentConfiguration
        self.environmentId = environmentId
    }
}

struct UpdateKxClusterDatabasesInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let databases: [FinspaceClientTypes.KxDatabaseConfiguration]?
    let deploymentConfiguration: FinspaceClientTypes.KxDeploymentConfiguration?
}

extension UpdateKxClusterDatabasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case databases
        case deploymentConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let databasesContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDatabaseConfiguration?].self, forKey: .databases)
        var databasesDecoded0:[FinspaceClientTypes.KxDatabaseConfiguration]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [FinspaceClientTypes.KxDatabaseConfiguration]()
            for structure0 in databasesContainer {
                if let structure0 = structure0 {
                    databasesDecoded0?.append(structure0)
                }
            }
        }
        databases = databasesDecoded0
        let deploymentConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxDeploymentConfiguration.self, forKey: .deploymentConfiguration)
        deploymentConfiguration = deploymentConfigurationDecoded
    }
}

extension UpdateKxClusterDatabasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateKxClusterDatabasesOutput: Swift.Equatable {

    public init() { }
}

enum UpdateKxClusterDatabasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateKxDatabaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateKxDatabaseInput {

    static func urlPathProvider(_ value: UpdateKxDatabaseInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())"
    }
}

public struct UpdateKxDatabaseInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The name of the kdb database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A description of the database.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.databaseName = databaseName
        self.description = description
        self.environmentId = environmentId
    }
}

struct UpdateKxDatabaseInputBody: Swift.Equatable {
    let description: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateKxDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateKxDatabaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateKxDatabaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.databaseName = output.databaseName
            self.description = output.description
            self.environmentId = output.environmentId
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
        } else {
            self.databaseName = nil
            self.description = nil
            self.environmentId = nil
            self.lastModifiedTimestamp = nil
        }
    }
}

public struct UpdateKxDatabaseOutput: Swift.Equatable {
    /// The name of the kdb database.
    public var databaseName: Swift.String?
    /// A description of the database.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// The last time that the database was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: ClientRuntime.Date?

    public init(
        databaseName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.databaseName = databaseName
        self.description = description
        self.environmentId = environmentId
        self.lastModifiedTimestamp = lastModifiedTimestamp
    }
}

struct UpdateKxDatabaseOutputBody: Swift.Equatable {
    let databaseName: Swift.String?
    let environmentId: Swift.String?
    let description: Swift.String?
    let lastModifiedTimestamp: ClientRuntime.Date?
}

extension UpdateKxDatabaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName
        case description
        case environmentId
        case lastModifiedTimestamp
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

enum UpdateKxDatabaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateKxDataviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changesetId
        case clientToken
        case description
        case segmentConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changesetId = self.changesetId {
            try encodeContainer.encode(changesetId, forKey: .changesetId)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let segmentConfigurations = segmentConfigurations {
            var segmentConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segmentConfigurations)
            for kxdataviewsegmentconfiguration0 in segmentConfigurations {
                try segmentConfigurationsContainer.encode(kxdataviewsegmentconfiguration0)
            }
        }
    }
}

extension UpdateKxDataviewInput {

    static func urlPathProvider(_ value: UpdateKxDataviewInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        guard let dataviewName = value.dataviewName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/dataviews/\(dataviewName.urlPercentEncoding())"
    }
}

public struct UpdateKxDataviewInput: Swift.Equatable {
    /// A unique identifier for the changeset.
    public var changesetId: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The name of the database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the dataview that you want to update.
    /// This member is required.
    public var dataviewName: Swift.String?
    /// The description for a dataview.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, where you want to update the dataview.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
    public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?

    public init(
        changesetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        dataviewName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil
    )
    {
        self.changesetId = changesetId
        self.clientToken = clientToken
        self.databaseName = databaseName
        self.dataviewName = dataviewName
        self.description = description
        self.environmentId = environmentId
        self.segmentConfigurations = segmentConfigurations
    }
}

struct UpdateKxDataviewInputBody: Swift.Equatable {
    let description: Swift.String?
    let changesetId: Swift.String?
    let segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
    let clientToken: Swift.String?
}

extension UpdateKxDataviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changesetId
        case clientToken
        case description
        case segmentConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let segmentConfigurationsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDataviewSegmentConfiguration?].self, forKey: .segmentConfigurations)
        var segmentConfigurationsDecoded0:[FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil
        if let segmentConfigurationsContainer = segmentConfigurationsContainer {
            segmentConfigurationsDecoded0 = [FinspaceClientTypes.KxDataviewSegmentConfiguration]()
            for structure0 in segmentConfigurationsContainer {
                if let structure0 = structure0 {
                    segmentConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        segmentConfigurations = segmentConfigurationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateKxDataviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateKxDataviewOutputBody = try responseDecoder.decode(responseBody: data)
            self.activeVersions = output.activeVersions
            self.autoUpdate = output.autoUpdate
            self.availabilityZoneId = output.availabilityZoneId
            self.azMode = output.azMode
            self.changesetId = output.changesetId
            self.createdTimestamp = output.createdTimestamp
            self.databaseName = output.databaseName
            self.dataviewName = output.dataviewName
            self.description = output.description
            self.environmentId = output.environmentId
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.segmentConfigurations = output.segmentConfigurations
            self.status = output.status
        } else {
            self.activeVersions = nil
            self.autoUpdate = false
            self.availabilityZoneId = nil
            self.azMode = nil
            self.changesetId = nil
            self.createdTimestamp = nil
            self.databaseName = nil
            self.dataviewName = nil
            self.description = nil
            self.environmentId = nil
            self.lastModifiedTimestamp = nil
            self.segmentConfigurations = nil
            self.status = nil
        }
    }
}

public struct UpdateKxDataviewOutput: Swift.Equatable {
    /// The current active changeset versions of the database on the given dataview.
    public var activeVersions: [FinspaceClientTypes.KxDataviewActiveVersion]?
    /// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview when new changesets are ingested. The default value is false.
    public var autoUpdate: Swift.Bool
    /// The identifier of the availability zones.
    public var availabilityZoneId: Swift.String?
    /// The number of availability zones you want to assign per cluster. This can be one of the following
    ///
    /// * SINGLE – Assigns one availability zone per cluster.
    ///
    /// * MULTI – Assigns all the availability zones per cluster.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// A unique identifier for the changeset.
    public var changesetId: Swift.String?
    /// The timestamp at which the dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: ClientRuntime.Date?
    /// The name of the database.
    public var databaseName: Swift.String?
    /// The name of the database under which the dataview was created.
    public var dataviewName: Swift.String?
    /// A description of the dataview.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, where you want to update the dataview.
    public var environmentId: Swift.String?
    /// The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
    public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
    /// The status of dataview creation.
    ///
    /// * CREATING – The dataview creation is in progress.
    ///
    /// * UPDATING – The dataview is in the process of being updated.
    ///
    /// * ACTIVE – The dataview is active.
    public var status: FinspaceClientTypes.KxDataviewStatus?

    public init(
        activeVersions: [FinspaceClientTypes.KxDataviewActiveVersion]? = nil,
        autoUpdate: Swift.Bool = false,
        availabilityZoneId: Swift.String? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        changesetId: Swift.String? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        databaseName: Swift.String? = nil,
        dataviewName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil,
        status: FinspaceClientTypes.KxDataviewStatus? = nil
    )
    {
        self.activeVersions = activeVersions
        self.autoUpdate = autoUpdate
        self.availabilityZoneId = availabilityZoneId
        self.azMode = azMode
        self.changesetId = changesetId
        self.createdTimestamp = createdTimestamp
        self.databaseName = databaseName
        self.dataviewName = dataviewName
        self.description = description
        self.environmentId = environmentId
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.segmentConfigurations = segmentConfigurations
        self.status = status
    }
}

struct UpdateKxDataviewOutputBody: Swift.Equatable {
    let environmentId: Swift.String?
    let databaseName: Swift.String?
    let dataviewName: Swift.String?
    let azMode: FinspaceClientTypes.KxAzMode?
    let availabilityZoneId: Swift.String?
    let changesetId: Swift.String?
    let segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
    let activeVersions: [FinspaceClientTypes.KxDataviewActiveVersion]?
    let status: FinspaceClientTypes.KxDataviewStatus?
    let autoUpdate: Swift.Bool
    let description: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
    let lastModifiedTimestamp: ClientRuntime.Date?
}

extension UpdateKxDataviewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeVersions
        case autoUpdate
        case availabilityZoneId
        case azMode
        case changesetId
        case createdTimestamp
        case databaseName
        case dataviewName
        case description
        case environmentId
        case lastModifiedTimestamp
        case segmentConfigurations
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dataviewNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataviewName)
        dataviewName = dataviewNameDecoded
        let azModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxAzMode.self, forKey: .azMode)
        azMode = azModeDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let segmentConfigurationsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDataviewSegmentConfiguration?].self, forKey: .segmentConfigurations)
        var segmentConfigurationsDecoded0:[FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil
        if let segmentConfigurationsContainer = segmentConfigurationsContainer {
            segmentConfigurationsDecoded0 = [FinspaceClientTypes.KxDataviewSegmentConfiguration]()
            for structure0 in segmentConfigurationsContainer {
                if let structure0 = structure0 {
                    segmentConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        segmentConfigurations = segmentConfigurationsDecoded0
        let activeVersionsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxDataviewActiveVersion?].self, forKey: .activeVersions)
        var activeVersionsDecoded0:[FinspaceClientTypes.KxDataviewActiveVersion]? = nil
        if let activeVersionsContainer = activeVersionsContainer {
            activeVersionsDecoded0 = [FinspaceClientTypes.KxDataviewActiveVersion]()
            for structure0 in activeVersionsContainer {
                if let structure0 = structure0 {
                    activeVersionsDecoded0?.append(structure0)
                }
            }
        }
        activeVersions = activeVersionsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxDataviewStatus.self, forKey: .status)
        status = statusDecoded
        let autoUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoUpdate) ?? false
        autoUpdate = autoUpdateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

enum UpdateKxDataviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateKxEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateKxEnvironmentInput {

    static func urlPathProvider(_ value: UpdateKxEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())"
    }
}

public struct UpdateKxEnvironmentInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A description of the kdb environment.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The name of the kdb environment.
    public var name: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.environmentId = environmentId
        self.name = name
    }
}

struct UpdateKxEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateKxEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateKxEnvironmentNetworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case customDNSConfiguration
        case transitGatewayConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customDNSConfiguration = customDNSConfiguration {
            var customDNSConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customDNSConfiguration)
            for customdnsserver0 in customDNSConfiguration {
                try customDNSConfigurationContainer.encode(customdnsserver0)
            }
        }
        if let transitGatewayConfiguration = self.transitGatewayConfiguration {
            try encodeContainer.encode(transitGatewayConfiguration, forKey: .transitGatewayConfiguration)
        }
    }
}

extension UpdateKxEnvironmentNetworkInput {

    static func urlPathProvider(_ value: UpdateKxEnvironmentNetworkInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/network"
    }
}

public struct UpdateKxEnvironmentNetworkInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
    public var customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the transit gateway and network configuration to connect the kdb environment to an internal network.
    public var transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration?

    public init(
        clientToken: Swift.String? = nil,
        customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]? = nil,
        environmentId: Swift.String? = nil,
        transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration? = nil
    )
    {
        self.clientToken = clientToken
        self.customDNSConfiguration = customDNSConfiguration
        self.environmentId = environmentId
        self.transitGatewayConfiguration = transitGatewayConfiguration
    }
}

struct UpdateKxEnvironmentNetworkInputBody: Swift.Equatable {
    let transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration?
    let customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]?
    let clientToken: Swift.String?
}

extension UpdateKxEnvironmentNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case customDNSConfiguration
        case transitGatewayConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.TransitGatewayConfiguration.self, forKey: .transitGatewayConfiguration)
        transitGatewayConfiguration = transitGatewayConfigurationDecoded
        let customDNSConfigurationContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.CustomDNSServer?].self, forKey: .customDNSConfiguration)
        var customDNSConfigurationDecoded0:[FinspaceClientTypes.CustomDNSServer]? = nil
        if let customDNSConfigurationContainer = customDNSConfigurationContainer {
            customDNSConfigurationDecoded0 = [FinspaceClientTypes.CustomDNSServer]()
            for structure0 in customDNSConfigurationContainer {
                if let structure0 = structure0 {
                    customDNSConfigurationDecoded0?.append(structure0)
                }
            }
        }
        customDNSConfiguration = customDNSConfigurationDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateKxEnvironmentNetworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateKxEnvironmentNetworkOutputBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZoneIds = output.availabilityZoneIds
            self.awsAccountId = output.awsAccountId
            self.creationTimestamp = output.creationTimestamp
            self.customDNSConfiguration = output.customDNSConfiguration
            self.dedicatedServiceAccountId = output.dedicatedServiceAccountId
            self.description = output.description
            self.dnsStatus = output.dnsStatus
            self.environmentArn = output.environmentArn
            self.environmentId = output.environmentId
            self.errorMessage = output.errorMessage
            self.kmsKeyId = output.kmsKeyId
            self.name = output.name
            self.status = output.status
            self.tgwStatus = output.tgwStatus
            self.transitGatewayConfiguration = output.transitGatewayConfiguration
            self.updateTimestamp = output.updateTimestamp
        } else {
            self.availabilityZoneIds = nil
            self.awsAccountId = nil
            self.creationTimestamp = nil
            self.customDNSConfiguration = nil
            self.dedicatedServiceAccountId = nil
            self.description = nil
            self.dnsStatus = nil
            self.environmentArn = nil
            self.environmentId = nil
            self.errorMessage = nil
            self.kmsKeyId = nil
            self.name = nil
            self.status = nil
            self.tgwStatus = nil
            self.transitGatewayConfiguration = nil
            self.updateTimestamp = nil
        }
    }
}

public struct UpdateKxEnvironmentNetworkOutput: Swift.Equatable {
    /// The identifier of the availability zones where subnets for the environment are created.
    public var availabilityZoneIds: [Swift.String]?
    /// The unique identifier of the AWS account that is used to create the kdb environment.
    public var awsAccountId: Swift.String?
    /// The timestamp at which the kdb environment was created in FinSpace.
    public var creationTimestamp: ClientRuntime.Date?
    /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
    public var customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]?
    /// A unique identifier for the AWS environment infrastructure account.
    public var dedicatedServiceAccountId: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The status of DNS configuration.
    public var dnsStatus: FinspaceClientTypes.DnsStatus?
    /// The ARN identifier of the environment.
    public var environmentArn: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// Specifies the error message that appears if a flow fails.
    public var errorMessage: Swift.String?
    /// The KMS key ID to encrypt your data in the FinSpace environment.
    public var kmsKeyId: Swift.String?
    /// The name of the kdb environment.
    public var name: Swift.String?
    /// The status of the kdb environment.
    public var status: FinspaceClientTypes.EnvironmentStatus?
    /// The status of the network configuration.
    public var tgwStatus: FinspaceClientTypes.TgwStatus?
    /// The structure of the transit gateway and network configuration that is used to connect the kdb environment to an internal network.
    public var transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration?
    /// The timestamp at which the kdb environment was updated.
    public var updateTimestamp: ClientRuntime.Date?

    public init(
        availabilityZoneIds: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        creationTimestamp: ClientRuntime.Date? = nil,
        customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]? = nil,
        dedicatedServiceAccountId: Swift.String? = nil,
        description: Swift.String? = nil,
        dnsStatus: FinspaceClientTypes.DnsStatus? = nil,
        environmentArn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: FinspaceClientTypes.EnvironmentStatus? = nil,
        tgwStatus: FinspaceClientTypes.TgwStatus? = nil,
        transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration? = nil,
        updateTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.availabilityZoneIds = availabilityZoneIds
        self.awsAccountId = awsAccountId
        self.creationTimestamp = creationTimestamp
        self.customDNSConfiguration = customDNSConfiguration
        self.dedicatedServiceAccountId = dedicatedServiceAccountId
        self.description = description
        self.dnsStatus = dnsStatus
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.status = status
        self.tgwStatus = tgwStatus
        self.transitGatewayConfiguration = transitGatewayConfiguration
        self.updateTimestamp = updateTimestamp
    }
}

struct UpdateKxEnvironmentNetworkOutputBody: Swift.Equatable {
    let name: Swift.String?
    let environmentId: Swift.String?
    let awsAccountId: Swift.String?
    let status: FinspaceClientTypes.EnvironmentStatus?
    let tgwStatus: FinspaceClientTypes.TgwStatus?
    let dnsStatus: FinspaceClientTypes.DnsStatus?
    let errorMessage: Swift.String?
    let description: Swift.String?
    let environmentArn: Swift.String?
    let kmsKeyId: Swift.String?
    let dedicatedServiceAccountId: Swift.String?
    let transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration?
    let customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]?
    let creationTimestamp: ClientRuntime.Date?
    let updateTimestamp: ClientRuntime.Date?
    let availabilityZoneIds: [Swift.String]?
}

extension UpdateKxEnvironmentNetworkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneIds
        case awsAccountId
        case creationTimestamp
        case customDNSConfiguration
        case dedicatedServiceAccountId
        case description
        case dnsStatus
        case environmentArn
        case environmentId
        case errorMessage
        case kmsKeyId
        case name
        case status
        case tgwStatus
        case transitGatewayConfiguration
        case updateTimestamp
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let tgwStatusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.TgwStatus.self, forKey: .tgwStatus)
        tgwStatus = tgwStatusDecoded
        let dnsStatusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.DnsStatus.self, forKey: .dnsStatus)
        dnsStatus = dnsStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dedicatedServiceAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedServiceAccountId)
        dedicatedServiceAccountId = dedicatedServiceAccountIdDecoded
        let transitGatewayConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.TransitGatewayConfiguration.self, forKey: .transitGatewayConfiguration)
        transitGatewayConfiguration = transitGatewayConfigurationDecoded
        let customDNSConfigurationContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.CustomDNSServer?].self, forKey: .customDNSConfiguration)
        var customDNSConfigurationDecoded0:[FinspaceClientTypes.CustomDNSServer]? = nil
        if let customDNSConfigurationContainer = customDNSConfigurationContainer {
            customDNSConfigurationDecoded0 = [FinspaceClientTypes.CustomDNSServer]()
            for structure0 in customDNSConfigurationContainer {
                if let structure0 = structure0 {
                    customDNSConfigurationDecoded0?.append(structure0)
                }
            }
        }
        customDNSConfiguration = customDNSConfigurationDecoded0
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let updateTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTimestamp)
        updateTimestamp = updateTimestampDecoded
        let availabilityZoneIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZoneIds)
        var availabilityZoneIdsDecoded0:[Swift.String]? = nil
        if let availabilityZoneIdsContainer = availabilityZoneIdsContainer {
            availabilityZoneIdsDecoded0 = [Swift.String]()
            for string0 in availabilityZoneIdsContainer {
                if let string0 = string0 {
                    availabilityZoneIdsDecoded0?.append(string0)
                }
            }
        }
        availabilityZoneIds = availabilityZoneIdsDecoded0
    }
}

enum UpdateKxEnvironmentNetworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateKxEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateKxEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZoneIds = output.availabilityZoneIds
            self.awsAccountId = output.awsAccountId
            self.creationTimestamp = output.creationTimestamp
            self.customDNSConfiguration = output.customDNSConfiguration
            self.dedicatedServiceAccountId = output.dedicatedServiceAccountId
            self.description = output.description
            self.dnsStatus = output.dnsStatus
            self.environmentArn = output.environmentArn
            self.environmentId = output.environmentId
            self.errorMessage = output.errorMessage
            self.kmsKeyId = output.kmsKeyId
            self.name = output.name
            self.status = output.status
            self.tgwStatus = output.tgwStatus
            self.transitGatewayConfiguration = output.transitGatewayConfiguration
            self.updateTimestamp = output.updateTimestamp
        } else {
            self.availabilityZoneIds = nil
            self.awsAccountId = nil
            self.creationTimestamp = nil
            self.customDNSConfiguration = nil
            self.dedicatedServiceAccountId = nil
            self.description = nil
            self.dnsStatus = nil
            self.environmentArn = nil
            self.environmentId = nil
            self.errorMessage = nil
            self.kmsKeyId = nil
            self.name = nil
            self.status = nil
            self.tgwStatus = nil
            self.transitGatewayConfiguration = nil
            self.updateTimestamp = nil
        }
    }
}

public struct UpdateKxEnvironmentOutput: Swift.Equatable {
    /// The identifier of the availability zones where subnets for the environment are created.
    public var availabilityZoneIds: [Swift.String]?
    /// The unique identifier of the AWS account that is used to create the kdb environment.
    public var awsAccountId: Swift.String?
    /// The timestamp at which the kdb environment was created in FinSpace.
    public var creationTimestamp: ClientRuntime.Date?
    /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
    public var customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]?
    /// A unique identifier for the AWS environment infrastructure account.
    public var dedicatedServiceAccountId: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The status of DNS configuration.
    public var dnsStatus: FinspaceClientTypes.DnsStatus?
    /// The ARN identifier of the environment.
    public var environmentArn: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// Specifies the error message that appears if a flow fails.
    public var errorMessage: Swift.String?
    /// The KMS key ID to encrypt your data in the FinSpace environment.
    public var kmsKeyId: Swift.String?
    /// The name of the kdb environment.
    public var name: Swift.String?
    /// The status of the kdb environment.
    public var status: FinspaceClientTypes.EnvironmentStatus?
    /// The status of the network configuration.
    public var tgwStatus: FinspaceClientTypes.TgwStatus?
    /// The structure of the transit gateway and network configuration that is used to connect the kdb environment to an internal network.
    public var transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration?
    /// The timestamp at which the kdb environment was updated.
    public var updateTimestamp: ClientRuntime.Date?

    public init(
        availabilityZoneIds: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        creationTimestamp: ClientRuntime.Date? = nil,
        customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]? = nil,
        dedicatedServiceAccountId: Swift.String? = nil,
        description: Swift.String? = nil,
        dnsStatus: FinspaceClientTypes.DnsStatus? = nil,
        environmentArn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: FinspaceClientTypes.EnvironmentStatus? = nil,
        tgwStatus: FinspaceClientTypes.TgwStatus? = nil,
        transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration? = nil,
        updateTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.availabilityZoneIds = availabilityZoneIds
        self.awsAccountId = awsAccountId
        self.creationTimestamp = creationTimestamp
        self.customDNSConfiguration = customDNSConfiguration
        self.dedicatedServiceAccountId = dedicatedServiceAccountId
        self.description = description
        self.dnsStatus = dnsStatus
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.status = status
        self.tgwStatus = tgwStatus
        self.transitGatewayConfiguration = transitGatewayConfiguration
        self.updateTimestamp = updateTimestamp
    }
}

struct UpdateKxEnvironmentOutputBody: Swift.Equatable {
    let name: Swift.String?
    let environmentId: Swift.String?
    let awsAccountId: Swift.String?
    let status: FinspaceClientTypes.EnvironmentStatus?
    let tgwStatus: FinspaceClientTypes.TgwStatus?
    let dnsStatus: FinspaceClientTypes.DnsStatus?
    let errorMessage: Swift.String?
    let description: Swift.String?
    let environmentArn: Swift.String?
    let kmsKeyId: Swift.String?
    let dedicatedServiceAccountId: Swift.String?
    let transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration?
    let customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]?
    let creationTimestamp: ClientRuntime.Date?
    let updateTimestamp: ClientRuntime.Date?
    let availabilityZoneIds: [Swift.String]?
}

extension UpdateKxEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneIds
        case awsAccountId
        case creationTimestamp
        case customDNSConfiguration
        case dedicatedServiceAccountId
        case description
        case dnsStatus
        case environmentArn
        case environmentId
        case errorMessage
        case kmsKeyId
        case name
        case status
        case tgwStatus
        case transitGatewayConfiguration
        case updateTimestamp
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let tgwStatusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.TgwStatus.self, forKey: .tgwStatus)
        tgwStatus = tgwStatusDecoded
        let dnsStatusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.DnsStatus.self, forKey: .dnsStatus)
        dnsStatus = dnsStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dedicatedServiceAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedServiceAccountId)
        dedicatedServiceAccountId = dedicatedServiceAccountIdDecoded
        let transitGatewayConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.TransitGatewayConfiguration.self, forKey: .transitGatewayConfiguration)
        transitGatewayConfiguration = transitGatewayConfigurationDecoded
        let customDNSConfigurationContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.CustomDNSServer?].self, forKey: .customDNSConfiguration)
        var customDNSConfigurationDecoded0:[FinspaceClientTypes.CustomDNSServer]? = nil
        if let customDNSConfigurationContainer = customDNSConfigurationContainer {
            customDNSConfigurationDecoded0 = [FinspaceClientTypes.CustomDNSServer]()
            for structure0 in customDNSConfigurationContainer {
                if let structure0 = structure0 {
                    customDNSConfigurationDecoded0?.append(structure0)
                }
            }
        }
        customDNSConfiguration = customDNSConfigurationDecoded0
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let updateTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTimestamp)
        updateTimestamp = updateTimestampDecoded
        let availabilityZoneIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZoneIds)
        var availabilityZoneIdsDecoded0:[Swift.String]? = nil
        if let availabilityZoneIdsContainer = availabilityZoneIdsContainer {
            availabilityZoneIdsDecoded0 = [Swift.String]()
            for string0 in availabilityZoneIdsContainer {
                if let string0 = string0 {
                    availabilityZoneIdsDecoded0?.append(string0)
                }
            }
        }
        availabilityZoneIds = availabilityZoneIdsDecoded0
    }
}

enum UpdateKxEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateKxUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case iamRole
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let iamRole = self.iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
    }
}

extension UpdateKxUserInput {

    static func urlPathProvider(_ value: UpdateKxUserInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let userName = value.userName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

public struct UpdateKxUserInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The IAM role ARN that is associated with the user.
    /// This member is required.
    public var iamRole: Swift.String?
    /// A unique identifier for the user.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.iamRole = iamRole
        self.userName = userName
    }
}

struct UpdateKxUserInputBody: Swift.Equatable {
    let iamRole: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateKxUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case iamRole
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateKxUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateKxUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentId = output.environmentId
            self.iamRole = output.iamRole
            self.userArn = output.userArn
            self.userName = output.userName
        } else {
            self.environmentId = nil
            self.iamRole = nil
            self.userArn = nil
            self.userName = nil
        }
    }
}

public struct UpdateKxUserOutput: Swift.Equatable {
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// The IAM role ARN that is associated with the user.
    public var iamRole: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    public var userArn: Swift.String?
    /// A unique identifier for the user.
    public var userName: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        userArn: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.iamRole = iamRole
        self.userArn = userArn
        self.userName = userName
    }
}

struct UpdateKxUserOutputBody: Swift.Equatable {
    let userName: Swift.String?
    let userArn: Swift.String?
    let environmentId: Swift.String?
    let iamRole: Swift.String?
}

extension UpdateKxUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
        case iamRole
        case userArn
        case userName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
    }
}

enum UpdateKxUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateKxVolumeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case nas1Configuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let nas1Configuration = self.nas1Configuration {
            try encodeContainer.encode(nas1Configuration, forKey: .nas1Configuration)
        }
    }
}

extension UpdateKxVolumeInput {

    static func urlPathProvider(_ value: UpdateKxVolumeInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let volumeName = value.volumeName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/kxvolumes/\(volumeName.urlPercentEncoding())"
    }
}

public struct UpdateKxVolumeInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A description of the volume.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment where you created the storage volume.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the configuration for the Network attached storage (NAS_1) file system volume.
    public var nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
    /// A unique identifier for the volume.
    /// This member is required.
    public var volumeName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        nas1Configuration: FinspaceClientTypes.KxNAS1Configuration? = nil,
        volumeName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.environmentId = environmentId
        self.nas1Configuration = nas1Configuration
        self.volumeName = volumeName
    }
}

struct UpdateKxVolumeInputBody: Swift.Equatable {
    let description: Swift.String?
    let clientToken: Swift.String?
    let nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
}

extension UpdateKxVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case nas1Configuration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nas1ConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxNAS1Configuration.self, forKey: .nas1Configuration)
        nas1Configuration = nas1ConfigurationDecoded
    }
}

extension UpdateKxVolumeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateKxVolumeOutputBody = try responseDecoder.decode(responseBody: data)
            self.attachedClusters = output.attachedClusters
            self.availabilityZoneIds = output.availabilityZoneIds
            self.azMode = output.azMode
            self.createdTimestamp = output.createdTimestamp
            self.description = output.description
            self.environmentId = output.environmentId
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.nas1Configuration = output.nas1Configuration
            self.status = output.status
            self.statusReason = output.statusReason
            self.volumeArn = output.volumeArn
            self.volumeName = output.volumeName
            self.volumeType = output.volumeType
        } else {
            self.attachedClusters = nil
            self.availabilityZoneIds = nil
            self.azMode = nil
            self.createdTimestamp = nil
            self.description = nil
            self.environmentId = nil
            self.lastModifiedTimestamp = nil
            self.nas1Configuration = nil
            self.status = nil
            self.statusReason = nil
            self.volumeArn = nil
            self.volumeName = nil
            self.volumeType = nil
        }
    }
}

public struct UpdateKxVolumeOutput: Swift.Equatable {
    /// Specifies the clusters that a volume is attached to.
    public var attachedClusters: [FinspaceClientTypes.KxAttachedCluster]?
    /// The identifier of the availability zones.
    public var availabilityZoneIds: [Swift.String]?
    /// The number of availability zones you want to assign per cluster. Currently, FinSpace only support SINGLE for volumes.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// The timestamp at which the volume was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: ClientRuntime.Date?
    /// The description for the volume.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment where you want to update the volume.
    public var environmentId: Swift.String?
    /// The last time that the volume was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// Specifies the configuration for the Network attached storage (NAS_1) file system volume.
    public var nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
    /// The status of the volume.
    ///
    /// * CREATING – The volume creation is in progress.
    ///
    /// * CREATE_FAILED – The volume creation has failed.
    ///
    /// * ACTIVE – The volume is active.
    ///
    /// * UPDATING – The volume is in the process of being updated.
    ///
    /// * UPDATE_FAILED – The update action failed.
    ///
    /// * UPDATED – The volume is successfully updated.
    ///
    /// * DELETING – The volume is in the process of being deleted.
    ///
    /// * DELETE_FAILED – The system failed to delete the volume.
    ///
    /// * DELETED – The volume is successfully deleted.
    public var status: FinspaceClientTypes.KxVolumeStatus?
    /// The error message when a failed state occurs.
    public var statusReason: Swift.String?
    /// The ARN identifier of the volume.
    public var volumeArn: Swift.String?
    /// A unique identifier for the volume that you want to update.
    public var volumeName: Swift.String?
    /// The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
    public var volumeType: FinspaceClientTypes.KxVolumeType?

    public init(
        attachedClusters: [FinspaceClientTypes.KxAttachedCluster]? = nil,
        availabilityZoneIds: [Swift.String]? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        nas1Configuration: FinspaceClientTypes.KxNAS1Configuration? = nil,
        status: FinspaceClientTypes.KxVolumeStatus? = nil,
        statusReason: Swift.String? = nil,
        volumeArn: Swift.String? = nil,
        volumeName: Swift.String? = nil,
        volumeType: FinspaceClientTypes.KxVolumeType? = nil
    )
    {
        self.attachedClusters = attachedClusters
        self.availabilityZoneIds = availabilityZoneIds
        self.azMode = azMode
        self.createdTimestamp = createdTimestamp
        self.description = description
        self.environmentId = environmentId
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.nas1Configuration = nas1Configuration
        self.status = status
        self.statusReason = statusReason
        self.volumeArn = volumeArn
        self.volumeName = volumeName
        self.volumeType = volumeType
    }
}

struct UpdateKxVolumeOutputBody: Swift.Equatable {
    let environmentId: Swift.String?
    let volumeName: Swift.String?
    let volumeType: FinspaceClientTypes.KxVolumeType?
    let volumeArn: Swift.String?
    let nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
    let status: FinspaceClientTypes.KxVolumeStatus?
    let description: Swift.String?
    let statusReason: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
    let azMode: FinspaceClientTypes.KxAzMode?
    let availabilityZoneIds: [Swift.String]?
    let lastModifiedTimestamp: ClientRuntime.Date?
    let attachedClusters: [FinspaceClientTypes.KxAttachedCluster]?
}

extension UpdateKxVolumeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedClusters
        case availabilityZoneIds
        case azMode
        case createdTimestamp
        case description
        case environmentId
        case lastModifiedTimestamp
        case nas1Configuration
        case status
        case statusReason
        case volumeArn
        case volumeName
        case volumeType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let volumeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeName)
        volumeName = volumeNameDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxVolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeArn)
        volumeArn = volumeArnDecoded
        let nas1ConfigurationDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxNAS1Configuration.self, forKey: .nas1Configuration)
        nas1Configuration = nas1ConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxVolumeStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let azModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.KxAzMode.self, forKey: .azMode)
        azMode = azModeDecoded
        let availabilityZoneIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZoneIds)
        var availabilityZoneIdsDecoded0:[Swift.String]? = nil
        if let availabilityZoneIdsContainer = availabilityZoneIdsContainer {
            availabilityZoneIdsDecoded0 = [Swift.String]()
            for string0 in availabilityZoneIdsContainer {
                if let string0 = string0 {
                    availabilityZoneIdsDecoded0?.append(string0)
                }
            }
        }
        availabilityZoneIds = availabilityZoneIdsDecoded0
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let attachedClustersContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.KxAttachedCluster?].self, forKey: .attachedClusters)
        var attachedClustersDecoded0:[FinspaceClientTypes.KxAttachedCluster]? = nil
        if let attachedClustersContainer = attachedClustersContainer {
            attachedClustersDecoded0 = [FinspaceClientTypes.KxAttachedCluster]()
            for structure0 in attachedClustersContainer {
                if let structure0 = structure0 {
                    attachedClustersDecoded0?.append(structure0)
                }
            }
        }
        attachedClusters = attachedClustersDecoded0
    }
}

enum UpdateKxVolumeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FinspaceClientTypes.Volume: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeName
        case volumeType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeName = self.volumeName {
            try encodeContainer.encode(volumeName, forKey: .volumeName)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType.rawValue, forKey: .volumeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeName)
        volumeName = volumeNameDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.VolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
    }
}

extension FinspaceClientTypes {
    /// The structure that consists of name and type of volume.
    public struct Volume: Swift.Equatable {
        /// A unique identifier for the volume.
        public var volumeName: Swift.String?
        /// The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
        public var volumeType: FinspaceClientTypes.VolumeType?

        public init(
            volumeName: Swift.String? = nil,
            volumeType: FinspaceClientTypes.VolumeType? = nil
        )
        {
            self.volumeName = volumeName
            self.volumeType = volumeType
        }
    }

}

extension FinspaceClientTypes {
    public enum VolumeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nas1
        case sdkUnknown(Swift.String)

        public static var allCases: [VolumeType] {
            return [
                .nas1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nas1: return "NAS_1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VolumeType(rawValue: rawValue) ?? VolumeType.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.VpcConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddressType
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidstring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidstring0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidstring0 in subnetIds {
                try subnetIdsContainer.encode(subnetidstring0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.IPAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
    }
}

extension FinspaceClientTypes {
    /// Configuration details about the network where the Privatelink endpoint of the cluster resides.
    public struct VpcConfiguration: Swift.Equatable {
        /// The IP address type for cluster network configuration parameters. The following type is available:
        ///
        /// * IP_V4 – IP address version 4
        public var ipAddressType: FinspaceClientTypes.IPAddressType?
        /// The unique identifier of the VPC security group applied to the VPC endpoint ENI for the cluster.
        public var securityGroupIds: [Swift.String]?
        /// The identifier of the subnet that the Privatelink VPC endpoint uses to connect to the cluster.
        public var subnetIds: [Swift.String]?
        /// The identifier of the VPC endpoint.
        public var vpcId: Swift.String?

        public init(
            ipAddressType: FinspaceClientTypes.IPAddressType? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.ipAddressType = ipAddressType
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}
