//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension FinspaceClientTypes {

    public enum AutoScalingMetric: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cpuUtilizationPercentage
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoScalingMetric] {
            return [
                .cpuUtilizationPercentage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cpuUtilizationPercentage: return "CPU_UTILIZATION_PERCENTAGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
    public struct AutoScalingConfiguration {
        /// The metric your cluster will track in order to scale in and out. For example, CPU_UTILIZATION_PERCENTAGE is the average CPU usage across all the nodes in a cluster.
        public var autoScalingMetric: FinspaceClientTypes.AutoScalingMetric?
        /// The highest number of nodes to scale. This value cannot be greater than 5.
        public var maxNodeCount: Swift.Int?
        /// The desired value of the chosen autoScalingMetric. When the metric drops below this value, the cluster will scale in. When the metric goes above this value, the cluster will scale out. You can set the target value between 1 and 100 percent.
        public var metricTarget: Swift.Double?
        /// The lowest number of nodes to scale. This value must be at least 1 and less than the maxNodeCount. If the nodes in a cluster belong to multiple availability zones, then minNodeCount must be at least 3.
        public var minNodeCount: Swift.Int?
        /// The duration in seconds that FinSpace will wait after a scale in event before initiating another scaling event.
        public var scaleInCooldownSeconds: Swift.Double?
        /// The duration in seconds that FinSpace will wait after a scale out event before initiating another scaling event.
        public var scaleOutCooldownSeconds: Swift.Double?

        public init(
            autoScalingMetric: FinspaceClientTypes.AutoScalingMetric? = nil,
            maxNodeCount: Swift.Int? = nil,
            metricTarget: Swift.Double? = nil,
            minNodeCount: Swift.Int? = nil,
            scaleInCooldownSeconds: Swift.Double? = nil,
            scaleOutCooldownSeconds: Swift.Double? = nil
        )
        {
            self.autoScalingMetric = autoScalingMetric
            self.maxNodeCount = maxNodeCount
            self.metricTarget = metricTarget
            self.minNodeCount = minNodeCount
            self.scaleInCooldownSeconds = scaleInCooldownSeconds
            self.scaleOutCooldownSeconds = scaleOutCooldownSeconds
        }
    }

}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A service limit or quota is exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension FinspaceClientTypes {

    public enum FederationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case federated
        case local
        case sdkUnknown(Swift.String)

        public static var allCases: [FederationMode] {
            return [
                .federated,
                .local
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .federated: return "FEDERATED"
            case .local: return "LOCAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// Configuration information when authentication mode is FEDERATED.
    public struct FederationParameters {
        /// The redirect or sign-in URL that should be entered into the SAML 2.0 compliant identity provider configuration (IdP).
        public var applicationCallBackURL: Swift.String?
        /// SAML attribute name and value. The name must always be Email and the value should be set to the attribute definition in which user email is set. For example, name would be Email and value http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress. Please check your SAML 2.0 compliant identity provider (IdP) documentation for details.
        public var attributeMap: [Swift.String: Swift.String]?
        /// Name of the identity provider (IdP).
        public var federationProviderName: Swift.String?
        /// The Uniform Resource Name (URN). Also referred as Service Provider URN or Audience URI or Service Provider Entity ID.
        public var federationURN: Swift.String?
        /// SAML 2.0 Metadata document from identity provider (IdP).
        public var samlMetadataDocument: Swift.String?
        /// Provide the metadata URL from your SAML 2.0 compliant identity provider (IdP).
        public var samlMetadataURL: Swift.String?

        public init(
            applicationCallBackURL: Swift.String? = nil,
            attributeMap: [Swift.String: Swift.String]? = nil,
            federationProviderName: Swift.String? = nil,
            federationURN: Swift.String? = nil,
            samlMetadataDocument: Swift.String? = nil,
            samlMetadataURL: Swift.String? = nil
        )
        {
            self.applicationCallBackURL = applicationCallBackURL
            self.attributeMap = attributeMap
            self.federationProviderName = federationProviderName
            self.federationURN = federationURN
            self.samlMetadataDocument = samlMetadataDocument
            self.samlMetadataURL = samlMetadataURL
        }
    }

}

extension FinspaceClientTypes {
    /// Configuration information for the superuser.
    public struct SuperuserParameters {
        /// The email address of the superuser.
        /// This member is required.
        public var emailAddress: Swift.String?
        /// The first name of the superuser.
        /// This member is required.
        public var firstName: Swift.String?
        /// The last name of the superuser.
        /// This member is required.
        public var lastName: Swift.String?

        public init(
            emailAddress: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil
        )
        {
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.lastName = lastName
        }
    }

}

extension FinspaceClientTypes.SuperuserParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuperuserParameters(firstName: \(Swift.String(describing: firstName)), lastName: \(Swift.String(describing: lastName)), emailAddress: \"CONTENT_REDACTED\")"}
}

public struct CreateEnvironmentInput {
    /// The list of Amazon Resource Names (ARN) of the data bundles to install. Currently supported data bundle ARNs:
    ///
    /// * arn:aws:finspace:${Region}::data-bundle/capital-markets-sample - Contains sample Capital Markets datasets, categories and controlled vocabularies.
    ///
    /// * arn:aws:finspace:${Region}::data-bundle/taq (default) - Contains trades and quotes data in addition to sample Capital Markets data.
    public var dataBundles: [Swift.String]?
    /// The description of the FinSpace environment to be created.
    public var description: Swift.String?
    /// Authentication mode for the environment.
    ///
    /// * FEDERATED - Users access FinSpace through Single Sign On (SSO) via your Identity provider.
    ///
    /// * LOCAL - Users access FinSpace via email and password managed within the FinSpace environment.
    public var federationMode: FinspaceClientTypes.FederationMode?
    /// Configuration information when authentication mode is FEDERATED.
    public var federationParameters: FinspaceClientTypes.FederationParameters?
    /// The KMS key id to encrypt your data in the FinSpace environment.
    public var kmsKeyId: Swift.String?
    /// The name of the FinSpace environment to be created.
    /// This member is required.
    public var name: Swift.String?
    /// Configuration information for the superuser.
    public var superuserParameters: FinspaceClientTypes.SuperuserParameters?
    /// Add tags to your FinSpace environment.
    public var tags: [Swift.String: Swift.String]?

    public init(
        dataBundles: [Swift.String]? = nil,
        description: Swift.String? = nil,
        federationMode: FinspaceClientTypes.FederationMode? = nil,
        federationParameters: FinspaceClientTypes.FederationParameters? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        superuserParameters: FinspaceClientTypes.SuperuserParameters? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.dataBundles = dataBundles
        self.description = description
        self.federationMode = federationMode
        self.federationParameters = federationParameters
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.superuserParameters = superuserParameters
        self.tags = tags
    }
}

public struct CreateEnvironmentOutput {
    /// The Amazon Resource Name (ARN) of the FinSpace environment that you created.
    public var environmentArn: Swift.String?
    /// The unique identifier for FinSpace environment that you created.
    public var environmentId: Swift.String?
    /// The sign-in URL for the web application of the FinSpace environment you created.
    public var environmentUrl: Swift.String?

    public init(
        environmentArn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        environmentUrl: Swift.String? = nil
    )
    {
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.environmentUrl = environmentUrl
    }
}

/// There was a conflict with this action, and it could not be completed.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the conflict exception.
        public internal(set) var reason: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

/// One or more resources can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension FinspaceClientTypes {

    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delete
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .delete,
                .put
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// A list of change request objects.
    public struct ChangeRequest {
        /// Defines the type of change request. A changeType can have the following values:
        ///
        /// * PUT – Adds or updates files in a database.
        ///
        /// * DELETE – Deletes files in a database.
        /// This member is required.
        public var changeType: FinspaceClientTypes.ChangeType?
        /// Defines the path within the database directory.
        /// This member is required.
        public var dbPath: Swift.String?
        /// Defines the S3 path of the source file that is required to add or update files in a database.
        public var s3Path: Swift.String?

        public init(
            changeType: FinspaceClientTypes.ChangeType? = nil,
            dbPath: Swift.String? = nil,
            s3Path: Swift.String? = nil
        )
        {
            self.changeType = changeType
            self.dbPath = dbPath
            self.s3Path = s3Path
        }
    }

}

public struct CreateKxChangesetInput {
    /// A list of change request objects that are run in order. A change request object consists of changeType , s3Path, and dbPath. A changeType can have the following values:
    ///
    /// * PUT – Adds or updates files in a database.
    ///
    /// * DELETE – Deletes files in a database.
    ///
    ///
    /// All the change requests require a mandatory dbPath attribute that defines the path within the database directory. All database paths must start with a leading / and end with a trailing /. The s3Path attribute defines the s3 source file path and is required for a PUT change type. The s3path must end with a trailing / if it is a directory and must end without a trailing / if it is a file. Here are few examples of how you can use the change request object:
    ///
    /// * This request adds a single sym file at database root location. { "changeType": "PUT", "s3Path":"s3://bucket/db/sym", "dbPath":"/"}
    ///
    /// * This request adds files in the given s3Path under the 2020.01.02 partition of the database. { "changeType": "PUT", "s3Path":"s3://bucket/db/2020.01.02/", "dbPath":"/2020.01.02/"}
    ///
    /// * This request adds files in the given s3Path under the taq table partition of the database. [ { "changeType": "PUT", "s3Path":"s3://bucket/db/2020.01.02/taq/", "dbPath":"/2020.01.02/taq/"}]
    ///
    /// * This request deletes the 2020.01.02 partition of the database. [{ "changeType": "DELETE", "dbPath": "/2020.01.02/"} ]
    ///
    /// * The DELETE request allows you to delete the existing files under the 2020.01.02 partition of the database, and the PUT request adds a new taq table under it. [ {"changeType": "DELETE", "dbPath":"/2020.01.02/"}, {"changeType": "PUT", "s3Path":"s3://bucket/db/2020.01.02/taq/", "dbPath":"/2020.01.02/taq/"}]
    /// This member is required.
    public var changeRequests: [FinspaceClientTypes.ChangeRequest]?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The name of the kdb database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier of the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        changeRequests: [FinspaceClientTypes.ChangeRequest]? = nil,
        clientToken: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.changeRequests = changeRequests
        self.clientToken = clientToken
        self.databaseName = databaseName
        self.environmentId = environmentId
    }
}

extension FinspaceClientTypes {

    public enum ErrorDetails: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case cancelled
        case internalServiceException
        case resourceNotFound
        case serviceQuotaExceeded
        case throttling
        case userRecoverable
        case validation
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorDetails] {
            return [
                .accessDenied,
                .cancelled,
                .internalServiceException,
                .resourceNotFound,
                .serviceQuotaExceeded,
                .throttling,
                .userRecoverable,
                .validation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "Missing required permission to perform this request."
            case .cancelled: return "Cancelled"
            case .internalServiceException: return "An internal error has occurred."
            case .resourceNotFound: return "One or more inputs to this request were not found."
            case .serviceQuotaExceeded: return "Service limits have been exceeded."
            case .throttling: return "The system temporarily lacks sufficient resources to process the request."
            case .userRecoverable: return "A user recoverable error has occurred"
            case .validation: return "The inputs to this request are invalid."
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// Provides details in the event of a failed flow, including the error type and the related error message.
    public struct ErrorInfo {
        /// Specifies the error message that appears if a flow fails.
        public var errorMessage: Swift.String?
        /// Specifies the type of error.
        public var errorType: FinspaceClientTypes.ErrorDetails?

        public init(
            errorMessage: Swift.String? = nil,
            errorType: FinspaceClientTypes.ErrorDetails? = nil
        )
        {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }
    }

}

extension FinspaceClientTypes {

    public enum ChangesetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case pending
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangesetStatus] {
            return [
                .completed,
                .failed,
                .pending,
                .processing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateKxChangesetOutput {
    /// A list of change requests.
    public var changeRequests: [FinspaceClientTypes.ChangeRequest]?
    /// A unique identifier for the changeset.
    public var changesetId: Swift.String?
    /// The timestamp at which the changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: Foundation.Date?
    /// The name of the kdb database.
    public var databaseName: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// The details of the error that you receive when creating a changeset. It consists of the type of error and the error message.
    public var errorInfo: FinspaceClientTypes.ErrorInfo?
    /// The timestamp at which the changeset was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: Foundation.Date?
    /// Status of the changeset creation process.
    ///
    /// * Pending – Changeset creation is pending.
    ///
    /// * Processing – Changeset creation is running.
    ///
    /// * Failed – Changeset creation has failed.
    ///
    /// * Complete – Changeset creation has succeeded.
    public var status: FinspaceClientTypes.ChangesetStatus?

    public init(
        changeRequests: [FinspaceClientTypes.ChangeRequest]? = nil,
        changesetId: Swift.String? = nil,
        createdTimestamp: Foundation.Date? = nil,
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        errorInfo: FinspaceClientTypes.ErrorInfo? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil,
        status: FinspaceClientTypes.ChangesetStatus? = nil
    )
    {
        self.changeRequests = changeRequests
        self.changesetId = changesetId
        self.createdTimestamp = createdTimestamp
        self.databaseName = databaseName
        self.environmentId = environmentId
        self.errorInfo = errorInfo
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.status = status
    }
}

extension FinspaceClientTypes {

    public enum KxAzMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case multi
        case single
        case sdkUnknown(Swift.String)

        public static var allCases: [KxAzMode] {
            return [
                .multi,
                .single
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .multi: return "MULTI"
            case .single: return "SINGLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// The configuration for read only disk cache associated with a cluster.
    public struct KxCacheStorageConfiguration {
        /// The size of cache in Gigabytes.
        /// This member is required.
        public var size: Swift.Int?
        /// The type of cache storage. The valid values are:
        ///
        /// * CACHE_1000 – This type provides at least 1000 MB/s disk access throughput.
        ///
        /// * CACHE_250 – This type provides at least 250 MB/s disk access throughput.
        ///
        /// * CACHE_12 – This type provides at least 12 MB/s disk access throughput.
        ///
        ///
        /// For cache type CACHE_1000 and CACHE_250 you can select cache size as 1200 GB or increments of 2400 GB. For cache type CACHE_12 you can select the cache size in increments of 6000 GB.
        /// This member is required.
        public var type: Swift.String?

        public init(
            size: Swift.Int? = nil,
            type: Swift.String? = nil
        )
        {
            self.size = size
            self.type = type
        }
    }

}

extension FinspaceClientTypes {
    /// A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, and number of instances.
    public struct CapacityConfiguration {
        /// The number of instances running in a cluster.
        public var nodeCount: Swift.Int?
        /// The type that determines the hardware of the host computer used for your cluster instance. Each node type offers different memory and storage capabilities. Choose a node type based on the requirements of the application or software that you plan to run on your instance. You can only specify one of the following values:
        ///
        /// * kx.s.large – The node type with a configuration of 12 GiB memory and 2 vCPUs.
        ///
        /// * kx.s.xlarge – The node type with a configuration of 27 GiB memory and 4 vCPUs.
        ///
        /// * kx.s.2xlarge – The node type with a configuration of 54 GiB memory and 8 vCPUs.
        ///
        /// * kx.s.4xlarge – The node type with a configuration of 108 GiB memory and 16 vCPUs.
        ///
        /// * kx.s.8xlarge – The node type with a configuration of 216 GiB memory and 32 vCPUs.
        ///
        /// * kx.s.16xlarge – The node type with a configuration of 432 GiB memory and 64 vCPUs.
        ///
        /// * kx.s.32xlarge – The node type with a configuration of 864 GiB memory and 128 vCPUs.
        public var nodeType: Swift.String?

        public init(
            nodeCount: Swift.Int? = nil,
            nodeType: Swift.String? = nil
        )
        {
            self.nodeCount = nodeCount
            self.nodeType = nodeType
        }
    }

}

extension FinspaceClientTypes {

    public enum KxClusterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gateway
        case gp
        case hdb
        case rdb
        case tickerplant
        case sdkUnknown(Swift.String)

        public static var allCases: [KxClusterType] {
            return [
                .gateway,
                .gp,
                .hdb,
                .rdb,
                .tickerplant
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gateway: return "GATEWAY"
            case .gp: return "GP"
            case .hdb: return "HDB"
            case .rdb: return "RDB"
            case .tickerplant: return "TICKERPLANT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// The structure of the customer code available within the running cluster.
    public struct CodeConfiguration {
        /// A unique name for the S3 bucket.
        public var s3Bucket: Swift.String?
        /// The full S3 path (excluding bucket) to the .zip file. This file contains the code that is loaded onto the cluster when it's started.
        public var s3Key: Swift.String?
        /// The version of an S3 object.
        public var s3ObjectVersion: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3ObjectVersion: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
        }
    }

}

extension FinspaceClientTypes {
    /// Defines the key-value pairs to make them available inside the cluster.
    public struct KxCommandLineArgument {
        /// The name of the key.
        public var key: Swift.String?
        /// The value of the key.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension FinspaceClientTypes {
    /// The structure of database cache configuration that is used for mapping database paths to cache types in clusters.
    public struct KxDatabaseCacheConfiguration {
        /// The type of disk cache. This parameter is used to map the database path to cache storage. The valid values are:
        ///
        /// * CACHE_1000 – This type provides at least 1000 MB/s disk access throughput.
        /// This member is required.
        public var cacheType: Swift.String?
        /// The name of the dataview to be used for caching historical data on disk.
        public var dataviewName: Swift.String?
        /// Specifies the portions of database that will be loaded into the cache for access.
        /// This member is required.
        public var dbPaths: [Swift.String]?

        public init(
            cacheType: Swift.String? = nil,
            dataviewName: Swift.String? = nil,
            dbPaths: [Swift.String]? = nil
        )
        {
            self.cacheType = cacheType
            self.dataviewName = dataviewName
            self.dbPaths = dbPaths
        }
    }

}

extension FinspaceClientTypes {
    /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
    public struct KxDataviewSegmentConfiguration {
        /// The database path of the data that you want to place on each selected volume for the segment. Each segment must have a unique database path for each volume.
        /// This member is required.
        public var dbPaths: [Swift.String]?
        /// Enables on-demand caching on the selected database path when a particular file or a column of the database is accessed. When on demand caching is True, dataviews perform minimal loading of files on the filesystem as needed. When it is set to False, everything is cached. The default value is False.
        public var onDemand: Swift.Bool
        /// The name of the volume where you want to add data.
        /// This member is required.
        public var volumeName: Swift.String?

        public init(
            dbPaths: [Swift.String]? = nil,
            onDemand: Swift.Bool = false,
            volumeName: Swift.String? = nil
        )
        {
            self.dbPaths = dbPaths
            self.onDemand = onDemand
            self.volumeName = volumeName
        }
    }

}

extension FinspaceClientTypes {
    /// The structure that stores the configuration details of a dataview.
    public struct KxDataviewConfiguration {
        /// A unique identifier for the changeset.
        public var changesetId: Swift.String?
        /// The unique identifier of the dataview.
        public var dataviewName: Swift.String?
        /// The version of the dataview corresponding to a given changeset.
        public var dataviewVersionId: Swift.String?
        /// The db path and volume configuration for the segmented database.
        public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?

        public init(
            changesetId: Swift.String? = nil,
            dataviewName: Swift.String? = nil,
            dataviewVersionId: Swift.String? = nil,
            segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil
        )
        {
            self.changesetId = changesetId
            self.dataviewName = dataviewName
            self.dataviewVersionId = dataviewVersionId
            self.segmentConfigurations = segmentConfigurations
        }
    }

}

extension FinspaceClientTypes {
    /// The configuration of data that is available for querying from this database.
    public struct KxDatabaseConfiguration {
        /// Configuration details for the disk cache used to increase performance reading from a kdb database mounted to the cluster.
        public var cacheConfigurations: [FinspaceClientTypes.KxDatabaseCacheConfiguration]?
        /// A unique identifier of the changeset that is associated with the cluster.
        public var changesetId: Swift.String?
        /// The name of the kdb database. When this parameter is specified in the structure, S3 with the whole database is included by default.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The configuration of the dataview to be used with specified cluster.
        public var dataviewConfiguration: FinspaceClientTypes.KxDataviewConfiguration?
        /// The name of the dataview to be used for caching historical data on disk.
        public var dataviewName: Swift.String?

        public init(
            cacheConfigurations: [FinspaceClientTypes.KxDatabaseCacheConfiguration]? = nil,
            changesetId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dataviewConfiguration: FinspaceClientTypes.KxDataviewConfiguration? = nil,
            dataviewName: Swift.String? = nil
        )
        {
            self.cacheConfigurations = cacheConfigurations
            self.changesetId = changesetId
            self.databaseName = databaseName
            self.dataviewConfiguration = dataviewConfiguration
            self.dataviewName = dataviewName
        }
    }

}

extension FinspaceClientTypes {

    public enum KxSavedownStorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sds01
        case sdkUnknown(Swift.String)

        public static var allCases: [KxSavedownStorageType] {
            return [
                .sds01
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sds01: return "SDS01"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// The size and type of temporary storage that is used to hold data during the savedown process. All the data written to this storage space is lost when the cluster node is restarted.
    public struct KxSavedownStorageConfiguration {
        /// The size of temporary storage in gibibytes.
        public var size: Swift.Int?
        /// The type of writeable storage space for temporarily storing your savedown data. The valid values are:
        ///
        /// * SDS01 – This type represents 3000 IOPS and io2 ebs volume type.
        public var type: FinspaceClientTypes.KxSavedownStorageType?
        /// The name of the kdb volume that you want to use as writeable save-down storage for clusters.
        public var volumeName: Swift.String?

        public init(
            size: Swift.Int? = nil,
            type: FinspaceClientTypes.KxSavedownStorageType? = nil,
            volumeName: Swift.String? = nil
        )
        {
            self.size = size
            self.type = type
            self.volumeName = volumeName
        }
    }

}

extension FinspaceClientTypes {
    /// The structure that stores the capacity configuration details of a scaling group.
    public struct KxScalingGroupConfiguration {
        /// The number of vCPUs that you want to reserve for each node of this kdb cluster on the scaling group host.
        public var cpu: Swift.Double?
        /// An optional hard limit on the amount of memory a kdb cluster can use.
        public var memoryLimit: Swift.Int?
        /// A reservation of the minimum amount of memory that should be available on the scaling group for a kdb cluster to be successfully placed in a scaling group.
        /// This member is required.
        public var memoryReservation: Swift.Int?
        /// The number of kdb cluster nodes.
        /// This member is required.
        public var nodeCount: Swift.Int?
        /// A unique identifier for the kdb scaling group.
        /// This member is required.
        public var scalingGroupName: Swift.String?

        public init(
            cpu: Swift.Double? = nil,
            memoryLimit: Swift.Int? = nil,
            memoryReservation: Swift.Int? = nil,
            nodeCount: Swift.Int? = nil,
            scalingGroupName: Swift.String? = nil
        )
        {
            self.cpu = cpu
            self.memoryLimit = memoryLimit
            self.memoryReservation = memoryReservation
            self.nodeCount = nodeCount
            self.scalingGroupName = scalingGroupName
        }
    }

}

extension FinspaceClientTypes {
    /// A configuration to store the Tickerplant logs. It consists of a list of volumes that will be mounted to your cluster. For the cluster type Tickerplant, the location of the TP volume on the cluster will be available by using the global variable .aws.tp_log_path.
    public struct TickerplantLogConfiguration {
        /// The name of the volumes for tickerplant logs.
        public var tickerplantLogVolumes: [Swift.String]?

        public init(
            tickerplantLogVolumes: [Swift.String]? = nil
        )
        {
            self.tickerplantLogVolumes = tickerplantLogVolumes
        }
    }

}

extension FinspaceClientTypes {

    public enum IPAddressType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ipV4
        case sdkUnknown(Swift.String)

        public static var allCases: [IPAddressType] {
            return [
                .ipV4
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ipV4: return "IP_V4"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// Configuration details about the network where the Privatelink endpoint of the cluster resides.
    public struct VpcConfiguration {
        /// The IP address type for cluster network configuration parameters. The following type is available:
        ///
        /// * IP_V4 – IP address version 4
        public var ipAddressType: FinspaceClientTypes.IPAddressType?
        /// The unique identifier of the VPC security group applied to the VPC endpoint ENI for the cluster.
        public var securityGroupIds: [Swift.String]?
        /// The identifier of the subnet that the Privatelink VPC endpoint uses to connect to the cluster.
        public var subnetIds: [Swift.String]?
        /// The identifier of the VPC endpoint.
        public var vpcId: Swift.String?

        public init(
            ipAddressType: FinspaceClientTypes.IPAddressType? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.ipAddressType = ipAddressType
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

public struct CreateKxClusterInput {
    /// The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
    public var autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration?
    /// The availability zone identifiers for the requested regions.
    public var availabilityZoneId: Swift.String?
    /// The number of availability zones you want to assign per cluster. This can be one of the following
    ///
    /// * SINGLE – Assigns one availability zone per cluster.
    ///
    /// * MULTI – Assigns all the availability zones per cluster.
    /// This member is required.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store.
    public var cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]?
    /// A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, and number of instances.
    public var capacityConfiguration: FinspaceClientTypes.CapacityConfiguration?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A description of the cluster.
    public var clusterDescription: Swift.String?
    /// A unique name for the cluster that you want to create.
    /// This member is required.
    public var clusterName: Swift.String?
    /// Specifies the type of KDB database that is being created. The following types are available:
    ///
    /// * HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.
    ///
    /// * RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.
    ///
    /// * GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.
    ///
    /// * GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.
    ///
    /// * Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
    /// This member is required.
    public var clusterType: FinspaceClientTypes.KxClusterType?
    /// The details of the custom code that you want to use inside a cluster when analyzing a data. It consists of the S3 source bucket, location, S3 object version, and the relative path from where the custom code is loaded into the cluster.
    public var code: FinspaceClientTypes.CodeConfiguration?
    /// Defines the key-value pairs to make them available inside the cluster.
    public var commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]?
    /// A list of databases that will be available for querying.
    public var databases: [FinspaceClientTypes.KxDatabaseConfiguration]?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
    public var executionRole: Swift.String?
    /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
    public var initializationScript: Swift.String?
    /// The version of FinSpace managed kdb to run.
    /// This member is required.
    public var releaseLabel: Swift.String?
    /// The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted.
    public var savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration?
    /// The structure that stores the configuration details of a scaling group.
    public var scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration?
    /// A list of key-value pairs to label the cluster. You can add up to 50 tags to a cluster.
    public var tags: [Swift.String: Swift.String]?
    /// A configuration to store Tickerplant logs. It consists of a list of volumes that will be mounted to your cluster. For the cluster type Tickerplant, the location of the TP volume on the cluster will be available by using the global variable .aws.tp_log_path.
    public var tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration?
    /// Configuration details about the network where the Privatelink endpoint of the cluster resides.
    /// This member is required.
    public var vpcConfiguration: FinspaceClientTypes.VpcConfiguration?

    public init(
        autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration? = nil,
        availabilityZoneId: Swift.String? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]? = nil,
        capacityConfiguration: FinspaceClientTypes.CapacityConfiguration? = nil,
        clientToken: Swift.String? = nil,
        clusterDescription: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        clusterType: FinspaceClientTypes.KxClusterType? = nil,
        code: FinspaceClientTypes.CodeConfiguration? = nil,
        commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]? = nil,
        databases: [FinspaceClientTypes.KxDatabaseConfiguration]? = nil,
        environmentId: Swift.String? = nil,
        executionRole: Swift.String? = nil,
        initializationScript: Swift.String? = nil,
        releaseLabel: Swift.String? = nil,
        savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration? = nil,
        scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration? = nil,
        vpcConfiguration: FinspaceClientTypes.VpcConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
        self.availabilityZoneId = availabilityZoneId
        self.azMode = azMode
        self.cacheStorageConfigurations = cacheStorageConfigurations
        self.capacityConfiguration = capacityConfiguration
        self.clientToken = clientToken
        self.clusterDescription = clusterDescription
        self.clusterName = clusterName
        self.clusterType = clusterType
        self.code = code
        self.commandLineArguments = commandLineArguments
        self.databases = databases
        self.environmentId = environmentId
        self.executionRole = executionRole
        self.initializationScript = initializationScript
        self.releaseLabel = releaseLabel
        self.savedownStorageConfiguration = savedownStorageConfiguration
        self.scalingGroupConfiguration = scalingGroupConfiguration
        self.tags = tags
        self.tickerplantLogConfiguration = tickerplantLogConfiguration
        self.vpcConfiguration = vpcConfiguration
    }
}

extension FinspaceClientTypes {

    public enum KxClusterStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case creating
        case deleted
        case deleteFailed
        case deleting
        case pending
        case running
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [KxClusterStatus] {
            return [
                .createFailed,
                .creating,
                .deleted,
                .deleteFailed,
                .deleting,
                .pending,
                .running,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {

    public enum VolumeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nas1
        case sdkUnknown(Swift.String)

        public static var allCases: [VolumeType] {
            return [
                .nas1
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nas1: return "NAS_1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// The structure that consists of name and type of volume.
    public struct Volume {
        /// A unique identifier for the volume.
        public var volumeName: Swift.String?
        /// The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
        public var volumeType: FinspaceClientTypes.VolumeType?

        public init(
            volumeName: Swift.String? = nil,
            volumeType: FinspaceClientTypes.VolumeType? = nil
        )
        {
            self.volumeName = volumeName
            self.volumeType = volumeType
        }
    }

}

public struct CreateKxClusterOutput {
    /// The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
    public var autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration?
    /// The availability zone identifiers for the requested regions.
    public var availabilityZoneId: Swift.String?
    /// The number of availability zones you want to assign per cluster. This can be one of the following
    ///
    /// * SINGLE – Assigns one availability zone per cluster.
    ///
    /// * MULTI – Assigns all the availability zones per cluster.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store.
    public var cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]?
    /// A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, and number of instances.
    public var capacityConfiguration: FinspaceClientTypes.CapacityConfiguration?
    /// A description of the cluster.
    public var clusterDescription: Swift.String?
    /// A unique name for the cluster.
    public var clusterName: Swift.String?
    /// Specifies the type of KDB database that is being created. The following types are available:
    ///
    /// * HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.
    ///
    /// * RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.
    ///
    /// * GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.
    ///
    /// * GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.
    ///
    /// * Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
    public var clusterType: FinspaceClientTypes.KxClusterType?
    /// The details of the custom code that you want to use inside a cluster when analyzing a data. It consists of the S3 source bucket, location, S3 object version, and the relative path from where the custom code is loaded into the cluster.
    public var code: FinspaceClientTypes.CodeConfiguration?
    /// Defines the key-value pairs to make them available inside the cluster.
    public var commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]?
    /// The timestamp at which the cluster was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: Foundation.Date?
    /// A list of databases that will be available for querying.
    public var databases: [FinspaceClientTypes.KxDatabaseConfiguration]?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
    public var executionRole: Swift.String?
    /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
    public var initializationScript: Swift.String?
    /// The last time that the cluster was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: Foundation.Date?
    /// A version of the FinSpace managed kdb to run.
    public var releaseLabel: Swift.String?
    /// The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted.
    public var savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration?
    /// The structure that stores the configuration details of a scaling group.
    public var scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration?
    /// The status of cluster creation.
    ///
    /// * PENDING – The cluster is pending creation.
    ///
    /// * CREATING – The cluster creation process is in progress.
    ///
    /// * CREATE_FAILED – The cluster creation process has failed.
    ///
    /// * RUNNING – The cluster creation process is running.
    ///
    /// * UPDATING – The cluster is in the process of being updated.
    ///
    /// * DELETING – The cluster is in the process of being deleted.
    ///
    /// * DELETED – The cluster has been deleted.
    ///
    /// * DELETE_FAILED – The cluster failed to delete.
    public var status: FinspaceClientTypes.KxClusterStatus?
    /// The error message when a failed state occurs.
    public var statusReason: Swift.String?
    /// A configuration to store the Tickerplant logs. It consists of a list of volumes that will be mounted to your cluster. For the cluster type Tickerplant, the location of the TP volume on the cluster will be available by using the global variable .aws.tp_log_path.
    public var tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration?
    /// A list of volumes mounted on the cluster.
    public var volumes: [FinspaceClientTypes.Volume]?
    /// Configuration details about the network where the Privatelink endpoint of the cluster resides.
    public var vpcConfiguration: FinspaceClientTypes.VpcConfiguration?

    public init(
        autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration? = nil,
        availabilityZoneId: Swift.String? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]? = nil,
        capacityConfiguration: FinspaceClientTypes.CapacityConfiguration? = nil,
        clusterDescription: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        clusterType: FinspaceClientTypes.KxClusterType? = nil,
        code: FinspaceClientTypes.CodeConfiguration? = nil,
        commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]? = nil,
        createdTimestamp: Foundation.Date? = nil,
        databases: [FinspaceClientTypes.KxDatabaseConfiguration]? = nil,
        environmentId: Swift.String? = nil,
        executionRole: Swift.String? = nil,
        initializationScript: Swift.String? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil,
        releaseLabel: Swift.String? = nil,
        savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration? = nil,
        scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration? = nil,
        status: FinspaceClientTypes.KxClusterStatus? = nil,
        statusReason: Swift.String? = nil,
        tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration? = nil,
        volumes: [FinspaceClientTypes.Volume]? = nil,
        vpcConfiguration: FinspaceClientTypes.VpcConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
        self.availabilityZoneId = availabilityZoneId
        self.azMode = azMode
        self.cacheStorageConfigurations = cacheStorageConfigurations
        self.capacityConfiguration = capacityConfiguration
        self.clusterDescription = clusterDescription
        self.clusterName = clusterName
        self.clusterType = clusterType
        self.code = code
        self.commandLineArguments = commandLineArguments
        self.createdTimestamp = createdTimestamp
        self.databases = databases
        self.environmentId = environmentId
        self.executionRole = executionRole
        self.initializationScript = initializationScript
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.releaseLabel = releaseLabel
        self.savedownStorageConfiguration = savedownStorageConfiguration
        self.scalingGroupConfiguration = scalingGroupConfiguration
        self.status = status
        self.statusReason = statusReason
        self.tickerplantLogConfiguration = tickerplantLogConfiguration
        self.volumes = volumes
        self.vpcConfiguration = vpcConfiguration
    }
}

/// The specified resource group already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateKxDatabaseInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The name of the kdb database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A description of the database.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// A list of key-value pairs to label the kdb database. You can add up to 50 tags to your kdb database
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.databaseName = databaseName
        self.description = description
        self.environmentId = environmentId
        self.tags = tags
    }
}

public struct CreateKxDatabaseOutput {
    /// The timestamp at which the database is created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: Foundation.Date?
    /// The ARN identifier of the database.
    public var databaseArn: Swift.String?
    /// The name of the kdb database.
    public var databaseName: Swift.String?
    /// A description of the database.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// The last time that the database was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: Foundation.Date?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        databaseArn: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.databaseArn = databaseArn
        self.databaseName = databaseName
        self.description = description
        self.environmentId = environmentId
        self.lastModifiedTimestamp = lastModifiedTimestamp
    }
}

public struct CreateKxDataviewInput {
    /// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview, when you ingest new changesets. The default value is false.
    public var autoUpdate: Swift.Bool?
    /// The identifier of the availability zones.
    public var availabilityZoneId: Swift.String?
    /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
    /// This member is required.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// A unique identifier of the changeset that you want to use to ingest data.
    public var changesetId: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The name of the database where you want to create a dataview.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier for the dataview.
    /// This member is required.
    public var dataviewName: Swift.String?
    /// A description of the dataview.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, where you want to create the dataview.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The option to specify whether you want to make the dataview writable to perform database maintenance. The following are some considerations related to writable dataviews.  
    ///
    /// * You cannot create partial writable dataviews. When you create writeable dataviews you must provide the entire database path.
    ///
    /// * You cannot perform updates on a writeable dataview. Hence, autoUpdate must be set as False if readWrite is True for a dataview.
    ///
    /// * You must also use a unique volume for creating a writeable dataview. So, if you choose a volume that is already in use by another dataview, the dataview creation fails.
    ///
    /// * Once you create a dataview as writeable, you cannot change it to read-only. So, you cannot update the readWrite parameter later.
    public var readWrite: Swift.Bool?
    /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
    public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
    /// A list of key-value pairs to label the dataview. You can add up to 50 tags to a dataview.
    public var tags: [Swift.String: Swift.String]?

    public init(
        autoUpdate: Swift.Bool? = false,
        availabilityZoneId: Swift.String? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        changesetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        dataviewName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        readWrite: Swift.Bool? = false,
        segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.autoUpdate = autoUpdate
        self.availabilityZoneId = availabilityZoneId
        self.azMode = azMode
        self.changesetId = changesetId
        self.clientToken = clientToken
        self.databaseName = databaseName
        self.dataviewName = dataviewName
        self.description = description
        self.environmentId = environmentId
        self.readWrite = readWrite
        self.segmentConfigurations = segmentConfigurations
        self.tags = tags
    }
}

extension FinspaceClientTypes {

    public enum KxDataviewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [KxDataviewStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateKxDataviewOutput {
    /// The option to select whether you want to apply all the future additions and corrections automatically to the dataview when you ingest new changesets. The default value is false.
    public var autoUpdate: Swift.Bool
    /// The identifier of the availability zones.
    public var availabilityZoneId: Swift.String?
    /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// A unique identifier for the changeset.
    public var changesetId: Swift.String?
    /// The timestamp at which the dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: Foundation.Date?
    /// The name of the database where you want to create a dataview.
    public var databaseName: Swift.String?
    /// A unique identifier for the dataview.
    public var dataviewName: Swift.String?
    /// A description of the dataview.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, where you want to create the dataview.
    public var environmentId: Swift.String?
    /// The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: Foundation.Date?
    /// Returns True if the dataview is created as writeable and False otherwise.
    public var readWrite: Swift.Bool
    /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
    public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
    /// The status of dataview creation.
    ///
    /// * CREATING – The dataview creation is in progress.
    ///
    /// * UPDATING – The dataview is in the process of being updated.
    ///
    /// * ACTIVE – The dataview is active.
    public var status: FinspaceClientTypes.KxDataviewStatus?

    public init(
        autoUpdate: Swift.Bool = false,
        availabilityZoneId: Swift.String? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        changesetId: Swift.String? = nil,
        createdTimestamp: Foundation.Date? = nil,
        databaseName: Swift.String? = nil,
        dataviewName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil,
        readWrite: Swift.Bool = false,
        segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil,
        status: FinspaceClientTypes.KxDataviewStatus? = nil
    )
    {
        self.autoUpdate = autoUpdate
        self.availabilityZoneId = availabilityZoneId
        self.azMode = azMode
        self.changesetId = changesetId
        self.createdTimestamp = createdTimestamp
        self.databaseName = databaseName
        self.dataviewName = dataviewName
        self.description = description
        self.environmentId = environmentId
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.readWrite = readWrite
        self.segmentConfigurations = segmentConfigurations
        self.status = status
    }
}

public struct CreateKxEnvironmentInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A description for the kdb environment.
    public var description: Swift.String?
    /// The KMS key ID to encrypt your data in the FinSpace environment.
    /// This member is required.
    public var kmsKeyId: Swift.String?
    /// The name of the kdb environment that you want to create.
    /// This member is required.
    public var name: Swift.String?
    /// A list of key-value pairs to label the kdb environment. You can add up to 50 tags to your kdb environment.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.tags = tags
    }
}

extension FinspaceClientTypes {

    public enum EnvironmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case createRequested
        case creating
        case deleted
        case deleteRequested
        case deleting
        case failedCreation
        case failedDeletion
        case failedUpdatingNetwork
        case retryDeletion
        case suspended
        case updateNetworkRequested
        case updatingNetwork
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentStatus] {
            return [
                .created,
                .createRequested,
                .creating,
                .deleted,
                .deleteRequested,
                .deleting,
                .failedCreation,
                .failedDeletion,
                .failedUpdatingNetwork,
                .retryDeletion,
                .suspended,
                .updateNetworkRequested,
                .updatingNetwork
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .createRequested: return "CREATE_REQUESTED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteRequested: return "DELETE_REQUESTED"
            case .deleting: return "DELETING"
            case .failedCreation: return "FAILED_CREATION"
            case .failedDeletion: return "FAILED_DELETION"
            case .failedUpdatingNetwork: return "FAILED_UPDATING_NETWORK"
            case .retryDeletion: return "RETRY_DELETION"
            case .suspended: return "SUSPENDED"
            case .updateNetworkRequested: return "UPDATE_NETWORK_REQUESTED"
            case .updatingNetwork: return "UPDATING_NETWORK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateKxEnvironmentOutput {
    /// The timestamp at which the kdb environment was created in FinSpace.
    public var creationTimestamp: Foundation.Date?
    /// A description for the kdb environment.
    public var description: Swift.String?
    /// The ARN identifier of the environment.
    public var environmentArn: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// The KMS key ID to encrypt your data in the FinSpace environment.
    public var kmsKeyId: Swift.String?
    /// The name of the kdb environment.
    public var name: Swift.String?
    /// The status of the kdb environment.
    public var status: FinspaceClientTypes.EnvironmentStatus?

    public init(
        creationTimestamp: Foundation.Date? = nil,
        description: Swift.String? = nil,
        environmentArn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: FinspaceClientTypes.EnvironmentStatus? = nil
    )
    {
        self.creationTimestamp = creationTimestamp
        self.description = description
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.status = status
    }
}

public struct CreateKxScalingGroupInput {
    /// The identifier of the availability zones.
    /// This member is required.
    public var availabilityZoneId: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A unique identifier for the kdb environment, where you want to create the scaling group.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The memory and CPU capabilities of the scaling group host on which FinSpace Managed kdb clusters will be placed. You can add one of the following values:
    ///
    /// * kx.sg.large – The host type with a configuration of 16 GiB memory and 2 vCPUs.
    ///
    /// * kx.sg.xlarge – The host type with a configuration of 32 GiB memory and 4 vCPUs.
    ///
    /// * kx.sg.2xlarge – The host type with a configuration of 64 GiB memory and 8 vCPUs.
    ///
    /// * kx.sg.4xlarge – The host type with a configuration of 108 GiB memory and 16 vCPUs.
    ///
    /// * kx.sg.8xlarge – The host type with a configuration of 216 GiB memory and 32 vCPUs.
    ///
    /// * kx.sg.16xlarge – The host type with a configuration of 432 GiB memory and 64 vCPUs.
    ///
    /// * kx.sg.32xlarge – The host type with a configuration of 864 GiB memory and 128 vCPUs.
    ///
    /// * kx.sg1.16xlarge – The host type with a configuration of 1949 GiB memory and 64 vCPUs.
    ///
    /// * kx.sg1.24xlarge – The host type with a configuration of 2948 GiB memory and 96 vCPUs.
    /// This member is required.
    public var hostType: Swift.String?
    /// A unique identifier for the kdb scaling group.
    /// This member is required.
    public var scalingGroupName: Swift.String?
    /// A list of key-value pairs to label the scaling group. You can add up to 50 tags to a scaling group.
    public var tags: [Swift.String: Swift.String]?

    public init(
        availabilityZoneId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        hostType: Swift.String? = nil,
        scalingGroupName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.hostType = hostType
        self.scalingGroupName = scalingGroupName
        self.tags = tags
    }
}

extension FinspaceClientTypes {

    public enum KxScalingGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleted
        case deleteFailed
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [KxScalingGroupStatus] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleted,
                .deleteFailed,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateKxScalingGroupOutput {
    /// The identifier of the availability zones.
    public var availabilityZoneId: Swift.String?
    /// The timestamp at which the scaling group was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: Foundation.Date?
    /// A unique identifier for the kdb environment, where you create the scaling group.
    public var environmentId: Swift.String?
    /// The memory and CPU capabilities of the scaling group host on which FinSpace Managed kdb clusters will be placed.
    public var hostType: Swift.String?
    /// The last time that the scaling group was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: Foundation.Date?
    /// A unique identifier for the kdb scaling group.
    public var scalingGroupName: Swift.String?
    /// The status of scaling group.
    ///
    /// * CREATING – The scaling group creation is in progress.
    ///
    /// * CREATE_FAILED – The scaling group creation has failed.
    ///
    /// * ACTIVE – The scaling group is active.
    ///
    /// * UPDATING – The scaling group is in the process of being updated.
    ///
    /// * UPDATE_FAILED – The update action failed.
    ///
    /// * DELETING – The scaling group is in the process of being deleted.
    ///
    /// * DELETE_FAILED – The system failed to delete the scaling group.
    ///
    /// * DELETED – The scaling group is successfully deleted.
    public var status: FinspaceClientTypes.KxScalingGroupStatus?

    public init(
        availabilityZoneId: Swift.String? = nil,
        createdTimestamp: Foundation.Date? = nil,
        environmentId: Swift.String? = nil,
        hostType: Swift.String? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil,
        scalingGroupName: Swift.String? = nil,
        status: FinspaceClientTypes.KxScalingGroupStatus? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.createdTimestamp = createdTimestamp
        self.environmentId = environmentId
        self.hostType = hostType
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.scalingGroupName = scalingGroupName
        self.status = status
    }
}

public struct CreateKxUserInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A unique identifier for the kdb environment where you want to create a user.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The IAM role ARN that will be associated with the user.
    /// This member is required.
    public var iamRole: Swift.String?
    /// A list of key-value pairs to label the user. You can add up to 50 tags to a user.
    public var tags: [Swift.String: Swift.String]?
    /// A unique identifier for the user.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.iamRole = iamRole
        self.tags = tags
        self.userName = userName
    }
}

public struct CreateKxUserOutput {
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// The IAM role ARN that will be associated with the user.
    public var iamRole: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    public var userArn: Swift.String?
    /// A unique identifier for the user.
    public var userName: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        userArn: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.iamRole = iamRole
        self.userArn = userArn
        self.userName = userName
    }
}

extension FinspaceClientTypes {

    public enum KxNAS1Type: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hdd12
        case ssd1000
        case ssd250
        case sdkUnknown(Swift.String)

        public static var allCases: [KxNAS1Type] {
            return [
                .hdd12,
                .ssd1000,
                .ssd250
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hdd12: return "HDD_12"
            case .ssd1000: return "SSD_1000"
            case .ssd250: return "SSD_250"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// The structure containing the size and type of the network attached storage (NAS_1) file system volume.
    public struct KxNAS1Configuration {
        /// The size of the network attached storage. For storage type SSD_1000 and SSD_250 you can select the minimum size as 1200 GB or increments of 2400 GB. For storage type HDD_12 you can select the minimum size as 6000 GB or increments of 6000 GB.
        public var size: Swift.Int?
        /// The type of the network attached storage.
        public var type: FinspaceClientTypes.KxNAS1Type?

        public init(
            size: Swift.Int? = nil,
            type: FinspaceClientTypes.KxNAS1Type? = nil
        )
        {
            self.size = size
            self.type = type
        }
    }

}

extension FinspaceClientTypes {

    public enum KxVolumeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nas1
        case sdkUnknown(Swift.String)

        public static var allCases: [KxVolumeType] {
            return [
                .nas1
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nas1: return "NAS_1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateKxVolumeInput {
    /// The identifier of the availability zones.
    /// This member is required.
    public var availabilityZoneIds: [Swift.String]?
    /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
    /// This member is required.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A description of the volume.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the configuration for the Network attached storage (NAS_1) file system volume. This parameter is required when you choose volumeType as NAS_1.
    public var nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
    /// A list of key-value pairs to label the volume. You can add up to 50 tags to a volume.
    public var tags: [Swift.String: Swift.String]?
    /// A unique identifier for the volume.
    /// This member is required.
    public var volumeName: Swift.String?
    /// The type of file system volume. Currently, FinSpace only supports NAS_1 volume type. When you select NAS_1 volume type, you must also provide nas1Configuration.
    /// This member is required.
    public var volumeType: FinspaceClientTypes.KxVolumeType?

    public init(
        availabilityZoneIds: [Swift.String]? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        nas1Configuration: FinspaceClientTypes.KxNAS1Configuration? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        volumeName: Swift.String? = nil,
        volumeType: FinspaceClientTypes.KxVolumeType? = nil
    )
    {
        self.availabilityZoneIds = availabilityZoneIds
        self.azMode = azMode
        self.clientToken = clientToken
        self.description = description
        self.environmentId = environmentId
        self.nas1Configuration = nas1Configuration
        self.tags = tags
        self.volumeName = volumeName
        self.volumeType = volumeType
    }
}

extension FinspaceClientTypes {

    public enum KxVolumeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleted
        case deleteFailed
        case deleting
        case updated
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [KxVolumeStatus] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleted,
                .deleteFailed,
                .deleting,
                .updated,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .updated: return "UPDATED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateKxVolumeOutput {
    /// The identifier of the availability zones.
    public var availabilityZoneIds: [Swift.String]?
    /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// The timestamp at which the volume was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: Foundation.Date?
    /// A description of the volume.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
    public var environmentId: Swift.String?
    /// Specifies the configuration for the Network attached storage (NAS_1) file system volume.
    public var nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
    /// The status of volume creation.
    ///
    /// * CREATING – The volume creation is in progress.
    ///
    /// * CREATE_FAILED – The volume creation has failed.
    ///
    /// * ACTIVE – The volume is active.
    ///
    /// * UPDATING – The volume is in the process of being updated.
    ///
    /// * UPDATE_FAILED – The update action failed.
    ///
    /// * UPDATED – The volume is successfully updated.
    ///
    /// * DELETING – The volume is in the process of being deleted.
    ///
    /// * DELETE_FAILED – The system failed to delete the volume.
    ///
    /// * DELETED – The volume is successfully deleted.
    public var status: FinspaceClientTypes.KxVolumeStatus?
    /// The error message when a failed state occurs.
    public var statusReason: Swift.String?
    /// The ARN identifier of the volume.
    public var volumeArn: Swift.String?
    /// A unique identifier for the volume.
    public var volumeName: Swift.String?
    /// The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
    public var volumeType: FinspaceClientTypes.KxVolumeType?

    public init(
        availabilityZoneIds: [Swift.String]? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        createdTimestamp: Foundation.Date? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        nas1Configuration: FinspaceClientTypes.KxNAS1Configuration? = nil,
        status: FinspaceClientTypes.KxVolumeStatus? = nil,
        statusReason: Swift.String? = nil,
        volumeArn: Swift.String? = nil,
        volumeName: Swift.String? = nil,
        volumeType: FinspaceClientTypes.KxVolumeType? = nil
    )
    {
        self.availabilityZoneIds = availabilityZoneIds
        self.azMode = azMode
        self.createdTimestamp = createdTimestamp
        self.description = description
        self.environmentId = environmentId
        self.nas1Configuration = nas1Configuration
        self.status = status
        self.statusReason = statusReason
        self.volumeArn = volumeArn
        self.volumeName = volumeName
        self.volumeType = volumeType
    }
}

public struct DeleteEnvironmentInput {
    /// The identifier for the FinSpace environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

public struct DeleteEnvironmentOutput {

    public init() { }
}

public struct DeleteKxClusterInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The name of the cluster that you want to delete.
    /// This member is required.
    public var clusterName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.clusterName = clusterName
        self.environmentId = environmentId
    }
}

public struct DeleteKxClusterOutput {

    public init() { }
}

public struct DeleteKxClusterNodeInput {
    /// The name of the cluster, for which you want to delete the nodes.
    /// This member is required.
    public var clusterName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// A unique identifier for the node that you want to delete.
    /// This member is required.
    public var nodeId: Swift.String?

    public init(
        clusterName: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        nodeId: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.environmentId = environmentId
        self.nodeId = nodeId
    }
}

public struct DeleteKxClusterNodeOutput {

    public init() { }
}

public struct DeleteKxDatabaseInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The name of the kdb database that you want to delete.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.databaseName = databaseName
        self.environmentId = environmentId
    }
}

public struct DeleteKxDatabaseOutput {

    public init() { }
}

public struct DeleteKxDataviewInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The name of the database whose dataview you want to delete.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the dataview that you want to delete.
    /// This member is required.
    public var dataviewName: Swift.String?
    /// A unique identifier for the kdb environment, from where you want to delete the dataview.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        dataviewName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.databaseName = databaseName
        self.dataviewName = dataviewName
        self.environmentId = environmentId
    }
}

public struct DeleteKxDataviewOutput {

    public init() { }
}

public struct DeleteKxEnvironmentInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.environmentId = environmentId
    }
}

public struct DeleteKxEnvironmentOutput {

    public init() { }
}

public struct DeleteKxScalingGroupInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A unique identifier for the kdb environment, from where you want to delete the dataview.
    /// This member is required.
    public var environmentId: Swift.String?
    /// A unique identifier for the kdb scaling group.
    /// This member is required.
    public var scalingGroupName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        scalingGroupName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.scalingGroupName = scalingGroupName
    }
}

public struct DeleteKxScalingGroupOutput {

    public init() { }
}

public struct DeleteKxUserInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// A unique identifier for the user that you want to delete.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.userName = userName
    }
}

public struct DeleteKxUserOutput {

    public init() { }
}

public struct DeleteKxVolumeInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The name of the volume that you want to delete.
    /// This member is required.
    public var volumeName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        volumeName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.volumeName = volumeName
    }
}

public struct DeleteKxVolumeOutput {

    public init() { }
}

public struct GetEnvironmentInput {
    /// The identifier of the FinSpace environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

extension FinspaceClientTypes {
    /// Represents an FinSpace environment.
    public struct Environment {
        /// The ID of the AWS account in which the FinSpace environment is created.
        public var awsAccountId: Swift.String?
        /// The AWS account ID of the dedicated service account associated with your FinSpace environment.
        public var dedicatedServiceAccountId: Swift.String?
        /// The description of the FinSpace environment.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of your FinSpace environment.
        public var environmentArn: Swift.String?
        /// The identifier of the FinSpace environment.
        public var environmentId: Swift.String?
        /// The sign-in URL for the web application of your FinSpace environment.
        public var environmentUrl: Swift.String?
        /// The authentication mode for the environment.
        public var federationMode: FinspaceClientTypes.FederationMode?
        /// Configuration information when authentication mode is FEDERATED.
        public var federationParameters: FinspaceClientTypes.FederationParameters?
        /// The KMS key id used to encrypt in the FinSpace environment.
        public var kmsKeyId: Swift.String?
        /// The name of the FinSpace environment.
        public var name: Swift.String?
        /// The URL of the integrated FinSpace notebook environment in your web application.
        public var sageMakerStudioDomainUrl: Swift.String?
        /// The current status of creation of the FinSpace environment.
        public var status: FinspaceClientTypes.EnvironmentStatus?

        public init(
            awsAccountId: Swift.String? = nil,
            dedicatedServiceAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            environmentArn: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            environmentUrl: Swift.String? = nil,
            federationMode: FinspaceClientTypes.FederationMode? = nil,
            federationParameters: FinspaceClientTypes.FederationParameters? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            sageMakerStudioDomainUrl: Swift.String? = nil,
            status: FinspaceClientTypes.EnvironmentStatus? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentUrl = environmentUrl
            self.federationMode = federationMode
            self.federationParameters = federationParameters
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.sageMakerStudioDomainUrl = sageMakerStudioDomainUrl
            self.status = status
        }
    }

}

public struct GetEnvironmentOutput {
    /// The name of the FinSpace environment.
    public var environment: FinspaceClientTypes.Environment?

    public init(
        environment: FinspaceClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

public struct GetKxChangesetInput {
    /// A unique identifier of the changeset for which you want to retrieve data.
    /// This member is required.
    public var changesetId: Swift.String?
    /// The name of the kdb database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        changesetId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.changesetId = changesetId
        self.databaseName = databaseName
        self.environmentId = environmentId
    }
}

public struct GetKxChangesetOutput {
    /// Beginning time from which the changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var activeFromTimestamp: Foundation.Date?
    /// A list of change request objects that are run in order.
    public var changeRequests: [FinspaceClientTypes.ChangeRequest]?
    /// A unique identifier for the changeset.
    public var changesetId: Swift.String?
    /// The timestamp at which the changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: Foundation.Date?
    /// The name of the kdb database.
    public var databaseName: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// Provides details in the event of a failed flow, including the error type and the related error message.
    public var errorInfo: FinspaceClientTypes.ErrorInfo?
    /// The timestamp at which the changeset was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: Foundation.Date?
    /// Status of the changeset creation process.
    ///
    /// * Pending – Changeset creation is pending.
    ///
    /// * Processing – Changeset creation is running.
    ///
    /// * Failed – Changeset creation has failed.
    ///
    /// * Complete – Changeset creation has succeeded.
    public var status: FinspaceClientTypes.ChangesetStatus?

    public init(
        activeFromTimestamp: Foundation.Date? = nil,
        changeRequests: [FinspaceClientTypes.ChangeRequest]? = nil,
        changesetId: Swift.String? = nil,
        createdTimestamp: Foundation.Date? = nil,
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        errorInfo: FinspaceClientTypes.ErrorInfo? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil,
        status: FinspaceClientTypes.ChangesetStatus? = nil
    )
    {
        self.activeFromTimestamp = activeFromTimestamp
        self.changeRequests = changeRequests
        self.changesetId = changesetId
        self.createdTimestamp = createdTimestamp
        self.databaseName = databaseName
        self.environmentId = environmentId
        self.errorInfo = errorInfo
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.status = status
    }
}

public struct GetKxClusterInput {
    /// The name of the cluster that you want to retrieve.
    /// This member is required.
    public var clusterName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clusterName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.environmentId = environmentId
    }
}

public struct GetKxClusterOutput {
    /// The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
    public var autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration?
    /// The availability zone identifiers for the requested regions.
    public var availabilityZoneId: Swift.String?
    /// The number of availability zones you want to assign per cluster. This can be one of the following
    ///
    /// * SINGLE – Assigns one availability zone per cluster.
    ///
    /// * MULTI – Assigns all the availability zones per cluster.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store.
    public var cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]?
    /// A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, and number of instances.
    public var capacityConfiguration: FinspaceClientTypes.CapacityConfiguration?
    /// A description of the cluster.
    public var clusterDescription: Swift.String?
    /// A unique name for the cluster.
    public var clusterName: Swift.String?
    /// Specifies the type of KDB database that is being created. The following types are available:
    ///
    /// * HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.
    ///
    /// * RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.
    ///
    /// * GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.
    ///
    /// * GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.
    ///
    /// * Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
    public var clusterType: FinspaceClientTypes.KxClusterType?
    /// The details of the custom code that you want to use inside a cluster when analyzing a data. It consists of the S3 source bucket, location, S3 object version, and the relative path from where the custom code is loaded into the cluster.
    public var code: FinspaceClientTypes.CodeConfiguration?
    /// Defines key-value pairs to make them available inside the cluster.
    public var commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]?
    /// The timestamp at which the cluster was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: Foundation.Date?
    /// A list of databases mounted on the cluster.
    public var databases: [FinspaceClientTypes.KxDatabaseConfiguration]?
    /// An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
    public var executionRole: Swift.String?
    /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
    public var initializationScript: Swift.String?
    /// The last time that the cluster was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: Foundation.Date?
    /// The version of FinSpace managed kdb to run.
    public var releaseLabel: Swift.String?
    /// The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted.
    public var savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration?
    /// The structure that stores the capacity configuration details of a scaling group.
    public var scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration?
    /// The status of cluster creation.
    ///
    /// * PENDING – The cluster is pending creation.
    ///
    /// * CREATING – The cluster creation process is in progress.
    ///
    /// * CREATE_FAILED – The cluster creation process has failed.
    ///
    /// * RUNNING – The cluster creation process is running.
    ///
    /// * UPDATING – The cluster is in the process of being updated.
    ///
    /// * DELETING – The cluster is in the process of being deleted.
    ///
    /// * DELETED – The cluster has been deleted.
    ///
    /// * DELETE_FAILED – The cluster failed to delete.
    public var status: FinspaceClientTypes.KxClusterStatus?
    /// The error message when a failed state occurs.
    public var statusReason: Swift.String?
    /// A configuration to store the Tickerplant logs. It consists of a list of volumes that will be mounted to your cluster. For the cluster type Tickerplant, the location of the TP volume on the cluster will be available by using the global variable .aws.tp_log_path.
    public var tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration?
    /// A list of volumes attached to the cluster.
    public var volumes: [FinspaceClientTypes.Volume]?
    /// Configuration details about the network where the Privatelink endpoint of the cluster resides.
    public var vpcConfiguration: FinspaceClientTypes.VpcConfiguration?

    public init(
        autoScalingConfiguration: FinspaceClientTypes.AutoScalingConfiguration? = nil,
        availabilityZoneId: Swift.String? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        cacheStorageConfigurations: [FinspaceClientTypes.KxCacheStorageConfiguration]? = nil,
        capacityConfiguration: FinspaceClientTypes.CapacityConfiguration? = nil,
        clusterDescription: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        clusterType: FinspaceClientTypes.KxClusterType? = nil,
        code: FinspaceClientTypes.CodeConfiguration? = nil,
        commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]? = nil,
        createdTimestamp: Foundation.Date? = nil,
        databases: [FinspaceClientTypes.KxDatabaseConfiguration]? = nil,
        executionRole: Swift.String? = nil,
        initializationScript: Swift.String? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil,
        releaseLabel: Swift.String? = nil,
        savedownStorageConfiguration: FinspaceClientTypes.KxSavedownStorageConfiguration? = nil,
        scalingGroupConfiguration: FinspaceClientTypes.KxScalingGroupConfiguration? = nil,
        status: FinspaceClientTypes.KxClusterStatus? = nil,
        statusReason: Swift.String? = nil,
        tickerplantLogConfiguration: FinspaceClientTypes.TickerplantLogConfiguration? = nil,
        volumes: [FinspaceClientTypes.Volume]? = nil,
        vpcConfiguration: FinspaceClientTypes.VpcConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
        self.availabilityZoneId = availabilityZoneId
        self.azMode = azMode
        self.cacheStorageConfigurations = cacheStorageConfigurations
        self.capacityConfiguration = capacityConfiguration
        self.clusterDescription = clusterDescription
        self.clusterName = clusterName
        self.clusterType = clusterType
        self.code = code
        self.commandLineArguments = commandLineArguments
        self.createdTimestamp = createdTimestamp
        self.databases = databases
        self.executionRole = executionRole
        self.initializationScript = initializationScript
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.releaseLabel = releaseLabel
        self.savedownStorageConfiguration = savedownStorageConfiguration
        self.scalingGroupConfiguration = scalingGroupConfiguration
        self.status = status
        self.statusReason = statusReason
        self.tickerplantLogConfiguration = tickerplantLogConfiguration
        self.volumes = volumes
        self.vpcConfiguration = vpcConfiguration
    }
}

public struct GetKxConnectionStringInput {
    /// A name of the kdb cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        clusterName: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.environmentId = environmentId
        self.userArn = userArn
    }
}

public struct GetKxConnectionStringOutput {
    /// The signed connection string that you can use to connect to clusters.
    public var signedConnectionString: Swift.String?

    public init(
        signedConnectionString: Swift.String? = nil
    )
    {
        self.signedConnectionString = signedConnectionString
    }
}

extension GetKxConnectionStringOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKxConnectionStringOutput(signedConnectionString: \"CONTENT_REDACTED\")"}
}

public struct GetKxDatabaseInput {
    /// The name of the kdb database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.environmentId = environmentId
    }
}

public struct GetKxDatabaseOutput {
    /// The timestamp at which the database is created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: Foundation.Date?
    /// The ARN identifier of the database.
    public var databaseArn: Swift.String?
    /// The name of the kdb database for which the information is retrieved.
    public var databaseName: Swift.String?
    /// A description of the database.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// A unique identifier for the changeset.
    public var lastCompletedChangesetId: Swift.String?
    /// The last time that the database was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: Foundation.Date?
    /// The total number of bytes in the database.
    public var numBytes: Swift.Int
    /// The total number of changesets in the database.
    public var numChangesets: Swift.Int
    /// The total number of files in the database.
    public var numFiles: Swift.Int

    public init(
        createdTimestamp: Foundation.Date? = nil,
        databaseArn: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastCompletedChangesetId: Swift.String? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil,
        numBytes: Swift.Int = 0,
        numChangesets: Swift.Int = 0,
        numFiles: Swift.Int = 0
    )
    {
        self.createdTimestamp = createdTimestamp
        self.databaseArn = databaseArn
        self.databaseName = databaseName
        self.description = description
        self.environmentId = environmentId
        self.lastCompletedChangesetId = lastCompletedChangesetId
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.numBytes = numBytes
        self.numChangesets = numChangesets
        self.numFiles = numFiles
    }
}

public struct GetKxDataviewInput {
    /// The name of the database where you created the dataview.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier for the dataview.
    /// This member is required.
    public var dataviewName: Swift.String?
    /// A unique identifier for the kdb environment, from where you want to retrieve the dataview details.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        dataviewName: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.dataviewName = dataviewName
        self.environmentId = environmentId
    }
}

extension FinspaceClientTypes {
    /// The active version of the dataview that is currently in use by this cluster.
    public struct KxDataviewActiveVersion {
        /// The list of clusters that are currently using this dataview.
        public var attachedClusters: [Swift.String]?
        /// A unique identifier for the changeset.
        public var changesetId: Swift.String?
        /// The timestamp at which the dataview version was active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createdTimestamp: Foundation.Date?
        /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
        public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
        /// A unique identifier of the active version.
        public var versionId: Swift.String?

        public init(
            attachedClusters: [Swift.String]? = nil,
            changesetId: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.attachedClusters = attachedClusters
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.segmentConfigurations = segmentConfigurations
            self.versionId = versionId
        }
    }

}

public struct GetKxDataviewOutput {
    /// The current active changeset versions of the database on the given dataview.
    public var activeVersions: [FinspaceClientTypes.KxDataviewActiveVersion]?
    /// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview when new changesets are ingested. The default value is false.
    public var autoUpdate: Swift.Bool
    /// The identifier of the availability zones.
    public var availabilityZoneId: Swift.String?
    /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// A unique identifier of the changeset that you want to use to ingest data.
    public var changesetId: Swift.String?
    /// The timestamp at which the dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: Foundation.Date?
    /// The name of the database where you created the dataview.
    public var databaseName: Swift.String?
    /// A unique identifier for the dataview.
    public var dataviewName: Swift.String?
    /// A description of the dataview.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, from where you want to retrieve the dataview details.
    public var environmentId: Swift.String?
    /// The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: Foundation.Date?
    /// Returns True if the dataview is created as writeable and False otherwise.
    public var readWrite: Swift.Bool
    /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
    public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
    /// The status of dataview creation.
    ///
    /// * CREATING – The dataview creation is in progress.
    ///
    /// * UPDATING – The dataview is in the process of being updated.
    ///
    /// * ACTIVE – The dataview is active.
    public var status: FinspaceClientTypes.KxDataviewStatus?
    /// The error message when a failed state occurs.
    public var statusReason: Swift.String?

    public init(
        activeVersions: [FinspaceClientTypes.KxDataviewActiveVersion]? = nil,
        autoUpdate: Swift.Bool = false,
        availabilityZoneId: Swift.String? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        changesetId: Swift.String? = nil,
        createdTimestamp: Foundation.Date? = nil,
        databaseName: Swift.String? = nil,
        dataviewName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil,
        readWrite: Swift.Bool = false,
        segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil,
        status: FinspaceClientTypes.KxDataviewStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.activeVersions = activeVersions
        self.autoUpdate = autoUpdate
        self.availabilityZoneId = availabilityZoneId
        self.azMode = azMode
        self.changesetId = changesetId
        self.createdTimestamp = createdTimestamp
        self.databaseName = databaseName
        self.dataviewName = dataviewName
        self.description = description
        self.environmentId = environmentId
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.readWrite = readWrite
        self.segmentConfigurations = segmentConfigurations
        self.status = status
        self.statusReason = statusReason
    }
}

public struct GetKxEnvironmentInput {
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

extension FinspaceClientTypes {
    /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
    public struct CustomDNSServer {
        /// The IP address of the DNS server.
        /// This member is required.
        public var customDNSServerIP: Swift.String?
        /// The name of the DNS server.
        /// This member is required.
        public var customDNSServerName: Swift.String?

        public init(
            customDNSServerIP: Swift.String? = nil,
            customDNSServerName: Swift.String? = nil
        )
        {
            self.customDNSServerIP = customDNSServerIP
            self.customDNSServerName = customDNSServerName
        }
    }

}

extension FinspaceClientTypes {

    public enum DnsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failedUpdate
        case `none`
        case successfullyUpdated
        case updateRequested
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DnsStatus] {
            return [
                .failedUpdate,
                .none,
                .successfullyUpdated,
                .updateRequested,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failedUpdate: return "FAILED_UPDATE"
            case .none: return "NONE"
            case .successfullyUpdated: return "SUCCESSFULLY_UPDATED"
            case .updateRequested: return "UPDATE_REQUESTED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {

    public enum TgwStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failedUpdate
        case `none`
        case successfullyUpdated
        case updateRequested
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [TgwStatus] {
            return [
                .failedUpdate,
                .none,
                .successfullyUpdated,
                .updateRequested,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failedUpdate: return "FAILED_UPDATE"
            case .none: return "NONE"
            case .successfullyUpdated: return "SUCCESSFULLY_UPDATED"
            case .updateRequested: return "UPDATE_REQUESTED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// Defines the ICMP protocol that consists of the ICMP type and code.
    public struct IcmpTypeCode {
        /// The ICMP code. A value of -1 means all codes for the specified ICMP type.
        /// This member is required.
        public var code: Swift.Int
        /// The ICMP type. A value of -1 means all types.
        /// This member is required.
        public var type: Swift.Int

        public init(
            code: Swift.Int = 0,
            type: Swift.Int = 0
        )
        {
            self.code = code
            self.type = type
        }
    }

}

extension FinspaceClientTypes {
    /// The range of ports the rule applies to.
    public struct PortRange {
        /// The first port in the range.
        /// This member is required.
        public var from: Swift.Int
        /// The last port in the range.
        /// This member is required.
        public var to: Swift.Int

        public init(
            from: Swift.Int = 0,
            to: Swift.Int = 0
        )
        {
            self.from = from
            self.to = to
        }
    }

}

extension FinspaceClientTypes {

    public enum RuleAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleAction] {
            return [
                .allow,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "allow"
            case .deny: return "deny"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// The network access control list (ACL) is an optional layer of security for your VPC that acts as a firewall for controlling traffic in and out of one or more subnets. The entry is a set of numbered ingress and egress rules that determine whether a packet should be allowed in or out of a subnet associated with the ACL. We process the entries in the ACL according to the rule numbers, in ascending order.
    public struct NetworkACLEntry {
        /// The IPv4 network range to allow or deny, in CIDR notation. For example, 172.16.0.0/24. We modify the specified CIDR block to its canonical form. For example, if you specify 100.68.0.18/18, we modify it to 100.68.0.0/18.
        /// This member is required.
        public var cidrBlock: Swift.String?
        /// Defines the ICMP protocol that consists of the ICMP type and code.
        public var icmpTypeCode: FinspaceClientTypes.IcmpTypeCode?
        /// The range of ports the rule applies to.
        public var portRange: FinspaceClientTypes.PortRange?
        /// The protocol number. A value of -1 means all the protocols.
        /// This member is required.
        public var `protocol`: Swift.String?
        /// Indicates whether to allow or deny the traffic that matches the rule.
        /// This member is required.
        public var ruleAction: FinspaceClientTypes.RuleAction?
        /// The rule number for the entry. For example 100. All the network ACL entries are processed in ascending order by rule number.
        /// This member is required.
        public var ruleNumber: Swift.Int?

        public init(
            cidrBlock: Swift.String? = nil,
            icmpTypeCode: FinspaceClientTypes.IcmpTypeCode? = nil,
            portRange: FinspaceClientTypes.PortRange? = nil,
            `protocol`: Swift.String? = nil,
            ruleAction: FinspaceClientTypes.RuleAction? = nil,
            ruleNumber: Swift.Int? = nil
        )
        {
            self.cidrBlock = cidrBlock
            self.icmpTypeCode = icmpTypeCode
            self.portRange = portRange
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
            self.ruleNumber = ruleNumber
        }
    }

}

extension FinspaceClientTypes {
    /// The structure of the transit gateway and network configuration that is used to connect the kdb environment to an internal network.
    public struct TransitGatewayConfiguration {
        /// The rules that define how you manage the outbound traffic from kdb network to your internal network.
        public var attachmentNetworkAclConfiguration: [FinspaceClientTypes.NetworkACLEntry]?
        /// The routing CIDR on behalf of kdb environment. It could be any "/26 range in the 100.64.0.0 CIDR space. After providing, it will be added to the customer's transit gateway routing table so that the traffics could be routed to kdb network.
        /// This member is required.
        public var routableCIDRSpace: Swift.String?
        /// The identifier of the transit gateway created by the customer to connect outbound traffics from kdb network to your internal network.
        /// This member is required.
        public var transitGatewayID: Swift.String?

        public init(
            attachmentNetworkAclConfiguration: [FinspaceClientTypes.NetworkACLEntry]? = nil,
            routableCIDRSpace: Swift.String? = nil,
            transitGatewayID: Swift.String? = nil
        )
        {
            self.attachmentNetworkAclConfiguration = attachmentNetworkAclConfiguration
            self.routableCIDRSpace = routableCIDRSpace
            self.transitGatewayID = transitGatewayID
        }
    }

}

public struct GetKxEnvironmentOutput {
    /// The identifier of the availability zones where subnets for the environment are created.
    public var availabilityZoneIds: [Swift.String]?
    /// The unique identifier of the AWS account that is used to create the kdb environment.
    public var awsAccountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the certificate authority of the kdb environment.
    public var certificateAuthorityArn: Swift.String?
    /// The timestamp at which the kdb environment was created in FinSpace.
    public var creationTimestamp: Foundation.Date?
    /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
    public var customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]?
    /// A unique identifier for the AWS environment infrastructure account.
    public var dedicatedServiceAccountId: Swift.String?
    /// A description for the kdb environment.
    public var description: Swift.String?
    /// The status of DNS configuration.
    public var dnsStatus: FinspaceClientTypes.DnsStatus?
    /// The ARN identifier of the environment.
    public var environmentArn: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// Specifies the error message that appears if a flow fails.
    public var errorMessage: Swift.String?
    /// The KMS key ID to encrypt your data in the FinSpace environment.
    public var kmsKeyId: Swift.String?
    /// The name of the kdb environment.
    public var name: Swift.String?
    /// The status of the kdb environment.
    public var status: FinspaceClientTypes.EnvironmentStatus?
    /// The status of the network configuration.
    public var tgwStatus: FinspaceClientTypes.TgwStatus?
    /// The structure of the transit gateway and network configuration that is used to connect the kdb environment to an internal network.
    public var transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration?
    /// The timestamp at which the kdb environment was updated.
    public var updateTimestamp: Foundation.Date?

    public init(
        availabilityZoneIds: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        certificateAuthorityArn: Swift.String? = nil,
        creationTimestamp: Foundation.Date? = nil,
        customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]? = nil,
        dedicatedServiceAccountId: Swift.String? = nil,
        description: Swift.String? = nil,
        dnsStatus: FinspaceClientTypes.DnsStatus? = nil,
        environmentArn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: FinspaceClientTypes.EnvironmentStatus? = nil,
        tgwStatus: FinspaceClientTypes.TgwStatus? = nil,
        transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration? = nil,
        updateTimestamp: Foundation.Date? = nil
    )
    {
        self.availabilityZoneIds = availabilityZoneIds
        self.awsAccountId = awsAccountId
        self.certificateAuthorityArn = certificateAuthorityArn
        self.creationTimestamp = creationTimestamp
        self.customDNSConfiguration = customDNSConfiguration
        self.dedicatedServiceAccountId = dedicatedServiceAccountId
        self.description = description
        self.dnsStatus = dnsStatus
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.status = status
        self.tgwStatus = tgwStatus
        self.transitGatewayConfiguration = transitGatewayConfiguration
        self.updateTimestamp = updateTimestamp
    }
}

public struct GetKxScalingGroupInput {
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// A unique identifier for the kdb scaling group.
    /// This member is required.
    public var scalingGroupName: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        scalingGroupName: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.scalingGroupName = scalingGroupName
    }
}

public struct GetKxScalingGroupOutput {
    /// The identifier of the availability zones.
    public var availabilityZoneId: Swift.String?
    /// The list of Managed kdb clusters that are currently active in the given scaling group.
    public var clusters: [Swift.String]?
    /// The timestamp at which the scaling group was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: Foundation.Date?
    /// The memory and CPU capabilities of the scaling group host on which FinSpace Managed kdb clusters will be placed. It can have one of the following values:
    ///
    /// * kx.sg.large – The host type with a configuration of 16 GiB memory and 2 vCPUs.
    ///
    /// * kx.sg.xlarge – The host type with a configuration of 32 GiB memory and 4 vCPUs.
    ///
    /// * kx.sg.2xlarge – The host type with a configuration of 64 GiB memory and 8 vCPUs.
    ///
    /// * kx.sg.4xlarge – The host type with a configuration of 108 GiB memory and 16 vCPUs.
    ///
    /// * kx.sg.8xlarge – The host type with a configuration of 216 GiB memory and 32 vCPUs.
    ///
    /// * kx.sg.16xlarge – The host type with a configuration of 432 GiB memory and 64 vCPUs.
    ///
    /// * kx.sg.32xlarge – The host type with a configuration of 864 GiB memory and 128 vCPUs.
    ///
    /// * kx.sg1.16xlarge – The host type with a configuration of 1949 GiB memory and 64 vCPUs.
    ///
    /// * kx.sg1.24xlarge – The host type with a configuration of 2948 GiB memory and 96 vCPUs.
    public var hostType: Swift.String?
    /// The last time that the scaling group was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: Foundation.Date?
    /// The ARN identifier for the scaling group.
    public var scalingGroupArn: Swift.String?
    /// A unique identifier for the kdb scaling group.
    public var scalingGroupName: Swift.String?
    /// The status of scaling group.
    ///
    /// * CREATING – The scaling group creation is in progress.
    ///
    /// * CREATE_FAILED – The scaling group creation has failed.
    ///
    /// * ACTIVE – The scaling group is active.
    ///
    /// * UPDATING – The scaling group is in the process of being updated.
    ///
    /// * UPDATE_FAILED – The update action failed.
    ///
    /// * DELETING – The scaling group is in the process of being deleted.
    ///
    /// * DELETE_FAILED – The system failed to delete the scaling group.
    ///
    /// * DELETED – The scaling group is successfully deleted.
    public var status: FinspaceClientTypes.KxScalingGroupStatus?
    /// The error message when a failed state occurs.
    public var statusReason: Swift.String?

    public init(
        availabilityZoneId: Swift.String? = nil,
        clusters: [Swift.String]? = nil,
        createdTimestamp: Foundation.Date? = nil,
        hostType: Swift.String? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil,
        scalingGroupArn: Swift.String? = nil,
        scalingGroupName: Swift.String? = nil,
        status: FinspaceClientTypes.KxScalingGroupStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.clusters = clusters
        self.createdTimestamp = createdTimestamp
        self.hostType = hostType
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.scalingGroupArn = scalingGroupArn
        self.scalingGroupName = scalingGroupName
        self.status = status
        self.statusReason = statusReason
    }
}

public struct GetKxUserInput {
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// A unique identifier for the user.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.userName = userName
    }
}

public struct GetKxUserOutput {
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// The IAM role ARN that is associated with the user.
    public var iamRole: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    public var userArn: Swift.String?
    /// A unique identifier for the user.
    public var userName: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        userArn: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.iamRole = iamRole
        self.userArn = userArn
        self.userName = userName
    }
}

public struct GetKxVolumeInput {
    /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
    /// This member is required.
    public var environmentId: Swift.String?
    /// A unique identifier for the volume.
    /// This member is required.
    public var volumeName: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        volumeName: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.volumeName = volumeName
    }
}

extension FinspaceClientTypes {
    /// The structure containing the metadata of the attached clusters.
    public struct KxAttachedCluster {
        /// A unique name for the attached cluster.
        public var clusterName: Swift.String?
        /// The status of the attached cluster.
        ///
        /// * PENDING – The cluster is pending creation.
        ///
        /// * CREATING – The cluster creation process is in progress.
        ///
        /// * CREATE_FAILED – The cluster creation process has failed.
        ///
        /// * RUNNING – The cluster creation process is running.
        ///
        /// * UPDATING – The cluster is in the process of being updated.
        ///
        /// * DELETING – The cluster is in the process of being deleted.
        ///
        /// * DELETED – The cluster has been deleted.
        ///
        /// * DELETE_FAILED – The cluster failed to delete.
        public var clusterStatus: FinspaceClientTypes.KxClusterStatus?
        /// Specifies the type of cluster. The volume for TP and RDB cluster types will be used for TP logs.
        public var clusterType: FinspaceClientTypes.KxClusterType?

        public init(
            clusterName: Swift.String? = nil,
            clusterStatus: FinspaceClientTypes.KxClusterStatus? = nil,
            clusterType: FinspaceClientTypes.KxClusterType? = nil
        )
        {
            self.clusterName = clusterName
            self.clusterStatus = clusterStatus
            self.clusterType = clusterType
        }
    }

}

public struct GetKxVolumeOutput {
    /// A list of cluster identifiers that a volume is attached to.
    public var attachedClusters: [FinspaceClientTypes.KxAttachedCluster]?
    /// The identifier of the availability zones.
    public var availabilityZoneIds: [Swift.String]?
    /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// The timestamp at which the volume was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: Foundation.Date?
    /// A description of the volume.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
    public var environmentId: Swift.String?
    /// The last time that the volume was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: Foundation.Date?
    /// Specifies the configuration for the Network attached storage (NAS_1) file system volume.
    public var nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
    /// The status of volume creation.
    ///
    /// * CREATING – The volume creation is in progress.
    ///
    /// * CREATE_FAILED – The volume creation has failed.
    ///
    /// * ACTIVE – The volume is active.
    ///
    /// * UPDATING – The volume is in the process of being updated.
    ///
    /// * UPDATE_FAILED – The update action failed.
    ///
    /// * UPDATED – The volume is successfully updated.
    ///
    /// * DELETING – The volume is in the process of being deleted.
    ///
    /// * DELETE_FAILED – The system failed to delete the volume.
    ///
    /// * DELETED – The volume is successfully deleted.
    public var status: FinspaceClientTypes.KxVolumeStatus?
    /// The error message when a failed state occurs.
    public var statusReason: Swift.String?
    /// The ARN identifier of the volume.
    public var volumeArn: Swift.String?
    /// A unique identifier for the volume.
    public var volumeName: Swift.String?
    /// The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
    public var volumeType: FinspaceClientTypes.KxVolumeType?

    public init(
        attachedClusters: [FinspaceClientTypes.KxAttachedCluster]? = nil,
        availabilityZoneIds: [Swift.String]? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        createdTimestamp: Foundation.Date? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil,
        nas1Configuration: FinspaceClientTypes.KxNAS1Configuration? = nil,
        status: FinspaceClientTypes.KxVolumeStatus? = nil,
        statusReason: Swift.String? = nil,
        volumeArn: Swift.String? = nil,
        volumeName: Swift.String? = nil,
        volumeType: FinspaceClientTypes.KxVolumeType? = nil
    )
    {
        self.attachedClusters = attachedClusters
        self.availabilityZoneIds = availabilityZoneIds
        self.azMode = azMode
        self.createdTimestamp = createdTimestamp
        self.description = description
        self.environmentId = environmentId
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.nas1Configuration = nas1Configuration
        self.status = status
        self.statusReason = statusReason
        self.volumeArn = volumeArn
        self.volumeName = volumeName
        self.volumeType = volumeType
    }
}

public struct ListEnvironmentsInput {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by FinSpace that specifies where to continue pagination if a previous request was truncated. To get the next set of pages, pass in the nextTokennextToken value from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListEnvironmentsOutput {
    /// A list of all of your FinSpace environments.
    public var environments: [FinspaceClientTypes.Environment]?
    /// A token that you can use in a subsequent call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        environments: [FinspaceClientTypes.Environment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

public struct ListKxChangesetsInput {
    /// The name of the kdb database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FinspaceClientTypes {
    /// Details of changeset.
    public struct KxChangesetListEntry {
        /// Beginning time from which the changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var activeFromTimestamp: Foundation.Date?
        /// A unique identifier for the changeset.
        public var changesetId: Swift.String?
        /// The timestamp at which the changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createdTimestamp: Foundation.Date?
        /// The timestamp at which the changeset was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTimestamp: Foundation.Date?
        /// Status of the changeset.
        ///
        /// * Pending – Changeset creation is pending.
        ///
        /// * Processing – Changeset creation is running.
        ///
        /// * Failed – Changeset creation has failed.
        ///
        /// * Complete – Changeset creation has succeeded.
        public var status: FinspaceClientTypes.ChangesetStatus?

        public init(
            activeFromTimestamp: Foundation.Date? = nil,
            changesetId: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            lastModifiedTimestamp: Foundation.Date? = nil,
            status: FinspaceClientTypes.ChangesetStatus? = nil
        )
        {
            self.activeFromTimestamp = activeFromTimestamp
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.status = status
        }
    }

}

public struct ListKxChangesetsOutput {
    /// A list of changesets for a database.
    public var kxChangesets: [FinspaceClientTypes.KxChangesetListEntry]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        kxChangesets: [FinspaceClientTypes.KxChangesetListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kxChangesets = kxChangesets
        self.nextToken = nextToken
    }
}

public struct ListKxClusterNodesInput {
    /// A unique name for the cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        clusterName: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FinspaceClientTypes {

    public enum KxNodeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case provisioning
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [KxNodeStatus] {
            return [
                .provisioning,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .provisioning: return "PROVISIONING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// A structure that stores metadata for a kdb node.
    public struct KxNode {
        /// The identifier of the availability zones where subnets for the environment are created.
        public var availabilityZoneId: Swift.String?
        /// The time when a particular node is started. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var launchTime: Foundation.Date?
        /// A unique identifier for the node.
        public var nodeId: Swift.String?
        /// Specifies the status of the cluster nodes.
        ///
        /// * RUNNING – The node is actively serving.
        ///
        /// * PROVISIONING – The node is being prepared.
        public var status: FinspaceClientTypes.KxNodeStatus?

        public init(
            availabilityZoneId: Swift.String? = nil,
            launchTime: Foundation.Date? = nil,
            nodeId: Swift.String? = nil,
            status: FinspaceClientTypes.KxNodeStatus? = nil
        )
        {
            self.availabilityZoneId = availabilityZoneId
            self.launchTime = launchTime
            self.nodeId = nodeId
            self.status = status
        }
    }

}

public struct ListKxClusterNodesOutput {
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// A list of nodes associated with the cluster.
    public var nodes: [FinspaceClientTypes.KxNode]?

    public init(
        nextToken: Swift.String? = nil,
        nodes: [FinspaceClientTypes.KxNode]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodes = nodes
    }
}

public struct ListKxClustersInput {
    /// Specifies the type of KDB database that is being created. The following types are available:
    ///
    /// * HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.
    ///
    /// * RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.
    ///
    /// * GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.
    ///
    /// * GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.
    ///
    /// * Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
    public var clusterType: FinspaceClientTypes.KxClusterType?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        clusterType: FinspaceClientTypes.KxClusterType? = nil,
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterType = clusterType
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FinspaceClientTypes {
    /// The details of a kdb cluster.
    public struct KxCluster {
        /// The availability zone identifiers for the requested regions.
        public var availabilityZoneId: Swift.String?
        /// The number of availability zones assigned per cluster. This can be one of the following:
        ///
        /// * SINGLE – Assigns one availability zone per cluster.
        ///
        /// * MULTI – Assigns all the availability zones per cluster.
        public var azMode: FinspaceClientTypes.KxAzMode?
        /// A description of the cluster.
        public var clusterDescription: Swift.String?
        /// A unique name for the cluster.
        public var clusterName: Swift.String?
        /// Specifies the type of KDB database that is being created. The following types are available:
        ///
        /// * HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.
        ///
        /// * RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.
        ///
        /// * GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.
        ///
        /// * GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.
        ///
        /// * Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
        public var clusterType: FinspaceClientTypes.KxClusterType?
        /// The timestamp at which the cluster was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createdTimestamp: Foundation.Date?
        /// An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
        public var executionRole: Swift.String?
        /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
        public var initializationScript: Swift.String?
        /// The last time that the cluster was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTimestamp: Foundation.Date?
        /// A version of the FinSpace managed kdb to run.
        public var releaseLabel: Swift.String?
        /// The status of a cluster.
        ///
        /// * PENDING – The cluster is pending creation.
        ///
        /// * CREATING –The cluster creation process is in progress.
        ///
        /// * CREATE_FAILED– The cluster creation process has failed.
        ///
        /// * RUNNING – The cluster creation process is running.
        ///
        /// * UPDATING – The cluster is in the process of being updated.
        ///
        /// * DELETING – The cluster is in the process of being deleted.
        ///
        /// * DELETED – The cluster has been deleted.
        ///
        /// * DELETE_FAILED – The cluster failed to delete.
        public var status: FinspaceClientTypes.KxClusterStatus?
        /// The error message when a failed state occurs.
        public var statusReason: Swift.String?
        /// A list of volumes attached to the cluster.
        public var volumes: [FinspaceClientTypes.Volume]?

        public init(
            availabilityZoneId: Swift.String? = nil,
            azMode: FinspaceClientTypes.KxAzMode? = nil,
            clusterDescription: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            clusterType: FinspaceClientTypes.KxClusterType? = nil,
            createdTimestamp: Foundation.Date? = nil,
            executionRole: Swift.String? = nil,
            initializationScript: Swift.String? = nil,
            lastModifiedTimestamp: Foundation.Date? = nil,
            releaseLabel: Swift.String? = nil,
            status: FinspaceClientTypes.KxClusterStatus? = nil,
            statusReason: Swift.String? = nil,
            volumes: [FinspaceClientTypes.Volume]? = nil
        )
        {
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.clusterDescription = clusterDescription
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.createdTimestamp = createdTimestamp
            self.executionRole = executionRole
            self.initializationScript = initializationScript
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.releaseLabel = releaseLabel
            self.status = status
            self.statusReason = statusReason
            self.volumes = volumes
        }
    }

}

public struct ListKxClustersOutput {
    /// Lists the cluster details.
    public var kxClusterSummaries: [FinspaceClientTypes.KxCluster]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        kxClusterSummaries: [FinspaceClientTypes.KxCluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kxClusterSummaries = kxClusterSummaries
        self.nextToken = nextToken
    }
}

public struct ListKxDatabasesInput {
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FinspaceClientTypes {
    /// Details about a FinSpace managed kdb database
    public struct KxDatabaseListEntry {
        /// The timestamp at which the database was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createdTimestamp: Foundation.Date?
        /// The name of the kdb database.
        public var databaseName: Swift.String?
        /// The last time that the database was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTimestamp: Foundation.Date?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            databaseName: Swift.String? = nil,
            lastModifiedTimestamp: Foundation.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.databaseName = databaseName
            self.lastModifiedTimestamp = lastModifiedTimestamp
        }
    }

}

public struct ListKxDatabasesOutput {
    /// A list of databases in the kdb environment.
    public var kxDatabases: [FinspaceClientTypes.KxDatabaseListEntry]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        kxDatabases: [FinspaceClientTypes.KxDatabaseListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kxDatabases = kxDatabases
        self.nextToken = nextToken
    }
}

public struct ListKxDataviewsInput {
    /// The name of the database where the dataviews were created.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A unique identifier for the kdb environment, for which you want to retrieve a list of dataviews.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FinspaceClientTypes {
    /// A collection of kdb dataview entries.
    public struct KxDataviewListEntry {
        /// The active changeset versions for the given dataview entry.
        public var activeVersions: [FinspaceClientTypes.KxDataviewActiveVersion]?
        /// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview when you ingest new changesets. The default value is false.
        public var autoUpdate: Swift.Bool
        /// The identifier of the availability zones.
        public var availabilityZoneId: Swift.String?
        /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
        public var azMode: FinspaceClientTypes.KxAzMode?
        /// A unique identifier for the changeset.
        public var changesetId: Swift.String?
        /// The timestamp at which the dataview list entry was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createdTimestamp: Foundation.Date?
        /// A unique identifier of the database.
        public var databaseName: Swift.String?
        /// A unique identifier of the dataview.
        public var dataviewName: Swift.String?
        /// A description for the dataview list entry.
        public var description: Swift.String?
        /// A unique identifier for the kdb environment.
        public var environmentId: Swift.String?
        /// The last time that the dataview list was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTimestamp: Foundation.Date?
        /// Returns True if the dataview is created as writeable and False otherwise.
        public var readWrite: Swift.Bool
        /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
        public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
        /// The status of a given dataview entry.
        public var status: FinspaceClientTypes.KxDataviewStatus?
        /// The error message when a failed state occurs.
        public var statusReason: Swift.String?

        public init(
            activeVersions: [FinspaceClientTypes.KxDataviewActiveVersion]? = nil,
            autoUpdate: Swift.Bool = false,
            availabilityZoneId: Swift.String? = nil,
            azMode: FinspaceClientTypes.KxAzMode? = nil,
            changesetId: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            databaseName: Swift.String? = nil,
            dataviewName: Swift.String? = nil,
            description: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            lastModifiedTimestamp: Foundation.Date? = nil,
            readWrite: Swift.Bool = false,
            segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil,
            status: FinspaceClientTypes.KxDataviewStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.activeVersions = activeVersions
            self.autoUpdate = autoUpdate
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.databaseName = databaseName
            self.dataviewName = dataviewName
            self.description = description
            self.environmentId = environmentId
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.readWrite = readWrite
            self.segmentConfigurations = segmentConfigurations
            self.status = status
            self.statusReason = statusReason
        }
    }

}

public struct ListKxDataviewsOutput {
    /// The list of kdb dataviews that are currently active for the given database.
    public var kxDataviews: [FinspaceClientTypes.KxDataviewListEntry]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        kxDataviews: [FinspaceClientTypes.KxDataviewListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kxDataviews = kxDataviews
        self.nextToken = nextToken
    }
}

public struct ListKxEnvironmentsInput {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FinspaceClientTypes {
    /// The details of a kdb environment.
    public struct KxEnvironment {
        /// The identifier of the availability zones where subnets for the environment are created.
        public var availabilityZoneIds: [Swift.String]?
        /// The unique identifier of the AWS account in which you create the kdb environment.
        public var awsAccountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the certificate authority:
        public var certificateAuthorityArn: Swift.String?
        /// The timestamp at which the kdb environment was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var creationTimestamp: Foundation.Date?
        /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
        public var customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]?
        /// A unique identifier for the AWS environment infrastructure account.
        public var dedicatedServiceAccountId: Swift.String?
        /// A description of the kdb environment.
        public var description: Swift.String?
        /// The status of DNS configuration.
        public var dnsStatus: FinspaceClientTypes.DnsStatus?
        /// The Amazon Resource Name (ARN) of your kdb environment.
        public var environmentArn: Swift.String?
        /// A unique identifier for the kdb environment.
        public var environmentId: Swift.String?
        /// Specifies the error message that appears if a flow fails.
        public var errorMessage: Swift.String?
        /// The unique identifier of the KMS key.
        public var kmsKeyId: Swift.String?
        /// The name of the kdb environment.
        public var name: Swift.String?
        /// The status of the environment creation.
        ///
        /// * CREATE_REQUESTED – Environment creation has been requested.
        ///
        /// * CREATING – Environment is in the process of being created.
        ///
        /// * FAILED_CREATION – Environment creation has failed.
        ///
        /// * CREATED – Environment is successfully created and is currently active.
        ///
        /// * DELETE REQUESTED – Environment deletion has been requested.
        ///
        /// * DELETING – Environment is in the process of being deleted.
        ///
        /// * RETRY_DELETION – Initial environment deletion failed, system is reattempting delete.
        ///
        /// * DELETED – Environment has been deleted.
        ///
        /// * FAILED_DELETION – Environment deletion has failed.
        public var status: FinspaceClientTypes.EnvironmentStatus?
        /// The status of the network configuration.
        public var tgwStatus: FinspaceClientTypes.TgwStatus?
        /// Specifies the transit gateway and network configuration to connect the kdb environment to an internal network.
        public var transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration?
        /// The timestamp at which the kdb environment was modified in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var updateTimestamp: Foundation.Date?

        public init(
            availabilityZoneIds: [Swift.String]? = nil,
            awsAccountId: Swift.String? = nil,
            certificateAuthorityArn: Swift.String? = nil,
            creationTimestamp: Foundation.Date? = nil,
            customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]? = nil,
            dedicatedServiceAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            dnsStatus: FinspaceClientTypes.DnsStatus? = nil,
            environmentArn: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            status: FinspaceClientTypes.EnvironmentStatus? = nil,
            tgwStatus: FinspaceClientTypes.TgwStatus? = nil,
            transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration? = nil,
            updateTimestamp: Foundation.Date? = nil
        )
        {
            self.availabilityZoneIds = availabilityZoneIds
            self.awsAccountId = awsAccountId
            self.certificateAuthorityArn = certificateAuthorityArn
            self.creationTimestamp = creationTimestamp
            self.customDNSConfiguration = customDNSConfiguration
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.dnsStatus = dnsStatus
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tgwStatus = tgwStatus
            self.transitGatewayConfiguration = transitGatewayConfiguration
            self.updateTimestamp = updateTimestamp
        }
    }

}

public struct ListKxEnvironmentsOutput {
    /// A list of environments in an account.
    public var environments: [FinspaceClientTypes.KxEnvironment]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        environments: [FinspaceClientTypes.KxEnvironment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

public struct ListKxScalingGroupsInput {
    /// A unique identifier for the kdb environment, for which you want to retrieve a list of scaling groups.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FinspaceClientTypes {
    /// A structure for storing metadata of scaling group.
    public struct KxScalingGroup {
        /// The identifier of the availability zones.
        public var availabilityZoneId: Swift.String?
        /// The list of clusters currently active in a given scaling group.
        public var clusters: [Swift.String]?
        /// The timestamp at which the scaling group was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createdTimestamp: Foundation.Date?
        /// The memory and CPU capabilities of the scaling group host on which FinSpace Managed kdb clusters will be placed. You can add one of the following values:
        ///
        /// * kx.sg.large – The host type with a configuration of 16 GiB memory and 2 vCPUs.
        ///
        /// * kx.sg.xlarge – The host type with a configuration of 32 GiB memory and 4 vCPUs.
        ///
        /// * kx.sg.2xlarge – The host type with a configuration of 64 GiB memory and 8 vCPUs.
        ///
        /// * kx.sg.4xlarge – The host type with a configuration of 108 GiB memory and 16 vCPUs.
        ///
        /// * kx.sg.8xlarge – The host type with a configuration of 216 GiB memory and 32 vCPUs.
        ///
        /// * kx.sg.16xlarge – The host type with a configuration of 432 GiB memory and 64 vCPUs.
        ///
        /// * kx.sg.32xlarge – The host type with a configuration of 864 GiB memory and 128 vCPUs.
        ///
        /// * kx.sg1.16xlarge – The host type with a configuration of 1949 GiB memory and 64 vCPUs.
        ///
        /// * kx.sg1.24xlarge – The host type with a configuration of 2948 GiB memory and 96 vCPUs.
        public var hostType: Swift.String?
        /// The last time that the scaling group was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTimestamp: Foundation.Date?
        /// A unique identifier for the kdb scaling group.
        public var scalingGroupName: Swift.String?
        /// The status of scaling groups.
        public var status: FinspaceClientTypes.KxScalingGroupStatus?
        /// The error message when a failed state occurs.
        public var statusReason: Swift.String?

        public init(
            availabilityZoneId: Swift.String? = nil,
            clusters: [Swift.String]? = nil,
            createdTimestamp: Foundation.Date? = nil,
            hostType: Swift.String? = nil,
            lastModifiedTimestamp: Foundation.Date? = nil,
            scalingGroupName: Swift.String? = nil,
            status: FinspaceClientTypes.KxScalingGroupStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.availabilityZoneId = availabilityZoneId
            self.clusters = clusters
            self.createdTimestamp = createdTimestamp
            self.hostType = hostType
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.scalingGroupName = scalingGroupName
            self.status = status
            self.statusReason = statusReason
        }
    }

}

public struct ListKxScalingGroupsOutput {
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// A list of scaling groups available in a kdb environment.
    public var scalingGroups: [FinspaceClientTypes.KxScalingGroup]?

    public init(
        nextToken: Swift.String? = nil,
        scalingGroups: [FinspaceClientTypes.KxScalingGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.scalingGroups = scalingGroups
    }
}

public struct ListKxUsersInput {
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FinspaceClientTypes {
    /// A structure that stores metadata for a kdb user.
    public struct KxUser {
        /// The timestamp at which the kdb user was created.
        public var createTimestamp: Foundation.Date?
        /// The IAM role ARN that is associated with the user.
        public var iamRole: Swift.String?
        /// The timestamp at which the kdb user was updated.
        public var updateTimestamp: Foundation.Date?
        /// The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        public var userArn: Swift.String?
        /// A unique identifier for the user.
        public var userName: Swift.String?

        public init(
            createTimestamp: Foundation.Date? = nil,
            iamRole: Swift.String? = nil,
            updateTimestamp: Foundation.Date? = nil,
            userArn: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.createTimestamp = createTimestamp
            self.iamRole = iamRole
            self.updateTimestamp = updateTimestamp
            self.userArn = userArn
            self.userName = userName
        }
    }

}

public struct ListKxUsersOutput {
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// A list of users in a kdb environment.
    public var users: [FinspaceClientTypes.KxUser]?

    public init(
        nextToken: Swift.String? = nil,
        users: [FinspaceClientTypes.KxUser]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

public struct ListKxVolumesInput {
    /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
    public var volumeType: FinspaceClientTypes.KxVolumeType?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        volumeType: FinspaceClientTypes.KxVolumeType? = nil
    )
    {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.volumeType = volumeType
    }
}

extension FinspaceClientTypes {
    /// The structure that contains the metadata of the volume.
    public struct KxVolume {
        /// The identifier of the availability zones.
        public var availabilityZoneIds: [Swift.String]?
        /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
        public var azMode: FinspaceClientTypes.KxAzMode?
        /// The timestamp at which the volume was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createdTimestamp: Foundation.Date?
        /// A description of the volume.
        public var description: Swift.String?
        /// The last time that the volume was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTimestamp: Foundation.Date?
        /// The status of volume.
        ///
        /// * CREATING – The volume creation is in progress.
        ///
        /// * CREATE_FAILED – The volume creation has failed.
        ///
        /// * ACTIVE – The volume is active.
        ///
        /// * UPDATING – The volume is in the process of being updated.
        ///
        /// * UPDATE_FAILED – The update action failed.
        ///
        /// * UPDATED – The volume is successfully updated.
        ///
        /// * DELETING – The volume is in the process of being deleted.
        ///
        /// * DELETE_FAILED – The system failed to delete the volume.
        ///
        /// * DELETED – The volume is successfully deleted.
        public var status: FinspaceClientTypes.KxVolumeStatus?
        /// The error message when a failed state occurs.
        public var statusReason: Swift.String?
        /// A unique identifier for the volume.
        public var volumeName: Swift.String?
        /// The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
        public var volumeType: FinspaceClientTypes.KxVolumeType?

        public init(
            availabilityZoneIds: [Swift.String]? = nil,
            azMode: FinspaceClientTypes.KxAzMode? = nil,
            createdTimestamp: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedTimestamp: Foundation.Date? = nil,
            status: FinspaceClientTypes.KxVolumeStatus? = nil,
            statusReason: Swift.String? = nil,
            volumeName: Swift.String? = nil,
            volumeType: FinspaceClientTypes.KxVolumeType? = nil
        )
        {
            self.availabilityZoneIds = availabilityZoneIds
            self.azMode = azMode
            self.createdTimestamp = createdTimestamp
            self.description = description
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.status = status
            self.statusReason = statusReason
            self.volumeName = volumeName
            self.volumeType = volumeType
        }
    }

}

public struct ListKxVolumesOutput {
    /// A summary of volumes.
    public var kxVolumeSummaries: [FinspaceClientTypes.KxVolume]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        kxVolumeSummaries: [FinspaceClientTypes.KxVolume]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kxVolumeSummaries = kxVolumeSummaries
        self.nextToken = nextToken
    }
}

/// The request is invalid. Something is wrong with the input to the request.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// A list of all tags for a resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags to be assigned to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// A FinSpace resource from which you want to remove a tag or tags. The value for this parameter is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys (names) of one or more tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateEnvironmentInput {
    /// The description of the environment.
    public var description: Swift.String?
    /// The identifier of the FinSpace environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Authentication mode for the environment.
    ///
    /// * FEDERATED - Users access FinSpace through Single Sign On (SSO) via your Identity provider.
    ///
    /// * LOCAL - Users access FinSpace via email and password managed within the FinSpace environment.
    public var federationMode: FinspaceClientTypes.FederationMode?
    /// Configuration information when authentication mode is FEDERATED.
    public var federationParameters: FinspaceClientTypes.FederationParameters?
    /// The name of the environment.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        federationMode: FinspaceClientTypes.FederationMode? = nil,
        federationParameters: FinspaceClientTypes.FederationParameters? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.environmentId = environmentId
        self.federationMode = federationMode
        self.federationParameters = federationParameters
        self.name = name
    }
}

public struct UpdateEnvironmentOutput {
    /// Returns the FinSpace environment object.
    public var environment: FinspaceClientTypes.Environment?

    public init(
        environment: FinspaceClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

extension FinspaceClientTypes {

    public enum KxClusterCodeDeploymentStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case force
        case noRestart
        case rolling
        case sdkUnknown(Swift.String)

        public static var allCases: [KxClusterCodeDeploymentStrategy] {
            return [
                .force,
                .noRestart,
                .rolling
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .force: return "FORCE"
            case .noRestart: return "NO_RESTART"
            case .rolling: return "ROLLING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// The configuration that allows you to choose how you want to update code on a cluster. Depending on the option you choose, you can reduce the time it takes to update the cluster.
    public struct KxClusterCodeDeploymentConfiguration {
        /// The type of deployment that you want on a cluster.
        ///
        /// * ROLLING – This options updates the cluster by stopping the exiting q process and starting a new q process with updated configuration.
        ///
        /// * NO_RESTART – This option updates the cluster without stopping the running q process. It is only available for GP type cluster. This option is quicker as it reduces the turn around time to update configuration on a cluster. With this deployment mode, you cannot update the initializationScript and commandLineArguments parameters.
        ///
        /// * FORCE – This option updates the cluster by immediately stopping all the running processes before starting up new ones with the updated configuration.
        /// This member is required.
        public var deploymentStrategy: FinspaceClientTypes.KxClusterCodeDeploymentStrategy?

        public init(
            deploymentStrategy: FinspaceClientTypes.KxClusterCodeDeploymentStrategy? = nil
        )
        {
            self.deploymentStrategy = deploymentStrategy
        }
    }

}

public struct UpdateKxClusterCodeConfigurationInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The name of the cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// The structure of the customer code available within the running cluster.
    /// This member is required.
    public var code: FinspaceClientTypes.CodeConfiguration?
    /// Specifies the key-value pairs to make them available inside the cluster. You cannot update this parameter for a NO_RESTART deployment.
    public var commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]?
    /// The configuration that allows you to choose how you want to update the code on a cluster.
    public var deploymentConfiguration: FinspaceClientTypes.KxClusterCodeDeploymentConfiguration?
    /// A unique identifier of the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q. You cannot update this parameter for a NO_RESTART deployment.
    public var initializationScript: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        code: FinspaceClientTypes.CodeConfiguration? = nil,
        commandLineArguments: [FinspaceClientTypes.KxCommandLineArgument]? = nil,
        deploymentConfiguration: FinspaceClientTypes.KxClusterCodeDeploymentConfiguration? = nil,
        environmentId: Swift.String? = nil,
        initializationScript: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.clusterName = clusterName
        self.code = code
        self.commandLineArguments = commandLineArguments
        self.deploymentConfiguration = deploymentConfiguration
        self.environmentId = environmentId
        self.initializationScript = initializationScript
    }
}

public struct UpdateKxClusterCodeConfigurationOutput {

    public init() { }
}

extension FinspaceClientTypes {

    public enum KxDeploymentStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case noRestart
        case rolling
        case sdkUnknown(Swift.String)

        public static var allCases: [KxDeploymentStrategy] {
            return [
                .noRestart,
                .rolling
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .noRestart: return "NO_RESTART"
            case .rolling: return "ROLLING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FinspaceClientTypes {
    /// The configuration that allows you to choose how you want to update the databases on a cluster. Depending on the option you choose, you can reduce the time it takes to update the cluster.
    public struct KxDeploymentConfiguration {
        /// The type of deployment that you want on a cluster.
        ///
        /// * ROLLING – This options updates the cluster by stopping the exiting q process and starting a new q process with updated configuration.
        ///
        /// * NO_RESTART – This option updates the cluster without stopping the running q process. It is only available for HDB type cluster. This option is quicker as it reduces the turn around time to update configuration on a cluster. With this deployment mode, you cannot update the initializationScript and commandLineArguments parameters.
        /// This member is required.
        public var deploymentStrategy: FinspaceClientTypes.KxDeploymentStrategy?

        public init(
            deploymentStrategy: FinspaceClientTypes.KxDeploymentStrategy? = nil
        )
        {
            self.deploymentStrategy = deploymentStrategy
        }
    }

}

public struct UpdateKxClusterDatabasesInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A unique name for the cluster that you want to modify.
    /// This member is required.
    public var clusterName: Swift.String?
    /// The structure of databases mounted on the cluster.
    /// This member is required.
    public var databases: [FinspaceClientTypes.KxDatabaseConfiguration]?
    /// The configuration that allows you to choose how you want to update the databases on a cluster.
    public var deploymentConfiguration: FinspaceClientTypes.KxDeploymentConfiguration?
    /// The unique identifier of a kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        databases: [FinspaceClientTypes.KxDatabaseConfiguration]? = nil,
        deploymentConfiguration: FinspaceClientTypes.KxDeploymentConfiguration? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.clusterName = clusterName
        self.databases = databases
        self.deploymentConfiguration = deploymentConfiguration
        self.environmentId = environmentId
    }
}

public struct UpdateKxClusterDatabasesOutput {

    public init() { }
}

public struct UpdateKxDatabaseInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The name of the kdb database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A description of the database.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.databaseName = databaseName
        self.description = description
        self.environmentId = environmentId
    }
}

public struct UpdateKxDatabaseOutput {
    /// The name of the kdb database.
    public var databaseName: Swift.String?
    /// A description of the database.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// The last time that the database was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: Foundation.Date?

    public init(
        databaseName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil
    )
    {
        self.databaseName = databaseName
        self.description = description
        self.environmentId = environmentId
        self.lastModifiedTimestamp = lastModifiedTimestamp
    }
}

public struct UpdateKxDataviewInput {
    /// A unique identifier for the changeset.
    public var changesetId: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The name of the database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the dataview that you want to update.
    /// This member is required.
    public var dataviewName: Swift.String?
    /// The description for a dataview.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, where you want to update the dataview.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
    public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?

    public init(
        changesetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        dataviewName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil
    )
    {
        self.changesetId = changesetId
        self.clientToken = clientToken
        self.databaseName = databaseName
        self.dataviewName = dataviewName
        self.description = description
        self.environmentId = environmentId
        self.segmentConfigurations = segmentConfigurations
    }
}

public struct UpdateKxDataviewOutput {
    /// The current active changeset versions of the database on the given dataview.
    public var activeVersions: [FinspaceClientTypes.KxDataviewActiveVersion]?
    /// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview when new changesets are ingested. The default value is false.
    public var autoUpdate: Swift.Bool
    /// The identifier of the availability zones.
    public var availabilityZoneId: Swift.String?
    /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// A unique identifier for the changeset.
    public var changesetId: Swift.String?
    /// The timestamp at which the dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: Foundation.Date?
    /// The name of the database.
    public var databaseName: Swift.String?
    /// The name of the database under which the dataview was created.
    public var dataviewName: Swift.String?
    /// A description of the dataview.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment, where you want to update the dataview.
    public var environmentId: Swift.String?
    /// The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: Foundation.Date?
    /// Returns True if the dataview is created as writeable and False otherwise.
    public var readWrite: Swift.Bool
    /// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
    public var segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]?
    /// The status of dataview creation.
    ///
    /// * CREATING – The dataview creation is in progress.
    ///
    /// * UPDATING – The dataview is in the process of being updated.
    ///
    /// * ACTIVE – The dataview is active.
    public var status: FinspaceClientTypes.KxDataviewStatus?

    public init(
        activeVersions: [FinspaceClientTypes.KxDataviewActiveVersion]? = nil,
        autoUpdate: Swift.Bool = false,
        availabilityZoneId: Swift.String? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        changesetId: Swift.String? = nil,
        createdTimestamp: Foundation.Date? = nil,
        databaseName: Swift.String? = nil,
        dataviewName: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil,
        readWrite: Swift.Bool = false,
        segmentConfigurations: [FinspaceClientTypes.KxDataviewSegmentConfiguration]? = nil,
        status: FinspaceClientTypes.KxDataviewStatus? = nil
    )
    {
        self.activeVersions = activeVersions
        self.autoUpdate = autoUpdate
        self.availabilityZoneId = availabilityZoneId
        self.azMode = azMode
        self.changesetId = changesetId
        self.createdTimestamp = createdTimestamp
        self.databaseName = databaseName
        self.dataviewName = dataviewName
        self.description = description
        self.environmentId = environmentId
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.readWrite = readWrite
        self.segmentConfigurations = segmentConfigurations
        self.status = status
    }
}

public struct UpdateKxEnvironmentInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A description of the kdb environment.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The name of the kdb environment.
    public var name: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.environmentId = environmentId
        self.name = name
    }
}

public struct UpdateKxEnvironmentOutput {
    /// The identifier of the availability zones where subnets for the environment are created.
    public var availabilityZoneIds: [Swift.String]?
    /// The unique identifier of the AWS account that is used to create the kdb environment.
    public var awsAccountId: Swift.String?
    /// The timestamp at which the kdb environment was created in FinSpace.
    public var creationTimestamp: Foundation.Date?
    /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
    public var customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]?
    /// A unique identifier for the AWS environment infrastructure account.
    public var dedicatedServiceAccountId: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The status of DNS configuration.
    public var dnsStatus: FinspaceClientTypes.DnsStatus?
    /// The ARN identifier of the environment.
    public var environmentArn: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// Specifies the error message that appears if a flow fails.
    public var errorMessage: Swift.String?
    /// The KMS key ID to encrypt your data in the FinSpace environment.
    public var kmsKeyId: Swift.String?
    /// The name of the kdb environment.
    public var name: Swift.String?
    /// The status of the kdb environment.
    public var status: FinspaceClientTypes.EnvironmentStatus?
    /// The status of the network configuration.
    public var tgwStatus: FinspaceClientTypes.TgwStatus?
    /// The structure of the transit gateway and network configuration that is used to connect the kdb environment to an internal network.
    public var transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration?
    /// The timestamp at which the kdb environment was updated.
    public var updateTimestamp: Foundation.Date?

    public init(
        availabilityZoneIds: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        creationTimestamp: Foundation.Date? = nil,
        customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]? = nil,
        dedicatedServiceAccountId: Swift.String? = nil,
        description: Swift.String? = nil,
        dnsStatus: FinspaceClientTypes.DnsStatus? = nil,
        environmentArn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: FinspaceClientTypes.EnvironmentStatus? = nil,
        tgwStatus: FinspaceClientTypes.TgwStatus? = nil,
        transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration? = nil,
        updateTimestamp: Foundation.Date? = nil
    )
    {
        self.availabilityZoneIds = availabilityZoneIds
        self.awsAccountId = awsAccountId
        self.creationTimestamp = creationTimestamp
        self.customDNSConfiguration = customDNSConfiguration
        self.dedicatedServiceAccountId = dedicatedServiceAccountId
        self.description = description
        self.dnsStatus = dnsStatus
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.status = status
        self.tgwStatus = tgwStatus
        self.transitGatewayConfiguration = transitGatewayConfiguration
        self.updateTimestamp = updateTimestamp
    }
}

public struct UpdateKxEnvironmentNetworkInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
    public var customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the transit gateway and network configuration to connect the kdb environment to an internal network.
    public var transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration?

    public init(
        clientToken: Swift.String? = nil,
        customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]? = nil,
        environmentId: Swift.String? = nil,
        transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration? = nil
    )
    {
        self.clientToken = clientToken
        self.customDNSConfiguration = customDNSConfiguration
        self.environmentId = environmentId
        self.transitGatewayConfiguration = transitGatewayConfiguration
    }
}

public struct UpdateKxEnvironmentNetworkOutput {
    /// The identifier of the availability zones where subnets for the environment are created.
    public var availabilityZoneIds: [Swift.String]?
    /// The unique identifier of the AWS account that is used to create the kdb environment.
    public var awsAccountId: Swift.String?
    /// The timestamp at which the kdb environment was created in FinSpace.
    public var creationTimestamp: Foundation.Date?
    /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
    public var customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]?
    /// A unique identifier for the AWS environment infrastructure account.
    public var dedicatedServiceAccountId: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The status of DNS configuration.
    public var dnsStatus: FinspaceClientTypes.DnsStatus?
    /// The ARN identifier of the environment.
    public var environmentArn: Swift.String?
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// Specifies the error message that appears if a flow fails.
    public var errorMessage: Swift.String?
    /// The KMS key ID to encrypt your data in the FinSpace environment.
    public var kmsKeyId: Swift.String?
    /// The name of the kdb environment.
    public var name: Swift.String?
    /// The status of the kdb environment.
    public var status: FinspaceClientTypes.EnvironmentStatus?
    /// The status of the network configuration.
    public var tgwStatus: FinspaceClientTypes.TgwStatus?
    /// The structure of the transit gateway and network configuration that is used to connect the kdb environment to an internal network.
    public var transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration?
    /// The timestamp at which the kdb environment was updated.
    public var updateTimestamp: Foundation.Date?

    public init(
        availabilityZoneIds: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        creationTimestamp: Foundation.Date? = nil,
        customDNSConfiguration: [FinspaceClientTypes.CustomDNSServer]? = nil,
        dedicatedServiceAccountId: Swift.String? = nil,
        description: Swift.String? = nil,
        dnsStatus: FinspaceClientTypes.DnsStatus? = nil,
        environmentArn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: FinspaceClientTypes.EnvironmentStatus? = nil,
        tgwStatus: FinspaceClientTypes.TgwStatus? = nil,
        transitGatewayConfiguration: FinspaceClientTypes.TransitGatewayConfiguration? = nil,
        updateTimestamp: Foundation.Date? = nil
    )
    {
        self.availabilityZoneIds = availabilityZoneIds
        self.awsAccountId = awsAccountId
        self.creationTimestamp = creationTimestamp
        self.customDNSConfiguration = customDNSConfiguration
        self.dedicatedServiceAccountId = dedicatedServiceAccountId
        self.description = description
        self.dnsStatus = dnsStatus
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.status = status
        self.tgwStatus = tgwStatus
        self.transitGatewayConfiguration = transitGatewayConfiguration
        self.updateTimestamp = updateTimestamp
    }
}

public struct UpdateKxUserInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A unique identifier for the kdb environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The IAM role ARN that is associated with the user.
    /// This member is required.
    public var iamRole: Swift.String?
    /// A unique identifier for the user.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.iamRole = iamRole
        self.userName = userName
    }
}

public struct UpdateKxUserOutput {
    /// A unique identifier for the kdb environment.
    public var environmentId: Swift.String?
    /// The IAM role ARN that is associated with the user.
    public var iamRole: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    public var userArn: Swift.String?
    /// A unique identifier for the user.
    public var userName: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        userArn: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.iamRole = iamRole
        self.userArn = userArn
        self.userName = userName
    }
}

public struct UpdateKxVolumeInput {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A description of the volume.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment where you created the storage volume.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the configuration for the Network attached storage (NAS_1) file system volume.
    public var nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
    /// A unique identifier for the volume.
    /// This member is required.
    public var volumeName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        nas1Configuration: FinspaceClientTypes.KxNAS1Configuration? = nil,
        volumeName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.environmentId = environmentId
        self.nas1Configuration = nas1Configuration
        self.volumeName = volumeName
    }
}

public struct UpdateKxVolumeOutput {
    /// Specifies the clusters that a volume is attached to.
    public var attachedClusters: [FinspaceClientTypes.KxAttachedCluster]?
    /// The identifier of the availability zones.
    public var availabilityZoneIds: [Swift.String]?
    /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
    public var azMode: FinspaceClientTypes.KxAzMode?
    /// The timestamp at which the volume was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createdTimestamp: Foundation.Date?
    /// The description for the volume.
    public var description: Swift.String?
    /// A unique identifier for the kdb environment where you want to update the volume.
    public var environmentId: Swift.String?
    /// The last time that the volume was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTimestamp: Foundation.Date?
    /// Specifies the configuration for the Network attached storage (NAS_1) file system volume.
    public var nas1Configuration: FinspaceClientTypes.KxNAS1Configuration?
    /// The status of the volume.
    ///
    /// * CREATING – The volume creation is in progress.
    ///
    /// * CREATE_FAILED – The volume creation has failed.
    ///
    /// * ACTIVE – The volume is active.
    ///
    /// * UPDATING – The volume is in the process of being updated.
    ///
    /// * UPDATE_FAILED – The update action failed.
    ///
    /// * UPDATED – The volume is successfully updated.
    ///
    /// * DELETING – The volume is in the process of being deleted.
    ///
    /// * DELETE_FAILED – The system failed to delete the volume.
    ///
    /// * DELETED – The volume is successfully deleted.
    public var status: FinspaceClientTypes.KxVolumeStatus?
    /// The error message when a failed state occurs.
    public var statusReason: Swift.String?
    /// The ARN identifier of the volume.
    public var volumeArn: Swift.String?
    /// A unique identifier for the volume that you want to update.
    public var volumeName: Swift.String?
    /// The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
    public var volumeType: FinspaceClientTypes.KxVolumeType?

    public init(
        attachedClusters: [FinspaceClientTypes.KxAttachedCluster]? = nil,
        availabilityZoneIds: [Swift.String]? = nil,
        azMode: FinspaceClientTypes.KxAzMode? = nil,
        createdTimestamp: Foundation.Date? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil,
        nas1Configuration: FinspaceClientTypes.KxNAS1Configuration? = nil,
        status: FinspaceClientTypes.KxVolumeStatus? = nil,
        statusReason: Swift.String? = nil,
        volumeArn: Swift.String? = nil,
        volumeName: Swift.String? = nil,
        volumeType: FinspaceClientTypes.KxVolumeType? = nil
    )
    {
        self.attachedClusters = attachedClusters
        self.availabilityZoneIds = availabilityZoneIds
        self.azMode = azMode
        self.createdTimestamp = createdTimestamp
        self.description = description
        self.environmentId = environmentId
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.nas1Configuration = nas1Configuration
        self.status = status
        self.statusReason = statusReason
        self.volumeArn = volumeArn
        self.volumeName = volumeName
        self.volumeType = volumeType
    }
}

extension CreateEnvironmentInput {

    static func urlPathProvider(_ value: CreateEnvironmentInput) -> Swift.String? {
        return "/environment"
    }
}

extension CreateKxChangesetInput {

    static func urlPathProvider(_ value: CreateKxChangesetInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/changesets"
    }
}

extension CreateKxClusterInput {

    static func urlPathProvider(_ value: CreateKxClusterInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters"
    }
}

extension CreateKxDatabaseInput {

    static func urlPathProvider(_ value: CreateKxDatabaseInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases"
    }
}

extension CreateKxDataviewInput {

    static func urlPathProvider(_ value: CreateKxDataviewInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/dataviews"
    }
}

extension CreateKxEnvironmentInput {

    static func urlPathProvider(_ value: CreateKxEnvironmentInput) -> Swift.String? {
        return "/kx/environments"
    }
}

extension CreateKxScalingGroupInput {

    static func urlPathProvider(_ value: CreateKxScalingGroupInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/scalingGroups"
    }
}

extension CreateKxUserInput {

    static func urlPathProvider(_ value: CreateKxUserInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/users"
    }
}

extension CreateKxVolumeInput {

    static func urlPathProvider(_ value: CreateKxVolumeInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/kxvolumes"
    }
}

extension DeleteEnvironmentInput {

    static func urlPathProvider(_ value: DeleteEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/environment/\(environmentId.urlPercentEncoding())"
    }
}

extension DeleteKxClusterInput {

    static func urlPathProvider(_ value: DeleteKxClusterInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let clusterName = value.clusterName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters/\(clusterName.urlPercentEncoding())"
    }
}

extension DeleteKxClusterInput {

    static func queryItemProvider(_ value: DeleteKxClusterInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteKxClusterNodeInput {

    static func urlPathProvider(_ value: DeleteKxClusterNodeInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let clusterName = value.clusterName else {
            return nil
        }
        guard let nodeId = value.nodeId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters/\(clusterName.urlPercentEncoding())/nodes/\(nodeId.urlPercentEncoding())"
    }
}

extension DeleteKxDatabaseInput {

    static func urlPathProvider(_ value: DeleteKxDatabaseInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())"
    }
}

extension DeleteKxDatabaseInput {

    static func queryItemProvider(_ value: DeleteKxDatabaseInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let clientToken = value.clientToken else {
            let message = "Creating a URL Query Item failed. clientToken is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
        items.append(clientTokenQueryItem)
        return items
    }
}

extension DeleteKxDataviewInput {

    static func urlPathProvider(_ value: DeleteKxDataviewInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        guard let dataviewName = value.dataviewName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/dataviews/\(dataviewName.urlPercentEncoding())"
    }
}

extension DeleteKxDataviewInput {

    static func queryItemProvider(_ value: DeleteKxDataviewInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let clientToken = value.clientToken else {
            let message = "Creating a URL Query Item failed. clientToken is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
        items.append(clientTokenQueryItem)
        return items
    }
}

extension DeleteKxEnvironmentInput {

    static func urlPathProvider(_ value: DeleteKxEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())"
    }
}

extension DeleteKxEnvironmentInput {

    static func queryItemProvider(_ value: DeleteKxEnvironmentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteKxScalingGroupInput {

    static func urlPathProvider(_ value: DeleteKxScalingGroupInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let scalingGroupName = value.scalingGroupName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/scalingGroups/\(scalingGroupName.urlPercentEncoding())"
    }
}

extension DeleteKxScalingGroupInput {

    static func queryItemProvider(_ value: DeleteKxScalingGroupInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteKxUserInput {

    static func urlPathProvider(_ value: DeleteKxUserInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let userName = value.userName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

extension DeleteKxUserInput {

    static func queryItemProvider(_ value: DeleteKxUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteKxVolumeInput {

    static func urlPathProvider(_ value: DeleteKxVolumeInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let volumeName = value.volumeName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/kxvolumes/\(volumeName.urlPercentEncoding())"
    }
}

extension DeleteKxVolumeInput {

    static func queryItemProvider(_ value: DeleteKxVolumeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension GetEnvironmentInput {

    static func urlPathProvider(_ value: GetEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/environment/\(environmentId.urlPercentEncoding())"
    }
}

extension GetKxChangesetInput {

    static func urlPathProvider(_ value: GetKxChangesetInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        guard let changesetId = value.changesetId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/changesets/\(changesetId.urlPercentEncoding())"
    }
}

extension GetKxClusterInput {

    static func urlPathProvider(_ value: GetKxClusterInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let clusterName = value.clusterName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters/\(clusterName.urlPercentEncoding())"
    }
}

extension GetKxConnectionStringInput {

    static func urlPathProvider(_ value: GetKxConnectionStringInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/connectionString"
    }
}

extension GetKxConnectionStringInput {

    static func queryItemProvider(_ value: GetKxConnectionStringInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let clusterName = value.clusterName else {
            let message = "Creating a URL Query Item failed. clusterName is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let clusterNameQueryItem = Smithy.URIQueryItem(name: "clusterName".urlPercentEncoding(), value: Swift.String(clusterName).urlPercentEncoding())
        items.append(clusterNameQueryItem)
        guard let userArn = value.userArn else {
            let message = "Creating a URL Query Item failed. userArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let userArnQueryItem = Smithy.URIQueryItem(name: "userArn".urlPercentEncoding(), value: Swift.String(userArn).urlPercentEncoding())
        items.append(userArnQueryItem)
        return items
    }
}

extension GetKxDatabaseInput {

    static func urlPathProvider(_ value: GetKxDatabaseInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())"
    }
}

extension GetKxDataviewInput {

    static func urlPathProvider(_ value: GetKxDataviewInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        guard let dataviewName = value.dataviewName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/dataviews/\(dataviewName.urlPercentEncoding())"
    }
}

extension GetKxEnvironmentInput {

    static func urlPathProvider(_ value: GetKxEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())"
    }
}

extension GetKxScalingGroupInput {

    static func urlPathProvider(_ value: GetKxScalingGroupInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let scalingGroupName = value.scalingGroupName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/scalingGroups/\(scalingGroupName.urlPercentEncoding())"
    }
}

extension GetKxUserInput {

    static func urlPathProvider(_ value: GetKxUserInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let userName = value.userName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

extension GetKxVolumeInput {

    static func urlPathProvider(_ value: GetKxVolumeInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let volumeName = value.volumeName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/kxvolumes/\(volumeName.urlPercentEncoding())"
    }
}

extension ListEnvironmentsInput {

    static func urlPathProvider(_ value: ListEnvironmentsInput) -> Swift.String? {
        return "/environment"
    }
}

extension ListEnvironmentsInput {

    static func queryItemProvider(_ value: ListEnvironmentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKxChangesetsInput {

    static func urlPathProvider(_ value: ListKxChangesetsInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/changesets"
    }
}

extension ListKxChangesetsInput {

    static func queryItemProvider(_ value: ListKxChangesetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKxClusterNodesInput {

    static func urlPathProvider(_ value: ListKxClusterNodesInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let clusterName = value.clusterName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters/\(clusterName.urlPercentEncoding())/nodes"
    }
}

extension ListKxClusterNodesInput {

    static func queryItemProvider(_ value: ListKxClusterNodesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKxClustersInput {

    static func urlPathProvider(_ value: ListKxClustersInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters"
    }
}

extension ListKxClustersInput {

    static func queryItemProvider(_ value: ListKxClustersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clusterType = value.clusterType {
            let clusterTypeQueryItem = Smithy.URIQueryItem(name: "clusterType".urlPercentEncoding(), value: Swift.String(clusterType.rawValue).urlPercentEncoding())
            items.append(clusterTypeQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListKxDatabasesInput {

    static func urlPathProvider(_ value: ListKxDatabasesInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases"
    }
}

extension ListKxDatabasesInput {

    static func queryItemProvider(_ value: ListKxDatabasesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKxDataviewsInput {

    static func urlPathProvider(_ value: ListKxDataviewsInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/dataviews"
    }
}

extension ListKxDataviewsInput {

    static func queryItemProvider(_ value: ListKxDataviewsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKxEnvironmentsInput {

    static func urlPathProvider(_ value: ListKxEnvironmentsInput) -> Swift.String? {
        return "/kx/environments"
    }
}

extension ListKxEnvironmentsInput {

    static func queryItemProvider(_ value: ListKxEnvironmentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKxScalingGroupsInput {

    static func urlPathProvider(_ value: ListKxScalingGroupsInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/scalingGroups"
    }
}

extension ListKxScalingGroupsInput {

    static func queryItemProvider(_ value: ListKxScalingGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListKxUsersInput {

    static func urlPathProvider(_ value: ListKxUsersInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/users"
    }
}

extension ListKxUsersInput {

    static func queryItemProvider(_ value: ListKxUsersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKxVolumesInput {

    static func urlPathProvider(_ value: ListKxVolumesInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/kxvolumes"
    }
}

extension ListKxVolumesInput {

    static func queryItemProvider(_ value: ListKxVolumesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let volumeType = value.volumeType {
            let volumeTypeQueryItem = Smithy.URIQueryItem(name: "volumeType".urlPercentEncoding(), value: Swift.String(volumeType.rawValue).urlPercentEncoding())
            items.append(volumeTypeQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateEnvironmentInput {

    static func urlPathProvider(_ value: UpdateEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/environment/\(environmentId.urlPercentEncoding())"
    }
}

extension UpdateKxClusterCodeConfigurationInput {

    static func urlPathProvider(_ value: UpdateKxClusterCodeConfigurationInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let clusterName = value.clusterName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters/\(clusterName.urlPercentEncoding())/configuration/code"
    }
}

extension UpdateKxClusterDatabasesInput {

    static func urlPathProvider(_ value: UpdateKxClusterDatabasesInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let clusterName = value.clusterName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/clusters/\(clusterName.urlPercentEncoding())/configuration/databases"
    }
}

extension UpdateKxDatabaseInput {

    static func urlPathProvider(_ value: UpdateKxDatabaseInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())"
    }
}

extension UpdateKxDataviewInput {

    static func urlPathProvider(_ value: UpdateKxDataviewInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let databaseName = value.databaseName else {
            return nil
        }
        guard let dataviewName = value.dataviewName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/databases/\(databaseName.urlPercentEncoding())/dataviews/\(dataviewName.urlPercentEncoding())"
    }
}

extension UpdateKxEnvironmentInput {

    static func urlPathProvider(_ value: UpdateKxEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())"
    }
}

extension UpdateKxEnvironmentNetworkInput {

    static func urlPathProvider(_ value: UpdateKxEnvironmentNetworkInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/network"
    }
}

extension UpdateKxUserInput {

    static func urlPathProvider(_ value: UpdateKxUserInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let userName = value.userName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

extension UpdateKxVolumeInput {

    static func urlPathProvider(_ value: UpdateKxVolumeInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let volumeName = value.volumeName else {
            return nil
        }
        return "/kx/environments/\(environmentId.urlPercentEncoding())/kxvolumes/\(volumeName.urlPercentEncoding())"
    }
}

extension CreateEnvironmentInput {

    static func write(value: CreateEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataBundles"].writeList(value.dataBundles, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["federationMode"].write(value.federationMode)
        try writer["federationParameters"].write(value.federationParameters, with: FinspaceClientTypes.FederationParameters.write(value:to:))
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["superuserParameters"].write(value.superuserParameters, with: FinspaceClientTypes.SuperuserParameters.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateKxChangesetInput {

    static func write(value: CreateKxChangesetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["changeRequests"].writeList(value.changeRequests, memberWritingClosure: FinspaceClientTypes.ChangeRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
    }
}

extension CreateKxClusterInput {

    static func write(value: CreateKxClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoScalingConfiguration"].write(value.autoScalingConfiguration, with: FinspaceClientTypes.AutoScalingConfiguration.write(value:to:))
        try writer["availabilityZoneId"].write(value.availabilityZoneId)
        try writer["azMode"].write(value.azMode)
        try writer["cacheStorageConfigurations"].writeList(value.cacheStorageConfigurations, memberWritingClosure: FinspaceClientTypes.KxCacheStorageConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["capacityConfiguration"].write(value.capacityConfiguration, with: FinspaceClientTypes.CapacityConfiguration.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["clusterDescription"].write(value.clusterDescription)
        try writer["clusterName"].write(value.clusterName)
        try writer["clusterType"].write(value.clusterType)
        try writer["code"].write(value.code, with: FinspaceClientTypes.CodeConfiguration.write(value:to:))
        try writer["commandLineArguments"].writeList(value.commandLineArguments, memberWritingClosure: FinspaceClientTypes.KxCommandLineArgument.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["databases"].writeList(value.databases, memberWritingClosure: FinspaceClientTypes.KxDatabaseConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["executionRole"].write(value.executionRole)
        try writer["initializationScript"].write(value.initializationScript)
        try writer["releaseLabel"].write(value.releaseLabel)
        try writer["savedownStorageConfiguration"].write(value.savedownStorageConfiguration, with: FinspaceClientTypes.KxSavedownStorageConfiguration.write(value:to:))
        try writer["scalingGroupConfiguration"].write(value.scalingGroupConfiguration, with: FinspaceClientTypes.KxScalingGroupConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tickerplantLogConfiguration"].write(value.tickerplantLogConfiguration, with: FinspaceClientTypes.TickerplantLogConfiguration.write(value:to:))
        try writer["vpcConfiguration"].write(value.vpcConfiguration, with: FinspaceClientTypes.VpcConfiguration.write(value:to:))
    }
}

extension CreateKxDatabaseInput {

    static func write(value: CreateKxDatabaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["databaseName"].write(value.databaseName)
        try writer["description"].write(value.description)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateKxDataviewInput {

    static func write(value: CreateKxDataviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoUpdate"].write(value.autoUpdate)
        try writer["availabilityZoneId"].write(value.availabilityZoneId)
        try writer["azMode"].write(value.azMode)
        try writer["changesetId"].write(value.changesetId)
        try writer["clientToken"].write(value.clientToken)
        try writer["dataviewName"].write(value.dataviewName)
        try writer["description"].write(value.description)
        try writer["readWrite"].write(value.readWrite)
        try writer["segmentConfigurations"].writeList(value.segmentConfigurations, memberWritingClosure: FinspaceClientTypes.KxDataviewSegmentConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateKxEnvironmentInput {

    static func write(value: CreateKxEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateKxScalingGroupInput {

    static func write(value: CreateKxScalingGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["availabilityZoneId"].write(value.availabilityZoneId)
        try writer["clientToken"].write(value.clientToken)
        try writer["hostType"].write(value.hostType)
        try writer["scalingGroupName"].write(value.scalingGroupName)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateKxUserInput {

    static func write(value: CreateKxUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["iamRole"].write(value.iamRole)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["userName"].write(value.userName)
    }
}

extension CreateKxVolumeInput {

    static func write(value: CreateKxVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["availabilityZoneIds"].writeList(value.availabilityZoneIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["azMode"].write(value.azMode)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["nas1Configuration"].write(value.nas1Configuration, with: FinspaceClientTypes.KxNAS1Configuration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["volumeName"].write(value.volumeName)
        try writer["volumeType"].write(value.volumeType)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateEnvironmentInput {

    static func write(value: UpdateEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["federationMode"].write(value.federationMode)
        try writer["federationParameters"].write(value.federationParameters, with: FinspaceClientTypes.FederationParameters.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension UpdateKxClusterCodeConfigurationInput {

    static func write(value: UpdateKxClusterCodeConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["code"].write(value.code, with: FinspaceClientTypes.CodeConfiguration.write(value:to:))
        try writer["commandLineArguments"].writeList(value.commandLineArguments, memberWritingClosure: FinspaceClientTypes.KxCommandLineArgument.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["deploymentConfiguration"].write(value.deploymentConfiguration, with: FinspaceClientTypes.KxClusterCodeDeploymentConfiguration.write(value:to:))
        try writer["initializationScript"].write(value.initializationScript)
    }
}

extension UpdateKxClusterDatabasesInput {

    static func write(value: UpdateKxClusterDatabasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["databases"].writeList(value.databases, memberWritingClosure: FinspaceClientTypes.KxDatabaseConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["deploymentConfiguration"].write(value.deploymentConfiguration, with: FinspaceClientTypes.KxDeploymentConfiguration.write(value:to:))
    }
}

extension UpdateKxDatabaseInput {

    static func write(value: UpdateKxDatabaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
    }
}

extension UpdateKxDataviewInput {

    static func write(value: UpdateKxDataviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["changesetId"].write(value.changesetId)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["segmentConfigurations"].writeList(value.segmentConfigurations, memberWritingClosure: FinspaceClientTypes.KxDataviewSegmentConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateKxEnvironmentInput {

    static func write(value: UpdateKxEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension UpdateKxEnvironmentNetworkInput {

    static func write(value: UpdateKxEnvironmentNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["customDNSConfiguration"].writeList(value.customDNSConfiguration, memberWritingClosure: FinspaceClientTypes.CustomDNSServer.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["transitGatewayConfiguration"].write(value.transitGatewayConfiguration, with: FinspaceClientTypes.TransitGatewayConfiguration.write(value:to:))
    }
}

extension UpdateKxUserInput {

    static func write(value: UpdateKxUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["iamRole"].write(value.iamRole)
    }
}

extension UpdateKxVolumeInput {

    static func write(value: UpdateKxVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["nas1Configuration"].write(value.nas1Configuration, with: FinspaceClientTypes.KxNAS1Configuration.write(value:to:))
    }
}

extension CreateEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEnvironmentOutput()
        value.environmentArn = try reader["environmentArn"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.environmentUrl = try reader["environmentUrl"].readIfPresent()
        return value
    }
}

extension CreateKxChangesetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKxChangesetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKxChangesetOutput()
        value.changeRequests = try reader["changeRequests"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.ChangeRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.changesetId = try reader["changesetId"].readIfPresent()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.errorInfo = try reader["errorInfo"].readIfPresent(with: FinspaceClientTypes.ErrorInfo.read(from:))
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateKxClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKxClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKxClusterOutput()
        value.autoScalingConfiguration = try reader["autoScalingConfiguration"].readIfPresent(with: FinspaceClientTypes.AutoScalingConfiguration.read(from:))
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.azMode = try reader["azMode"].readIfPresent()
        value.cacheStorageConfigurations = try reader["cacheStorageConfigurations"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxCacheStorageConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.capacityConfiguration = try reader["capacityConfiguration"].readIfPresent(with: FinspaceClientTypes.CapacityConfiguration.read(from:))
        value.clusterDescription = try reader["clusterDescription"].readIfPresent()
        value.clusterName = try reader["clusterName"].readIfPresent()
        value.clusterType = try reader["clusterType"].readIfPresent()
        value.code = try reader["code"].readIfPresent(with: FinspaceClientTypes.CodeConfiguration.read(from:))
        value.commandLineArguments = try reader["commandLineArguments"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxCommandLineArgument.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.databases = try reader["databases"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxDatabaseConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.executionRole = try reader["executionRole"].readIfPresent()
        value.initializationScript = try reader["initializationScript"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.releaseLabel = try reader["releaseLabel"].readIfPresent()
        value.savedownStorageConfiguration = try reader["savedownStorageConfiguration"].readIfPresent(with: FinspaceClientTypes.KxSavedownStorageConfiguration.read(from:))
        value.scalingGroupConfiguration = try reader["scalingGroupConfiguration"].readIfPresent(with: FinspaceClientTypes.KxScalingGroupConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.tickerplantLogConfiguration = try reader["tickerplantLogConfiguration"].readIfPresent(with: FinspaceClientTypes.TickerplantLogConfiguration.read(from:))
        value.volumes = try reader["volumes"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.Volume.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcConfiguration = try reader["vpcConfiguration"].readIfPresent(with: FinspaceClientTypes.VpcConfiguration.read(from:))
        return value
    }
}

extension CreateKxDatabaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKxDatabaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKxDatabaseOutput()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.databaseArn = try reader["databaseArn"].readIfPresent()
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension CreateKxDataviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKxDataviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKxDataviewOutput()
        value.autoUpdate = try reader["autoUpdate"].readIfPresent() ?? false
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.azMode = try reader["azMode"].readIfPresent()
        value.changesetId = try reader["changesetId"].readIfPresent()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.dataviewName = try reader["dataviewName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.readWrite = try reader["readWrite"].readIfPresent() ?? false
        value.segmentConfigurations = try reader["segmentConfigurations"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxDataviewSegmentConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateKxEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKxEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKxEnvironmentOutput()
        value.creationTimestamp = try reader["creationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.environmentArn = try reader["environmentArn"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateKxScalingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKxScalingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKxScalingGroupOutput()
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.hostType = try reader["hostType"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.scalingGroupName = try reader["scalingGroupName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateKxUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKxUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKxUserOutput()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.iamRole = try reader["iamRole"].readIfPresent()
        value.userArn = try reader["userArn"].readIfPresent()
        value.userName = try reader["userName"].readIfPresent()
        return value
    }
}

extension CreateKxVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKxVolumeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKxVolumeOutput()
        value.availabilityZoneIds = try reader["availabilityZoneIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.azMode = try reader["azMode"].readIfPresent()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.nas1Configuration = try reader["nas1Configuration"].readIfPresent(with: FinspaceClientTypes.KxNAS1Configuration.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.volumeArn = try reader["volumeArn"].readIfPresent()
        value.volumeName = try reader["volumeName"].readIfPresent()
        value.volumeType = try reader["volumeType"].readIfPresent()
        return value
    }
}

extension DeleteEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEnvironmentOutput {
        return DeleteEnvironmentOutput()
    }
}

extension DeleteKxClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKxClusterOutput {
        return DeleteKxClusterOutput()
    }
}

extension DeleteKxClusterNodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKxClusterNodeOutput {
        return DeleteKxClusterNodeOutput()
    }
}

extension DeleteKxDatabaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKxDatabaseOutput {
        return DeleteKxDatabaseOutput()
    }
}

extension DeleteKxDataviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKxDataviewOutput {
        return DeleteKxDataviewOutput()
    }
}

extension DeleteKxEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKxEnvironmentOutput {
        return DeleteKxEnvironmentOutput()
    }
}

extension DeleteKxScalingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKxScalingGroupOutput {
        return DeleteKxScalingGroupOutput()
    }
}

extension DeleteKxUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKxUserOutput {
        return DeleteKxUserOutput()
    }
}

extension DeleteKxVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKxVolumeOutput {
        return DeleteKxVolumeOutput()
    }
}

extension GetEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentOutput()
        value.environment = try reader["environment"].readIfPresent(with: FinspaceClientTypes.Environment.read(from:))
        return value
    }
}

extension GetKxChangesetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKxChangesetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKxChangesetOutput()
        value.activeFromTimestamp = try reader["activeFromTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.changeRequests = try reader["changeRequests"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.ChangeRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.changesetId = try reader["changesetId"].readIfPresent()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.errorInfo = try reader["errorInfo"].readIfPresent(with: FinspaceClientTypes.ErrorInfo.read(from:))
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetKxClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKxClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKxClusterOutput()
        value.autoScalingConfiguration = try reader["autoScalingConfiguration"].readIfPresent(with: FinspaceClientTypes.AutoScalingConfiguration.read(from:))
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.azMode = try reader["azMode"].readIfPresent()
        value.cacheStorageConfigurations = try reader["cacheStorageConfigurations"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxCacheStorageConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.capacityConfiguration = try reader["capacityConfiguration"].readIfPresent(with: FinspaceClientTypes.CapacityConfiguration.read(from:))
        value.clusterDescription = try reader["clusterDescription"].readIfPresent()
        value.clusterName = try reader["clusterName"].readIfPresent()
        value.clusterType = try reader["clusterType"].readIfPresent()
        value.code = try reader["code"].readIfPresent(with: FinspaceClientTypes.CodeConfiguration.read(from:))
        value.commandLineArguments = try reader["commandLineArguments"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxCommandLineArgument.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.databases = try reader["databases"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxDatabaseConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.executionRole = try reader["executionRole"].readIfPresent()
        value.initializationScript = try reader["initializationScript"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.releaseLabel = try reader["releaseLabel"].readIfPresent()
        value.savedownStorageConfiguration = try reader["savedownStorageConfiguration"].readIfPresent(with: FinspaceClientTypes.KxSavedownStorageConfiguration.read(from:))
        value.scalingGroupConfiguration = try reader["scalingGroupConfiguration"].readIfPresent(with: FinspaceClientTypes.KxScalingGroupConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.tickerplantLogConfiguration = try reader["tickerplantLogConfiguration"].readIfPresent(with: FinspaceClientTypes.TickerplantLogConfiguration.read(from:))
        value.volumes = try reader["volumes"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.Volume.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcConfiguration = try reader["vpcConfiguration"].readIfPresent(with: FinspaceClientTypes.VpcConfiguration.read(from:))
        return value
    }
}

extension GetKxConnectionStringOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKxConnectionStringOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKxConnectionStringOutput()
        value.signedConnectionString = try reader["signedConnectionString"].readIfPresent()
        return value
    }
}

extension GetKxDatabaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKxDatabaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKxDatabaseOutput()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.databaseArn = try reader["databaseArn"].readIfPresent()
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.lastCompletedChangesetId = try reader["lastCompletedChangesetId"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.numBytes = try reader["numBytes"].readIfPresent() ?? 0
        value.numChangesets = try reader["numChangesets"].readIfPresent() ?? 0
        value.numFiles = try reader["numFiles"].readIfPresent() ?? 0
        return value
    }
}

extension GetKxDataviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKxDataviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKxDataviewOutput()
        value.activeVersions = try reader["activeVersions"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxDataviewActiveVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.autoUpdate = try reader["autoUpdate"].readIfPresent() ?? false
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.azMode = try reader["azMode"].readIfPresent()
        value.changesetId = try reader["changesetId"].readIfPresent()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.dataviewName = try reader["dataviewName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.readWrite = try reader["readWrite"].readIfPresent() ?? false
        value.segmentConfigurations = try reader["segmentConfigurations"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxDataviewSegmentConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension GetKxEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKxEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKxEnvironmentOutput()
        value.availabilityZoneIds = try reader["availabilityZoneIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.certificateAuthorityArn = try reader["certificateAuthorityArn"].readIfPresent()
        value.creationTimestamp = try reader["creationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.customDNSConfiguration = try reader["customDNSConfiguration"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.CustomDNSServer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dedicatedServiceAccountId = try reader["dedicatedServiceAccountId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.dnsStatus = try reader["dnsStatus"].readIfPresent()
        value.environmentArn = try reader["environmentArn"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.tgwStatus = try reader["tgwStatus"].readIfPresent()
        value.transitGatewayConfiguration = try reader["transitGatewayConfiguration"].readIfPresent(with: FinspaceClientTypes.TransitGatewayConfiguration.read(from:))
        value.updateTimestamp = try reader["updateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetKxScalingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKxScalingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKxScalingGroupOutput()
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.clusters = try reader["clusters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.hostType = try reader["hostType"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.scalingGroupArn = try reader["scalingGroupArn"].readIfPresent()
        value.scalingGroupName = try reader["scalingGroupName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension GetKxUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKxUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKxUserOutput()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.iamRole = try reader["iamRole"].readIfPresent()
        value.userArn = try reader["userArn"].readIfPresent()
        value.userName = try reader["userName"].readIfPresent()
        return value
    }
}

extension GetKxVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKxVolumeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKxVolumeOutput()
        value.attachedClusters = try reader["attachedClusters"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxAttachedCluster.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.availabilityZoneIds = try reader["availabilityZoneIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.azMode = try reader["azMode"].readIfPresent()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nas1Configuration = try reader["nas1Configuration"].readIfPresent(with: FinspaceClientTypes.KxNAS1Configuration.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.volumeArn = try reader["volumeArn"].readIfPresent()
        value.volumeName = try reader["volumeName"].readIfPresent()
        value.volumeType = try reader["volumeType"].readIfPresent()
        return value
    }
}

extension ListEnvironmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnvironmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentsOutput()
        value.environments = try reader["environments"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.Environment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListKxChangesetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKxChangesetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKxChangesetsOutput()
        value.kxChangesets = try reader["kxChangesets"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxChangesetListEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListKxClusterNodesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKxClusterNodesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKxClusterNodesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.nodes = try reader["nodes"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxNode.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListKxClustersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKxClustersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKxClustersOutput()
        value.kxClusterSummaries = try reader["kxClusterSummaries"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxCluster.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListKxDatabasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKxDatabasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKxDatabasesOutput()
        value.kxDatabases = try reader["kxDatabases"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxDatabaseListEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListKxDataviewsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKxDataviewsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKxDataviewsOutput()
        value.kxDataviews = try reader["kxDataviews"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxDataviewListEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListKxEnvironmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKxEnvironmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKxEnvironmentsOutput()
        value.environments = try reader["environments"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxEnvironment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListKxScalingGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKxScalingGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKxScalingGroupsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.scalingGroups = try reader["scalingGroups"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxScalingGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListKxUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKxUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKxUsersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.users = try reader["users"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxUser.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListKxVolumesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKxVolumesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKxVolumesOutput()
        value.kxVolumeSummaries = try reader["kxVolumeSummaries"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxVolume.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEnvironmentOutput()
        value.environment = try reader["environment"].readIfPresent(with: FinspaceClientTypes.Environment.read(from:))
        return value
    }
}

extension UpdateKxClusterCodeConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKxClusterCodeConfigurationOutput {
        return UpdateKxClusterCodeConfigurationOutput()
    }
}

extension UpdateKxClusterDatabasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKxClusterDatabasesOutput {
        return UpdateKxClusterDatabasesOutput()
    }
}

extension UpdateKxDatabaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKxDatabaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKxDatabaseOutput()
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension UpdateKxDataviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKxDataviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKxDataviewOutput()
        value.activeVersions = try reader["activeVersions"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxDataviewActiveVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.autoUpdate = try reader["autoUpdate"].readIfPresent() ?? false
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.azMode = try reader["azMode"].readIfPresent()
        value.changesetId = try reader["changesetId"].readIfPresent()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.dataviewName = try reader["dataviewName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.readWrite = try reader["readWrite"].readIfPresent() ?? false
        value.segmentConfigurations = try reader["segmentConfigurations"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxDataviewSegmentConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension UpdateKxEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKxEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKxEnvironmentOutput()
        value.availabilityZoneIds = try reader["availabilityZoneIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.creationTimestamp = try reader["creationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.customDNSConfiguration = try reader["customDNSConfiguration"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.CustomDNSServer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dedicatedServiceAccountId = try reader["dedicatedServiceAccountId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.dnsStatus = try reader["dnsStatus"].readIfPresent()
        value.environmentArn = try reader["environmentArn"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.tgwStatus = try reader["tgwStatus"].readIfPresent()
        value.transitGatewayConfiguration = try reader["transitGatewayConfiguration"].readIfPresent(with: FinspaceClientTypes.TransitGatewayConfiguration.read(from:))
        value.updateTimestamp = try reader["updateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension UpdateKxEnvironmentNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKxEnvironmentNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKxEnvironmentNetworkOutput()
        value.availabilityZoneIds = try reader["availabilityZoneIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.creationTimestamp = try reader["creationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.customDNSConfiguration = try reader["customDNSConfiguration"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.CustomDNSServer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dedicatedServiceAccountId = try reader["dedicatedServiceAccountId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.dnsStatus = try reader["dnsStatus"].readIfPresent()
        value.environmentArn = try reader["environmentArn"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.tgwStatus = try reader["tgwStatus"].readIfPresent()
        value.transitGatewayConfiguration = try reader["transitGatewayConfiguration"].readIfPresent(with: FinspaceClientTypes.TransitGatewayConfiguration.read(from:))
        value.updateTimestamp = try reader["updateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension UpdateKxUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKxUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKxUserOutput()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.iamRole = try reader["iamRole"].readIfPresent()
        value.userArn = try reader["userArn"].readIfPresent()
        value.userName = try reader["userName"].readIfPresent()
        return value
    }
}

extension UpdateKxVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKxVolumeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKxVolumeOutput()
        value.attachedClusters = try reader["attachedClusters"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxAttachedCluster.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.availabilityZoneIds = try reader["availabilityZoneIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.azMode = try reader["azMode"].readIfPresent()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nas1Configuration = try reader["nas1Configuration"].readIfPresent(with: FinspaceClientTypes.KxNAS1Configuration.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.volumeArn = try reader["volumeArn"].readIfPresent()
        value.volumeName = try reader["volumeName"].readIfPresent()
        value.volumeType = try reader["volumeType"].readIfPresent()
        return value
    }
}

enum CreateEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateKxChangesetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateKxClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateKxDatabaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateKxDataviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateKxEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateKxScalingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateKxUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateKxVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKxClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKxClusterNodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKxDatabaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKxDataviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKxEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKxScalingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKxUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKxVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKxChangesetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKxClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKxConnectionStringOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKxDatabaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKxDataviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKxEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKxScalingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKxUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKxVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnvironmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKxChangesetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKxClusterNodesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKxClustersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKxDatabasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKxDataviewsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKxEnvironmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKxScalingGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKxUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKxVolumesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKxClusterCodeConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKxClusterDatabasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKxDatabaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKxDataviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKxEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKxEnvironmentNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKxUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKxVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FinspaceClientTypes.ChangeRequest {

    static func write(value: FinspaceClientTypes.ChangeRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["changeType"].write(value.changeType)
        try writer["dbPath"].write(value.dbPath)
        try writer["s3Path"].write(value.s3Path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.ChangeRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.ChangeRequest()
        value.changeType = try reader["changeType"].readIfPresent() ?? .sdkUnknown("")
        value.s3Path = try reader["s3Path"].readIfPresent()
        value.dbPath = try reader["dbPath"].readIfPresent() ?? ""
        return value
    }
}

extension FinspaceClientTypes.ErrorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.ErrorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.ErrorInfo()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorType = try reader["errorType"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.TickerplantLogConfiguration {

    static func write(value: FinspaceClientTypes.TickerplantLogConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tickerplantLogVolumes"].writeList(value.tickerplantLogVolumes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.TickerplantLogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.TickerplantLogConfiguration()
        value.tickerplantLogVolumes = try reader["tickerplantLogVolumes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FinspaceClientTypes.Volume {

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.Volume {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.Volume()
        value.volumeName = try reader["volumeName"].readIfPresent()
        value.volumeType = try reader["volumeType"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.KxDatabaseConfiguration {

    static func write(value: FinspaceClientTypes.KxDatabaseConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cacheConfigurations"].writeList(value.cacheConfigurations, memberWritingClosure: FinspaceClientTypes.KxDatabaseCacheConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["changesetId"].write(value.changesetId)
        try writer["databaseName"].write(value.databaseName)
        try writer["dataviewConfiguration"].write(value.dataviewConfiguration, with: FinspaceClientTypes.KxDataviewConfiguration.write(value:to:))
        try writer["dataviewName"].write(value.dataviewName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxDatabaseConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxDatabaseConfiguration()
        value.databaseName = try reader["databaseName"].readIfPresent() ?? ""
        value.cacheConfigurations = try reader["cacheConfigurations"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxDatabaseCacheConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.changesetId = try reader["changesetId"].readIfPresent()
        value.dataviewName = try reader["dataviewName"].readIfPresent()
        value.dataviewConfiguration = try reader["dataviewConfiguration"].readIfPresent(with: FinspaceClientTypes.KxDataviewConfiguration.read(from:))
        return value
    }
}

extension FinspaceClientTypes.KxDataviewConfiguration {

    static func write(value: FinspaceClientTypes.KxDataviewConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["changesetId"].write(value.changesetId)
        try writer["dataviewName"].write(value.dataviewName)
        try writer["dataviewVersionId"].write(value.dataviewVersionId)
        try writer["segmentConfigurations"].writeList(value.segmentConfigurations, memberWritingClosure: FinspaceClientTypes.KxDataviewSegmentConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxDataviewConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxDataviewConfiguration()
        value.dataviewName = try reader["dataviewName"].readIfPresent()
        value.dataviewVersionId = try reader["dataviewVersionId"].readIfPresent()
        value.changesetId = try reader["changesetId"].readIfPresent()
        value.segmentConfigurations = try reader["segmentConfigurations"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxDataviewSegmentConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FinspaceClientTypes.KxDataviewSegmentConfiguration {

    static func write(value: FinspaceClientTypes.KxDataviewSegmentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dbPaths"].writeList(value.dbPaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["onDemand"].write(value.onDemand)
        try writer["volumeName"].write(value.volumeName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxDataviewSegmentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxDataviewSegmentConfiguration()
        value.dbPaths = try reader["dbPaths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.volumeName = try reader["volumeName"].readIfPresent() ?? ""
        value.onDemand = try reader["onDemand"].readIfPresent() ?? false
        return value
    }
}

extension FinspaceClientTypes.KxDatabaseCacheConfiguration {

    static func write(value: FinspaceClientTypes.KxDatabaseCacheConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cacheType"].write(value.cacheType)
        try writer["dataviewName"].write(value.dataviewName)
        try writer["dbPaths"].writeList(value.dbPaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxDatabaseCacheConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxDatabaseCacheConfiguration()
        value.cacheType = try reader["cacheType"].readIfPresent() ?? ""
        value.dbPaths = try reader["dbPaths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.dataviewName = try reader["dataviewName"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.KxCacheStorageConfiguration {

    static func write(value: FinspaceClientTypes.KxCacheStorageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["size"].write(value.size)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxCacheStorageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxCacheStorageConfiguration()
        value.type = try reader["type"].readIfPresent() ?? ""
        value.size = try reader["size"].readIfPresent() ?? 0
        return value
    }
}

extension FinspaceClientTypes.AutoScalingConfiguration {

    static func write(value: FinspaceClientTypes.AutoScalingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoScalingMetric"].write(value.autoScalingMetric)
        try writer["maxNodeCount"].write(value.maxNodeCount)
        try writer["metricTarget"].write(value.metricTarget)
        try writer["minNodeCount"].write(value.minNodeCount)
        try writer["scaleInCooldownSeconds"].write(value.scaleInCooldownSeconds)
        try writer["scaleOutCooldownSeconds"].write(value.scaleOutCooldownSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.AutoScalingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.AutoScalingConfiguration()
        value.minNodeCount = try reader["minNodeCount"].readIfPresent()
        value.maxNodeCount = try reader["maxNodeCount"].readIfPresent()
        value.autoScalingMetric = try reader["autoScalingMetric"].readIfPresent()
        value.metricTarget = try reader["metricTarget"].readIfPresent()
        value.scaleInCooldownSeconds = try reader["scaleInCooldownSeconds"].readIfPresent()
        value.scaleOutCooldownSeconds = try reader["scaleOutCooldownSeconds"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.CapacityConfiguration {

    static func write(value: FinspaceClientTypes.CapacityConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nodeCount"].write(value.nodeCount)
        try writer["nodeType"].write(value.nodeType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.CapacityConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.CapacityConfiguration()
        value.nodeType = try reader["nodeType"].readIfPresent()
        value.nodeCount = try reader["nodeCount"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.VpcConfiguration {

    static func write(value: FinspaceClientTypes.VpcConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ipAddressType"].write(value.ipAddressType)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.VpcConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.VpcConfiguration()
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.KxCommandLineArgument {

    static func write(value: FinspaceClientTypes.KxCommandLineArgument?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxCommandLineArgument {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxCommandLineArgument()
        value.key = try reader["key"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.CodeConfiguration {

    static func write(value: FinspaceClientTypes.CodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Bucket"].write(value.s3Bucket)
        try writer["s3Key"].write(value.s3Key)
        try writer["s3ObjectVersion"].write(value.s3ObjectVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.CodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.CodeConfiguration()
        value.s3Bucket = try reader["s3Bucket"].readIfPresent()
        value.s3Key = try reader["s3Key"].readIfPresent()
        value.s3ObjectVersion = try reader["s3ObjectVersion"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.KxSavedownStorageConfiguration {

    static func write(value: FinspaceClientTypes.KxSavedownStorageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["size"].write(value.size)
        try writer["type"].write(value.type)
        try writer["volumeName"].write(value.volumeName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxSavedownStorageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxSavedownStorageConfiguration()
        value.type = try reader["type"].readIfPresent()
        value.size = try reader["size"].readIfPresent()
        value.volumeName = try reader["volumeName"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.KxScalingGroupConfiguration {

    static func write(value: FinspaceClientTypes.KxScalingGroupConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cpu"].write(value.cpu)
        try writer["memoryLimit"].write(value.memoryLimit)
        try writer["memoryReservation"].write(value.memoryReservation)
        try writer["nodeCount"].write(value.nodeCount)
        try writer["scalingGroupName"].write(value.scalingGroupName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxScalingGroupConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxScalingGroupConfiguration()
        value.scalingGroupName = try reader["scalingGroupName"].readIfPresent() ?? ""
        value.memoryLimit = try reader["memoryLimit"].readIfPresent()
        value.memoryReservation = try reader["memoryReservation"].readIfPresent() ?? 0
        value.nodeCount = try reader["nodeCount"].readIfPresent() ?? 0
        value.cpu = try reader["cpu"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.KxNAS1Configuration {

    static func write(value: FinspaceClientTypes.KxNAS1Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["size"].write(value.size)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxNAS1Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxNAS1Configuration()
        value.type = try reader["type"].readIfPresent()
        value.size = try reader["size"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.Environment {

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.Environment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.Environment()
        value.name = try reader["name"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.environmentUrl = try reader["environmentUrl"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.environmentArn = try reader["environmentArn"].readIfPresent()
        value.sageMakerStudioDomainUrl = try reader["sageMakerStudioDomainUrl"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.dedicatedServiceAccountId = try reader["dedicatedServiceAccountId"].readIfPresent()
        value.federationMode = try reader["federationMode"].readIfPresent()
        value.federationParameters = try reader["federationParameters"].readIfPresent(with: FinspaceClientTypes.FederationParameters.read(from:))
        return value
    }
}

extension FinspaceClientTypes.FederationParameters {

    static func write(value: FinspaceClientTypes.FederationParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationCallBackURL"].write(value.applicationCallBackURL)
        try writer["attributeMap"].writeMap(value.attributeMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["federationProviderName"].write(value.federationProviderName)
        try writer["federationURN"].write(value.federationURN)
        try writer["samlMetadataDocument"].write(value.samlMetadataDocument)
        try writer["samlMetadataURL"].write(value.samlMetadataURL)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.FederationParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.FederationParameters()
        value.samlMetadataDocument = try reader["samlMetadataDocument"].readIfPresent()
        value.samlMetadataURL = try reader["samlMetadataURL"].readIfPresent()
        value.applicationCallBackURL = try reader["applicationCallBackURL"].readIfPresent()
        value.federationURN = try reader["federationURN"].readIfPresent()
        value.federationProviderName = try reader["federationProviderName"].readIfPresent()
        value.attributeMap = try reader["attributeMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FinspaceClientTypes.KxDataviewActiveVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxDataviewActiveVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxDataviewActiveVersion()
        value.changesetId = try reader["changesetId"].readIfPresent()
        value.segmentConfigurations = try reader["segmentConfigurations"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxDataviewSegmentConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.attachedClusters = try reader["attachedClusters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.versionId = try reader["versionId"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.TransitGatewayConfiguration {

    static func write(value: FinspaceClientTypes.TransitGatewayConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attachmentNetworkAclConfiguration"].writeList(value.attachmentNetworkAclConfiguration, memberWritingClosure: FinspaceClientTypes.NetworkACLEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["routableCIDRSpace"].write(value.routableCIDRSpace)
        try writer["transitGatewayID"].write(value.transitGatewayID)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.TransitGatewayConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.TransitGatewayConfiguration()
        value.transitGatewayID = try reader["transitGatewayID"].readIfPresent() ?? ""
        value.routableCIDRSpace = try reader["routableCIDRSpace"].readIfPresent() ?? ""
        value.attachmentNetworkAclConfiguration = try reader["attachmentNetworkAclConfiguration"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.NetworkACLEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FinspaceClientTypes.NetworkACLEntry {

    static func write(value: FinspaceClientTypes.NetworkACLEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cidrBlock"].write(value.cidrBlock)
        try writer["icmpTypeCode"].write(value.icmpTypeCode, with: FinspaceClientTypes.IcmpTypeCode.write(value:to:))
        try writer["portRange"].write(value.portRange, with: FinspaceClientTypes.PortRange.write(value:to:))
        try writer["protocol"].write(value.`protocol`)
        try writer["ruleAction"].write(value.ruleAction)
        try writer["ruleNumber"].write(value.ruleNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.NetworkACLEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.NetworkACLEntry()
        value.ruleNumber = try reader["ruleNumber"].readIfPresent() ?? 0
        value.`protocol` = try reader["protocol"].readIfPresent() ?? ""
        value.ruleAction = try reader["ruleAction"].readIfPresent() ?? .sdkUnknown("")
        value.portRange = try reader["portRange"].readIfPresent(with: FinspaceClientTypes.PortRange.read(from:))
        value.icmpTypeCode = try reader["icmpTypeCode"].readIfPresent(with: FinspaceClientTypes.IcmpTypeCode.read(from:))
        value.cidrBlock = try reader["cidrBlock"].readIfPresent() ?? ""
        return value
    }
}

extension FinspaceClientTypes.IcmpTypeCode {

    static func write(value: FinspaceClientTypes.IcmpTypeCode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["code"].write(value.code)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.IcmpTypeCode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.IcmpTypeCode()
        value.type = try reader["type"].readIfPresent() ?? 0
        value.code = try reader["code"].readIfPresent() ?? 0
        return value
    }
}

extension FinspaceClientTypes.PortRange {

    static func write(value: FinspaceClientTypes.PortRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["from"].write(value.from)
        try writer["to"].write(value.to)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.PortRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.PortRange()
        value.from = try reader["from"].readIfPresent() ?? 0
        value.to = try reader["to"].readIfPresent() ?? 0
        return value
    }
}

extension FinspaceClientTypes.CustomDNSServer {

    static func write(value: FinspaceClientTypes.CustomDNSServer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customDNSServerIP"].write(value.customDNSServerIP)
        try writer["customDNSServerName"].write(value.customDNSServerName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.CustomDNSServer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.CustomDNSServer()
        value.customDNSServerName = try reader["customDNSServerName"].readIfPresent() ?? ""
        value.customDNSServerIP = try reader["customDNSServerIP"].readIfPresent() ?? ""
        return value
    }
}

extension FinspaceClientTypes.KxAttachedCluster {

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxAttachedCluster {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxAttachedCluster()
        value.clusterName = try reader["clusterName"].readIfPresent()
        value.clusterType = try reader["clusterType"].readIfPresent()
        value.clusterStatus = try reader["clusterStatus"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.KxChangesetListEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxChangesetListEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxChangesetListEntry()
        value.changesetId = try reader["changesetId"].readIfPresent()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.activeFromTimestamp = try reader["activeFromTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.KxNode {

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxNode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxNode()
        value.nodeId = try reader["nodeId"].readIfPresent()
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.launchTime = try reader["launchTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.KxCluster {

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxCluster {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxCluster()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.clusterName = try reader["clusterName"].readIfPresent()
        value.clusterType = try reader["clusterType"].readIfPresent()
        value.clusterDescription = try reader["clusterDescription"].readIfPresent()
        value.releaseLabel = try reader["releaseLabel"].readIfPresent()
        value.volumes = try reader["volumes"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.Volume.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.initializationScript = try reader["initializationScript"].readIfPresent()
        value.executionRole = try reader["executionRole"].readIfPresent()
        value.azMode = try reader["azMode"].readIfPresent()
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension FinspaceClientTypes.KxDatabaseListEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxDatabaseListEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxDatabaseListEntry()
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension FinspaceClientTypes.KxDataviewListEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxDataviewListEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxDataviewListEntry()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.dataviewName = try reader["dataviewName"].readIfPresent()
        value.azMode = try reader["azMode"].readIfPresent()
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.changesetId = try reader["changesetId"].readIfPresent()
        value.segmentConfigurations = try reader["segmentConfigurations"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxDataviewSegmentConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.activeVersions = try reader["activeVersions"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.KxDataviewActiveVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.autoUpdate = try reader["autoUpdate"].readIfPresent() ?? false
        value.readWrite = try reader["readWrite"].readIfPresent() ?? false
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.KxEnvironment {

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxEnvironment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxEnvironment()
        value.name = try reader["name"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.tgwStatus = try reader["tgwStatus"].readIfPresent()
        value.dnsStatus = try reader["dnsStatus"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.environmentArn = try reader["environmentArn"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.dedicatedServiceAccountId = try reader["dedicatedServiceAccountId"].readIfPresent()
        value.transitGatewayConfiguration = try reader["transitGatewayConfiguration"].readIfPresent(with: FinspaceClientTypes.TransitGatewayConfiguration.read(from:))
        value.customDNSConfiguration = try reader["customDNSConfiguration"].readListIfPresent(memberReadingClosure: FinspaceClientTypes.CustomDNSServer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationTimestamp = try reader["creationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updateTimestamp = try reader["updateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.availabilityZoneIds = try reader["availabilityZoneIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.certificateAuthorityArn = try reader["certificateAuthorityArn"].readIfPresent()
        return value
    }
}

extension FinspaceClientTypes.KxScalingGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxScalingGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxScalingGroup()
        value.scalingGroupName = try reader["scalingGroupName"].readIfPresent()
        value.hostType = try reader["hostType"].readIfPresent()
        value.clusters = try reader["clusters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension FinspaceClientTypes.KxUser {

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxUser {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxUser()
        value.userArn = try reader["userArn"].readIfPresent()
        value.userName = try reader["userName"].readIfPresent()
        value.iamRole = try reader["iamRole"].readIfPresent()
        value.createTimestamp = try reader["createTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updateTimestamp = try reader["updateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension FinspaceClientTypes.KxVolume {

    static func read(from reader: SmithyJSON.Reader) throws -> FinspaceClientTypes.KxVolume {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FinspaceClientTypes.KxVolume()
        value.volumeName = try reader["volumeName"].readIfPresent()
        value.volumeType = try reader["volumeType"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.azMode = try reader["azMode"].readIfPresent()
        value.availabilityZoneIds = try reader["availabilityZoneIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension FinspaceClientTypes.SuperuserParameters {

    static func write(value: FinspaceClientTypes.SuperuserParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["emailAddress"].write(value.emailAddress)
        try writer["firstName"].write(value.firstName)
        try writer["lastName"].write(value.lastName)
    }
}

extension FinspaceClientTypes.KxClusterCodeDeploymentConfiguration {

    static func write(value: FinspaceClientTypes.KxClusterCodeDeploymentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deploymentStrategy"].write(value.deploymentStrategy)
    }
}

extension FinspaceClientTypes.KxDeploymentConfiguration {

    static func write(value: FinspaceClientTypes.KxDeploymentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deploymentStrategy"].write(value.deploymentStrategy)
    }
}

public enum FinspaceClientTypes {}
