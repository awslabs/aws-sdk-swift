// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have permissions to perform the requested operation. The user or role that is making the request must have at least one IAM permissions policy attached that grants the required permissions. For more information, see Access Management in the IAM User Guide.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageV2ClientTypes {
    public enum AdMarkerHls: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daterange
        case sdkUnknown(Swift.String)

        public static var allCases: [AdMarkerHls] {
            return [
                .daterange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daterange: return "DATERANGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdMarkerHls(rawValue: rawValue) ?? AdMarkerHls.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageV2ClientTypes.ChannelGroupListConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case modifiedAt = "ModifiedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelGroupName = self.channelGroupName {
            try encodeContainer.encode(channelGroupName, forKey: .channelGroupName)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .epochSeconds, forKey: .modifiedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The configuration of the channel group.
    public struct ChannelGroupListConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) associated with the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        /// This member is required.
        public var channelGroupName: Swift.String?
        /// The date and time the channel group was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Any descriptive information that you want to add to the channel group for future identification purposes.
        public var description: Swift.String?
        /// The date and time the channel group was modified.
        /// This member is required.
        public var modifiedAt: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            channelGroupName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            modifiedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.createdAt = createdAt
            self.description = description
            self.modifiedAt = modifiedAt
        }
    }

}

extension MediaPackageV2ClientTypes.ChannelListConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case modifiedAt = "ModifiedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelGroupName = self.channelGroupName {
            try encodeContainer.encode(channelGroupName, forKey: .channelGroupName)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .epochSeconds, forKey: .modifiedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The configuration of the channel.
    public struct ChannelListConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) associated with the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        /// This member is required.
        public var channelGroupName: Swift.String?
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        /// This member is required.
        public var channelName: Swift.String?
        /// The date and time the channel was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Any descriptive information that you want to add to the channel for future identification purposes.
        public var description: Swift.String?
        /// The date and time the channel was modified.
        /// This member is required.
        public var modifiedAt: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            channelGroupName: Swift.String? = nil,
            channelName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            modifiedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.createdAt = createdAt
            self.description = description
            self.modifiedAt = modifiedAt
        }
    }

}

extension MediaPackageV2ClientTypes {
    public enum CmafEncryptionMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cbcs
        case cenc
        case sdkUnknown(Swift.String)

        public static var allCases: [CmafEncryptionMethod] {
            return [
                .cbcs,
                .cenc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cbcs: return "CBCS"
            case .cenc: return "CENC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CmafEncryptionMethod(rawValue: rawValue) ?? CmafEncryptionMethod.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.conflictExceptionType = output.conflictExceptionType
            self.properties.message = output.message
        } else {
            self.properties.conflictExceptionType = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Updating or deleting this resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The type of ConflictException.
        public internal(set) var conflictExceptionType: MediaPackageV2ClientTypes.ConflictExceptionType? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        conflictExceptionType: MediaPackageV2ClientTypes.ConflictExceptionType? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.conflictExceptionType = conflictExceptionType
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let conflictExceptionType: MediaPackageV2ClientTypes.ConflictExceptionType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictExceptionType = "ConflictExceptionType"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let conflictExceptionTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ConflictExceptionType.self, forKey: .conflictExceptionType)
        conflictExceptionType = conflictExceptionTypeDecoded
    }
}

extension MediaPackageV2ClientTypes {
    public enum ConflictExceptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conflictingOperation
        case idempotentParameterMismatch
        case resourceAlreadyExists
        case resourceInUse
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionType] {
            return [
                .conflictingOperation,
                .idempotentParameterMismatch,
                .resourceAlreadyExists,
                .resourceInUse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conflictingOperation: return "CONFLICTING_OPERATION"
            case .idempotentParameterMismatch: return "IDEMPOTENT_PARAMETER_MISMATCH"
            case .resourceAlreadyExists: return "RESOURCE_ALREADY_EXISTS"
            case .resourceInUse: return "RESOURCE_IN_USE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionType(rawValue: rawValue) ?? ConflictExceptionType.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageV2ClientTypes {
    public enum ContainerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cmaf
        case ts
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerType] {
            return [
                .cmaf,
                .ts,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cmaf: return "CMAF"
            case .ts: return "TS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerType(rawValue: rawValue) ?? ContainerType.sdkUnknown(rawValue)
        }
    }
}

extension CreateChannelGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelGroupName = "ChannelGroupName"
        case description = "Description"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelGroupName = self.channelGroupName {
            try encodeContainer.encode(channelGroupName, forKey: .channelGroupName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateChannelGroupInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "x-amzn-client-token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateChannelGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channelGroup"
    }
}

public struct CreateChannelGroupInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region. You can't use spaces in the name. You can't change the name after you create the channel group.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Enter any descriptive text that helps you to identify the channel group.
    public var description: Swift.String?
    /// A comma-separated list of tag key:value pairs that you define. For example: "Key1": "Value1",
    ///     "Key2": "Value2"
    public var tags: [Swift.String:Swift.String]?

    public init(
        channelGroupName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.clientToken = clientToken
        self.description = description
        self.tags = tags
    }
}

struct CreateChannelGroupInputBody: Swift.Equatable {
    let channelGroupName: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateChannelGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelGroupName = "ChannelGroupName"
        case description = "Description"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateChannelGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.createdAt = output.createdAt
            self.description = output.description
            self.egressDomain = output.egressDomain
            self.modifiedAt = output.modifiedAt
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.createdAt = nil
            self.description = nil
            self.egressDomain = nil
            self.modifiedAt = nil
            self.tags = nil
        }
    }
}

public struct CreateChannelGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The date and time the channel group was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your channel group.
    public var description: Swift.String?
    /// The output domain where the source stream should be sent. Integrate the egress domain with a downstream CDN (such as Amazon CloudFront) or playback device.
    /// This member is required.
    public var egressDomain: Swift.String?
    /// The date and time the channel group was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The comma-separated list of tag key:value pairs assigned to the channel group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        egressDomain: Swift.String? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.createdAt = createdAt
        self.description = description
        self.egressDomain = egressDomain
        self.modifiedAt = modifiedAt
        self.tags = tags
    }
}

struct CreateChannelGroupOutputBody: Swift.Equatable {
    let channelGroupName: Swift.String?
    let arn: Swift.String?
    let egressDomain: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateChannelGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case egressDomain = "EgressDomain"
        case modifiedAt = "ModifiedAt"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let egressDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .egressDomain)
        egressDomain = egressDomainDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateChannelGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName = "ChannelName"
        case description = "Description"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateChannelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "x-amzn-client-token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel"
    }
}

public struct CreateChannelInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group. You can't change the name after you create the channel.
    /// This member is required.
    public var channelName: Swift.String?
    /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Enter any descriptive text that helps you to identify the channel.
    public var description: Swift.String?
    /// A comma-separated list of tag key:value pairs that you define. For example: "Key1": "Value1",
    ///     "Key2": "Value2"
    public var tags: [Swift.String:Swift.String]?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.clientToken = clientToken
        self.description = description
        self.tags = tags
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    let channelName: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName = "ChannelName"
        case description = "Description"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.createdAt = output.createdAt
            self.description = output.description
            self.ingestEndpoints = output.ingestEndpoints
            self.modifiedAt = output.modifiedAt
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.channelName = nil
            self.createdAt = nil
            self.description = nil
            self.ingestEndpoints = nil
            self.modifiedAt = nil
            self.tags = nil
        }
    }
}

public struct CreateChannelOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The date and time the channel was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your channel.
    public var description: Swift.String?
    /// The list of ingest endpoints.
    public var ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]?
    /// The date and time the channel was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The comma-separated list of tag key:value pairs assigned to the channel.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.createdAt = createdAt
        self.description = description
        self.ingestEndpoints = ingestEndpoints
        self.modifiedAt = modifiedAt
        self.tags = tags
    }
}

struct CreateChannelOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let channelName: Swift.String?
    let channelGroupName: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case ingestEndpoints = "IngestEndpoints"
        case modifiedAt = "ModifiedAt"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ingestEndpointsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.IngestEndpoint?].self, forKey: .ingestEndpoints)
        var ingestEndpointsDecoded0:[MediaPackageV2ClientTypes.IngestEndpoint]? = nil
        if let ingestEndpointsContainer = ingestEndpointsContainer {
            ingestEndpointsDecoded0 = [MediaPackageV2ClientTypes.IngestEndpoint]()
            for structure0 in ingestEndpointsContainer {
                if let structure0 = structure0 {
                    ingestEndpointsDecoded0?.append(structure0)
                }
            }
        }
        ingestEndpoints = ingestEndpointsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaPackageV2ClientTypes.CreateHlsManifestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childManifestName = "ChildManifestName"
        case manifestName = "ManifestName"
        case manifestWindowSeconds = "ManifestWindowSeconds"
        case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
        case scteHls = "ScteHls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childManifestName = self.childManifestName {
            try encodeContainer.encode(childManifestName, forKey: .childManifestName)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let manifestWindowSeconds = self.manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if let programDateTimeIntervalSeconds = self.programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if let scteHls = self.scteHls {
            try encodeContainer.encode(scteHls, forKey: .scteHls)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let childManifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childManifestName)
        childManifestName = childManifestNameDecoded
        let scteHlsDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ScteHls.self, forKey: .scteHls)
        scteHls = scteHlsDecoded
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// Create an HTTP live streaming (HLS) manifest configuration.
    public struct CreateHlsManifestConfiguration: Swift.Equatable {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index, with an added suffix to distinguish it from the manifest name. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public var childManifestName: Swift.String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The total duration (in seconds) of the manifest's content.
        public var manifestWindowSeconds: Swift.Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval, EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest. The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player. ID3Timed metadata messages generate every 5 seconds whenever the content is ingested. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// The SCTE configuration.
        public var scteHls: MediaPackageV2ClientTypes.ScteHls?

        public init(
            childManifestName: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            manifestWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            scteHls: MediaPackageV2ClientTypes.ScteHls? = nil
        )
        {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
        }
    }

}

extension MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childManifestName = "ChildManifestName"
        case manifestName = "ManifestName"
        case manifestWindowSeconds = "ManifestWindowSeconds"
        case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
        case scteHls = "ScteHls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childManifestName = self.childManifestName {
            try encodeContainer.encode(childManifestName, forKey: .childManifestName)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let manifestWindowSeconds = self.manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if let programDateTimeIntervalSeconds = self.programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if let scteHls = self.scteHls {
            try encodeContainer.encode(scteHls, forKey: .scteHls)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let childManifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childManifestName)
        childManifestName = childManifestNameDecoded
        let scteHlsDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ScteHls.self, forKey: .scteHls)
        scteHls = scteHlsDecoded
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// Create a low-latency HTTP live streaming (HLS) manifest configuration.
    public struct CreateLowLatencyHlsManifestConfiguration: Swift.Equatable {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index, with an added suffix to distinguish it from the manifest name. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public var childManifestName: Swift.String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The total duration (in seconds) of the manifest's content.
        public var manifestWindowSeconds: Swift.Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval, EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest. The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player. ID3Timed metadata messages generate every 5 seconds whenever the content is ingested. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// The SCTE configuration.
        public var scteHls: MediaPackageV2ClientTypes.ScteHls?

        public init(
            childManifestName: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            manifestWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            scteHls: MediaPackageV2ClientTypes.ScteHls? = nil
        )
        {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
        }
    }

}

extension CreateOriginEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerType = "ContainerType"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case originEndpointName = "OriginEndpointName"
        case segment = "Segment"
        case startoverWindowSeconds = "StartoverWindowSeconds"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerType = self.containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for createhlsmanifestconfiguration0 in hlsManifests {
                try hlsManifestsContainer.encode(createhlsmanifestconfiguration0)
            }
        }
        if let lowLatencyHlsManifests = lowLatencyHlsManifests {
            var lowLatencyHlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lowLatencyHlsManifests)
            for createlowlatencyhlsmanifestconfiguration0 in lowLatencyHlsManifests {
                try lowLatencyHlsManifestsContainer.encode(createlowlatencyhlsmanifestconfiguration0)
            }
        }
        if let originEndpointName = self.originEndpointName {
            try encodeContainer.encode(originEndpointName, forKey: .originEndpointName)
        }
        if let segment = self.segment {
            try encodeContainer.encode(segment, forKey: .segment)
        }
        if let startoverWindowSeconds = self.startoverWindowSeconds {
            try encodeContainer.encode(startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateOriginEndpointInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "x-amzn-client-token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateOriginEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint"
    }
}

public struct CreateOriginEndpointInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The type of container to attach to this origin endpoint. A container type is a file format that encapsulates one or more media streams, such as audio and video, into a single file. You can't change the container type after you create the endpoint.
    /// This member is required.
    public var containerType: MediaPackageV2ClientTypes.ContainerType?
    /// Enter any descriptive text that helps you to identify the origin endpoint.
    public var description: Swift.String?
    /// An HTTP live streaming (HLS) manifest configuration.
    public var hlsManifests: [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]?
    /// A low-latency HLS manifest configuration.
    public var lowLatencyHlsManifests: [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and must be unique for your account in the AWS Region and channel. You can't use spaces in the name. You can't change the name after you create the endpoint.
    /// This member is required.
    public var originEndpointName: Swift.String?
    /// The segment configuration, including the segment name, duration, and other configuration values.
    public var segment: MediaPackageV2ClientTypes.Segment?
    /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window. The maximum startover window is 1,209,600 seconds (14 days).
    public var startoverWindowSeconds: Swift.Int?
    /// A comma-separated list of tag key:value pairs that you define. For example: "Key1": "Value1",
    ///     "Key2": "Value2"
    public var tags: [Swift.String:Swift.String]?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        containerType: MediaPackageV2ClientTypes.ContainerType? = nil,
        description: Swift.String? = nil,
        hlsManifests: [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]? = nil,
        lowLatencyHlsManifests: [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]? = nil,
        originEndpointName: Swift.String? = nil,
        segment: MediaPackageV2ClientTypes.Segment? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.clientToken = clientToken
        self.containerType = containerType
        self.description = description
        self.hlsManifests = hlsManifests
        self.lowLatencyHlsManifests = lowLatencyHlsManifests
        self.originEndpointName = originEndpointName
        self.segment = segment
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
    }
}

struct CreateOriginEndpointInputBody: Swift.Equatable {
    let originEndpointName: Swift.String?
    let containerType: MediaPackageV2ClientTypes.ContainerType?
    let segment: MediaPackageV2ClientTypes.Segment?
    let description: Swift.String?
    let startoverWindowSeconds: Swift.Int?
    let hlsManifests: [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]?
    let lowLatencyHlsManifests: [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateOriginEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerType = "ContainerType"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case originEndpointName = "OriginEndpointName"
        case segment = "Segment"
        case startoverWindowSeconds = "StartoverWindowSeconds"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointName)
        originEndpointName = originEndpointNameDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let segmentDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.Segment.self, forKey: .segment)
        segment = segmentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.CreateHlsManifestConfiguration?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let lowLatencyHlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration?].self, forKey: .lowLatencyHlsManifests)
        var lowLatencyHlsManifestsDecoded0:[MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]? = nil
        if let lowLatencyHlsManifestsContainer = lowLatencyHlsManifestsContainer {
            lowLatencyHlsManifestsDecoded0 = [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]()
            for structure0 in lowLatencyHlsManifestsContainer {
                if let structure0 = structure0 {
                    lowLatencyHlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        lowLatencyHlsManifests = lowLatencyHlsManifestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateOriginEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateOriginEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.containerType = output.containerType
            self.createdAt = output.createdAt
            self.description = output.description
            self.hlsManifests = output.hlsManifests
            self.lowLatencyHlsManifests = output.lowLatencyHlsManifests
            self.modifiedAt = output.modifiedAt
            self.originEndpointName = output.originEndpointName
            self.segment = output.segment
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.channelName = nil
            self.containerType = nil
            self.createdAt = nil
            self.description = nil
            self.hlsManifests = nil
            self.lowLatencyHlsManifests = nil
            self.modifiedAt = nil
            self.originEndpointName = nil
            self.segment = nil
            self.startoverWindowSeconds = nil
            self.tags = nil
        }
    }
}

public struct CreateOriginEndpointOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The type of container attached to this origin endpoint.
    /// This member is required.
    public var containerType: MediaPackageV2ClientTypes.ContainerType?
    /// The date and time the origin endpoint was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your origin endpoint.
    public var description: Swift.String?
    /// An HTTP live streaming (HLS) manifest configuration.
    public var hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]?
    /// A low-latency HLS manifest configuration.
    public var lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]?
    /// The date and time the origin endpoint was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?
    /// The segment configuration, including the segment name, duration, and other configuration values.
    /// This member is required.
    public var segment: MediaPackageV2ClientTypes.Segment?
    /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window.
    public var startoverWindowSeconds: Swift.Int?
    /// The comma-separated list of tag key:value pairs assigned to the origin endpoint.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        containerType: MediaPackageV2ClientTypes.ContainerType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]? = nil,
        lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        originEndpointName: Swift.String? = nil,
        segment: MediaPackageV2ClientTypes.Segment? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.containerType = containerType
        self.createdAt = createdAt
        self.description = description
        self.hlsManifests = hlsManifests
        self.lowLatencyHlsManifests = lowLatencyHlsManifests
        self.modifiedAt = modifiedAt
        self.originEndpointName = originEndpointName
        self.segment = segment
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
    }
}

struct CreateOriginEndpointOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let channelGroupName: Swift.String?
    let channelName: Swift.String?
    let originEndpointName: Swift.String?
    let containerType: MediaPackageV2ClientTypes.ContainerType?
    let segment: MediaPackageV2ClientTypes.Segment?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let startoverWindowSeconds: Swift.Int?
    let hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]?
    let lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateOriginEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case containerType = "ContainerType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case modifiedAt = "ModifiedAt"
        case originEndpointName = "OriginEndpointName"
        case segment = "Segment"
        case startoverWindowSeconds = "StartoverWindowSeconds"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let originEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointName)
        originEndpointName = originEndpointNameDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let segmentDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.Segment.self, forKey: .segment)
        segment = segmentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.GetHlsManifestConfiguration?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageV2ClientTypes.GetHlsManifestConfiguration]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let lowLatencyHlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration?].self, forKey: .lowLatencyHlsManifests)
        var lowLatencyHlsManifestsDecoded0:[MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]? = nil
        if let lowLatencyHlsManifestsContainer = lowLatencyHlsManifestsContainer {
            lowLatencyHlsManifestsDecoded0 = [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]()
            for structure0 in lowLatencyHlsManifestsContainer {
                if let structure0 = structure0 {
                    lowLatencyHlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        lowLatencyHlsManifests = lowLatencyHlsManifestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateOriginEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteChannelGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())"
    }
}

public struct DeleteChannelGroupInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
    }
}

struct DeleteChannelGroupInputBody: Swift.Equatable {
}

extension DeleteChannelGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteChannelGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteChannelGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())"
    }
}

public struct DeleteChannelInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
}

extension DeleteChannelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteChannelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteChannelPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/policy"
    }
}

public struct DeleteChannelPolicyInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
    }
}

struct DeleteChannelPolicyInputBody: Swift.Equatable {
}

extension DeleteChannelPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteChannelPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteChannelPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteOriginEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        guard let originEndpointName = originEndpointName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint/\(originEndpointName.urlPercentEncoding())"
    }
}

public struct DeleteOriginEndpointInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        originEndpointName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.originEndpointName = originEndpointName
    }
}

struct DeleteOriginEndpointInputBody: Swift.Equatable {
}

extension DeleteOriginEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOriginEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteOriginEndpointOutput: Swift.Equatable {

    public init() { }
}

enum DeleteOriginEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteOriginEndpointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        guard let originEndpointName = originEndpointName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint/\(originEndpointName.urlPercentEncoding())/policy"
    }
}

public struct DeleteOriginEndpointPolicyInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        originEndpointName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.originEndpointName = originEndpointName
    }
}

struct DeleteOriginEndpointPolicyInputBody: Swift.Equatable {
}

extension DeleteOriginEndpointPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOriginEndpointPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteOriginEndpointPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteOriginEndpointPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaPackageV2ClientTypes {
    public enum DrmSystem: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clearKeyAes128
        case fairplay
        case playready
        case widevine
        case sdkUnknown(Swift.String)

        public static var allCases: [DrmSystem] {
            return [
                .clearKeyAes128,
                .fairplay,
                .playready,
                .widevine,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clearKeyAes128: return "CLEAR_KEY_AES_128"
            case .fairplay: return "FAIRPLAY"
            case .playready: return "PLAYREADY"
            case .widevine: return "WIDEVINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DrmSystem(rawValue: rawValue) ?? DrmSystem.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageV2ClientTypes.Encryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constantInitializationVector = "ConstantInitializationVector"
        case encryptionMethod = "EncryptionMethod"
        case keyRotationIntervalSeconds = "KeyRotationIntervalSeconds"
        case spekeKeyProvider = "SpekeKeyProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constantInitializationVector = self.constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let encryptionMethod = self.encryptionMethod {
            try encodeContainer.encode(encryptionMethod, forKey: .encryptionMethod)
        }
        if let keyRotationIntervalSeconds = self.keyRotationIntervalSeconds {
            try encodeContainer.encode(keyRotationIntervalSeconds, forKey: .keyRotationIntervalSeconds)
        }
        if let spekeKeyProvider = self.spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let encryptionMethodDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.EncryptionMethod.self, forKey: .encryptionMethod)
        encryptionMethod = encryptionMethodDecoded
        let keyRotationIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .keyRotationIntervalSeconds)
        keyRotationIntervalSeconds = keyRotationIntervalSecondsDecoded
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The parameters for encrypting content.
    public struct Encryption: Swift.Equatable {
        /// A 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting content. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
        public var constantInitializationVector: Swift.String?
        /// The encryption method to use.
        /// This member is required.
        public var encryptionMethod: MediaPackageV2ClientTypes.EncryptionMethod?
        /// The frequency (in seconds) of key changes for live workflows, in which content is streamed real time. The service retrieves content keys before the live content begins streaming, and then retrieves them as needed over the lifetime of the workflow. By default, key rotation is set to 300 seconds (5 minutes), the minimum rotation interval, which is equivalent to setting it to 300. If you don't enter an interval, content keys aren't rotated. The following example setting causes the service to rotate keys every thirty minutes: 1800
        public var keyRotationIntervalSeconds: Swift.Int?
        /// The parameters for the SPEKE key provider.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageV2ClientTypes.SpekeKeyProvider?

        public init(
            constantInitializationVector: Swift.String? = nil,
            encryptionMethod: MediaPackageV2ClientTypes.EncryptionMethod? = nil,
            keyRotationIntervalSeconds: Swift.Int? = nil,
            spekeKeyProvider: MediaPackageV2ClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageV2ClientTypes.EncryptionContractConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case presetSpeke20Audio = "PresetSpeke20Audio"
        case presetSpeke20Video = "PresetSpeke20Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let presetSpeke20Audio = self.presetSpeke20Audio {
            try encodeContainer.encode(presetSpeke20Audio.rawValue, forKey: .presetSpeke20Audio)
        }
        if let presetSpeke20Video = self.presetSpeke20Video {
            try encodeContainer.encode(presetSpeke20Video.rawValue, forKey: .presetSpeke20Video)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presetSpeke20AudioDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.PresetSpeke20Audio.self, forKey: .presetSpeke20Audio)
        presetSpeke20Audio = presetSpeke20AudioDecoded
        let presetSpeke20VideoDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.PresetSpeke20Video.self, forKey: .presetSpeke20Video)
        presetSpeke20Video = presetSpeke20VideoDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// Configure one or more content encryption keys for your endpoints that use SPEKE Version 2.0. The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream. To configure the encryption contract, specify which audio and video encryption presets to use.
    public struct EncryptionContractConfiguration: Swift.Equatable {
        /// A collection of audio encryption presets. Value description:
        ///
        /// * PRESET-AUDIO-1 - Use one content key to encrypt all of the audio tracks in your stream.
        ///
        /// * PRESET-AUDIO-2 - Use one content key to encrypt all of the stereo audio tracks and one content key to encrypt all of the multichannel audio tracks.
        ///
        /// * PRESET-AUDIO-3 - Use one content key to encrypt all of the stereo audio tracks, one content key to encrypt all of the multichannel audio tracks with 3 to 6 channels, and one content key to encrypt all of the multichannel audio tracks with more than 6 channels.
        ///
        /// * SHARED - Use the same content key for all of the audio and video tracks in your stream.
        ///
        /// * UNENCRYPTED - Don't encrypt any of the audio tracks in your stream.
        /// This member is required.
        public var presetSpeke20Audio: MediaPackageV2ClientTypes.PresetSpeke20Audio?
        /// A collection of video encryption presets. Value description:
        ///
        /// * PRESET-VIDEO-1 - Use one content key to encrypt all of the video tracks in your stream.
        ///
        /// * PRESET-VIDEO-2 - Use one content key to encrypt all of the SD video tracks and one content key for all HD and higher resolutions video tracks.
        ///
        /// * PRESET-VIDEO-3 - Use one content key to encrypt all of the SD video tracks, one content key for HD video tracks and one content key for all UHD video tracks.
        ///
        /// * PRESET-VIDEO-4 - Use one content key to encrypt all of the SD video tracks, one content key for HD video tracks, one content key for all UHD1 video tracks and one content key for all UHD2 video tracks.
        ///
        /// * PRESET-VIDEO-5 - Use one content key to encrypt all of the SD video tracks, one content key for HD1 video tracks, one content key for HD2 video tracks, one content key for all UHD1 video tracks and one content key for all UHD2 video tracks.
        ///
        /// * PRESET-VIDEO-6 - Use one content key to encrypt all of the SD video tracks, one content key for HD1 video tracks, one content key for HD2 video tracks and one content key for all UHD video tracks.
        ///
        /// * PRESET-VIDEO-7 - Use one content key to encrypt all of the SD+HD1 video tracks, one content key for HD2 video tracks and one content key for all UHD video tracks.
        ///
        /// * PRESET-VIDEO-8 - Use one content key to encrypt all of the SD+HD1 video tracks, one content key for HD2 video tracks, one content key for all UHD1 video tracks and one content key for all UHD2 video tracks.
        ///
        /// * SHARED - Use the same content key for all of the video and audio tracks in your stream.
        ///
        /// * UNENCRYPTED - Don't encrypt any of the video tracks in your stream.
        /// This member is required.
        public var presetSpeke20Video: MediaPackageV2ClientTypes.PresetSpeke20Video?

        public init(
            presetSpeke20Audio: MediaPackageV2ClientTypes.PresetSpeke20Audio? = nil,
            presetSpeke20Video: MediaPackageV2ClientTypes.PresetSpeke20Video? = nil
        )
        {
            self.presetSpeke20Audio = presetSpeke20Audio
            self.presetSpeke20Video = presetSpeke20Video
        }
    }

}

extension MediaPackageV2ClientTypes.EncryptionMethod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cmafEncryptionMethod = "CmafEncryptionMethod"
        case tsEncryptionMethod = "TsEncryptionMethod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cmafEncryptionMethod = self.cmafEncryptionMethod {
            try encodeContainer.encode(cmafEncryptionMethod.rawValue, forKey: .cmafEncryptionMethod)
        }
        if let tsEncryptionMethod = self.tsEncryptionMethod {
            try encodeContainer.encode(tsEncryptionMethod.rawValue, forKey: .tsEncryptionMethod)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tsEncryptionMethodDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.TsEncryptionMethod.self, forKey: .tsEncryptionMethod)
        tsEncryptionMethod = tsEncryptionMethodDecoded
        let cmafEncryptionMethodDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.CmafEncryptionMethod.self, forKey: .cmafEncryptionMethod)
        cmafEncryptionMethod = cmafEncryptionMethodDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The encryption type.
    public struct EncryptionMethod: Swift.Equatable {
        /// The encryption method to use.
        public var cmafEncryptionMethod: MediaPackageV2ClientTypes.CmafEncryptionMethod?
        /// The encryption method to use.
        public var tsEncryptionMethod: MediaPackageV2ClientTypes.TsEncryptionMethod?

        public init(
            cmafEncryptionMethod: MediaPackageV2ClientTypes.CmafEncryptionMethod? = nil,
            tsEncryptionMethod: MediaPackageV2ClientTypes.TsEncryptionMethod? = nil
        )
        {
            self.cmafEncryptionMethod = cmafEncryptionMethod
            self.tsEncryptionMethod = tsEncryptionMethod
        }
    }

}

extension GetChannelGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())"
    }
}

public struct GetChannelGroupInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
    }
}

struct GetChannelGroupInputBody: Swift.Equatable {
}

extension GetChannelGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetChannelGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.createdAt = output.createdAt
            self.description = output.description
            self.egressDomain = output.egressDomain
            self.modifiedAt = output.modifiedAt
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.createdAt = nil
            self.description = nil
            self.egressDomain = nil
            self.modifiedAt = nil
            self.tags = nil
        }
    }
}

public struct GetChannelGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The date and time the channel group was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your channel group.
    public var description: Swift.String?
    /// The output domain where the source stream should be sent. Integrate the domain with a downstream CDN (such as Amazon CloudFront) or playback device.
    /// This member is required.
    public var egressDomain: Swift.String?
    /// The date and time the channel group was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The comma-separated list of tag key:value pairs assigned to the channel group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        egressDomain: Swift.String? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.createdAt = createdAt
        self.description = description
        self.egressDomain = egressDomain
        self.modifiedAt = modifiedAt
        self.tags = tags
    }
}

struct GetChannelGroupOutputBody: Swift.Equatable {
    let channelGroupName: Swift.String?
    let arn: Swift.String?
    let egressDomain: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetChannelGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case egressDomain = "EgressDomain"
        case modifiedAt = "ModifiedAt"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let egressDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .egressDomain)
        egressDomain = egressDomainDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetChannelGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())"
    }
}

public struct GetChannelInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
    }
}

struct GetChannelInputBody: Swift.Equatable {
}

extension GetChannelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.createdAt = output.createdAt
            self.description = output.description
            self.ingestEndpoints = output.ingestEndpoints
            self.modifiedAt = output.modifiedAt
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.channelName = nil
            self.createdAt = nil
            self.description = nil
            self.ingestEndpoints = nil
            self.modifiedAt = nil
            self.tags = nil
        }
    }
}

public struct GetChannelOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The date and time the channel was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your channel.
    public var description: Swift.String?
    /// The list of ingest endpoints.
    public var ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]?
    /// The date and time the channel was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The comma-separated list of tag key:value pairs assigned to the channel.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.createdAt = createdAt
        self.description = description
        self.ingestEndpoints = ingestEndpoints
        self.modifiedAt = modifiedAt
        self.tags = tags
    }
}

struct GetChannelOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let channelName: Swift.String?
    let channelGroupName: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]?
    let tags: [Swift.String:Swift.String]?
}

extension GetChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case ingestEndpoints = "IngestEndpoints"
        case modifiedAt = "ModifiedAt"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ingestEndpointsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.IngestEndpoint?].self, forKey: .ingestEndpoints)
        var ingestEndpointsDecoded0:[MediaPackageV2ClientTypes.IngestEndpoint]? = nil
        if let ingestEndpointsContainer = ingestEndpointsContainer {
            ingestEndpointsDecoded0 = [MediaPackageV2ClientTypes.IngestEndpoint]()
            for structure0 in ingestEndpointsContainer {
                if let structure0 = structure0 {
                    ingestEndpointsDecoded0?.append(structure0)
                }
            }
        }
        ingestEndpoints = ingestEndpointsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetChannelPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/policy"
    }
}

public struct GetChannelPolicyInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
    }
}

struct GetChannelPolicyInputBody: Swift.Equatable {
}

extension GetChannelPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetChannelPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.policy = output.policy
        } else {
            self.channelGroupName = nil
            self.channelName = nil
            self.policy = nil
        }
    }
}

public struct GetChannelPolicyOutput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The policy assigned to the channel.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.policy = policy
    }
}

struct GetChannelPolicyOutputBody: Swift.Equatable {
    let channelGroupName: Swift.String?
    let channelName: Swift.String?
    let policy: Swift.String?
}

extension GetChannelPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetChannelPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaPackageV2ClientTypes.GetHlsManifestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childManifestName = "ChildManifestName"
        case manifestName = "ManifestName"
        case manifestWindowSeconds = "ManifestWindowSeconds"
        case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
        case scteHls = "ScteHls"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childManifestName = self.childManifestName {
            try encodeContainer.encode(childManifestName, forKey: .childManifestName)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let manifestWindowSeconds = self.manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if let programDateTimeIntervalSeconds = self.programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if let scteHls = self.scteHls {
            try encodeContainer.encode(scteHls, forKey: .scteHls)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let childManifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childManifestName)
        childManifestName = childManifestNameDecoded
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
        let scteHlsDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ScteHls.self, forKey: .scteHls)
        scteHls = scteHlsDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// Retrieve the HTTP live streaming (HLS) manifest configuration.
    public struct GetHlsManifestConfiguration: Swift.Equatable {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public var childManifestName: Swift.String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The total duration (in seconds) of the manifest's content.
        public var manifestWindowSeconds: Swift.Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval, EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest. The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player. ID3Timed metadata messages generate every 5 seconds whenever the content is ingested. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// The SCTE configuration.
        public var scteHls: MediaPackageV2ClientTypes.ScteHls?
        /// The egress domain URL for stream delivery from MediaPackage.
        /// This member is required.
        public var url: Swift.String?

        public init(
            childManifestName: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            manifestWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            scteHls: MediaPackageV2ClientTypes.ScteHls? = nil,
            url: Swift.String? = nil
        )
        {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
            self.url = url
        }
    }

}

extension MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childManifestName = "ChildManifestName"
        case manifestName = "ManifestName"
        case manifestWindowSeconds = "ManifestWindowSeconds"
        case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
        case scteHls = "ScteHls"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childManifestName = self.childManifestName {
            try encodeContainer.encode(childManifestName, forKey: .childManifestName)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let manifestWindowSeconds = self.manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if let programDateTimeIntervalSeconds = self.programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if let scteHls = self.scteHls {
            try encodeContainer.encode(scteHls, forKey: .scteHls)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let childManifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childManifestName)
        childManifestName = childManifestNameDecoded
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
        let scteHlsDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ScteHls.self, forKey: .scteHls)
        scteHls = scteHlsDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// Retrieve the low-latency HTTP live streaming (HLS) manifest configuration.
    public struct GetLowLatencyHlsManifestConfiguration: Swift.Equatable {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public var childManifestName: Swift.String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The total duration (in seconds) of the manifest's content.
        public var manifestWindowSeconds: Swift.Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval, EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest. The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player. ID3Timed metadata messages generate every 5 seconds whenever the content is ingested. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// The SCTE configuration.
        public var scteHls: MediaPackageV2ClientTypes.ScteHls?
        /// The egress domain URL for stream delivery from MediaPackage.
        /// This member is required.
        public var url: Swift.String?

        public init(
            childManifestName: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            manifestWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            scteHls: MediaPackageV2ClientTypes.ScteHls? = nil,
            url: Swift.String? = nil
        )
        {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
            self.url = url
        }
    }

}

extension GetOriginEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        guard let originEndpointName = originEndpointName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint/\(originEndpointName.urlPercentEncoding())"
    }
}

public struct GetOriginEndpointInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        originEndpointName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.originEndpointName = originEndpointName
    }
}

struct GetOriginEndpointInputBody: Swift.Equatable {
}

extension GetOriginEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetOriginEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetOriginEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.containerType = output.containerType
            self.createdAt = output.createdAt
            self.description = output.description
            self.hlsManifests = output.hlsManifests
            self.lowLatencyHlsManifests = output.lowLatencyHlsManifests
            self.modifiedAt = output.modifiedAt
            self.originEndpointName = output.originEndpointName
            self.segment = output.segment
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.channelName = nil
            self.containerType = nil
            self.createdAt = nil
            self.description = nil
            self.hlsManifests = nil
            self.lowLatencyHlsManifests = nil
            self.modifiedAt = nil
            self.originEndpointName = nil
            self.segment = nil
            self.startoverWindowSeconds = nil
            self.tags = nil
        }
    }
}

public struct GetOriginEndpointOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The type of container attached to this origin endpoint.
    /// This member is required.
    public var containerType: MediaPackageV2ClientTypes.ContainerType?
    /// The date and time the origin endpoint was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your origin endpoint.
    public var description: Swift.String?
    /// An HTTP live streaming (HLS) manifest configuration.
    public var hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]?
    /// A low-latency HLS manifest configuration.
    public var lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]?
    /// The date and time the origin endpoint was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?
    /// The segment configuration, including the segment name, duration, and other configuration values.
    /// This member is required.
    public var segment: MediaPackageV2ClientTypes.Segment?
    /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window.
    public var startoverWindowSeconds: Swift.Int?
    /// The comma-separated list of tag key:value pairs assigned to the origin endpoint.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        containerType: MediaPackageV2ClientTypes.ContainerType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]? = nil,
        lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        originEndpointName: Swift.String? = nil,
        segment: MediaPackageV2ClientTypes.Segment? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.containerType = containerType
        self.createdAt = createdAt
        self.description = description
        self.hlsManifests = hlsManifests
        self.lowLatencyHlsManifests = lowLatencyHlsManifests
        self.modifiedAt = modifiedAt
        self.originEndpointName = originEndpointName
        self.segment = segment
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
    }
}

struct GetOriginEndpointOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let channelGroupName: Swift.String?
    let channelName: Swift.String?
    let originEndpointName: Swift.String?
    let containerType: MediaPackageV2ClientTypes.ContainerType?
    let segment: MediaPackageV2ClientTypes.Segment?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let startoverWindowSeconds: Swift.Int?
    let hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]?
    let lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]?
    let tags: [Swift.String:Swift.String]?
}

extension GetOriginEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case containerType = "ContainerType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case modifiedAt = "ModifiedAt"
        case originEndpointName = "OriginEndpointName"
        case segment = "Segment"
        case startoverWindowSeconds = "StartoverWindowSeconds"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let originEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointName)
        originEndpointName = originEndpointNameDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let segmentDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.Segment.self, forKey: .segment)
        segment = segmentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.GetHlsManifestConfiguration?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageV2ClientTypes.GetHlsManifestConfiguration]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let lowLatencyHlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration?].self, forKey: .lowLatencyHlsManifests)
        var lowLatencyHlsManifestsDecoded0:[MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]? = nil
        if let lowLatencyHlsManifestsContainer = lowLatencyHlsManifestsContainer {
            lowLatencyHlsManifestsDecoded0 = [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]()
            for structure0 in lowLatencyHlsManifestsContainer {
                if let structure0 = structure0 {
                    lowLatencyHlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        lowLatencyHlsManifests = lowLatencyHlsManifestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetOriginEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetOriginEndpointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        guard let originEndpointName = originEndpointName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint/\(originEndpointName.urlPercentEncoding())/policy"
    }
}

public struct GetOriginEndpointPolicyInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        originEndpointName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.originEndpointName = originEndpointName
    }
}

struct GetOriginEndpointPolicyInputBody: Swift.Equatable {
}

extension GetOriginEndpointPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetOriginEndpointPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetOriginEndpointPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.originEndpointName = output.originEndpointName
            self.policy = output.policy
        } else {
            self.channelGroupName = nil
            self.channelName = nil
            self.originEndpointName = nil
            self.policy = nil
        }
    }
}

public struct GetOriginEndpointPolicyOutput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?
    /// The policy assigned to the origin endpoint.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        originEndpointName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.originEndpointName = originEndpointName
        self.policy = policy
    }
}

struct GetOriginEndpointPolicyOutputBody: Swift.Equatable {
    let channelGroupName: Swift.String?
    let channelName: Swift.String?
    let originEndpointName: Swift.String?
    let policy: Swift.String?
}

extension GetOriginEndpointPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case originEndpointName = "OriginEndpointName"
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let originEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointName)
        originEndpointName = originEndpointNameDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetOriginEndpointPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaPackageV2ClientTypes.IngestEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The ingest domain URL where the source stream should be sent.
    public struct IngestEndpoint: Swift.Equatable {
        /// The system-generated unique identifier for the IngestEndpoint.
        public var id: Swift.String?
        /// The ingest domain URL where the source stream should be sent.
        public var url: Swift.String?

        public init(
            id: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.id = id
            self.url = url
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that an error from the service occurred while trying to process a request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChannelGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channelGroup"
    }
}

public struct ListChannelGroupsInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelGroupsInputBody: Swift.Equatable {
}

extension ListChannelGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChannelGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelGroupsOutput: Swift.Equatable {
    /// The objects being returned.
    public var items: [MediaPackageV2ClientTypes.ChannelGroupListConfiguration]?
    /// The pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [MediaPackageV2ClientTypes.ChannelGroupListConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListChannelGroupsOutputBody: Swift.Equatable {
    let items: [MediaPackageV2ClientTypes.ChannelGroupListConfiguration]?
    let nextToken: Swift.String?
}

extension ListChannelGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.ChannelGroupListConfiguration?].self, forKey: .items)
        var itemsDecoded0:[MediaPackageV2ClientTypes.ChannelGroupListConfiguration]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaPackageV2ClientTypes.ChannelGroupListConfiguration]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListChannelGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListChannelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel"
    }
}

public struct ListChannelsInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Swift.Equatable {
}

extension ListChannelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChannelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutput: Swift.Equatable {
    /// The objects being returned.
    public var items: [MediaPackageV2ClientTypes.ChannelListConfiguration]?
    /// The pagination token from the GET list request.
    public var nextToken: Swift.String?

    public init(
        items: [MediaPackageV2ClientTypes.ChannelListConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputBody: Swift.Equatable {
    let items: [MediaPackageV2ClientTypes.ChannelListConfiguration]?
    let nextToken: Swift.String?
}

extension ListChannelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.ChannelListConfiguration?].self, forKey: .items)
        var itemsDecoded0:[MediaPackageV2ClientTypes.ChannelListConfiguration]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaPackageV2ClientTypes.ChannelListConfiguration]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListChannelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaPackageV2ClientTypes.ListHlsManifestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childManifestName = "ChildManifestName"
        case manifestName = "ManifestName"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childManifestName = self.childManifestName {
            try encodeContainer.encode(childManifestName, forKey: .childManifestName)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let childManifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childManifestName)
        childManifestName = childManifestNameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// List the HTTP live streaming (HLS) manifest configuration.
    public struct ListHlsManifestConfiguration: Swift.Equatable {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public var childManifestName: Swift.String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The egress domain URL for stream delivery from MediaPackage.
        public var url: Swift.String?

        public init(
            childManifestName: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.url = url
        }
    }

}

extension MediaPackageV2ClientTypes.ListLowLatencyHlsManifestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childManifestName = "ChildManifestName"
        case manifestName = "ManifestName"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childManifestName = self.childManifestName {
            try encodeContainer.encode(childManifestName, forKey: .childManifestName)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let childManifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childManifestName)
        childManifestName = childManifestNameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// List the low-latency HTTP live streaming (HLS) manifest configuration.
    public struct ListLowLatencyHlsManifestConfiguration: Swift.Equatable {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public var childManifestName: Swift.String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The egress domain URL for stream delivery from MediaPackage.
        public var url: Swift.String?

        public init(
            childManifestName: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.url = url
        }
    }

}

extension ListOriginEndpointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListOriginEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint"
    }
}

public struct ListOriginEndpointsInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOriginEndpointsInputBody: Swift.Equatable {
}

extension ListOriginEndpointsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListOriginEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOriginEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListOriginEndpointsOutput: Swift.Equatable {
    /// The objects being returned.
    public var items: [MediaPackageV2ClientTypes.OriginEndpointListConfiguration]?
    /// The pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [MediaPackageV2ClientTypes.OriginEndpointListConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListOriginEndpointsOutputBody: Swift.Equatable {
    let items: [MediaPackageV2ClientTypes.OriginEndpointListConfiguration]?
    let nextToken: Swift.String?
}

extension ListOriginEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.OriginEndpointListConfiguration?].self, forKey: .items)
        var itemsDecoded0:[MediaPackageV2ClientTypes.OriginEndpointListConfiguration]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaPackageV2ClientTypes.OriginEndpointListConfiguration]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListOriginEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the CloudWatch resource that you want to view tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaPackageV2ClientTypes.OriginEndpointListConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case containerType = "ContainerType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case modifiedAt = "ModifiedAt"
        case originEndpointName = "OriginEndpointName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelGroupName = self.channelGroupName {
            try encodeContainer.encode(channelGroupName, forKey: .channelGroupName)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let containerType = self.containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for listhlsmanifestconfiguration0 in hlsManifests {
                try hlsManifestsContainer.encode(listhlsmanifestconfiguration0)
            }
        }
        if let lowLatencyHlsManifests = lowLatencyHlsManifests {
            var lowLatencyHlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lowLatencyHlsManifests)
            for listlowlatencyhlsmanifestconfiguration0 in lowLatencyHlsManifests {
                try lowLatencyHlsManifestsContainer.encode(listlowlatencyhlsmanifestconfiguration0)
            }
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .epochSeconds, forKey: .modifiedAt)
        }
        if let originEndpointName = self.originEndpointName {
            try encodeContainer.encode(originEndpointName, forKey: .originEndpointName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let originEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointName)
        originEndpointName = originEndpointNameDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.ListHlsManifestConfiguration?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageV2ClientTypes.ListHlsManifestConfiguration]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageV2ClientTypes.ListHlsManifestConfiguration]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let lowLatencyHlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.ListLowLatencyHlsManifestConfiguration?].self, forKey: .lowLatencyHlsManifests)
        var lowLatencyHlsManifestsDecoded0:[MediaPackageV2ClientTypes.ListLowLatencyHlsManifestConfiguration]? = nil
        if let lowLatencyHlsManifestsContainer = lowLatencyHlsManifestsContainer {
            lowLatencyHlsManifestsDecoded0 = [MediaPackageV2ClientTypes.ListLowLatencyHlsManifestConfiguration]()
            for structure0 in lowLatencyHlsManifestsContainer {
                if let structure0 = structure0 {
                    lowLatencyHlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        lowLatencyHlsManifests = lowLatencyHlsManifestsDecoded0
    }
}

extension MediaPackageV2ClientTypes {
    /// The configuration of the origin endpoint.
    public struct OriginEndpointListConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) associated with the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        /// This member is required.
        public var channelGroupName: Swift.String?
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        /// This member is required.
        public var channelName: Swift.String?
        /// The type of container attached to this origin endpoint. A container type is a file format that encapsulates one or more media streams, such as audio and video, into a single file.
        /// This member is required.
        public var containerType: MediaPackageV2ClientTypes.ContainerType?
        /// The date and time the origin endpoint was created.
        public var createdAt: ClientRuntime.Date?
        /// Any descriptive information that you want to add to the origin endpoint for future identification purposes.
        public var description: Swift.String?
        /// An HTTP live streaming (HLS) manifest configuration.
        public var hlsManifests: [MediaPackageV2ClientTypes.ListHlsManifestConfiguration]?
        /// A low-latency HLS manifest configuration.
        public var lowLatencyHlsManifests: [MediaPackageV2ClientTypes.ListLowLatencyHlsManifestConfiguration]?
        /// The date and time the origin endpoint was modified.
        public var modifiedAt: ClientRuntime.Date?
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        /// This member is required.
        public var originEndpointName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            channelGroupName: Swift.String? = nil,
            channelName: Swift.String? = nil,
            containerType: MediaPackageV2ClientTypes.ContainerType? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            hlsManifests: [MediaPackageV2ClientTypes.ListHlsManifestConfiguration]? = nil,
            lowLatencyHlsManifests: [MediaPackageV2ClientTypes.ListLowLatencyHlsManifestConfiguration]? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            originEndpointName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.containerType = containerType
            self.createdAt = createdAt
            self.description = description
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
            self.modifiedAt = modifiedAt
            self.originEndpointName = originEndpointName
        }
    }

}

extension MediaPackageV2ClientTypes {
    public enum PresetSpeke20Audio: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case presetAudio1
        case presetAudio2
        case presetAudio3
        case shared
        case unencrypted
        case sdkUnknown(Swift.String)

        public static var allCases: [PresetSpeke20Audio] {
            return [
                .presetAudio1,
                .presetAudio2,
                .presetAudio3,
                .shared,
                .unencrypted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .presetAudio1: return "PRESET_AUDIO_1"
            case .presetAudio2: return "PRESET_AUDIO_2"
            case .presetAudio3: return "PRESET_AUDIO_3"
            case .shared: return "SHARED"
            case .unencrypted: return "UNENCRYPTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PresetSpeke20Audio(rawValue: rawValue) ?? PresetSpeke20Audio.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageV2ClientTypes {
    public enum PresetSpeke20Video: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case presetVideo1
        case presetVideo2
        case presetVideo3
        case presetVideo4
        case presetVideo5
        case presetVideo6
        case presetVideo7
        case presetVideo8
        case shared
        case unencrypted
        case sdkUnknown(Swift.String)

        public static var allCases: [PresetSpeke20Video] {
            return [
                .presetVideo1,
                .presetVideo2,
                .presetVideo3,
                .presetVideo4,
                .presetVideo5,
                .presetVideo6,
                .presetVideo7,
                .presetVideo8,
                .shared,
                .unencrypted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .presetVideo1: return "PRESET_VIDEO_1"
            case .presetVideo2: return "PRESET_VIDEO_2"
            case .presetVideo3: return "PRESET_VIDEO_3"
            case .presetVideo4: return "PRESET_VIDEO_4"
            case .presetVideo5: return "PRESET_VIDEO_5"
            case .presetVideo6: return "PRESET_VIDEO_6"
            case .presetVideo7: return "PRESET_VIDEO_7"
            case .presetVideo8: return "PRESET_VIDEO_8"
            case .shared: return "SHARED"
            case .unencrypted: return "UNENCRYPTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PresetSpeke20Video(rawValue: rawValue) ?? PresetSpeke20Video.sdkUnknown(rawValue)
        }
    }
}

extension PutChannelPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutChannelPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/policy"
    }
}

public struct PutChannelPolicyInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The policy to attach to the specified channel.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.policy = policy
    }
}

struct PutChannelPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutChannelPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutChannelPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutChannelPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutChannelPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutOriginEndpointPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutOriginEndpointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        guard let originEndpointName = originEndpointName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint/\(originEndpointName.urlPercentEncoding())/policy"
    }
}

public struct PutOriginEndpointPolicyInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?
    /// The policy to attach to the specified origin endpoint.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        originEndpointName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.originEndpointName = originEndpointName
        self.policy = policy
    }
}

struct PutOriginEndpointPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutOriginEndpointPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutOriginEndpointPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutOriginEndpointPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutOriginEndpointPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceTypeNotFound = output.resourceTypeNotFound
        } else {
            self.properties.message = nil
            self.properties.resourceTypeNotFound = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The specified resource type wasn't found.
        public internal(set) var resourceTypeNotFound: MediaPackageV2ClientTypes.ResourceTypeNotFound? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceTypeNotFound: MediaPackageV2ClientTypes.ResourceTypeNotFound? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceTypeNotFound = resourceTypeNotFound
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceTypeNotFound: MediaPackageV2ClientTypes.ResourceTypeNotFound?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceTypeNotFound = "ResourceTypeNotFound"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeNotFoundDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ResourceTypeNotFound.self, forKey: .resourceTypeNotFound)
        resourceTypeNotFound = resourceTypeNotFoundDecoded
    }
}

extension MediaPackageV2ClientTypes {
    public enum ResourceTypeNotFound: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case channel
        case channelGroup
        case originEndpoint
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceTypeNotFound] {
            return [
                .channel,
                .channelGroup,
                .originEndpoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .channel: return "CHANNEL"
            case .channelGroup: return "CHANNEL_GROUP"
            case .originEndpoint: return "ORIGIN_ENDPOINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceTypeNotFound(rawValue: rawValue) ?? ResourceTypeNotFound.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageV2ClientTypes.Scte: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scteFilter = "ScteFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scteFilter = scteFilter {
            var scteFilterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scteFilter)
            for sctefilter0 in scteFilter {
                try scteFilterContainer.encode(sctefilter0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scteFilterContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.ScteFilter?].self, forKey: .scteFilter)
        var scteFilterDecoded0:[MediaPackageV2ClientTypes.ScteFilter]? = nil
        if let scteFilterContainer = scteFilterContainer {
            scteFilterDecoded0 = [MediaPackageV2ClientTypes.ScteFilter]()
            for enum0 in scteFilterContainer {
                if let enum0 = enum0 {
                    scteFilterDecoded0?.append(enum0)
                }
            }
        }
        scteFilter = scteFilterDecoded0
    }
}

extension MediaPackageV2ClientTypes {
    /// The SCTE configuration.
    public struct Scte: Swift.Equatable {
        /// The SCTE-35 message types that you want to be treated as ad markers in the output.
        public var scteFilter: [MediaPackageV2ClientTypes.ScteFilter]?

        public init(
            scteFilter: [MediaPackageV2ClientTypes.ScteFilter]? = nil
        )
        {
            self.scteFilter = scteFilter
        }
    }

}

extension MediaPackageV2ClientTypes {
    public enum ScteFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `break`
        case distributorAdvertisement
        case distributorOverlayPlacementOpportunity
        case distributorPlacementOpportunity
        case program
        case providerAdvertisement
        case providerOverlayPlacementOpportunity
        case providerPlacementOpportunity
        case spliceInsert
        case sdkUnknown(Swift.String)

        public static var allCases: [ScteFilter] {
            return [
                .break,
                .distributorAdvertisement,
                .distributorOverlayPlacementOpportunity,
                .distributorPlacementOpportunity,
                .program,
                .providerAdvertisement,
                .providerOverlayPlacementOpportunity,
                .providerPlacementOpportunity,
                .spliceInsert,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .break: return "BREAK"
            case .distributorAdvertisement: return "DISTRIBUTOR_ADVERTISEMENT"
            case .distributorOverlayPlacementOpportunity: return "DISTRIBUTOR_OVERLAY_PLACEMENT_OPPORTUNITY"
            case .distributorPlacementOpportunity: return "DISTRIBUTOR_PLACEMENT_OPPORTUNITY"
            case .program: return "PROGRAM"
            case .providerAdvertisement: return "PROVIDER_ADVERTISEMENT"
            case .providerOverlayPlacementOpportunity: return "PROVIDER_OVERLAY_PLACEMENT_OPPORTUNITY"
            case .providerPlacementOpportunity: return "PROVIDER_PLACEMENT_OPPORTUNITY"
            case .spliceInsert: return "SPLICE_INSERT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScteFilter(rawValue: rawValue) ?? ScteFilter.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageV2ClientTypes.ScteHls: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adMarkerHls = "AdMarkerHls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkerHls = self.adMarkerHls {
            try encodeContainer.encode(adMarkerHls.rawValue, forKey: .adMarkerHls)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkerHlsDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.AdMarkerHls.self, forKey: .adMarkerHls)
        adMarkerHls = adMarkerHlsDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The SCTE configuration.
    public struct ScteHls: Swift.Equatable {
        /// Ad markers indicate when ads should be inserted during playback. If you include ad markers in the content stream in your upstream encoders, then you need to inform MediaPackage what to do with the ad markers in the output. Choose what you want MediaPackage to do with the ad markers. Value description:
        ///
        /// * DATERANGE - Insert EXT-X-DATERANGE tags to signal ad and program transition events in TS and CMAF manifests. If you use DATERANGE, you must set a programDateTimeIntervalSeconds value of 1 or higher. To learn more about DATERANGE, see [SCTE-35 Ad Marker EXT-X-DATERANGE](http://docs.aws.amazon.com/mediapackage/latest/ug/scte-35-ad-marker-ext-x-daterange.html).
        public var adMarkerHls: MediaPackageV2ClientTypes.AdMarkerHls?

        public init(
            adMarkerHls: MediaPackageV2ClientTypes.AdMarkerHls? = nil
        )
        {
            self.adMarkerHls = adMarkerHls
        }
    }

}

extension MediaPackageV2ClientTypes.Segment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "Encryption"
        case includeIframeOnlyStreams = "IncludeIframeOnlyStreams"
        case scte = "Scte"
        case segmentDurationSeconds = "SegmentDurationSeconds"
        case segmentName = "SegmentName"
        case tsIncludeDvbSubtitles = "TsIncludeDvbSubtitles"
        case tsUseAudioRenditionGroup = "TsUseAudioRenditionGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let includeIframeOnlyStreams = self.includeIframeOnlyStreams {
            try encodeContainer.encode(includeIframeOnlyStreams, forKey: .includeIframeOnlyStreams)
        }
        if let scte = self.scte {
            try encodeContainer.encode(scte, forKey: .scte)
        }
        if let segmentDurationSeconds = self.segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let segmentName = self.segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
        if let tsIncludeDvbSubtitles = self.tsIncludeDvbSubtitles {
            try encodeContainer.encode(tsIncludeDvbSubtitles, forKey: .tsIncludeDvbSubtitles)
        }
        if let tsUseAudioRenditionGroup = self.tsUseAudioRenditionGroup {
            try encodeContainer.encode(tsUseAudioRenditionGroup, forKey: .tsUseAudioRenditionGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let segmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
        let tsUseAudioRenditionGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .tsUseAudioRenditionGroup)
        tsUseAudioRenditionGroup = tsUseAudioRenditionGroupDecoded
        let includeIframeOnlyStreamsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeIframeOnlyStreams)
        includeIframeOnlyStreams = includeIframeOnlyStreamsDecoded
        let tsIncludeDvbSubtitlesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .tsIncludeDvbSubtitles)
        tsIncludeDvbSubtitles = tsIncludeDvbSubtitlesDecoded
        let scteDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.Scte.self, forKey: .scte)
        scte = scteDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The segment configuration, including the segment name, duration, and other configuration values.
    public struct Segment: Swift.Equatable {
        /// The parameters for encrypting content.
        public var encryption: MediaPackageV2ClientTypes.Encryption?
        /// When selected, the stream set includes an additional I-frame only stream, along with the other tracks. If false, this extra stream is not included. MediaPackage generates an I-frame only stream from the first rendition in the manifest. The service inserts EXT-I-FRAMES-ONLY tags in the output manifest, and then generates and includes an I-frames only playlist in the stream. This playlist permits player functionality like fast forward and rewind.
        public var includeIframeOnlyStreams: Swift.Bool?
        /// The SCTE configuration options in the segment settings.
        public var scte: MediaPackageV2ClientTypes.Scte?
        /// The duration (in seconds) of each segment. Enter a value equal to, or a multiple of, the input segment duration. If the value that you enter is different from the input segment duration, MediaPackage rounds segments to the nearest multiple of the input segment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// The name that describes the segment. The name is the base name of the segment used in all content manifests inside of the endpoint. You can't use spaces in the name.
        public var segmentName: Swift.String?
        /// By default, MediaPackage excludes all digital video broadcasting (DVB) subtitles from the output. When selected, MediaPackage passes through DVB subtitles into the output.
        public var tsIncludeDvbSubtitles: Swift.Bool?
        /// When selected, MediaPackage bundles all audio tracks in a rendition group. All other tracks in the stream can be used with any audio rendition from the group.
        public var tsUseAudioRenditionGroup: Swift.Bool?

        public init(
            encryption: MediaPackageV2ClientTypes.Encryption? = nil,
            includeIframeOnlyStreams: Swift.Bool? = nil,
            scte: MediaPackageV2ClientTypes.Scte? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            segmentName: Swift.String? = nil,
            tsIncludeDvbSubtitles: Swift.Bool? = nil,
            tsUseAudioRenditionGroup: Swift.Bool? = nil
        )
        {
            self.encryption = encryption
            self.includeIframeOnlyStreams = includeIframeOnlyStreams
            self.scte = scte
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentName = segmentName
            self.tsIncludeDvbSubtitles = tsIncludeDvbSubtitles
            self.tsUseAudioRenditionGroup = tsUseAudioRenditionGroup
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageV2ClientTypes.SpekeKeyProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case drmSystems = "DrmSystems"
        case encryptionContractConfiguration = "EncryptionContractConfiguration"
        case resourceId = "ResourceId"
        case roleArn = "RoleArn"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let drmSystems = drmSystems {
            var drmSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .drmSystems)
            for drmsystem0 in drmSystems {
                try drmSystemsContainer.encode(drmsystem0.rawValue)
            }
        }
        if let encryptionContractConfiguration = self.encryptionContractConfiguration {
            try encodeContainer.encode(encryptionContractConfiguration, forKey: .encryptionContractConfiguration)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionContractConfigurationDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.EncryptionContractConfiguration.self, forKey: .encryptionContractConfiguration)
        encryptionContractConfiguration = encryptionContractConfigurationDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let drmSystemsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.DrmSystem?].self, forKey: .drmSystems)
        var drmSystemsDecoded0:[MediaPackageV2ClientTypes.DrmSystem]? = nil
        if let drmSystemsContainer = drmSystemsContainer {
            drmSystemsDecoded0 = [MediaPackageV2ClientTypes.DrmSystem]()
            for enum0 in drmSystemsContainer {
                if let enum0 = enum0 {
                    drmSystemsDecoded0?.append(enum0)
                }
            }
        }
        drmSystems = drmSystemsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The parameters for the SPEKE key provider.
    public struct SpekeKeyProvider: Swift.Equatable {
        /// The DRM solution provider you're using to protect your content during distribution.
        /// This member is required.
        public var drmSystems: [MediaPackageV2ClientTypes.DrmSystem]?
        /// Configure one or more content encryption keys for your endpoints that use SPEKE Version 2.0. The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream. To configure the encryption contract, specify which audio and video encryption presets to use.
        /// This member is required.
        public var encryptionContractConfiguration: MediaPackageV2ClientTypes.EncryptionContractConfiguration?
        /// The unique identifier for the content. The service sends this to the key server to identify the current endpoint. How unique you make this depends on how fine-grained you want access controls to be. The service does not permit you to use the same ID for two simultaneous encryption processes. The resource ID is also known as the content ID. The following example shows a resource ID: MovieNight20171126093045
        /// This member is required.
        public var resourceId: Swift.String?
        /// The ARN for the IAM role granted by the key provider that provides access to the key provider API. This role must have a trust policy that allows MediaPackage to assume the role, and it must have a sufficient permissions policy to allow access to the specific key retrieval URL. Get this from your DRM solution provider. Valid format: arn:aws:iam::{accountID}:role/{name}. The following example shows a role ARN: arn:aws:iam::444455556666:role/SpekeAccess
        /// This member is required.
        public var roleArn: Swift.String?
        /// The URL of the API Gateway proxy that you set up to talk to your key server. The API Gateway proxy must reside in the same AWS Region as MediaPackage and must start with https://. The following example shows a URL: https://1wm2dx1f33.execute-api.us-west-2.amazonaws.com/SpekeSample/copyProtection
        /// This member is required.
        public var url: Swift.String?

        public init(
            drmSystems: [MediaPackageV2ClientTypes.DrmSystem]? = nil,
            encryptionContractConfiguration: MediaPackageV2ClientTypes.EncryptionContractConfiguration? = nil,
            resourceId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.drmSystems = drmSystems
            self.encryptionContractConfiguration = encryptionContractConfiguration
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.url = url
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the MediaPackage resource that you're adding tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request throughput limit was exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageV2ClientTypes {
    public enum TsEncryptionMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes128
        case sampleAes
        case sdkUnknown(Swift.String)

        public static var allCases: [TsEncryptionMethod] {
            return [
                .aes128,
                .sampleAes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes128: return "AES_128"
            case .sampleAes: return "SAMPLE_AES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TsEncryptionMethod(rawValue: rawValue) ?? TsEncryptionMethod.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the MediaPackage resource that you're removing tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateChannelGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateChannelGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())"
    }
}

public struct UpdateChannelGroupInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// Any descriptive information that you want to add to the channel group for future identification purposes.
    public var description: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.description = description
    }
}

struct UpdateChannelGroupInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateChannelGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateChannelGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateChannelGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.createdAt = output.createdAt
            self.description = output.description
            self.egressDomain = output.egressDomain
            self.modifiedAt = output.modifiedAt
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.createdAt = nil
            self.description = nil
            self.egressDomain = nil
            self.modifiedAt = nil
            self.tags = nil
        }
    }
}

public struct UpdateChannelGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The date and time the channel group was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your channel group.
    public var description: Swift.String?
    /// The output domain where the source stream is sent. Integrate the domain with a downstream CDN (such as Amazon CloudFront) or playback device.
    /// This member is required.
    public var egressDomain: Swift.String?
    /// The date and time the channel group was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The comma-separated list of tag key:value pairs assigned to the channel group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        egressDomain: Swift.String? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.createdAt = createdAt
        self.description = description
        self.egressDomain = egressDomain
        self.modifiedAt = modifiedAt
        self.tags = tags
    }
}

struct UpdateChannelGroupOutputBody: Swift.Equatable {
    let channelGroupName: Swift.String?
    let arn: Swift.String?
    let egressDomain: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateChannelGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case egressDomain = "EgressDomain"
        case modifiedAt = "ModifiedAt"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let egressDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .egressDomain)
        egressDomain = egressDomainDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateChannelGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())"
    }
}

public struct UpdateChannelInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// Any descriptive information that you want to add to the channel for future identification purposes.
    public var description: Swift.String?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.description = description
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.createdAt = output.createdAt
            self.description = output.description
            self.ingestEndpoints = output.ingestEndpoints
            self.modifiedAt = output.modifiedAt
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.channelName = nil
            self.createdAt = nil
            self.description = nil
            self.ingestEndpoints = nil
            self.modifiedAt = nil
            self.tags = nil
        }
    }
}

public struct UpdateChannelOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The date and time the channel was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your channel.
    public var description: Swift.String?
    /// The list of ingest endpoints.
    public var ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]?
    /// The date and time the channel was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The comma-separated list of tag key:value pairs assigned to the channel.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.createdAt = createdAt
        self.description = description
        self.ingestEndpoints = ingestEndpoints
        self.modifiedAt = modifiedAt
        self.tags = tags
    }
}

struct UpdateChannelOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let channelName: Swift.String?
    let channelGroupName: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case ingestEndpoints = "IngestEndpoints"
        case modifiedAt = "ModifiedAt"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ingestEndpointsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.IngestEndpoint?].self, forKey: .ingestEndpoints)
        var ingestEndpointsDecoded0:[MediaPackageV2ClientTypes.IngestEndpoint]? = nil
        if let ingestEndpointsContainer = ingestEndpointsContainer {
            ingestEndpointsDecoded0 = [MediaPackageV2ClientTypes.IngestEndpoint]()
            for structure0 in ingestEndpointsContainer {
                if let structure0 = structure0 {
                    ingestEndpointsDecoded0?.append(structure0)
                }
            }
        }
        ingestEndpoints = ingestEndpointsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateOriginEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerType = "ContainerType"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case segment = "Segment"
        case startoverWindowSeconds = "StartoverWindowSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerType = self.containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for createhlsmanifestconfiguration0 in hlsManifests {
                try hlsManifestsContainer.encode(createhlsmanifestconfiguration0)
            }
        }
        if let lowLatencyHlsManifests = lowLatencyHlsManifests {
            var lowLatencyHlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lowLatencyHlsManifests)
            for createlowlatencyhlsmanifestconfiguration0 in lowLatencyHlsManifests {
                try lowLatencyHlsManifestsContainer.encode(createlowlatencyhlsmanifestconfiguration0)
            }
        }
        if let segment = self.segment {
            try encodeContainer.encode(segment, forKey: .segment)
        }
        if let startoverWindowSeconds = self.startoverWindowSeconds {
            try encodeContainer.encode(startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }
    }
}

extension UpdateOriginEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        guard let originEndpointName = originEndpointName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint/\(originEndpointName.urlPercentEncoding())"
    }
}

public struct UpdateOriginEndpointInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The type of container attached to this origin endpoint. A container type is a file format that encapsulates one or more media streams, such as audio and video, into a single file.
    /// This member is required.
    public var containerType: MediaPackageV2ClientTypes.ContainerType?
    /// Any descriptive information that you want to add to the origin endpoint for future identification purposes.
    public var description: Swift.String?
    /// An HTTP live streaming (HLS) manifest configuration.
    public var hlsManifests: [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]?
    /// A low-latency HLS manifest configuration.
    public var lowLatencyHlsManifests: [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?
    /// The segment configuration, including the segment name, duration, and other configuration values.
    public var segment: MediaPackageV2ClientTypes.Segment?
    /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window. The maximum startover window is 1,209,600 seconds (14 days).
    public var startoverWindowSeconds: Swift.Int?

    public init(
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        containerType: MediaPackageV2ClientTypes.ContainerType? = nil,
        description: Swift.String? = nil,
        hlsManifests: [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]? = nil,
        lowLatencyHlsManifests: [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]? = nil,
        originEndpointName: Swift.String? = nil,
        segment: MediaPackageV2ClientTypes.Segment? = nil,
        startoverWindowSeconds: Swift.Int? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.containerType = containerType
        self.description = description
        self.hlsManifests = hlsManifests
        self.lowLatencyHlsManifests = lowLatencyHlsManifests
        self.originEndpointName = originEndpointName
        self.segment = segment
        self.startoverWindowSeconds = startoverWindowSeconds
    }
}

struct UpdateOriginEndpointInputBody: Swift.Equatable {
    let containerType: MediaPackageV2ClientTypes.ContainerType?
    let segment: MediaPackageV2ClientTypes.Segment?
    let description: Swift.String?
    let startoverWindowSeconds: Swift.Int?
    let hlsManifests: [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]?
    let lowLatencyHlsManifests: [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]?
}

extension UpdateOriginEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerType = "ContainerType"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case segment = "Segment"
        case startoverWindowSeconds = "StartoverWindowSeconds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let segmentDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.Segment.self, forKey: .segment)
        segment = segmentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.CreateHlsManifestConfiguration?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let lowLatencyHlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration?].self, forKey: .lowLatencyHlsManifests)
        var lowLatencyHlsManifestsDecoded0:[MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]? = nil
        if let lowLatencyHlsManifestsContainer = lowLatencyHlsManifestsContainer {
            lowLatencyHlsManifestsDecoded0 = [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]()
            for structure0 in lowLatencyHlsManifestsContainer {
                if let structure0 = structure0 {
                    lowLatencyHlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        lowLatencyHlsManifests = lowLatencyHlsManifestsDecoded0
    }
}

extension UpdateOriginEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateOriginEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.containerType = output.containerType
            self.createdAt = output.createdAt
            self.description = output.description
            self.hlsManifests = output.hlsManifests
            self.lowLatencyHlsManifests = output.lowLatencyHlsManifests
            self.modifiedAt = output.modifiedAt
            self.originEndpointName = output.originEndpointName
            self.segment = output.segment
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.channelName = nil
            self.containerType = nil
            self.createdAt = nil
            self.description = nil
            self.hlsManifests = nil
            self.lowLatencyHlsManifests = nil
            self.modifiedAt = nil
            self.originEndpointName = nil
            self.segment = nil
            self.startoverWindowSeconds = nil
            self.tags = nil
        }
    }
}

public struct UpdateOriginEndpointOutput: Swift.Equatable {
    /// The ARN associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The type of container attached to this origin endpoint.
    /// This member is required.
    public var containerType: MediaPackageV2ClientTypes.ContainerType?
    /// The date and time the origin endpoint was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description of the origin endpoint.
    public var description: Swift.String?
    /// An HTTP live streaming (HLS) manifest configuration.
    public var hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]?
    /// A low-latency HLS manifest configuration.
    public var lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]?
    /// The date and time the origin endpoint was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?
    /// The segment configuration, including the segment name, duration, and other configuration values.
    /// This member is required.
    public var segment: MediaPackageV2ClientTypes.Segment?
    /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window.
    public var startoverWindowSeconds: Swift.Int?
    /// The comma-separated list of tag key:value pairs assigned to the origin endpoint.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        containerType: MediaPackageV2ClientTypes.ContainerType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]? = nil,
        lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        originEndpointName: Swift.String? = nil,
        segment: MediaPackageV2ClientTypes.Segment? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.containerType = containerType
        self.createdAt = createdAt
        self.description = description
        self.hlsManifests = hlsManifests
        self.lowLatencyHlsManifests = lowLatencyHlsManifests
        self.modifiedAt = modifiedAt
        self.originEndpointName = originEndpointName
        self.segment = segment
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
    }
}

struct UpdateOriginEndpointOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let channelGroupName: Swift.String?
    let channelName: Swift.String?
    let originEndpointName: Swift.String?
    let containerType: MediaPackageV2ClientTypes.ContainerType?
    let segment: MediaPackageV2ClientTypes.Segment?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let startoverWindowSeconds: Swift.Int?
    let hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]?
    let lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateOriginEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case containerType = "ContainerType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case modifiedAt = "ModifiedAt"
        case originEndpointName = "OriginEndpointName"
        case segment = "Segment"
        case startoverWindowSeconds = "StartoverWindowSeconds"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let originEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointName)
        originEndpointName = originEndpointNameDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let segmentDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.Segment.self, forKey: .segment)
        segment = segmentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.GetHlsManifestConfiguration?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageV2ClientTypes.GetHlsManifestConfiguration]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let lowLatencyHlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration?].self, forKey: .lowLatencyHlsManifests)
        var lowLatencyHlsManifestsDecoded0:[MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]? = nil
        if let lowLatencyHlsManifestsContainer = lowLatencyHlsManifestsContainer {
            lowLatencyHlsManifestsDecoded0 = [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]()
            for structure0 in lowLatencyHlsManifestsContainer {
                if let structure0 = structure0 {
                    lowLatencyHlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        lowLatencyHlsManifests = lowLatencyHlsManifestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateOriginEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.validationExceptionType = output.validationExceptionType
        } else {
            self.properties.message = nil
            self.properties.validationExceptionType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input failed to meet the constraints specified by the AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The type of ValidationException.
        public internal(set) var validationExceptionType: MediaPackageV2ClientTypes.ValidationExceptionType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        validationExceptionType: MediaPackageV2ClientTypes.ValidationExceptionType? = nil
    )
    {
        self.properties.message = message
        self.properties.validationExceptionType = validationExceptionType
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let validationExceptionType: MediaPackageV2ClientTypes.ValidationExceptionType?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case validationExceptionType = "ValidationExceptionType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let validationExceptionTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ValidationExceptionType.self, forKey: .validationExceptionType)
        validationExceptionType = validationExceptionTypeDecoded
    }
}

extension MediaPackageV2ClientTypes {
    public enum ValidationExceptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cencIvIncompatible
        case containerTypeImmutable
        case drmSystemsEncryptionMethodIncompatible
        case encryptionContractShared
        case encryptionContractUnencrypted
        case encryptionContractWithoutAudioRenditionIncompatible
        case encryptionMethodContainerTypeMismatch
        case invalidPaginationMaxResults
        case invalidPaginationToken
        case invalidPolicy
        case invalidRoleArn
        case manifestNameCollision
        case memberDoesNotMatchPattern
        case memberInvalid
        case memberInvalidEnumValue
        case memberMaxLength
        case memberMaxValue
        case memberMinLength
        case memberMinValue
        case memberMissing
        case numManifestsHigh
        case numManifestsLow
        case roleArnInvalidFormat
        case roleArnLengthOutOfRange
        case roleArnNotAssumable
        case urlInvalid
        case urlLinkLocalAddress
        case urlLocalAddress
        case urlLoopbackAddress
        case urlMulticastAddress
        case urlPort
        case urlScheme
        case urlUnknownHost
        case urlUserInfo
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionType] {
            return [
                .cencIvIncompatible,
                .containerTypeImmutable,
                .drmSystemsEncryptionMethodIncompatible,
                .encryptionContractShared,
                .encryptionContractUnencrypted,
                .encryptionContractWithoutAudioRenditionIncompatible,
                .encryptionMethodContainerTypeMismatch,
                .invalidPaginationMaxResults,
                .invalidPaginationToken,
                .invalidPolicy,
                .invalidRoleArn,
                .manifestNameCollision,
                .memberDoesNotMatchPattern,
                .memberInvalid,
                .memberInvalidEnumValue,
                .memberMaxLength,
                .memberMaxValue,
                .memberMinLength,
                .memberMinValue,
                .memberMissing,
                .numManifestsHigh,
                .numManifestsLow,
                .roleArnInvalidFormat,
                .roleArnLengthOutOfRange,
                .roleArnNotAssumable,
                .urlInvalid,
                .urlLinkLocalAddress,
                .urlLocalAddress,
                .urlLoopbackAddress,
                .urlMulticastAddress,
                .urlPort,
                .urlScheme,
                .urlUnknownHost,
                .urlUserInfo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cencIvIncompatible: return "CENC_IV_INCOMPATIBLE"
            case .containerTypeImmutable: return "CONTAINER_TYPE_IMMUTABLE"
            case .drmSystemsEncryptionMethodIncompatible: return "DRM_SYSTEMS_ENCRYPTION_METHOD_INCOMPATIBLE"
            case .encryptionContractShared: return "ENCRYPTION_CONTRACT_SHARED"
            case .encryptionContractUnencrypted: return "ENCRYPTION_CONTRACT_UNENCRYPTED"
            case .encryptionContractWithoutAudioRenditionIncompatible: return "ENCRYPTION_CONTRACT_WITHOUT_AUDIO_RENDITION_INCOMPATIBLE"
            case .encryptionMethodContainerTypeMismatch: return "ENCRYPTION_METHOD_CONTAINER_TYPE_MISMATCH"
            case .invalidPaginationMaxResults: return "INVALID_PAGINATION_MAX_RESULTS"
            case .invalidPaginationToken: return "INVALID_PAGINATION_TOKEN"
            case .invalidPolicy: return "INVALID_POLICY"
            case .invalidRoleArn: return "INVALID_ROLE_ARN"
            case .manifestNameCollision: return "MANIFEST_NAME_COLLISION"
            case .memberDoesNotMatchPattern: return "MEMBER_DOES_NOT_MATCH_PATTERN"
            case .memberInvalid: return "MEMBER_INVALID"
            case .memberInvalidEnumValue: return "MEMBER_INVALID_ENUM_VALUE"
            case .memberMaxLength: return "MEMBER_MAX_LENGTH"
            case .memberMaxValue: return "MEMBER_MAX_VALUE"
            case .memberMinLength: return "MEMBER_MIN_LENGTH"
            case .memberMinValue: return "MEMBER_MIN_VALUE"
            case .memberMissing: return "MEMBER_MISSING"
            case .numManifestsHigh: return "NUM_MANIFESTS_HIGH"
            case .numManifestsLow: return "NUM_MANIFESTS_LOW"
            case .roleArnInvalidFormat: return "ROLE_ARN_INVALID_FORMAT"
            case .roleArnLengthOutOfRange: return "ROLE_ARN_LENGTH_OUT_OF_RANGE"
            case .roleArnNotAssumable: return "ROLE_ARN_NOT_ASSUMABLE"
            case .urlInvalid: return "URL_INVALID"
            case .urlLinkLocalAddress: return "URL_LINK_LOCAL_ADDRESS"
            case .urlLocalAddress: return "URL_LOCAL_ADDRESS"
            case .urlLoopbackAddress: return "URL_LOOPBACK_ADDRESS"
            case .urlMulticastAddress: return "URL_MULTICAST_ADDRESS"
            case .urlPort: return "URL_PORT"
            case .urlScheme: return "URL_SCHEME"
            case .urlUnknownHost: return "URL_UNKNOWN_HOST"
            case .urlUserInfo: return "URL_USER_INFO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionType(rawValue: rawValue) ?? ValidationExceptionType.sdkUnknown(rawValue)
        }
    }
}
