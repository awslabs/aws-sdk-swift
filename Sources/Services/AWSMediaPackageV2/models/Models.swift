// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have permissions to perform the requested operation. The user or role that is making the request must have at least one IAM permissions policy attached that grants the required permissions. For more information, see Access Management in the IAM User Guide.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable, Swift.Error {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageV2ClientTypes {
    public enum AdMarkerHls: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daterange
        case sdkUnknown(Swift.String)

        public static var allCases: [AdMarkerHls] {
            return [
                .daterange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daterange: return "DATERANGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdMarkerHls(rawValue: rawValue) ?? AdMarkerHls.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageV2ClientTypes.ChannelGroupListConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case modifiedAt = "ModifiedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelGroupName = self.channelGroupName {
            try encodeContainer.encode(channelGroupName, forKey: .channelGroupName)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .epochSeconds, forKey: .modifiedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The configuration of the channel group.
    public struct ChannelGroupListConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) associated with the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        /// This member is required.
        public var channelGroupName: Swift.String?
        /// The date and time the channel group was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Any descriptive information that you want to add to the channel group for future identification purposes.
        public var description: Swift.String?
        /// The date and time the channel group was modified.
        /// This member is required.
        public var modifiedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            channelGroupName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            modifiedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.createdAt = createdAt
            self.description = description
            self.modifiedAt = modifiedAt
        }
    }

}

extension MediaPackageV2ClientTypes.ChannelListConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case modifiedAt = "ModifiedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelGroupName = self.channelGroupName {
            try encodeContainer.encode(channelGroupName, forKey: .channelGroupName)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .epochSeconds, forKey: .modifiedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The configuration of the channel.
    public struct ChannelListConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) associated with the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        /// This member is required.
        public var channelGroupName: Swift.String?
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        /// This member is required.
        public var channelName: Swift.String?
        /// The date and time the channel was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Any descriptive information that you want to add to the channel for future identification purposes.
        public var description: Swift.String?
        /// The date and time the channel was modified.
        /// This member is required.
        public var modifiedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            channelGroupName: Swift.String? = nil,
            channelName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            modifiedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.createdAt = createdAt
            self.description = description
            self.modifiedAt = modifiedAt
        }
    }

}

extension MediaPackageV2ClientTypes {
    public enum CmafEncryptionMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cbcs
        case cenc
        case sdkUnknown(Swift.String)

        public static var allCases: [CmafEncryptionMethod] {
            return [
                .cbcs,
                .cenc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cbcs: return "CBCS"
            case .cenc: return "CENC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CmafEncryptionMethod(rawValue: rawValue) ?? CmafEncryptionMethod.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.conflictExceptionType = output.conflictExceptionType
            self.message = output.message
        } else {
            self.conflictExceptionType = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Updating or deleting this resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable, Swift.Error {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The type of ConflictException.
    public var conflictExceptionType: MediaPackageV2ClientTypes.ConflictExceptionType?
    public var message: Swift.String?

    public init (
        conflictExceptionType: MediaPackageV2ClientTypes.ConflictExceptionType? = nil,
        message: Swift.String? = nil
    )
    {
        self.conflictExceptionType = conflictExceptionType
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let conflictExceptionType: MediaPackageV2ClientTypes.ConflictExceptionType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictExceptionType = "ConflictExceptionType"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let conflictExceptionTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ConflictExceptionType.self, forKey: .conflictExceptionType)
        conflictExceptionType = conflictExceptionTypeDecoded
    }
}

extension MediaPackageV2ClientTypes {
    public enum ConflictExceptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conflictingOperation
        case idempotentParameterMismatch
        case resourceAlreadyExists
        case resourceInUse
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionType] {
            return [
                .conflictingOperation,
                .idempotentParameterMismatch,
                .resourceAlreadyExists,
                .resourceInUse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conflictingOperation: return "CONFLICTING_OPERATION"
            case .idempotentParameterMismatch: return "IDEMPOTENT_PARAMETER_MISMATCH"
            case .resourceAlreadyExists: return "RESOURCE_ALREADY_EXISTS"
            case .resourceInUse: return "RESOURCE_IN_USE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionType(rawValue: rawValue) ?? ConflictExceptionType.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageV2ClientTypes {
    public enum ContainerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cmaf
        case ts
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerType] {
            return [
                .cmaf,
                .ts,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cmaf: return "CMAF"
            case .ts: return "TS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerType(rawValue: rawValue) ?? ContainerType.sdkUnknown(rawValue)
        }
    }
}

extension CreateChannelGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelGroupName = "ChannelGroupName"
        case description = "Description"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelGroupName = self.channelGroupName {
            try encodeContainer.encode(channelGroupName, forKey: .channelGroupName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateChannelGroupInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "x-amzn-client-token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateChannelGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channelGroup"
    }
}

public struct CreateChannelGroupInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region. You can't use spaces in the name. You can't change the name after you create the channel group.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Enter any descriptive text that helps you to identify the channel group.
    public var description: Swift.String?
    /// A comma-separated list of tag key:value pairs that you define. For example: "Key1": "Value1",
    ///     "Key2": "Value2"
    public var tags: [Swift.String:Swift.String]?

    public init (
        channelGroupName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.clientToken = clientToken
        self.description = description
        self.tags = tags
    }
}

struct CreateChannelGroupInputBody: Swift.Equatable {
    let channelGroupName: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateChannelGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelGroupName = "ChannelGroupName"
        case description = "Description"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateChannelGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: CreateChannelGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.createdAt = output.createdAt
            self.description = output.description
            self.egressDomain = output.egressDomain
            self.modifiedAt = output.modifiedAt
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.createdAt = nil
            self.description = nil
            self.egressDomain = nil
            self.modifiedAt = nil
            self.tags = nil
        }
    }
}

public struct CreateChannelGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The date and time the channel group was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your channel group.
    public var description: Swift.String?
    /// The output domain where the source stream should be sent. Integrate the egress domain with a downstream CDN (such as Amazon CloudFront) or playback device.
    /// This member is required.
    public var egressDomain: Swift.String?
    /// The date and time the channel group was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The comma-separated list of tag key:value pairs assigned to the channel group.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        egressDomain: Swift.String? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.createdAt = createdAt
        self.description = description
        self.egressDomain = egressDomain
        self.modifiedAt = modifiedAt
        self.tags = tags
    }
}

struct CreateChannelGroupOutputResponseBody: Swift.Equatable {
    let channelGroupName: Swift.String?
    let arn: Swift.String?
    let egressDomain: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateChannelGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case egressDomain = "EgressDomain"
        case modifiedAt = "ModifiedAt"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let egressDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .egressDomain)
        egressDomain = egressDomainDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName = "ChannelName"
        case description = "Description"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateChannelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "x-amzn-client-token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel"
    }
}

public struct CreateChannelInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group. You can't change the name after you create the channel.
    /// This member is required.
    public var channelName: Swift.String?
    /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Enter any descriptive text that helps you to identify the channel.
    public var description: Swift.String?
    /// A comma-separated list of tag key:value pairs that you define. For example: "Key1": "Value1",
    ///     "Key2": "Value2"
    public var tags: [Swift.String:Swift.String]?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.clientToken = clientToken
        self.description = description
        self.tags = tags
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    let channelName: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName = "ChannelName"
        case description = "Description"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.createdAt = output.createdAt
            self.description = output.description
            self.ingestEndpoints = output.ingestEndpoints
            self.modifiedAt = output.modifiedAt
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.channelName = nil
            self.createdAt = nil
            self.description = nil
            self.ingestEndpoints = nil
            self.modifiedAt = nil
            self.tags = nil
        }
    }
}

public struct CreateChannelOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The date and time the channel was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your channel.
    public var description: Swift.String?
    /// The list of ingest endpoints.
    public var ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]?
    /// The date and time the channel was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The comma-separated list of tag key:value pairs assigned to the channel.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.createdAt = createdAt
        self.description = description
        self.ingestEndpoints = ingestEndpoints
        self.modifiedAt = modifiedAt
        self.tags = tags
    }
}

struct CreateChannelOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let channelName: Swift.String?
    let channelGroupName: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case ingestEndpoints = "IngestEndpoints"
        case modifiedAt = "ModifiedAt"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ingestEndpointsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.IngestEndpoint?].self, forKey: .ingestEndpoints)
        var ingestEndpointsDecoded0:[MediaPackageV2ClientTypes.IngestEndpoint]? = nil
        if let ingestEndpointsContainer = ingestEndpointsContainer {
            ingestEndpointsDecoded0 = [MediaPackageV2ClientTypes.IngestEndpoint]()
            for structure0 in ingestEndpointsContainer {
                if let structure0 = structure0 {
                    ingestEndpointsDecoded0?.append(structure0)
                }
            }
        }
        ingestEndpoints = ingestEndpointsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaPackageV2ClientTypes.CreateHlsManifestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childManifestName = "ChildManifestName"
        case manifestName = "ManifestName"
        case manifestWindowSeconds = "ManifestWindowSeconds"
        case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
        case scteHls = "ScteHls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childManifestName = self.childManifestName {
            try encodeContainer.encode(childManifestName, forKey: .childManifestName)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let manifestWindowSeconds = self.manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if let programDateTimeIntervalSeconds = self.programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if let scteHls = self.scteHls {
            try encodeContainer.encode(scteHls, forKey: .scteHls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let childManifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childManifestName)
        childManifestName = childManifestNameDecoded
        let scteHlsDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ScteHls.self, forKey: .scteHls)
        scteHls = scteHlsDecoded
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// Create an HTTP live streaming (HLS) manifest configuration.
    public struct CreateHlsManifestConfiguration: Swift.Equatable {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index, with an added suffix to distinguish it from the manifest name. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public var childManifestName: Swift.String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The total duration (in seconds) of the manifest's content.
        public var manifestWindowSeconds: Swift.Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval, EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest. The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player. ID3Timed metadata messages generate every 5 seconds whenever the content is ingested. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// The SCTE configuration.
        public var scteHls: MediaPackageV2ClientTypes.ScteHls?

        public init (
            childManifestName: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            manifestWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            scteHls: MediaPackageV2ClientTypes.ScteHls? = nil
        )
        {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
        }
    }

}

extension MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childManifestName = "ChildManifestName"
        case manifestName = "ManifestName"
        case manifestWindowSeconds = "ManifestWindowSeconds"
        case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
        case scteHls = "ScteHls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childManifestName = self.childManifestName {
            try encodeContainer.encode(childManifestName, forKey: .childManifestName)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let manifestWindowSeconds = self.manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if let programDateTimeIntervalSeconds = self.programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if let scteHls = self.scteHls {
            try encodeContainer.encode(scteHls, forKey: .scteHls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let childManifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childManifestName)
        childManifestName = childManifestNameDecoded
        let scteHlsDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ScteHls.self, forKey: .scteHls)
        scteHls = scteHlsDecoded
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// Create a low-latency HTTP live streaming (HLS) manifest configuration.
    public struct CreateLowLatencyHlsManifestConfiguration: Swift.Equatable {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index, with an added suffix to distinguish it from the manifest name. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public var childManifestName: Swift.String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The total duration (in seconds) of the manifest's content.
        public var manifestWindowSeconds: Swift.Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval, EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest. The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player. ID3Timed metadata messages generate every 5 seconds whenever the content is ingested. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// The SCTE configuration.
        public var scteHls: MediaPackageV2ClientTypes.ScteHls?

        public init (
            childManifestName: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            manifestWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            scteHls: MediaPackageV2ClientTypes.ScteHls? = nil
        )
        {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
        }
    }

}

extension CreateOriginEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerType = "ContainerType"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case originEndpointName = "OriginEndpointName"
        case segment = "Segment"
        case startoverWindowSeconds = "StartoverWindowSeconds"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerType = self.containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for createhlsmanifestconfiguration0 in hlsManifests {
                try hlsManifestsContainer.encode(createhlsmanifestconfiguration0)
            }
        }
        if let lowLatencyHlsManifests = lowLatencyHlsManifests {
            var lowLatencyHlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lowLatencyHlsManifests)
            for createlowlatencyhlsmanifestconfiguration0 in lowLatencyHlsManifests {
                try lowLatencyHlsManifestsContainer.encode(createlowlatencyhlsmanifestconfiguration0)
            }
        }
        if let originEndpointName = self.originEndpointName {
            try encodeContainer.encode(originEndpointName, forKey: .originEndpointName)
        }
        if let segment = self.segment {
            try encodeContainer.encode(segment, forKey: .segment)
        }
        if let startoverWindowSeconds = self.startoverWindowSeconds {
            try encodeContainer.encode(startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateOriginEndpointInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "x-amzn-client-token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateOriginEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint"
    }
}

public struct CreateOriginEndpointInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The type of container to attach to this origin endpoint. A container type is a file format that encapsulates one or more media streams, such as audio and video, into a single file. You can't change the container type after you create the endpoint.
    /// This member is required.
    public var containerType: MediaPackageV2ClientTypes.ContainerType?
    /// Enter any descriptive text that helps you to identify the origin endpoint.
    public var description: Swift.String?
    /// An HTTP live streaming (HLS) manifest configuration.
    public var hlsManifests: [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]?
    /// A low-latency HLS manifest configuration.
    public var lowLatencyHlsManifests: [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and must be unique for your account in the AWS Region and channel. You can't use spaces in the name. You can't change the name after you create the endpoint.
    /// This member is required.
    public var originEndpointName: Swift.String?
    /// The segment configuration, including the segment name, duration, and other configuration values.
    public var segment: MediaPackageV2ClientTypes.Segment?
    /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window. The maximum startover window is 1,209,600 seconds (14 days).
    public var startoverWindowSeconds: Swift.Int?
    /// A comma-separated list of tag key:value pairs that you define. For example: "Key1": "Value1",
    ///     "Key2": "Value2"
    public var tags: [Swift.String:Swift.String]?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        containerType: MediaPackageV2ClientTypes.ContainerType? = nil,
        description: Swift.String? = nil,
        hlsManifests: [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]? = nil,
        lowLatencyHlsManifests: [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]? = nil,
        originEndpointName: Swift.String? = nil,
        segment: MediaPackageV2ClientTypes.Segment? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.clientToken = clientToken
        self.containerType = containerType
        self.description = description
        self.hlsManifests = hlsManifests
        self.lowLatencyHlsManifests = lowLatencyHlsManifests
        self.originEndpointName = originEndpointName
        self.segment = segment
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
    }
}

struct CreateOriginEndpointInputBody: Swift.Equatable {
    let originEndpointName: Swift.String?
    let containerType: MediaPackageV2ClientTypes.ContainerType?
    let segment: MediaPackageV2ClientTypes.Segment?
    let description: Swift.String?
    let startoverWindowSeconds: Swift.Int?
    let hlsManifests: [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]?
    let lowLatencyHlsManifests: [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateOriginEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerType = "ContainerType"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case originEndpointName = "OriginEndpointName"
        case segment = "Segment"
        case startoverWindowSeconds = "StartoverWindowSeconds"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointName)
        originEndpointName = originEndpointNameDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let segmentDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.Segment.self, forKey: .segment)
        segment = segmentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.CreateHlsManifestConfiguration?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let lowLatencyHlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration?].self, forKey: .lowLatencyHlsManifests)
        var lowLatencyHlsManifestsDecoded0:[MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]? = nil
        if let lowLatencyHlsManifestsContainer = lowLatencyHlsManifestsContainer {
            lowLatencyHlsManifestsDecoded0 = [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]()
            for structure0 in lowLatencyHlsManifestsContainer {
                if let structure0 = structure0 {
                    lowLatencyHlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        lowLatencyHlsManifests = lowLatencyHlsManifestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateOriginEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOriginEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateOriginEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOriginEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: CreateOriginEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.containerType = output.containerType
            self.createdAt = output.createdAt
            self.description = output.description
            self.hlsManifests = output.hlsManifests
            self.lowLatencyHlsManifests = output.lowLatencyHlsManifests
            self.modifiedAt = output.modifiedAt
            self.originEndpointName = output.originEndpointName
            self.segment = output.segment
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.channelName = nil
            self.containerType = nil
            self.createdAt = nil
            self.description = nil
            self.hlsManifests = nil
            self.lowLatencyHlsManifests = nil
            self.modifiedAt = nil
            self.originEndpointName = nil
            self.segment = nil
            self.startoverWindowSeconds = nil
            self.tags = nil
        }
    }
}

public struct CreateOriginEndpointOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The type of container attached to this origin endpoint.
    /// This member is required.
    public var containerType: MediaPackageV2ClientTypes.ContainerType?
    /// The date and time the origin endpoint was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your origin endpoint.
    public var description: Swift.String?
    /// An HTTP live streaming (HLS) manifest configuration.
    public var hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]?
    /// A low-latency HLS manifest configuration.
    public var lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]?
    /// The date and time the origin endpoint was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?
    /// The segment configuration, including the segment name, duration, and other configuration values.
    /// This member is required.
    public var segment: MediaPackageV2ClientTypes.Segment?
    /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window.
    public var startoverWindowSeconds: Swift.Int?
    /// The comma-separated list of tag key:value pairs assigned to the origin endpoint.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        containerType: MediaPackageV2ClientTypes.ContainerType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]? = nil,
        lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        originEndpointName: Swift.String? = nil,
        segment: MediaPackageV2ClientTypes.Segment? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.containerType = containerType
        self.createdAt = createdAt
        self.description = description
        self.hlsManifests = hlsManifests
        self.lowLatencyHlsManifests = lowLatencyHlsManifests
        self.modifiedAt = modifiedAt
        self.originEndpointName = originEndpointName
        self.segment = segment
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
    }
}

struct CreateOriginEndpointOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let channelGroupName: Swift.String?
    let channelName: Swift.String?
    let originEndpointName: Swift.String?
    let containerType: MediaPackageV2ClientTypes.ContainerType?
    let segment: MediaPackageV2ClientTypes.Segment?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let startoverWindowSeconds: Swift.Int?
    let hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]?
    let lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateOriginEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case containerType = "ContainerType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case modifiedAt = "ModifiedAt"
        case originEndpointName = "OriginEndpointName"
        case segment = "Segment"
        case startoverWindowSeconds = "StartoverWindowSeconds"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let originEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointName)
        originEndpointName = originEndpointNameDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let segmentDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.Segment.self, forKey: .segment)
        segment = segmentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.GetHlsManifestConfiguration?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageV2ClientTypes.GetHlsManifestConfiguration]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let lowLatencyHlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration?].self, forKey: .lowLatencyHlsManifests)
        var lowLatencyHlsManifestsDecoded0:[MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]? = nil
        if let lowLatencyHlsManifestsContainer = lowLatencyHlsManifestsContainer {
            lowLatencyHlsManifestsDecoded0 = [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]()
            for structure0 in lowLatencyHlsManifestsContainer {
                if let structure0 = structure0 {
                    lowLatencyHlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        lowLatencyHlsManifests = lowLatencyHlsManifestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DeleteChannelGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())"
    }
}

public struct DeleteChannelGroupInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
    }
}

struct DeleteChannelGroupInputBody: Swift.Equatable {
}

extension DeleteChannelGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteChannelGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())"
    }
}

public struct DeleteChannelInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
}

extension DeleteChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteChannelPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/policy"
    }
}

public struct DeleteChannelPolicyInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
    }
}

struct DeleteChannelPolicyInputBody: Swift.Equatable {
}

extension DeleteChannelPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteChannelPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteOriginEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        guard let originEndpointName = originEndpointName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint/\(originEndpointName.urlPercentEncoding())"
    }
}

public struct DeleteOriginEndpointInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        originEndpointName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.originEndpointName = originEndpointName
    }
}

struct DeleteOriginEndpointInputBody: Swift.Equatable {
}

extension DeleteOriginEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOriginEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOriginEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteOriginEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOriginEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOriginEndpointOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteOriginEndpointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        guard let originEndpointName = originEndpointName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint/\(originEndpointName.urlPercentEncoding())/policy"
    }
}

public struct DeleteOriginEndpointPolicyInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        originEndpointName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.originEndpointName = originEndpointName
    }
}

struct DeleteOriginEndpointPolicyInputBody: Swift.Equatable {
}

extension DeleteOriginEndpointPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOriginEndpointPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOriginEndpointPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteOriginEndpointPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOriginEndpointPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOriginEndpointPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension MediaPackageV2ClientTypes {
    public enum DrmSystem: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clearKeyAes128
        case fairplay
        case playready
        case widevine
        case sdkUnknown(Swift.String)

        public static var allCases: [DrmSystem] {
            return [
                .clearKeyAes128,
                .fairplay,
                .playready,
                .widevine,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clearKeyAes128: return "CLEAR_KEY_AES_128"
            case .fairplay: return "FAIRPLAY"
            case .playready: return "PLAYREADY"
            case .widevine: return "WIDEVINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DrmSystem(rawValue: rawValue) ?? DrmSystem.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageV2ClientTypes.Encryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constantInitializationVector = "ConstantInitializationVector"
        case encryptionMethod = "EncryptionMethod"
        case keyRotationIntervalSeconds = "KeyRotationIntervalSeconds"
        case spekeKeyProvider = "SpekeKeyProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constantInitializationVector = self.constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let encryptionMethod = self.encryptionMethod {
            try encodeContainer.encode(encryptionMethod, forKey: .encryptionMethod)
        }
        if let keyRotationIntervalSeconds = self.keyRotationIntervalSeconds {
            try encodeContainer.encode(keyRotationIntervalSeconds, forKey: .keyRotationIntervalSeconds)
        }
        if let spekeKeyProvider = self.spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let encryptionMethodDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.EncryptionMethod.self, forKey: .encryptionMethod)
        encryptionMethod = encryptionMethodDecoded
        let keyRotationIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .keyRotationIntervalSeconds)
        keyRotationIntervalSeconds = keyRotationIntervalSecondsDecoded
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The parameters for encrypting content.
    public struct Encryption: Swift.Equatable {
        /// A 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting content. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
        public var constantInitializationVector: Swift.String?
        /// The encryption method to use.
        /// This member is required.
        public var encryptionMethod: MediaPackageV2ClientTypes.EncryptionMethod?
        /// The frequency (in seconds) of key changes for live workflows, in which content is streamed real time. The service retrieves content keys before the live content begins streaming, and then retrieves them as needed over the lifetime of the workflow. By default, key rotation is set to 300 seconds (5 minutes), the minimum rotation interval, which is equivalent to setting it to 300. If you don't enter an interval, content keys aren't rotated. The following example setting causes the service to rotate keys every thirty minutes: 1800
        public var keyRotationIntervalSeconds: Swift.Int?
        /// The parameters for the SPEKE key provider.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageV2ClientTypes.SpekeKeyProvider?

        public init (
            constantInitializationVector: Swift.String? = nil,
            encryptionMethod: MediaPackageV2ClientTypes.EncryptionMethod? = nil,
            keyRotationIntervalSeconds: Swift.Int? = nil,
            spekeKeyProvider: MediaPackageV2ClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageV2ClientTypes.EncryptionContractConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case presetSpeke20Audio = "PresetSpeke20Audio"
        case presetSpeke20Video = "PresetSpeke20Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let presetSpeke20Audio = self.presetSpeke20Audio {
            try encodeContainer.encode(presetSpeke20Audio.rawValue, forKey: .presetSpeke20Audio)
        }
        if let presetSpeke20Video = self.presetSpeke20Video {
            try encodeContainer.encode(presetSpeke20Video.rawValue, forKey: .presetSpeke20Video)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presetSpeke20AudioDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.PresetSpeke20Audio.self, forKey: .presetSpeke20Audio)
        presetSpeke20Audio = presetSpeke20AudioDecoded
        let presetSpeke20VideoDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.PresetSpeke20Video.self, forKey: .presetSpeke20Video)
        presetSpeke20Video = presetSpeke20VideoDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// Configure one or more content encryption keys for your endpoints that use SPEKE Version 2.0. The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream. To configure the encryption contract, specify which audio and video encryption presets to use.
    public struct EncryptionContractConfiguration: Swift.Equatable {
        /// A collection of audio encryption presets. Value description:
        ///
        /// * PRESET-AUDIO-1 - Use one content key to encrypt all of the audio tracks in your stream.
        ///
        /// * PRESET-AUDIO-2 - Use one content key to encrypt all of the stereo audio tracks and one content key to encrypt all of the multichannel audio tracks.
        ///
        /// * PRESET-AUDIO-3 - Use one content key to encrypt all of the stereo audio tracks, one content key to encrypt all of the multichannel audio tracks with 3 to 6 channels, and one content key to encrypt all of the multichannel audio tracks with more than 6 channels.
        ///
        /// * SHARED - Use the same content key for all of the audio and video tracks in your stream.
        ///
        /// * UNENCRYPTED - Don't encrypt any of the audio tracks in your stream.
        /// This member is required.
        public var presetSpeke20Audio: MediaPackageV2ClientTypes.PresetSpeke20Audio?
        /// A collection of video encryption presets. Value description:
        ///
        /// * PRESET-VIDEO-1 - Use one content key to encrypt all of the video tracks in your stream.
        ///
        /// * PRESET-VIDEO-2 - Use one content key to encrypt all of the SD video tracks and one content key for all HD and higher resolutions video tracks.
        ///
        /// * PRESET-VIDEO-3 - Use one content key to encrypt all of the SD video tracks, one content key for HD video tracks and one content key for all UHD video tracks.
        ///
        /// * PRESET-VIDEO-4 - Use one content key to encrypt all of the SD video tracks, one content key for HD video tracks, one content key for all UHD1 video tracks and one content key for all UHD2 video tracks.
        ///
        /// * PRESET-VIDEO-5 - Use one content key to encrypt all of the SD video tracks, one content key for HD1 video tracks, one content key for HD2 video tracks, one content key for all UHD1 video tracks and one content key for all UHD2 video tracks.
        ///
        /// * PRESET-VIDEO-6 - Use one content key to encrypt all of the SD video tracks, one content key for HD1 video tracks, one content key for HD2 video tracks and one content key for all UHD video tracks.
        ///
        /// * PRESET-VIDEO-7 - Use one content key to encrypt all of the SD+HD1 video tracks, one content key for HD2 video tracks and one content key for all UHD video tracks.
        ///
        /// * PRESET-VIDEO-8 - Use one content key to encrypt all of the SD+HD1 video tracks, one content key for HD2 video tracks, one content key for all UHD1 video tracks and one content key for all UHD2 video tracks.
        ///
        /// * SHARED - Use the same content key for all of the video and audio tracks in your stream.
        ///
        /// * UNENCRYPTED - Don't encrypt any of the video tracks in your stream.
        /// This member is required.
        public var presetSpeke20Video: MediaPackageV2ClientTypes.PresetSpeke20Video?

        public init (
            presetSpeke20Audio: MediaPackageV2ClientTypes.PresetSpeke20Audio? = nil,
            presetSpeke20Video: MediaPackageV2ClientTypes.PresetSpeke20Video? = nil
        )
        {
            self.presetSpeke20Audio = presetSpeke20Audio
            self.presetSpeke20Video = presetSpeke20Video
        }
    }

}

extension MediaPackageV2ClientTypes.EncryptionMethod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cmafEncryptionMethod = "CmafEncryptionMethod"
        case tsEncryptionMethod = "TsEncryptionMethod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cmafEncryptionMethod = self.cmafEncryptionMethod {
            try encodeContainer.encode(cmafEncryptionMethod.rawValue, forKey: .cmafEncryptionMethod)
        }
        if let tsEncryptionMethod = self.tsEncryptionMethod {
            try encodeContainer.encode(tsEncryptionMethod.rawValue, forKey: .tsEncryptionMethod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tsEncryptionMethodDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.TsEncryptionMethod.self, forKey: .tsEncryptionMethod)
        tsEncryptionMethod = tsEncryptionMethodDecoded
        let cmafEncryptionMethodDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.CmafEncryptionMethod.self, forKey: .cmafEncryptionMethod)
        cmafEncryptionMethod = cmafEncryptionMethodDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The encryption type.
    public struct EncryptionMethod: Swift.Equatable {
        /// The encryption method to use.
        public var cmafEncryptionMethod: MediaPackageV2ClientTypes.CmafEncryptionMethod?
        /// The encryption method to use.
        public var tsEncryptionMethod: MediaPackageV2ClientTypes.TsEncryptionMethod?

        public init (
            cmafEncryptionMethod: MediaPackageV2ClientTypes.CmafEncryptionMethod? = nil,
            tsEncryptionMethod: MediaPackageV2ClientTypes.TsEncryptionMethod? = nil
        )
        {
            self.cmafEncryptionMethod = cmafEncryptionMethod
            self.tsEncryptionMethod = tsEncryptionMethod
        }
    }

}

extension GetChannelGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())"
    }
}

public struct GetChannelGroupInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
    }
}

struct GetChannelGroupInputBody: Swift.Equatable {
}

extension GetChannelGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetChannelGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetChannelGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.createdAt = output.createdAt
            self.description = output.description
            self.egressDomain = output.egressDomain
            self.modifiedAt = output.modifiedAt
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.createdAt = nil
            self.description = nil
            self.egressDomain = nil
            self.modifiedAt = nil
            self.tags = nil
        }
    }
}

public struct GetChannelGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The date and time the channel group was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your channel group.
    public var description: Swift.String?
    /// The output domain where the source stream should be sent. Integrate the domain with a downstream CDN (such as Amazon CloudFront) or playback device.
    /// This member is required.
    public var egressDomain: Swift.String?
    /// The date and time the channel group was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The comma-separated list of tag key:value pairs assigned to the channel group.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        egressDomain: Swift.String? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.createdAt = createdAt
        self.description = description
        self.egressDomain = egressDomain
        self.modifiedAt = modifiedAt
        self.tags = tags
    }
}

struct GetChannelGroupOutputResponseBody: Swift.Equatable {
    let channelGroupName: Swift.String?
    let arn: Swift.String?
    let egressDomain: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetChannelGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case egressDomain = "EgressDomain"
        case modifiedAt = "ModifiedAt"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let egressDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .egressDomain)
        egressDomain = egressDomainDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())"
    }
}

public struct GetChannelInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
    }
}

struct GetChannelInputBody: Swift.Equatable {
}

extension GetChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.createdAt = output.createdAt
            self.description = output.description
            self.ingestEndpoints = output.ingestEndpoints
            self.modifiedAt = output.modifiedAt
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.channelName = nil
            self.createdAt = nil
            self.description = nil
            self.ingestEndpoints = nil
            self.modifiedAt = nil
            self.tags = nil
        }
    }
}

public struct GetChannelOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The date and time the channel was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your channel.
    public var description: Swift.String?
    /// The list of ingest endpoints.
    public var ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]?
    /// The date and time the channel was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The comma-separated list of tag key:value pairs assigned to the channel.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.createdAt = createdAt
        self.description = description
        self.ingestEndpoints = ingestEndpoints
        self.modifiedAt = modifiedAt
        self.tags = tags
    }
}

struct GetChannelOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let channelName: Swift.String?
    let channelGroupName: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]?
    let tags: [Swift.String:Swift.String]?
}

extension GetChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case ingestEndpoints = "IngestEndpoints"
        case modifiedAt = "ModifiedAt"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ingestEndpointsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.IngestEndpoint?].self, forKey: .ingestEndpoints)
        var ingestEndpointsDecoded0:[MediaPackageV2ClientTypes.IngestEndpoint]? = nil
        if let ingestEndpointsContainer = ingestEndpointsContainer {
            ingestEndpointsDecoded0 = [MediaPackageV2ClientTypes.IngestEndpoint]()
            for structure0 in ingestEndpointsContainer {
                if let structure0 = structure0 {
                    ingestEndpointsDecoded0?.append(structure0)
                }
            }
        }
        ingestEndpoints = ingestEndpointsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetChannelPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/policy"
    }
}

public struct GetChannelPolicyInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
    }
}

struct GetChannelPolicyInputBody: Swift.Equatable {
}

extension GetChannelPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetChannelPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetChannelPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.policy = output.policy
        } else {
            self.channelGroupName = nil
            self.channelName = nil
            self.policy = nil
        }
    }
}

public struct GetChannelPolicyOutputResponse: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The policy assigned to the channel.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.policy = policy
    }
}

struct GetChannelPolicyOutputResponseBody: Swift.Equatable {
    let channelGroupName: Swift.String?
    let channelName: Swift.String?
    let policy: Swift.String?
}

extension GetChannelPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension MediaPackageV2ClientTypes.GetHlsManifestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childManifestName = "ChildManifestName"
        case manifestName = "ManifestName"
        case manifestWindowSeconds = "ManifestWindowSeconds"
        case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
        case scteHls = "ScteHls"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childManifestName = self.childManifestName {
            try encodeContainer.encode(childManifestName, forKey: .childManifestName)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let manifestWindowSeconds = self.manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if let programDateTimeIntervalSeconds = self.programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if let scteHls = self.scteHls {
            try encodeContainer.encode(scteHls, forKey: .scteHls)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let childManifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childManifestName)
        childManifestName = childManifestNameDecoded
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
        let scteHlsDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ScteHls.self, forKey: .scteHls)
        scteHls = scteHlsDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// Retrieve the HTTP live streaming (HLS) manifest configuration.
    public struct GetHlsManifestConfiguration: Swift.Equatable {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public var childManifestName: Swift.String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The total duration (in seconds) of the manifest's content.
        public var manifestWindowSeconds: Swift.Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval, EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest. The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player. ID3Timed metadata messages generate every 5 seconds whenever the content is ingested. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// The SCTE configuration.
        public var scteHls: MediaPackageV2ClientTypes.ScteHls?
        /// The egress domain URL for stream delivery from MediaPackage.
        /// This member is required.
        public var url: Swift.String?

        public init (
            childManifestName: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            manifestWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            scteHls: MediaPackageV2ClientTypes.ScteHls? = nil,
            url: Swift.String? = nil
        )
        {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
            self.url = url
        }
    }

}

extension MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childManifestName = "ChildManifestName"
        case manifestName = "ManifestName"
        case manifestWindowSeconds = "ManifestWindowSeconds"
        case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
        case scteHls = "ScteHls"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childManifestName = self.childManifestName {
            try encodeContainer.encode(childManifestName, forKey: .childManifestName)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let manifestWindowSeconds = self.manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if let programDateTimeIntervalSeconds = self.programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if let scteHls = self.scteHls {
            try encodeContainer.encode(scteHls, forKey: .scteHls)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let childManifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childManifestName)
        childManifestName = childManifestNameDecoded
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
        let scteHlsDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ScteHls.self, forKey: .scteHls)
        scteHls = scteHlsDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// Retrieve the low-latency HTTP live streaming (HLS) manifest configuration.
    public struct GetLowLatencyHlsManifestConfiguration: Swift.Equatable {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public var childManifestName: Swift.String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The total duration (in seconds) of the manifest's content.
        public var manifestWindowSeconds: Swift.Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval, EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest. The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player. ID3Timed metadata messages generate every 5 seconds whenever the content is ingested. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// The SCTE configuration.
        public var scteHls: MediaPackageV2ClientTypes.ScteHls?
        /// The egress domain URL for stream delivery from MediaPackage.
        /// This member is required.
        public var url: Swift.String?

        public init (
            childManifestName: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            manifestWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            scteHls: MediaPackageV2ClientTypes.ScteHls? = nil,
            url: Swift.String? = nil
        )
        {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
            self.url = url
        }
    }

}

extension GetOriginEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        guard let originEndpointName = originEndpointName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint/\(originEndpointName.urlPercentEncoding())"
    }
}

public struct GetOriginEndpointInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        originEndpointName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.originEndpointName = originEndpointName
    }
}

struct GetOriginEndpointInputBody: Swift.Equatable {
}

extension GetOriginEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOriginEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOriginEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetOriginEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOriginEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetOriginEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.containerType = output.containerType
            self.createdAt = output.createdAt
            self.description = output.description
            self.hlsManifests = output.hlsManifests
            self.lowLatencyHlsManifests = output.lowLatencyHlsManifests
            self.modifiedAt = output.modifiedAt
            self.originEndpointName = output.originEndpointName
            self.segment = output.segment
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.channelName = nil
            self.containerType = nil
            self.createdAt = nil
            self.description = nil
            self.hlsManifests = nil
            self.lowLatencyHlsManifests = nil
            self.modifiedAt = nil
            self.originEndpointName = nil
            self.segment = nil
            self.startoverWindowSeconds = nil
            self.tags = nil
        }
    }
}

public struct GetOriginEndpointOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The type of container attached to this origin endpoint.
    /// This member is required.
    public var containerType: MediaPackageV2ClientTypes.ContainerType?
    /// The date and time the origin endpoint was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your origin endpoint.
    public var description: Swift.String?
    /// An HTTP live streaming (HLS) manifest configuration.
    public var hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]?
    /// A low-latency HLS manifest configuration.
    public var lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]?
    /// The date and time the origin endpoint was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?
    /// The segment configuration, including the segment name, duration, and other configuration values.
    /// This member is required.
    public var segment: MediaPackageV2ClientTypes.Segment?
    /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window.
    public var startoverWindowSeconds: Swift.Int?
    /// The comma-separated list of tag key:value pairs assigned to the origin endpoint.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        containerType: MediaPackageV2ClientTypes.ContainerType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]? = nil,
        lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        originEndpointName: Swift.String? = nil,
        segment: MediaPackageV2ClientTypes.Segment? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.containerType = containerType
        self.createdAt = createdAt
        self.description = description
        self.hlsManifests = hlsManifests
        self.lowLatencyHlsManifests = lowLatencyHlsManifests
        self.modifiedAt = modifiedAt
        self.originEndpointName = originEndpointName
        self.segment = segment
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
    }
}

struct GetOriginEndpointOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let channelGroupName: Swift.String?
    let channelName: Swift.String?
    let originEndpointName: Swift.String?
    let containerType: MediaPackageV2ClientTypes.ContainerType?
    let segment: MediaPackageV2ClientTypes.Segment?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let startoverWindowSeconds: Swift.Int?
    let hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]?
    let lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]?
    let tags: [Swift.String:Swift.String]?
}

extension GetOriginEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case containerType = "ContainerType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case modifiedAt = "ModifiedAt"
        case originEndpointName = "OriginEndpointName"
        case segment = "Segment"
        case startoverWindowSeconds = "StartoverWindowSeconds"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let originEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointName)
        originEndpointName = originEndpointNameDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let segmentDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.Segment.self, forKey: .segment)
        segment = segmentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.GetHlsManifestConfiguration?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageV2ClientTypes.GetHlsManifestConfiguration]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let lowLatencyHlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration?].self, forKey: .lowLatencyHlsManifests)
        var lowLatencyHlsManifestsDecoded0:[MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]? = nil
        if let lowLatencyHlsManifestsContainer = lowLatencyHlsManifestsContainer {
            lowLatencyHlsManifestsDecoded0 = [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]()
            for structure0 in lowLatencyHlsManifestsContainer {
                if let structure0 = structure0 {
                    lowLatencyHlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        lowLatencyHlsManifests = lowLatencyHlsManifestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetOriginEndpointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        guard let originEndpointName = originEndpointName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint/\(originEndpointName.urlPercentEncoding())/policy"
    }
}

public struct GetOriginEndpointPolicyInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        originEndpointName: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.originEndpointName = originEndpointName
    }
}

struct GetOriginEndpointPolicyInputBody: Swift.Equatable {
}

extension GetOriginEndpointPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOriginEndpointPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOriginEndpointPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetOriginEndpointPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOriginEndpointPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetOriginEndpointPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.originEndpointName = output.originEndpointName
            self.policy = output.policy
        } else {
            self.channelGroupName = nil
            self.channelName = nil
            self.originEndpointName = nil
            self.policy = nil
        }
    }
}

public struct GetOriginEndpointPolicyOutputResponse: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?
    /// The policy assigned to the origin endpoint.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        originEndpointName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.originEndpointName = originEndpointName
        self.policy = policy
    }
}

struct GetOriginEndpointPolicyOutputResponseBody: Swift.Equatable {
    let channelGroupName: Swift.String?
    let channelName: Swift.String?
    let originEndpointName: Swift.String?
    let policy: Swift.String?
}

extension GetOriginEndpointPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case originEndpointName = "OriginEndpointName"
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let originEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointName)
        originEndpointName = originEndpointNameDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension MediaPackageV2ClientTypes.IngestEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The ingest domain URL where the source stream should be sent.
    public struct IngestEndpoint: Swift.Equatable {
        /// The system-generated unique identifier for the IngestEndpoint.
        public var id: Swift.String?
        /// The ingest domain URL where the source stream should be sent.
        public var url: Swift.String?

        public init (
            id: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.id = id
            self.url = url
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that an error from the service occurred while trying to process a request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable, Swift.Error {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChannelGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channelGroup"
    }
}

public struct ListChannelGroupsInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelGroupsInputBody: Swift.Equatable {
}

extension ListChannelGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChannelGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ListChannelGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelGroupsOutputResponse: Swift.Equatable {
    /// The objects being returned.
    public var items: [MediaPackageV2ClientTypes.ChannelGroupListConfiguration]?
    /// The pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaPackageV2ClientTypes.ChannelGroupListConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListChannelGroupsOutputResponseBody: Swift.Equatable {
    let items: [MediaPackageV2ClientTypes.ChannelGroupListConfiguration]?
    let nextToken: Swift.String?
}

extension ListChannelGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.ChannelGroupListConfiguration?].self, forKey: .items)
        var itemsDecoded0:[MediaPackageV2ClientTypes.ChannelGroupListConfiguration]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaPackageV2ClientTypes.ChannelGroupListConfiguration]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel"
    }
}

public struct ListChannelsInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Swift.Equatable {
}

extension ListChannelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChannelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Swift.Equatable {
    /// The objects being returned.
    public var items: [MediaPackageV2ClientTypes.ChannelListConfiguration]?
    /// The pagination token from the GET list request.
    public var nextToken: Swift.String?

    public init (
        items: [MediaPackageV2ClientTypes.ChannelListConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Swift.Equatable {
    let items: [MediaPackageV2ClientTypes.ChannelListConfiguration]?
    let nextToken: Swift.String?
}

extension ListChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.ChannelListConfiguration?].self, forKey: .items)
        var itemsDecoded0:[MediaPackageV2ClientTypes.ChannelListConfiguration]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaPackageV2ClientTypes.ChannelListConfiguration]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MediaPackageV2ClientTypes.ListHlsManifestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childManifestName = "ChildManifestName"
        case manifestName = "ManifestName"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childManifestName = self.childManifestName {
            try encodeContainer.encode(childManifestName, forKey: .childManifestName)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let childManifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childManifestName)
        childManifestName = childManifestNameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// List the HTTP live streaming (HLS) manifest configuration.
    public struct ListHlsManifestConfiguration: Swift.Equatable {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public var childManifestName: Swift.String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The egress domain URL for stream delivery from MediaPackage.
        public var url: Swift.String?

        public init (
            childManifestName: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.url = url
        }
    }

}

extension MediaPackageV2ClientTypes.ListLowLatencyHlsManifestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childManifestName = "ChildManifestName"
        case manifestName = "ManifestName"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childManifestName = self.childManifestName {
            try encodeContainer.encode(childManifestName, forKey: .childManifestName)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let childManifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childManifestName)
        childManifestName = childManifestNameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// List the low-latency HTTP live streaming (HLS) manifest configuration.
    public struct ListLowLatencyHlsManifestConfiguration: Swift.Equatable {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public var childManifestName: Swift.String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The egress domain URL for stream delivery from MediaPackage.
        public var url: Swift.String?

        public init (
            childManifestName: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.url = url
        }
    }

}

extension ListOriginEndpointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListOriginEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint"
    }
}

public struct ListOriginEndpointsInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOriginEndpointsInputBody: Swift.Equatable {
}

extension ListOriginEndpointsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListOriginEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOriginEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListOriginEndpointsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOriginEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ListOriginEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListOriginEndpointsOutputResponse: Swift.Equatable {
    /// The objects being returned.
    public var items: [MediaPackageV2ClientTypes.OriginEndpointListConfiguration]?
    /// The pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaPackageV2ClientTypes.OriginEndpointListConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListOriginEndpointsOutputResponseBody: Swift.Equatable {
    let items: [MediaPackageV2ClientTypes.OriginEndpointListConfiguration]?
    let nextToken: Swift.String?
}

extension ListOriginEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.OriginEndpointListConfiguration?].self, forKey: .items)
        var itemsDecoded0:[MediaPackageV2ClientTypes.OriginEndpointListConfiguration]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaPackageV2ClientTypes.OriginEndpointListConfiguration]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the CloudWatch resource that you want to view tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaPackageV2ClientTypes.OriginEndpointListConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case containerType = "ContainerType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case modifiedAt = "ModifiedAt"
        case originEndpointName = "OriginEndpointName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelGroupName = self.channelGroupName {
            try encodeContainer.encode(channelGroupName, forKey: .channelGroupName)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let containerType = self.containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for listhlsmanifestconfiguration0 in hlsManifests {
                try hlsManifestsContainer.encode(listhlsmanifestconfiguration0)
            }
        }
        if let lowLatencyHlsManifests = lowLatencyHlsManifests {
            var lowLatencyHlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lowLatencyHlsManifests)
            for listlowlatencyhlsmanifestconfiguration0 in lowLatencyHlsManifests {
                try lowLatencyHlsManifestsContainer.encode(listlowlatencyhlsmanifestconfiguration0)
            }
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .epochSeconds, forKey: .modifiedAt)
        }
        if let originEndpointName = self.originEndpointName {
            try encodeContainer.encode(originEndpointName, forKey: .originEndpointName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let originEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointName)
        originEndpointName = originEndpointNameDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.ListHlsManifestConfiguration?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageV2ClientTypes.ListHlsManifestConfiguration]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageV2ClientTypes.ListHlsManifestConfiguration]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let lowLatencyHlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.ListLowLatencyHlsManifestConfiguration?].self, forKey: .lowLatencyHlsManifests)
        var lowLatencyHlsManifestsDecoded0:[MediaPackageV2ClientTypes.ListLowLatencyHlsManifestConfiguration]? = nil
        if let lowLatencyHlsManifestsContainer = lowLatencyHlsManifestsContainer {
            lowLatencyHlsManifestsDecoded0 = [MediaPackageV2ClientTypes.ListLowLatencyHlsManifestConfiguration]()
            for structure0 in lowLatencyHlsManifestsContainer {
                if let structure0 = structure0 {
                    lowLatencyHlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        lowLatencyHlsManifests = lowLatencyHlsManifestsDecoded0
    }
}

extension MediaPackageV2ClientTypes {
    /// The configuration of the origin endpoint.
    public struct OriginEndpointListConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) associated with the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        /// This member is required.
        public var channelGroupName: Swift.String?
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        /// This member is required.
        public var channelName: Swift.String?
        /// The type of container attached to this origin endpoint. A container type is a file format that encapsulates one or more media streams, such as audio and video, into a single file.
        /// This member is required.
        public var containerType: MediaPackageV2ClientTypes.ContainerType?
        /// The date and time the origin endpoint was created.
        public var createdAt: ClientRuntime.Date?
        /// Any descriptive information that you want to add to the origin endpoint for future identification purposes.
        public var description: Swift.String?
        /// An HTTP live streaming (HLS) manifest configuration.
        public var hlsManifests: [MediaPackageV2ClientTypes.ListHlsManifestConfiguration]?
        /// A low-latency HLS manifest configuration.
        public var lowLatencyHlsManifests: [MediaPackageV2ClientTypes.ListLowLatencyHlsManifestConfiguration]?
        /// The date and time the origin endpoint was modified.
        public var modifiedAt: ClientRuntime.Date?
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        /// This member is required.
        public var originEndpointName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            channelGroupName: Swift.String? = nil,
            channelName: Swift.String? = nil,
            containerType: MediaPackageV2ClientTypes.ContainerType? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            hlsManifests: [MediaPackageV2ClientTypes.ListHlsManifestConfiguration]? = nil,
            lowLatencyHlsManifests: [MediaPackageV2ClientTypes.ListLowLatencyHlsManifestConfiguration]? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            originEndpointName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.containerType = containerType
            self.createdAt = createdAt
            self.description = description
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
            self.modifiedAt = modifiedAt
            self.originEndpointName = originEndpointName
        }
    }

}

extension MediaPackageV2ClientTypes {
    public enum PresetSpeke20Audio: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case presetAudio1
        case presetAudio2
        case presetAudio3
        case shared
        case unencrypted
        case sdkUnknown(Swift.String)

        public static var allCases: [PresetSpeke20Audio] {
            return [
                .presetAudio1,
                .presetAudio2,
                .presetAudio3,
                .shared,
                .unencrypted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .presetAudio1: return "PRESET_AUDIO_1"
            case .presetAudio2: return "PRESET_AUDIO_2"
            case .presetAudio3: return "PRESET_AUDIO_3"
            case .shared: return "SHARED"
            case .unencrypted: return "UNENCRYPTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PresetSpeke20Audio(rawValue: rawValue) ?? PresetSpeke20Audio.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageV2ClientTypes {
    public enum PresetSpeke20Video: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case presetVideo1
        case presetVideo2
        case presetVideo3
        case presetVideo4
        case presetVideo5
        case presetVideo6
        case presetVideo7
        case presetVideo8
        case shared
        case unencrypted
        case sdkUnknown(Swift.String)

        public static var allCases: [PresetSpeke20Video] {
            return [
                .presetVideo1,
                .presetVideo2,
                .presetVideo3,
                .presetVideo4,
                .presetVideo5,
                .presetVideo6,
                .presetVideo7,
                .presetVideo8,
                .shared,
                .unencrypted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .presetVideo1: return "PRESET_VIDEO_1"
            case .presetVideo2: return "PRESET_VIDEO_2"
            case .presetVideo3: return "PRESET_VIDEO_3"
            case .presetVideo4: return "PRESET_VIDEO_4"
            case .presetVideo5: return "PRESET_VIDEO_5"
            case .presetVideo6: return "PRESET_VIDEO_6"
            case .presetVideo7: return "PRESET_VIDEO_7"
            case .presetVideo8: return "PRESET_VIDEO_8"
            case .shared: return "SHARED"
            case .unencrypted: return "UNENCRYPTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PresetSpeke20Video(rawValue: rawValue) ?? PresetSpeke20Video.sdkUnknown(rawValue)
        }
    }
}

extension PutChannelPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutChannelPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/policy"
    }
}

public struct PutChannelPolicyInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The policy to attach to the specified channel.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.policy = policy
    }
}

struct PutChannelPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutChannelPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutChannelPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutChannelPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutChannelPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutChannelPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutChannelPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutOriginEndpointPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutOriginEndpointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        guard let originEndpointName = originEndpointName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint/\(originEndpointName.urlPercentEncoding())/policy"
    }
}

public struct PutOriginEndpointPolicyInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?
    /// The policy to attach to the specified origin endpoint.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        originEndpointName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.originEndpointName = originEndpointName
        self.policy = policy
    }
}

struct PutOriginEndpointPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutOriginEndpointPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutOriginEndpointPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutOriginEndpointPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutOriginEndpointPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutOriginEndpointPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutOriginEndpointPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceTypeNotFound = output.resourceTypeNotFound
        } else {
            self.message = nil
            self.resourceTypeNotFound = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource doesn't exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable, Swift.Error {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The specified resource type wasn't found.
    public var resourceTypeNotFound: MediaPackageV2ClientTypes.ResourceTypeNotFound?

    public init (
        message: Swift.String? = nil,
        resourceTypeNotFound: MediaPackageV2ClientTypes.ResourceTypeNotFound? = nil
    )
    {
        self.message = message
        self.resourceTypeNotFound = resourceTypeNotFound
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceTypeNotFound: MediaPackageV2ClientTypes.ResourceTypeNotFound?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceTypeNotFound = "ResourceTypeNotFound"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeNotFoundDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ResourceTypeNotFound.self, forKey: .resourceTypeNotFound)
        resourceTypeNotFound = resourceTypeNotFoundDecoded
    }
}

extension MediaPackageV2ClientTypes {
    public enum ResourceTypeNotFound: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case channel
        case channelGroup
        case originEndpoint
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceTypeNotFound] {
            return [
                .channel,
                .channelGroup,
                .originEndpoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .channel: return "CHANNEL"
            case .channelGroup: return "CHANNEL_GROUP"
            case .originEndpoint: return "ORIGIN_ENDPOINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceTypeNotFound(rawValue: rawValue) ?? ResourceTypeNotFound.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageV2ClientTypes.Scte: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scteFilter = "ScteFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scteFilter = scteFilter {
            var scteFilterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scteFilter)
            for sctefilter0 in scteFilter {
                try scteFilterContainer.encode(sctefilter0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scteFilterContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.ScteFilter?].self, forKey: .scteFilter)
        var scteFilterDecoded0:[MediaPackageV2ClientTypes.ScteFilter]? = nil
        if let scteFilterContainer = scteFilterContainer {
            scteFilterDecoded0 = [MediaPackageV2ClientTypes.ScteFilter]()
            for enum0 in scteFilterContainer {
                if let enum0 = enum0 {
                    scteFilterDecoded0?.append(enum0)
                }
            }
        }
        scteFilter = scteFilterDecoded0
    }
}

extension MediaPackageV2ClientTypes {
    /// The SCTE configuration.
    public struct Scte: Swift.Equatable {
        /// The SCTE-35 message types that you want to be treated as ad markers in the output.
        public var scteFilter: [MediaPackageV2ClientTypes.ScteFilter]?

        public init (
            scteFilter: [MediaPackageV2ClientTypes.ScteFilter]? = nil
        )
        {
            self.scteFilter = scteFilter
        }
    }

}

extension MediaPackageV2ClientTypes {
    public enum ScteFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `break`
        case distributorAdvertisement
        case distributorOverlayPlacementOpportunity
        case distributorPlacementOpportunity
        case program
        case providerAdvertisement
        case providerOverlayPlacementOpportunity
        case providerPlacementOpportunity
        case spliceInsert
        case sdkUnknown(Swift.String)

        public static var allCases: [ScteFilter] {
            return [
                .break,
                .distributorAdvertisement,
                .distributorOverlayPlacementOpportunity,
                .distributorPlacementOpportunity,
                .program,
                .providerAdvertisement,
                .providerOverlayPlacementOpportunity,
                .providerPlacementOpportunity,
                .spliceInsert,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .break: return "BREAK"
            case .distributorAdvertisement: return "DISTRIBUTOR_ADVERTISEMENT"
            case .distributorOverlayPlacementOpportunity: return "DISTRIBUTOR_OVERLAY_PLACEMENT_OPPORTUNITY"
            case .distributorPlacementOpportunity: return "DISTRIBUTOR_PLACEMENT_OPPORTUNITY"
            case .program: return "PROGRAM"
            case .providerAdvertisement: return "PROVIDER_ADVERTISEMENT"
            case .providerOverlayPlacementOpportunity: return "PROVIDER_OVERLAY_PLACEMENT_OPPORTUNITY"
            case .providerPlacementOpportunity: return "PROVIDER_PLACEMENT_OPPORTUNITY"
            case .spliceInsert: return "SPLICE_INSERT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScteFilter(rawValue: rawValue) ?? ScteFilter.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageV2ClientTypes.ScteHls: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adMarkerHls = "AdMarkerHls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkerHls = self.adMarkerHls {
            try encodeContainer.encode(adMarkerHls.rawValue, forKey: .adMarkerHls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkerHlsDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.AdMarkerHls.self, forKey: .adMarkerHls)
        adMarkerHls = adMarkerHlsDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The SCTE configuration.
    public struct ScteHls: Swift.Equatable {
        /// Ad markers indicate when ads should be inserted during playback. If you include ad markers in the content stream in your upstream encoders, then you need to inform MediaPackage what to do with the ad markers in the output. Choose what you want MediaPackage to do with the ad markers. Value description:
        ///
        /// * DATERANGE - Insert EXT-X-DATERANGE tags to signal ad and program transition events in TS and CMAF manifests. If you use DATERANGE, you must set a programDateTimeIntervalSeconds value of 1 or higher. To learn more about DATERANGE, see [SCTE-35 Ad Marker EXT-X-DATERANGE](http://docs.aws.amazon.com/mediapackage/latest/ug/scte-35-ad-marker-ext-x-daterange.html).
        public var adMarkerHls: MediaPackageV2ClientTypes.AdMarkerHls?

        public init (
            adMarkerHls: MediaPackageV2ClientTypes.AdMarkerHls? = nil
        )
        {
            self.adMarkerHls = adMarkerHls
        }
    }

}

extension MediaPackageV2ClientTypes.Segment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "Encryption"
        case includeIframeOnlyStreams = "IncludeIframeOnlyStreams"
        case scte = "Scte"
        case segmentDurationSeconds = "SegmentDurationSeconds"
        case segmentName = "SegmentName"
        case tsIncludeDvbSubtitles = "TsIncludeDvbSubtitles"
        case tsUseAudioRenditionGroup = "TsUseAudioRenditionGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let includeIframeOnlyStreams = self.includeIframeOnlyStreams {
            try encodeContainer.encode(includeIframeOnlyStreams, forKey: .includeIframeOnlyStreams)
        }
        if let scte = self.scte {
            try encodeContainer.encode(scte, forKey: .scte)
        }
        if let segmentDurationSeconds = self.segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let segmentName = self.segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
        if let tsIncludeDvbSubtitles = self.tsIncludeDvbSubtitles {
            try encodeContainer.encode(tsIncludeDvbSubtitles, forKey: .tsIncludeDvbSubtitles)
        }
        if let tsUseAudioRenditionGroup = self.tsUseAudioRenditionGroup {
            try encodeContainer.encode(tsUseAudioRenditionGroup, forKey: .tsUseAudioRenditionGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let segmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
        let tsUseAudioRenditionGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .tsUseAudioRenditionGroup)
        tsUseAudioRenditionGroup = tsUseAudioRenditionGroupDecoded
        let includeIframeOnlyStreamsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeIframeOnlyStreams)
        includeIframeOnlyStreams = includeIframeOnlyStreamsDecoded
        let tsIncludeDvbSubtitlesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .tsIncludeDvbSubtitles)
        tsIncludeDvbSubtitles = tsIncludeDvbSubtitlesDecoded
        let scteDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.Scte.self, forKey: .scte)
        scte = scteDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The segment configuration, including the segment name, duration, and other configuration values.
    public struct Segment: Swift.Equatable {
        /// The parameters for encrypting content.
        public var encryption: MediaPackageV2ClientTypes.Encryption?
        /// When selected, the stream set includes an additional I-frame only stream, along with the other tracks. If false, this extra stream is not included. MediaPackage generates an I-frame only stream from the first rendition in the manifest. The service inserts EXT-I-FRAMES-ONLY tags in the output manifest, and then generates and includes an I-frames only playlist in the stream. This playlist permits player functionality like fast forward and rewind.
        public var includeIframeOnlyStreams: Swift.Bool?
        /// The SCTE configuration options in the segment settings.
        public var scte: MediaPackageV2ClientTypes.Scte?
        /// The duration (in seconds) of each segment. Enter a value equal to, or a multiple of, the input segment duration. If the value that you enter is different from the input segment duration, MediaPackage rounds segments to the nearest multiple of the input segment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// The name that describes the segment. The name is the base name of the segment used in all content manifests inside of the endpoint. You can't use spaces in the name.
        public var segmentName: Swift.String?
        /// By default, MediaPackage excludes all digital video broadcasting (DVB) subtitles from the output. When selected, MediaPackage passes through DVB subtitles into the output.
        public var tsIncludeDvbSubtitles: Swift.Bool?
        /// When selected, MediaPackage bundles all audio tracks in a rendition group. All other tracks in the stream can be used with any audio rendition from the group.
        public var tsUseAudioRenditionGroup: Swift.Bool?

        public init (
            encryption: MediaPackageV2ClientTypes.Encryption? = nil,
            includeIframeOnlyStreams: Swift.Bool? = nil,
            scte: MediaPackageV2ClientTypes.Scte? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            segmentName: Swift.String? = nil,
            tsIncludeDvbSubtitles: Swift.Bool? = nil,
            tsUseAudioRenditionGroup: Swift.Bool? = nil
        )
        {
            self.encryption = encryption
            self.includeIframeOnlyStreams = includeIframeOnlyStreams
            self.scte = scte
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentName = segmentName
            self.tsIncludeDvbSubtitles = tsIncludeDvbSubtitles
            self.tsUseAudioRenditionGroup = tsUseAudioRenditionGroup
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable, Swift.Error {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageV2ClientTypes.SpekeKeyProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case drmSystems = "DrmSystems"
        case encryptionContractConfiguration = "EncryptionContractConfiguration"
        case resourceId = "ResourceId"
        case roleArn = "RoleArn"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let drmSystems = drmSystems {
            var drmSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .drmSystems)
            for drmsystem0 in drmSystems {
                try drmSystemsContainer.encode(drmsystem0.rawValue)
            }
        }
        if let encryptionContractConfiguration = self.encryptionContractConfiguration {
            try encodeContainer.encode(encryptionContractConfiguration, forKey: .encryptionContractConfiguration)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionContractConfigurationDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.EncryptionContractConfiguration.self, forKey: .encryptionContractConfiguration)
        encryptionContractConfiguration = encryptionContractConfigurationDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let drmSystemsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.DrmSystem?].self, forKey: .drmSystems)
        var drmSystemsDecoded0:[MediaPackageV2ClientTypes.DrmSystem]? = nil
        if let drmSystemsContainer = drmSystemsContainer {
            drmSystemsDecoded0 = [MediaPackageV2ClientTypes.DrmSystem]()
            for enum0 in drmSystemsContainer {
                if let enum0 = enum0 {
                    drmSystemsDecoded0?.append(enum0)
                }
            }
        }
        drmSystems = drmSystemsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaPackageV2ClientTypes {
    /// The parameters for the SPEKE key provider.
    public struct SpekeKeyProvider: Swift.Equatable {
        /// The DRM solution provider you're using to protect your content during distribution.
        /// This member is required.
        public var drmSystems: [MediaPackageV2ClientTypes.DrmSystem]?
        /// Configure one or more content encryption keys for your endpoints that use SPEKE Version 2.0. The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream. To configure the encryption contract, specify which audio and video encryption presets to use.
        /// This member is required.
        public var encryptionContractConfiguration: MediaPackageV2ClientTypes.EncryptionContractConfiguration?
        /// The unique identifier for the content. The service sends this to the key server to identify the current endpoint. How unique you make this depends on how fine-grained you want access controls to be. The service does not permit you to use the same ID for two simultaneous encryption processes. The resource ID is also known as the content ID. The following example shows a resource ID: MovieNight20171126093045
        /// This member is required.
        public var resourceId: Swift.String?
        /// The ARN for the IAM role granted by the key provider that provides access to the key provider API. This role must have a trust policy that allows MediaPackage to assume the role, and it must have a sufficient permissions policy to allow access to the specific key retrieval URL. Get this from your DRM solution provider. Valid format: arn:aws:iam::{accountID}:role/{name}. The following example shows a role ARN: arn:aws:iam::444455556666:role/SpekeAccess
        /// This member is required.
        public var roleArn: Swift.String?
        /// The URL of the API Gateway proxy that you set up to talk to your key server. The API Gateway proxy must reside in the same AWS Region as MediaPackage and must start with https://. The following example shows a URL: https://1wm2dx1f33.execute-api.us-west-2.amazonaws.com/SpekeSample/copyProtection
        /// This member is required.
        public var url: Swift.String?

        public init (
            drmSystems: [MediaPackageV2ClientTypes.DrmSystem]? = nil,
            encryptionContractConfiguration: MediaPackageV2ClientTypes.EncryptionContractConfiguration? = nil,
            resourceId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.drmSystems = drmSystems
            self.encryptionContractConfiguration = encryptionContractConfiguration
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.url = url
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the MediaPackage resource that you're adding tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request throughput limit was exceeded.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable, Swift.Error {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageV2ClientTypes {
    public enum TsEncryptionMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes128
        case sampleAes
        case sdkUnknown(Swift.String)

        public static var allCases: [TsEncryptionMethod] {
            return [
                .aes128,
                .sampleAes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes128: return "AES_128"
            case .sampleAes: return "SAMPLE_AES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TsEncryptionMethod(rawValue: rawValue) ?? TsEncryptionMethod.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the MediaPackage resource that you're removing tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateChannelGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateChannelGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())"
    }
}

public struct UpdateChannelGroupInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// Any descriptive information that you want to add to the channel group for future identification purposes.
    public var description: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.description = description
    }
}

struct UpdateChannelGroupInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateChannelGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateChannelGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateChannelGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: UpdateChannelGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.createdAt = output.createdAt
            self.description = output.description
            self.egressDomain = output.egressDomain
            self.modifiedAt = output.modifiedAt
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.createdAt = nil
            self.description = nil
            self.egressDomain = nil
            self.modifiedAt = nil
            self.tags = nil
        }
    }
}

public struct UpdateChannelGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The date and time the channel group was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your channel group.
    public var description: Swift.String?
    /// The output domain where the source stream is sent. Integrate the domain with a downstream CDN (such as Amazon CloudFront) or playback device.
    /// This member is required.
    public var egressDomain: Swift.String?
    /// The date and time the channel group was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The comma-separated list of tag key:value pairs assigned to the channel group.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        egressDomain: Swift.String? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.createdAt = createdAt
        self.description = description
        self.egressDomain = egressDomain
        self.modifiedAt = modifiedAt
        self.tags = tags
    }
}

struct UpdateChannelGroupOutputResponseBody: Swift.Equatable {
    let channelGroupName: Swift.String?
    let arn: Swift.String?
    let egressDomain: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateChannelGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case egressDomain = "EgressDomain"
        case modifiedAt = "ModifiedAt"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let egressDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .egressDomain)
        egressDomain = egressDomainDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())"
    }
}

public struct UpdateChannelInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// Any descriptive information that you want to add to the channel for future identification purposes.
    public var description: Swift.String?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.description = description
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: UpdateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.createdAt = output.createdAt
            self.description = output.description
            self.ingestEndpoints = output.ingestEndpoints
            self.modifiedAt = output.modifiedAt
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.channelName = nil
            self.createdAt = nil
            self.description = nil
            self.ingestEndpoints = nil
            self.modifiedAt = nil
            self.tags = nil
        }
    }
}

public struct UpdateChannelOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The date and time the channel was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description for your channel.
    public var description: Swift.String?
    /// The list of ingest endpoints.
    public var ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]?
    /// The date and time the channel was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The comma-separated list of tag key:value pairs assigned to the channel.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.createdAt = createdAt
        self.description = description
        self.ingestEndpoints = ingestEndpoints
        self.modifiedAt = modifiedAt
        self.tags = tags
    }
}

struct UpdateChannelOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let channelName: Swift.String?
    let channelGroupName: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let ingestEndpoints: [MediaPackageV2ClientTypes.IngestEndpoint]?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case ingestEndpoints = "IngestEndpoints"
        case modifiedAt = "ModifiedAt"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ingestEndpointsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.IngestEndpoint?].self, forKey: .ingestEndpoints)
        var ingestEndpointsDecoded0:[MediaPackageV2ClientTypes.IngestEndpoint]? = nil
        if let ingestEndpointsContainer = ingestEndpointsContainer {
            ingestEndpointsDecoded0 = [MediaPackageV2ClientTypes.IngestEndpoint]()
            for structure0 in ingestEndpointsContainer {
                if let structure0 = structure0 {
                    ingestEndpointsDecoded0?.append(structure0)
                }
            }
        }
        ingestEndpoints = ingestEndpointsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateOriginEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerType = "ContainerType"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case segment = "Segment"
        case startoverWindowSeconds = "StartoverWindowSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerType = self.containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for createhlsmanifestconfiguration0 in hlsManifests {
                try hlsManifestsContainer.encode(createhlsmanifestconfiguration0)
            }
        }
        if let lowLatencyHlsManifests = lowLatencyHlsManifests {
            var lowLatencyHlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lowLatencyHlsManifests)
            for createlowlatencyhlsmanifestconfiguration0 in lowLatencyHlsManifests {
                try lowLatencyHlsManifestsContainer.encode(createlowlatencyhlsmanifestconfiguration0)
            }
        }
        if let segment = self.segment {
            try encodeContainer.encode(segment, forKey: .segment)
        }
        if let startoverWindowSeconds = self.startoverWindowSeconds {
            try encodeContainer.encode(startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }
    }
}

extension UpdateOriginEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelGroupName = channelGroupName else {
            return nil
        }
        guard let channelName = channelName else {
            return nil
        }
        guard let originEndpointName = originEndpointName else {
            return nil
        }
        return "/channelGroup/\(channelGroupName.urlPercentEncoding())/channel/\(channelName.urlPercentEncoding())/originEndpoint/\(originEndpointName.urlPercentEncoding())"
    }
}

public struct UpdateOriginEndpointInput: Swift.Equatable {
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The type of container attached to this origin endpoint. A container type is a file format that encapsulates one or more media streams, such as audio and video, into a single file.
    /// This member is required.
    public var containerType: MediaPackageV2ClientTypes.ContainerType?
    /// Any descriptive information that you want to add to the origin endpoint for future identification purposes.
    public var description: Swift.String?
    /// An HTTP live streaming (HLS) manifest configuration.
    public var hlsManifests: [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]?
    /// A low-latency HLS manifest configuration.
    public var lowLatencyHlsManifests: [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?
    /// The segment configuration, including the segment name, duration, and other configuration values.
    public var segment: MediaPackageV2ClientTypes.Segment?
    /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window. The maximum startover window is 1,209,600 seconds (14 days).
    public var startoverWindowSeconds: Swift.Int?

    public init (
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        containerType: MediaPackageV2ClientTypes.ContainerType? = nil,
        description: Swift.String? = nil,
        hlsManifests: [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]? = nil,
        lowLatencyHlsManifests: [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]? = nil,
        originEndpointName: Swift.String? = nil,
        segment: MediaPackageV2ClientTypes.Segment? = nil,
        startoverWindowSeconds: Swift.Int? = nil
    )
    {
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.containerType = containerType
        self.description = description
        self.hlsManifests = hlsManifests
        self.lowLatencyHlsManifests = lowLatencyHlsManifests
        self.originEndpointName = originEndpointName
        self.segment = segment
        self.startoverWindowSeconds = startoverWindowSeconds
    }
}

struct UpdateOriginEndpointInputBody: Swift.Equatable {
    let containerType: MediaPackageV2ClientTypes.ContainerType?
    let segment: MediaPackageV2ClientTypes.Segment?
    let description: Swift.String?
    let startoverWindowSeconds: Swift.Int?
    let hlsManifests: [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]?
    let lowLatencyHlsManifests: [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]?
}

extension UpdateOriginEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerType = "ContainerType"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case segment = "Segment"
        case startoverWindowSeconds = "StartoverWindowSeconds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let segmentDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.Segment.self, forKey: .segment)
        segment = segmentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.CreateHlsManifestConfiguration?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageV2ClientTypes.CreateHlsManifestConfiguration]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let lowLatencyHlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration?].self, forKey: .lowLatencyHlsManifests)
        var lowLatencyHlsManifestsDecoded0:[MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]? = nil
        if let lowLatencyHlsManifestsContainer = lowLatencyHlsManifestsContainer {
            lowLatencyHlsManifestsDecoded0 = [MediaPackageV2ClientTypes.CreateLowLatencyHlsManifestConfiguration]()
            for structure0 in lowLatencyHlsManifestsContainer {
                if let structure0 = structure0 {
                    lowLatencyHlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        lowLatencyHlsManifests = lowLatencyHlsManifestsDecoded0
    }
}

extension UpdateOriginEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOriginEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateOriginEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOriginEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: UpdateOriginEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelGroupName = output.channelGroupName
            self.channelName = output.channelName
            self.containerType = output.containerType
            self.createdAt = output.createdAt
            self.description = output.description
            self.hlsManifests = output.hlsManifests
            self.lowLatencyHlsManifests = output.lowLatencyHlsManifests
            self.modifiedAt = output.modifiedAt
            self.originEndpointName = output.originEndpointName
            self.segment = output.segment
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelGroupName = nil
            self.channelName = nil
            self.containerType = nil
            self.createdAt = nil
            self.description = nil
            self.hlsManifests = nil
            self.lowLatencyHlsManifests = nil
            self.modifiedAt = nil
            self.originEndpointName = nil
            self.segment = nil
            self.startoverWindowSeconds = nil
            self.tags = nil
        }
    }
}

public struct UpdateOriginEndpointOutputResponse: Swift.Equatable {
    /// The ARN associated with the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
    /// This member is required.
    public var channelGroupName: Swift.String?
    /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
    /// This member is required.
    public var channelName: Swift.String?
    /// The type of container attached to this origin endpoint.
    /// This member is required.
    public var containerType: MediaPackageV2ClientTypes.ContainerType?
    /// The date and time the origin endpoint was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description of the origin endpoint.
    public var description: Swift.String?
    /// An HTTP live streaming (HLS) manifest configuration.
    public var hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]?
    /// A low-latency HLS manifest configuration.
    public var lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]?
    /// The date and time the origin endpoint was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
    /// This member is required.
    public var originEndpointName: Swift.String?
    /// The segment configuration, including the segment name, duration, and other configuration values.
    /// This member is required.
    public var segment: MediaPackageV2ClientTypes.Segment?
    /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window.
    public var startoverWindowSeconds: Swift.Int?
    /// The comma-separated list of tag key:value pairs assigned to the origin endpoint.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        channelGroupName: Swift.String? = nil,
        channelName: Swift.String? = nil,
        containerType: MediaPackageV2ClientTypes.ContainerType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]? = nil,
        lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        originEndpointName: Swift.String? = nil,
        segment: MediaPackageV2ClientTypes.Segment? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelGroupName = channelGroupName
        self.channelName = channelName
        self.containerType = containerType
        self.createdAt = createdAt
        self.description = description
        self.hlsManifests = hlsManifests
        self.lowLatencyHlsManifests = lowLatencyHlsManifests
        self.modifiedAt = modifiedAt
        self.originEndpointName = originEndpointName
        self.segment = segment
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
    }
}

struct UpdateOriginEndpointOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let channelGroupName: Swift.String?
    let channelName: Swift.String?
    let originEndpointName: Swift.String?
    let containerType: MediaPackageV2ClientTypes.ContainerType?
    let segment: MediaPackageV2ClientTypes.Segment?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let description: Swift.String?
    let startoverWindowSeconds: Swift.Int?
    let hlsManifests: [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]?
    let lowLatencyHlsManifests: [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateOriginEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelGroupName = "ChannelGroupName"
        case channelName = "ChannelName"
        case containerType = "ContainerType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case hlsManifests = "HlsManifests"
        case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        case modifiedAt = "ModifiedAt"
        case originEndpointName = "OriginEndpointName"
        case segment = "Segment"
        case startoverWindowSeconds = "StartoverWindowSeconds"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelGroupName)
        channelGroupName = channelGroupNameDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let originEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointName)
        originEndpointName = originEndpointNameDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let segmentDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.Segment.self, forKey: .segment)
        segment = segmentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.GetHlsManifestConfiguration?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageV2ClientTypes.GetHlsManifestConfiguration]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageV2ClientTypes.GetHlsManifestConfiguration]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let lowLatencyHlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration?].self, forKey: .lowLatencyHlsManifests)
        var lowLatencyHlsManifestsDecoded0:[MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]? = nil
        if let lowLatencyHlsManifestsContainer = lowLatencyHlsManifestsContainer {
            lowLatencyHlsManifestsDecoded0 = [MediaPackageV2ClientTypes.GetLowLatencyHlsManifestConfiguration]()
            for structure0 in lowLatencyHlsManifestsContainer {
                if let structure0 = structure0 {
                    lowLatencyHlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        lowLatencyHlsManifests = lowLatencyHlsManifestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.validationExceptionType = output.validationExceptionType
        } else {
            self.message = nil
            self.validationExceptionType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input failed to meet the constraints specified by the AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable, Swift.Error {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The type of ValidationException.
    public var validationExceptionType: MediaPackageV2ClientTypes.ValidationExceptionType?

    public init (
        message: Swift.String? = nil,
        validationExceptionType: MediaPackageV2ClientTypes.ValidationExceptionType? = nil
    )
    {
        self.message = message
        self.validationExceptionType = validationExceptionType
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let validationExceptionType: MediaPackageV2ClientTypes.ValidationExceptionType?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case validationExceptionType = "ValidationExceptionType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let validationExceptionTypeDecoded = try containerValues.decodeIfPresent(MediaPackageV2ClientTypes.ValidationExceptionType.self, forKey: .validationExceptionType)
        validationExceptionType = validationExceptionTypeDecoded
    }
}

extension MediaPackageV2ClientTypes {
    public enum ValidationExceptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cencIvIncompatible
        case containerTypeImmutable
        case drmSystemsEncryptionMethodIncompatible
        case encryptionContractShared
        case encryptionContractUnencrypted
        case encryptionContractWithoutAudioRenditionIncompatible
        case encryptionMethodContainerTypeMismatch
        case invalidPaginationMaxResults
        case invalidPaginationToken
        case invalidPolicy
        case invalidRoleArn
        case manifestNameCollision
        case memberDoesNotMatchPattern
        case memberInvalid
        case memberInvalidEnumValue
        case memberMaxLength
        case memberMaxValue
        case memberMinLength
        case memberMinValue
        case memberMissing
        case numManifestsHigh
        case numManifestsLow
        case roleArnInvalidFormat
        case roleArnLengthOutOfRange
        case roleArnNotAssumable
        case urlInvalid
        case urlLinkLocalAddress
        case urlLocalAddress
        case urlLoopbackAddress
        case urlMulticastAddress
        case urlPort
        case urlScheme
        case urlUnknownHost
        case urlUserInfo
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionType] {
            return [
                .cencIvIncompatible,
                .containerTypeImmutable,
                .drmSystemsEncryptionMethodIncompatible,
                .encryptionContractShared,
                .encryptionContractUnencrypted,
                .encryptionContractWithoutAudioRenditionIncompatible,
                .encryptionMethodContainerTypeMismatch,
                .invalidPaginationMaxResults,
                .invalidPaginationToken,
                .invalidPolicy,
                .invalidRoleArn,
                .manifestNameCollision,
                .memberDoesNotMatchPattern,
                .memberInvalid,
                .memberInvalidEnumValue,
                .memberMaxLength,
                .memberMaxValue,
                .memberMinLength,
                .memberMinValue,
                .memberMissing,
                .numManifestsHigh,
                .numManifestsLow,
                .roleArnInvalidFormat,
                .roleArnLengthOutOfRange,
                .roleArnNotAssumable,
                .urlInvalid,
                .urlLinkLocalAddress,
                .urlLocalAddress,
                .urlLoopbackAddress,
                .urlMulticastAddress,
                .urlPort,
                .urlScheme,
                .urlUnknownHost,
                .urlUserInfo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cencIvIncompatible: return "CENC_IV_INCOMPATIBLE"
            case .containerTypeImmutable: return "CONTAINER_TYPE_IMMUTABLE"
            case .drmSystemsEncryptionMethodIncompatible: return "DRM_SYSTEMS_ENCRYPTION_METHOD_INCOMPATIBLE"
            case .encryptionContractShared: return "ENCRYPTION_CONTRACT_SHARED"
            case .encryptionContractUnencrypted: return "ENCRYPTION_CONTRACT_UNENCRYPTED"
            case .encryptionContractWithoutAudioRenditionIncompatible: return "ENCRYPTION_CONTRACT_WITHOUT_AUDIO_RENDITION_INCOMPATIBLE"
            case .encryptionMethodContainerTypeMismatch: return "ENCRYPTION_METHOD_CONTAINER_TYPE_MISMATCH"
            case .invalidPaginationMaxResults: return "INVALID_PAGINATION_MAX_RESULTS"
            case .invalidPaginationToken: return "INVALID_PAGINATION_TOKEN"
            case .invalidPolicy: return "INVALID_POLICY"
            case .invalidRoleArn: return "INVALID_ROLE_ARN"
            case .manifestNameCollision: return "MANIFEST_NAME_COLLISION"
            case .memberDoesNotMatchPattern: return "MEMBER_DOES_NOT_MATCH_PATTERN"
            case .memberInvalid: return "MEMBER_INVALID"
            case .memberInvalidEnumValue: return "MEMBER_INVALID_ENUM_VALUE"
            case .memberMaxLength: return "MEMBER_MAX_LENGTH"
            case .memberMaxValue: return "MEMBER_MAX_VALUE"
            case .memberMinLength: return "MEMBER_MIN_LENGTH"
            case .memberMinValue: return "MEMBER_MIN_VALUE"
            case .memberMissing: return "MEMBER_MISSING"
            case .numManifestsHigh: return "NUM_MANIFESTS_HIGH"
            case .numManifestsLow: return "NUM_MANIFESTS_LOW"
            case .roleArnInvalidFormat: return "ROLE_ARN_INVALID_FORMAT"
            case .roleArnLengthOutOfRange: return "ROLE_ARN_LENGTH_OUT_OF_RANGE"
            case .roleArnNotAssumable: return "ROLE_ARN_NOT_ASSUMABLE"
            case .urlInvalid: return "URL_INVALID"
            case .urlLinkLocalAddress: return "URL_LINK_LOCAL_ADDRESS"
            case .urlLocalAddress: return "URL_LOCAL_ADDRESS"
            case .urlLoopbackAddress: return "URL_LOOPBACK_ADDRESS"
            case .urlMulticastAddress: return "URL_MULTICAST_ADDRESS"
            case .urlPort: return "URL_PORT"
            case .urlScheme: return "URL_SCHEME"
            case .urlUnknownHost: return "URL_UNKNOWN_HOST"
            case .urlUserInfo: return "URL_USER_INFO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionType(rawValue: rawValue) ?? ValidationExceptionType.sdkUnknown(rawValue)
        }
    }
}
