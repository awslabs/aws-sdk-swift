// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have sufficient permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was a conflict with this request. Try again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the ConflictException error
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource in use
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource in use
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension EndpointTemporarilyUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EndpointTemporarilyUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The cluster endpoint isn't available. Try another cluster endpoint.
public struct EndpointTemporarilyUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EndpointTemporarilyUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EndpointTemporarilyUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EndpointTemporarilyUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetRoutingControlStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routingControlArn = self.routingControlArn {
            try encodeContainer.encode(routingControlArn, forKey: .routingControlArn)
        }
    }
}

extension GetRoutingControlStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRoutingControlStateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the routing control that you want to get the state for.
    /// This member is required.
    public var routingControlArn: Swift.String?

    public init(
        routingControlArn: Swift.String? = nil
    )
    {
        self.routingControlArn = routingControlArn
    }
}

struct GetRoutingControlStateInputBody: Swift.Equatable {
    let routingControlArn: Swift.String?
}

extension GetRoutingControlStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlArn)
        routingControlArn = routingControlArnDecoded
    }
}

extension GetRoutingControlStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRoutingControlStateOutputBody = try responseDecoder.decode(responseBody: data)
            self.routingControlArn = output.routingControlArn
            self.routingControlName = output.routingControlName
            self.routingControlState = output.routingControlState
        } else {
            self.routingControlArn = nil
            self.routingControlName = nil
            self.routingControlState = nil
        }
    }
}

public struct GetRoutingControlStateOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the response.
    /// This member is required.
    public var routingControlArn: Swift.String?
    /// The routing control name.
    public var routingControlName: Swift.String?
    /// The state of the routing control.
    /// This member is required.
    public var routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?

    public init(
        routingControlArn: Swift.String? = nil,
        routingControlName: Swift.String? = nil,
        routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState? = nil
    )
    {
        self.routingControlArn = routingControlArn
        self.routingControlName = routingControlName
        self.routingControlState = routingControlState
    }
}

struct GetRoutingControlStateOutputBody: Swift.Equatable {
    let routingControlArn: Swift.String?
    let routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?
    let routingControlName: Swift.String?
}

extension GetRoutingControlStateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
        case routingControlName = "RoutingControlName"
        case routingControlState = "RoutingControlState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlArn)
        routingControlArn = routingControlArnDecoded
        let routingControlStateDecoded = try containerValues.decodeIfPresent(Route53RecoveryClusterClientTypes.RoutingControlState.self, forKey: .routingControlState)
        routingControlState = routingControlStateDecoded
        let routingControlNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlName)
        routingControlName = routingControlNameDecoded
    }
}

enum GetRoutingControlStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EndpointTemporarilyUnavailableException": return try await EndpointTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an unexpected error during processing of the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListRoutingControlsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlPanelArn = "ControlPanelArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlPanelArn = self.controlPanelArn {
            try encodeContainer.encode(controlPanelArn, forKey: .controlPanelArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRoutingControlsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRoutingControlsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the control panel of the routing controls to list.
    public var controlPanelArn: Swift.String?
    /// The number of routing controls objects that you want to return with this call. The default value is 500.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        controlPanelArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlPanelArn = controlPanelArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRoutingControlsInputBody: Swift.Equatable {
    let controlPanelArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRoutingControlsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlPanelArn = "ControlPanelArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlPanelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlPanelArn)
        controlPanelArn = controlPanelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRoutingControlsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRoutingControlsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.routingControls = output.routingControls
        } else {
            self.nextToken = nil
            self.routingControls = nil
        }
    }
}

public struct ListRoutingControlsOutput: Swift.Equatable {
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The list of routing controls.
    /// This member is required.
    public var routingControls: [Route53RecoveryClusterClientTypes.RoutingControl]?

    public init(
        nextToken: Swift.String? = nil,
        routingControls: [Route53RecoveryClusterClientTypes.RoutingControl]? = nil
    )
    {
        self.nextToken = nextToken
        self.routingControls = routingControls
    }
}

struct ListRoutingControlsOutputBody: Swift.Equatable {
    let routingControls: [Route53RecoveryClusterClientTypes.RoutingControl]?
    let nextToken: Swift.String?
}

extension ListRoutingControlsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case routingControls = "RoutingControls"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingControlsContainer = try containerValues.decodeIfPresent([Route53RecoveryClusterClientTypes.RoutingControl?].self, forKey: .routingControls)
        var routingControlsDecoded0:[Route53RecoveryClusterClientTypes.RoutingControl]? = nil
        if let routingControlsContainer = routingControlsContainer {
            routingControlsDecoded0 = [Route53RecoveryClusterClientTypes.RoutingControl]()
            for structure0 in routingControlsContainer {
                if let structure0 = structure0 {
                    routingControlsDecoded0?.append(structure0)
                }
            }
        }
        routingControls = routingControlsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRoutingControlsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EndpointTemporarilyUnavailableException": return try await EndpointTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request references a routing control or control panel that was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Hypothetical resource identifier that was not found
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Hypothetical resource type that was not found
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension Route53RecoveryClusterClientTypes.RoutingControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlPanelArn = "ControlPanelArn"
        case controlPanelName = "ControlPanelName"
        case routingControlArn = "RoutingControlArn"
        case routingControlName = "RoutingControlName"
        case routingControlState = "RoutingControlState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlPanelArn = self.controlPanelArn {
            try encodeContainer.encode(controlPanelArn, forKey: .controlPanelArn)
        }
        if let controlPanelName = self.controlPanelName {
            try encodeContainer.encode(controlPanelName, forKey: .controlPanelName)
        }
        if let routingControlArn = self.routingControlArn {
            try encodeContainer.encode(routingControlArn, forKey: .routingControlArn)
        }
        if let routingControlName = self.routingControlName {
            try encodeContainer.encode(routingControlName, forKey: .routingControlName)
        }
        if let routingControlState = self.routingControlState {
            try encodeContainer.encode(routingControlState.rawValue, forKey: .routingControlState)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlPanelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlPanelArn)
        controlPanelArn = controlPanelArnDecoded
        let controlPanelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlPanelName)
        controlPanelName = controlPanelNameDecoded
        let routingControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlArn)
        routingControlArn = routingControlArnDecoded
        let routingControlNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlName)
        routingControlName = routingControlNameDecoded
        let routingControlStateDecoded = try containerValues.decodeIfPresent(Route53RecoveryClusterClientTypes.RoutingControlState.self, forKey: .routingControlState)
        routingControlState = routingControlStateDecoded
    }
}

extension Route53RecoveryClusterClientTypes {
    /// A routing control, which is a simple on/off switch that you can use to route traffic to cells. When a routing control state is On, traffic flows to a cell. When the state is Off, traffic does not flow.
    public struct RoutingControl: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the control panel where the routing control is located.
        public var controlPanelArn: Swift.String?
        /// The name of the control panel where the routing control is located.
        public var controlPanelName: Swift.String?
        /// The Amazon Resource Name (ARN) of the routing control.
        public var routingControlArn: Swift.String?
        /// The name of the routing control.
        public var routingControlName: Swift.String?
        /// The current state of the routing control. When a routing control state is On, traffic flows to a cell. When the state is Off, traffic does not flow.
        public var routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?

        public init(
            controlPanelArn: Swift.String? = nil,
            controlPanelName: Swift.String? = nil,
            routingControlArn: Swift.String? = nil,
            routingControlName: Swift.String? = nil,
            routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState? = nil
        )
        {
            self.controlPanelArn = controlPanelArn
            self.controlPanelName = controlPanelName
            self.routingControlArn = routingControlArn
            self.routingControlName = routingControlName
            self.routingControlState = routingControlState
        }
    }

}

extension Route53RecoveryClusterClientTypes {
    public enum RoutingControlState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutingControlState] {
            return [
                .off,
                .on,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "Off"
            case .on: return "On"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoutingControlState(rawValue: rawValue) ?? RoutingControlState.sdkUnknown(rawValue)
        }
    }
}

extension ServiceLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.limitCode = output.limitCode
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.limitCode = nil
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request can't update that many routing control states at the same time. Try again with fewer routing control states.
public struct ServiceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The code of the limit that was exceeded.
        /// This member is required.
        public internal(set) var limitCode: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource identifier of the limit that was exceeded.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type of the limit that was exceeded.
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code of the limit that was exceeded.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limitCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.limitCode = limitCode
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let limitCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitCode
        case message
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let limitCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitCode)
        limitCode = limitCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because of request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
        case routingControlState = "RoutingControlState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routingControlArn = self.routingControlArn {
            try encodeContainer.encode(routingControlArn, forKey: .routingControlArn)
        }
        if let routingControlState = self.routingControlState {
            try encodeContainer.encode(routingControlState.rawValue, forKey: .routingControlState)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlArn)
        routingControlArn = routingControlArnDecoded
        let routingControlStateDecoded = try containerValues.decodeIfPresent(Route53RecoveryClusterClientTypes.RoutingControlState.self, forKey: .routingControlState)
        routingControlState = routingControlStateDecoded
    }
}

extension Route53RecoveryClusterClientTypes {
    /// A routing control state entry.
    public struct UpdateRoutingControlStateEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for a routing control state entry.
        /// This member is required.
        public var routingControlArn: Swift.String?
        /// The routing control state in a set of routing control state entries.
        /// This member is required.
        public var routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?

        public init(
            routingControlArn: Swift.String? = nil,
            routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState? = nil
        )
        {
            self.routingControlArn = routingControlArn
            self.routingControlState = routingControlState
        }
    }

}

extension UpdateRoutingControlStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
        case routingControlState = "RoutingControlState"
        case safetyRulesToOverride = "SafetyRulesToOverride"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routingControlArn = self.routingControlArn {
            try encodeContainer.encode(routingControlArn, forKey: .routingControlArn)
        }
        if let routingControlState = self.routingControlState {
            try encodeContainer.encode(routingControlState.rawValue, forKey: .routingControlState)
        }
        if let safetyRulesToOverride = safetyRulesToOverride {
            var safetyRulesToOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .safetyRulesToOverride)
            for arn0 in safetyRulesToOverride {
                try safetyRulesToOverrideContainer.encode(arn0)
            }
        }
    }
}

extension UpdateRoutingControlStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRoutingControlStateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the routing control that you want to update the state for.
    /// This member is required.
    public var routingControlArn: Swift.String?
    /// The state of the routing control. You can set the value to be On or Off.
    /// This member is required.
    public var routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?
    /// The Amazon Resource Names (ARNs) for the safety rules that you want to override when you're updating the state of a routing control. You can override one safety rule or multiple safety rules by including one or more ARNs, separated by commas. For more information, see [ Override safety rules to reroute traffic](https://docs.aws.amazon.com/r53recovery/latest/dg/routing-control.override-safety-rule.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
    public var safetyRulesToOverride: [Swift.String]?

    public init(
        routingControlArn: Swift.String? = nil,
        routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState? = nil,
        safetyRulesToOverride: [Swift.String]? = nil
    )
    {
        self.routingControlArn = routingControlArn
        self.routingControlState = routingControlState
        self.safetyRulesToOverride = safetyRulesToOverride
    }
}

struct UpdateRoutingControlStateInputBody: Swift.Equatable {
    let routingControlArn: Swift.String?
    let routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?
    let safetyRulesToOverride: [Swift.String]?
}

extension UpdateRoutingControlStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
        case routingControlState = "RoutingControlState"
        case safetyRulesToOverride = "SafetyRulesToOverride"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlArn)
        routingControlArn = routingControlArnDecoded
        let routingControlStateDecoded = try containerValues.decodeIfPresent(Route53RecoveryClusterClientTypes.RoutingControlState.self, forKey: .routingControlState)
        routingControlState = routingControlStateDecoded
        let safetyRulesToOverrideContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .safetyRulesToOverride)
        var safetyRulesToOverrideDecoded0:[Swift.String]? = nil
        if let safetyRulesToOverrideContainer = safetyRulesToOverrideContainer {
            safetyRulesToOverrideDecoded0 = [Swift.String]()
            for string0 in safetyRulesToOverrideContainer {
                if let string0 = string0 {
                    safetyRulesToOverrideDecoded0?.append(string0)
                }
            }
        }
        safetyRulesToOverride = safetyRulesToOverrideDecoded0
    }
}

extension UpdateRoutingControlStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRoutingControlStateOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRoutingControlStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EndpointTemporarilyUnavailableException": return try await EndpointTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRoutingControlStatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case safetyRulesToOverride = "SafetyRulesToOverride"
        case updateRoutingControlStateEntries = "UpdateRoutingControlStateEntries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let safetyRulesToOverride = safetyRulesToOverride {
            var safetyRulesToOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .safetyRulesToOverride)
            for arn0 in safetyRulesToOverride {
                try safetyRulesToOverrideContainer.encode(arn0)
            }
        }
        if let updateRoutingControlStateEntries = updateRoutingControlStateEntries {
            var updateRoutingControlStateEntriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updateRoutingControlStateEntries)
            for updateroutingcontrolstateentry0 in updateRoutingControlStateEntries {
                try updateRoutingControlStateEntriesContainer.encode(updateroutingcontrolstateentry0)
            }
        }
    }
}

extension UpdateRoutingControlStatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRoutingControlStatesInput: Swift.Equatable {
    /// The Amazon Resource Names (ARNs) for the safety rules that you want to override when you're updating routing control states. You can override one safety rule or multiple safety rules by including one or more ARNs, separated by commas. For more information, see [ Override safety rules to reroute traffic](https://docs.aws.amazon.com/r53recovery/latest/dg/routing-control.override-safety-rule.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
    public var safetyRulesToOverride: [Swift.String]?
    /// A set of routing control entries that you want to update.
    /// This member is required.
    public var updateRoutingControlStateEntries: [Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]?

    public init(
        safetyRulesToOverride: [Swift.String]? = nil,
        updateRoutingControlStateEntries: [Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]? = nil
    )
    {
        self.safetyRulesToOverride = safetyRulesToOverride
        self.updateRoutingControlStateEntries = updateRoutingControlStateEntries
    }
}

struct UpdateRoutingControlStatesInputBody: Swift.Equatable {
    let updateRoutingControlStateEntries: [Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]?
    let safetyRulesToOverride: [Swift.String]?
}

extension UpdateRoutingControlStatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case safetyRulesToOverride = "SafetyRulesToOverride"
        case updateRoutingControlStateEntries = "UpdateRoutingControlStateEntries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateRoutingControlStateEntriesContainer = try containerValues.decodeIfPresent([Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry?].self, forKey: .updateRoutingControlStateEntries)
        var updateRoutingControlStateEntriesDecoded0:[Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]? = nil
        if let updateRoutingControlStateEntriesContainer = updateRoutingControlStateEntriesContainer {
            updateRoutingControlStateEntriesDecoded0 = [Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]()
            for structure0 in updateRoutingControlStateEntriesContainer {
                if let structure0 = structure0 {
                    updateRoutingControlStateEntriesDecoded0?.append(structure0)
                }
            }
        }
        updateRoutingControlStateEntries = updateRoutingControlStateEntriesDecoded0
        let safetyRulesToOverrideContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .safetyRulesToOverride)
        var safetyRulesToOverrideDecoded0:[Swift.String]? = nil
        if let safetyRulesToOverrideContainer = safetyRulesToOverrideContainer {
            safetyRulesToOverrideDecoded0 = [Swift.String]()
            for string0 in safetyRulesToOverrideContainer {
                if let string0 = string0 {
                    safetyRulesToOverrideDecoded0?.append(string0)
                }
            }
        }
        safetyRulesToOverride = safetyRulesToOverrideDecoded0
    }
}

extension UpdateRoutingControlStatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRoutingControlStatesOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRoutingControlStatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EndpointTemporarilyUnavailableException": return try await EndpointTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLimitExceededException": return try await ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was a validation error on the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that caused the error, if applicable
        public internal(set) var fields: [Route53RecoveryClusterClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Reason the request failed validation
        public internal(set) var reason: Route53RecoveryClusterClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [Route53RecoveryClusterClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: Route53RecoveryClusterClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: Route53RecoveryClusterClientTypes.ValidationExceptionReason?
    let fields: [Route53RecoveryClusterClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Route53RecoveryClusterClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Route53RecoveryClusterClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[Route53RecoveryClusterClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Route53RecoveryClusterClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension Route53RecoveryClusterClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53RecoveryClusterClientTypes {
    /// There was a validation error on the request.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Information about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The field that had the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension Route53RecoveryClusterClientTypes {
    /// Reason the request failed validation
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
