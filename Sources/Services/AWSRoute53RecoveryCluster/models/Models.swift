// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have sufficient permissions to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a conflict with this request. Try again.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the ConflictException error
    /// This member is required.
    public var message: Swift.String?
    /// Identifier of the resource in use
    /// This member is required.
    public var resourceId: Swift.String?
    /// Type of the resource in use
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension EndpointTemporarilyUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EndpointTemporarilyUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The cluster endpoint isn't available. Try another cluster endpoint.
public struct EndpointTemporarilyUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointTemporarilyUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EndpointTemporarilyUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetRoutingControlStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routingControlArn = self.routingControlArn {
            try encodeContainer.encode(routingControlArn, forKey: .routingControlArn)
        }
    }
}

extension GetRoutingControlStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRoutingControlStateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the routing control that you want to get the state for.
    /// This member is required.
    public var routingControlArn: Swift.String?

    public init (
        routingControlArn: Swift.String? = nil
    )
    {
        self.routingControlArn = routingControlArn
    }
}

struct GetRoutingControlStateInputBody: Swift.Equatable {
    let routingControlArn: Swift.String?
}

extension GetRoutingControlStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlArn)
        routingControlArn = routingControlArnDecoded
    }
}

extension GetRoutingControlStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRoutingControlStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointTemporarilyUnavailableException" : self = .endpointTemporarilyUnavailableException(try EndpointTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRoutingControlStateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case endpointTemporarilyUnavailableException(EndpointTemporarilyUnavailableException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRoutingControlStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRoutingControlStateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.routingControlArn = output.routingControlArn
            self.routingControlName = output.routingControlName
            self.routingControlState = output.routingControlState
        } else {
            self.routingControlArn = nil
            self.routingControlName = nil
            self.routingControlState = nil
        }
    }
}

public struct GetRoutingControlStateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the response.
    /// This member is required.
    public var routingControlArn: Swift.String?
    /// The routing control name.
    public var routingControlName: Swift.String?
    /// The state of the routing control.
    /// This member is required.
    public var routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?

    public init (
        routingControlArn: Swift.String? = nil,
        routingControlName: Swift.String? = nil,
        routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState? = nil
    )
    {
        self.routingControlArn = routingControlArn
        self.routingControlName = routingControlName
        self.routingControlState = routingControlState
    }
}

struct GetRoutingControlStateOutputResponseBody: Swift.Equatable {
    let routingControlArn: Swift.String?
    let routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?
    let routingControlName: Swift.String?
}

extension GetRoutingControlStateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
        case routingControlName = "RoutingControlName"
        case routingControlState = "RoutingControlState"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlArn)
        routingControlArn = routingControlArnDecoded
        let routingControlStateDecoded = try containerValues.decodeIfPresent(Route53RecoveryClusterClientTypes.RoutingControlState.self, forKey: .routingControlState)
        routingControlState = routingControlStateDecoded
        let routingControlNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlName)
        routingControlName = routingControlNameDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an unexpected error during processing of the request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// Advice to clients on when the call can be safely retried
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListRoutingControlsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlPanelArn = "ControlPanelArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlPanelArn = self.controlPanelArn {
            try encodeContainer.encode(controlPanelArn, forKey: .controlPanelArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRoutingControlsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRoutingControlsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the control panel of the routing controls to list.
    public var controlPanelArn: Swift.String?
    /// The number of routing controls objects that you want to return with this call. The default value is 500.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        controlPanelArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlPanelArn = controlPanelArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRoutingControlsInputBody: Swift.Equatable {
    let controlPanelArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRoutingControlsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlPanelArn = "ControlPanelArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlPanelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlPanelArn)
        controlPanelArn = controlPanelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRoutingControlsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRoutingControlsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointTemporarilyUnavailableException" : self = .endpointTemporarilyUnavailableException(try EndpointTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRoutingControlsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case endpointTemporarilyUnavailableException(EndpointTemporarilyUnavailableException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoutingControlsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRoutingControlsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.routingControls = output.routingControls
        } else {
            self.nextToken = nil
            self.routingControls = nil
        }
    }
}

public struct ListRoutingControlsOutputResponse: Swift.Equatable {
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The list of routing controls.
    /// This member is required.
    public var routingControls: [Route53RecoveryClusterClientTypes.RoutingControl]?

    public init (
        nextToken: Swift.String? = nil,
        routingControls: [Route53RecoveryClusterClientTypes.RoutingControl]? = nil
    )
    {
        self.nextToken = nextToken
        self.routingControls = routingControls
    }
}

struct ListRoutingControlsOutputResponseBody: Swift.Equatable {
    let routingControls: [Route53RecoveryClusterClientTypes.RoutingControl]?
    let nextToken: Swift.String?
}

extension ListRoutingControlsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case routingControls = "RoutingControls"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingControlsContainer = try containerValues.decodeIfPresent([Route53RecoveryClusterClientTypes.RoutingControl?].self, forKey: .routingControls)
        var routingControlsDecoded0:[Route53RecoveryClusterClientTypes.RoutingControl]? = nil
        if let routingControlsContainer = routingControlsContainer {
            routingControlsDecoded0 = [Route53RecoveryClusterClientTypes.RoutingControl]()
            for structure0 in routingControlsContainer {
                if let structure0 = structure0 {
                    routingControlsDecoded0?.append(structure0)
                }
            }
        }
        routingControls = routingControlsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request references a routing control or control panel that was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Hypothetical resource identifier that was not found
    /// This member is required.
    public var resourceId: Swift.String?
    /// Hypothetical resource type that was not found
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension Route53RecoveryClusterClientTypes.RoutingControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlPanelArn = "ControlPanelArn"
        case controlPanelName = "ControlPanelName"
        case routingControlArn = "RoutingControlArn"
        case routingControlName = "RoutingControlName"
        case routingControlState = "RoutingControlState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlPanelArn = self.controlPanelArn {
            try encodeContainer.encode(controlPanelArn, forKey: .controlPanelArn)
        }
        if let controlPanelName = self.controlPanelName {
            try encodeContainer.encode(controlPanelName, forKey: .controlPanelName)
        }
        if let routingControlArn = self.routingControlArn {
            try encodeContainer.encode(routingControlArn, forKey: .routingControlArn)
        }
        if let routingControlName = self.routingControlName {
            try encodeContainer.encode(routingControlName, forKey: .routingControlName)
        }
        if let routingControlState = self.routingControlState {
            try encodeContainer.encode(routingControlState.rawValue, forKey: .routingControlState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlPanelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlPanelArn)
        controlPanelArn = controlPanelArnDecoded
        let controlPanelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlPanelName)
        controlPanelName = controlPanelNameDecoded
        let routingControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlArn)
        routingControlArn = routingControlArnDecoded
        let routingControlNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlName)
        routingControlName = routingControlNameDecoded
        let routingControlStateDecoded = try containerValues.decodeIfPresent(Route53RecoveryClusterClientTypes.RoutingControlState.self, forKey: .routingControlState)
        routingControlState = routingControlStateDecoded
    }
}

extension Route53RecoveryClusterClientTypes {
    /// A routing control, which is a simple on/off switch that you can use to route traffic to cells. When a routing control state is On, traffic flows to a cell. When the state is Off, traffic does not flow.
    public struct RoutingControl: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the control panel where the routing control is located.
        public var controlPanelArn: Swift.String?
        /// The name of the control panel where the routing control is located.
        public var controlPanelName: Swift.String?
        /// The Amazon Resource Name (ARN) of the routing control.
        public var routingControlArn: Swift.String?
        /// The name of the routing control.
        public var routingControlName: Swift.String?
        /// The current state of the routing control. When a routing control state is On, traffic flows to a cell. When the state is Off, traffic does not flow.
        public var routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?

        public init (
            controlPanelArn: Swift.String? = nil,
            controlPanelName: Swift.String? = nil,
            routingControlArn: Swift.String? = nil,
            routingControlName: Swift.String? = nil,
            routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState? = nil
        )
        {
            self.controlPanelArn = controlPanelArn
            self.controlPanelName = controlPanelName
            self.routingControlArn = routingControlArn
            self.routingControlName = routingControlName
            self.routingControlState = routingControlState
        }
    }

}

extension Route53RecoveryClusterClientTypes {
    public enum RoutingControlState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutingControlState] {
            return [
                .off,
                .on,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "Off"
            case .on: return "On"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoutingControlState(rawValue: rawValue) ?? RoutingControlState.sdkUnknown(rawValue)
        }
    }
}

extension ServiceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limitCode = output.limitCode
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.limitCode = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request can't update that many routing control states at the same time. Try again with fewer routing control states.
public struct ServiceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The code of the limit that was exceeded.
    /// This member is required.
    public var limitCode: Swift.String?
    /// This member is required.
    public var message: Swift.String?
    /// The resource identifier of the limit that was exceeded.
    public var resourceId: Swift.String?
    /// The resource type of the limit that was exceeded.
    public var resourceType: Swift.String?
    /// The service code of the limit that was exceeded.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        limitCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.limitCode = limitCode
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let limitCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitCode
        case message
        case resourceId
        case resourceType
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let limitCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitCode)
        limitCode = limitCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because of request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Advice to clients on when the call can be safely retried
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
        case routingControlState = "RoutingControlState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routingControlArn = self.routingControlArn {
            try encodeContainer.encode(routingControlArn, forKey: .routingControlArn)
        }
        if let routingControlState = self.routingControlState {
            try encodeContainer.encode(routingControlState.rawValue, forKey: .routingControlState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlArn)
        routingControlArn = routingControlArnDecoded
        let routingControlStateDecoded = try containerValues.decodeIfPresent(Route53RecoveryClusterClientTypes.RoutingControlState.self, forKey: .routingControlState)
        routingControlState = routingControlStateDecoded
    }
}

extension Route53RecoveryClusterClientTypes {
    /// A routing control state entry.
    public struct UpdateRoutingControlStateEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for a routing control state entry.
        /// This member is required.
        public var routingControlArn: Swift.String?
        /// The routing control state in a set of routing control state entries.
        /// This member is required.
        public var routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?

        public init (
            routingControlArn: Swift.String? = nil,
            routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState? = nil
        )
        {
            self.routingControlArn = routingControlArn
            self.routingControlState = routingControlState
        }
    }

}

extension UpdateRoutingControlStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
        case routingControlState = "RoutingControlState"
        case safetyRulesToOverride = "SafetyRulesToOverride"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routingControlArn = self.routingControlArn {
            try encodeContainer.encode(routingControlArn, forKey: .routingControlArn)
        }
        if let routingControlState = self.routingControlState {
            try encodeContainer.encode(routingControlState.rawValue, forKey: .routingControlState)
        }
        if let safetyRulesToOverride = safetyRulesToOverride {
            var safetyRulesToOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .safetyRulesToOverride)
            for arn0 in safetyRulesToOverride {
                try safetyRulesToOverrideContainer.encode(arn0)
            }
        }
    }
}

extension UpdateRoutingControlStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRoutingControlStateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the routing control that you want to update the state for.
    /// This member is required.
    public var routingControlArn: Swift.String?
    /// The state of the routing control. You can set the value to be On or Off.
    /// This member is required.
    public var routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?
    /// The Amazon Resource Names (ARNs) for the safety rules that you want to override when you're updating the state of a routing control. You can override one safety rule or multiple safety rules by including one or more ARNs, separated by commas. For more information, see [ Override safety rules to reroute traffic](https://docs.aws.amazon.com/r53recovery/latest/dg/routing-control.override-safety-rule.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
    public var safetyRulesToOverride: [Swift.String]?

    public init (
        routingControlArn: Swift.String? = nil,
        routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState? = nil,
        safetyRulesToOverride: [Swift.String]? = nil
    )
    {
        self.routingControlArn = routingControlArn
        self.routingControlState = routingControlState
        self.safetyRulesToOverride = safetyRulesToOverride
    }
}

struct UpdateRoutingControlStateInputBody: Swift.Equatable {
    let routingControlArn: Swift.String?
    let routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?
    let safetyRulesToOverride: [Swift.String]?
}

extension UpdateRoutingControlStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
        case routingControlState = "RoutingControlState"
        case safetyRulesToOverride = "SafetyRulesToOverride"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlArn)
        routingControlArn = routingControlArnDecoded
        let routingControlStateDecoded = try containerValues.decodeIfPresent(Route53RecoveryClusterClientTypes.RoutingControlState.self, forKey: .routingControlState)
        routingControlState = routingControlStateDecoded
        let safetyRulesToOverrideContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .safetyRulesToOverride)
        var safetyRulesToOverrideDecoded0:[Swift.String]? = nil
        if let safetyRulesToOverrideContainer = safetyRulesToOverrideContainer {
            safetyRulesToOverrideDecoded0 = [Swift.String]()
            for string0 in safetyRulesToOverrideContainer {
                if let string0 = string0 {
                    safetyRulesToOverrideDecoded0?.append(string0)
                }
            }
        }
        safetyRulesToOverride = safetyRulesToOverrideDecoded0
    }
}

extension UpdateRoutingControlStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoutingControlStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointTemporarilyUnavailableException" : self = .endpointTemporarilyUnavailableException(try EndpointTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRoutingControlStateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case endpointTemporarilyUnavailableException(EndpointTemporarilyUnavailableException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoutingControlStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoutingControlStateOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateRoutingControlStatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case safetyRulesToOverride = "SafetyRulesToOverride"
        case updateRoutingControlStateEntries = "UpdateRoutingControlStateEntries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let safetyRulesToOverride = safetyRulesToOverride {
            var safetyRulesToOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .safetyRulesToOverride)
            for arn0 in safetyRulesToOverride {
                try safetyRulesToOverrideContainer.encode(arn0)
            }
        }
        if let updateRoutingControlStateEntries = updateRoutingControlStateEntries {
            var updateRoutingControlStateEntriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updateRoutingControlStateEntries)
            for updateroutingcontrolstateentry0 in updateRoutingControlStateEntries {
                try updateRoutingControlStateEntriesContainer.encode(updateroutingcontrolstateentry0)
            }
        }
    }
}

extension UpdateRoutingControlStatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRoutingControlStatesInput: Swift.Equatable {
    /// The Amazon Resource Names (ARNs) for the safety rules that you want to override when you're updating routing control states. You can override one safety rule or multiple safety rules by including one or more ARNs, separated by commas. For more information, see [ Override safety rules to reroute traffic](https://docs.aws.amazon.com/r53recovery/latest/dg/routing-control.override-safety-rule.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
    public var safetyRulesToOverride: [Swift.String]?
    /// A set of routing control entries that you want to update.
    /// This member is required.
    public var updateRoutingControlStateEntries: [Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]?

    public init (
        safetyRulesToOverride: [Swift.String]? = nil,
        updateRoutingControlStateEntries: [Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]? = nil
    )
    {
        self.safetyRulesToOverride = safetyRulesToOverride
        self.updateRoutingControlStateEntries = updateRoutingControlStateEntries
    }
}

struct UpdateRoutingControlStatesInputBody: Swift.Equatable {
    let updateRoutingControlStateEntries: [Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]?
    let safetyRulesToOverride: [Swift.String]?
}

extension UpdateRoutingControlStatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case safetyRulesToOverride = "SafetyRulesToOverride"
        case updateRoutingControlStateEntries = "UpdateRoutingControlStateEntries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateRoutingControlStateEntriesContainer = try containerValues.decodeIfPresent([Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry?].self, forKey: .updateRoutingControlStateEntries)
        var updateRoutingControlStateEntriesDecoded0:[Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]? = nil
        if let updateRoutingControlStateEntriesContainer = updateRoutingControlStateEntriesContainer {
            updateRoutingControlStateEntriesDecoded0 = [Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]()
            for structure0 in updateRoutingControlStateEntriesContainer {
                if let structure0 = structure0 {
                    updateRoutingControlStateEntriesDecoded0?.append(structure0)
                }
            }
        }
        updateRoutingControlStateEntries = updateRoutingControlStateEntriesDecoded0
        let safetyRulesToOverrideContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .safetyRulesToOverride)
        var safetyRulesToOverrideDecoded0:[Swift.String]? = nil
        if let safetyRulesToOverrideContainer = safetyRulesToOverrideContainer {
            safetyRulesToOverrideDecoded0 = [Swift.String]()
            for string0 in safetyRulesToOverrideContainer {
                if let string0 = string0 {
                    safetyRulesToOverrideDecoded0?.append(string0)
                }
            }
        }
        safetyRulesToOverride = safetyRulesToOverrideDecoded0
    }
}

extension UpdateRoutingControlStatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoutingControlStatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointTemporarilyUnavailableException" : self = .endpointTemporarilyUnavailableException(try EndpointTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRoutingControlStatesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case endpointTemporarilyUnavailableException(EndpointTemporarilyUnavailableException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoutingControlStatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoutingControlStatesOutputResponse: Swift.Equatable {

    public init () { }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a validation error on the request.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The fields that caused the error, if applicable
    public var fields: [Route53RecoveryClusterClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// Reason the request failed validation
    public var reason: Route53RecoveryClusterClientTypes.ValidationExceptionReason?

    public init (
        fields: [Route53RecoveryClusterClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: Route53RecoveryClusterClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: Route53RecoveryClusterClientTypes.ValidationExceptionReason?
    let fields: [Route53RecoveryClusterClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Route53RecoveryClusterClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Route53RecoveryClusterClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[Route53RecoveryClusterClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Route53RecoveryClusterClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension Route53RecoveryClusterClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53RecoveryClusterClientTypes {
    /// There was a validation error on the request.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Information about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The field that had the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension Route53RecoveryClusterClientTypes {
    /// Reason the request failed validation
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
