// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActivateEventSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension ActivateEventSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ActivateEventSourceInput: Swift.Equatable {
    /// The name of the partner event source to activate.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct ActivateEventSourceInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension ActivateEventSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ActivateEventSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateEventSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ActivateEventSourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidStateException(InvalidStateException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateEventSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ActivateEventSourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension EventBridgeClientTypes.ApiDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDestinationArn = "ApiDestinationArn"
        case apiDestinationState = "ApiDestinationState"
        case connectionArn = "ConnectionArn"
        case creationTime = "CreationTime"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiDestinationArn = self.apiDestinationArn {
            try encodeContainer.encode(apiDestinationArn, forKey: .apiDestinationArn)
        }
        if let apiDestinationState = self.apiDestinationState {
            try encodeContainer.encode(apiDestinationState.rawValue, forKey: .apiDestinationState)
        }
        if let connectionArn = self.connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let invocationEndpoint = self.invocationEndpoint {
            try encodeContainer.encode(invocationEndpoint, forKey: .invocationEndpoint)
        }
        if let invocationRateLimitPerSecond = self.invocationRateLimitPerSecond {
            try encodeContainer.encode(invocationRateLimitPerSecond, forKey: .invocationRateLimitPerSecond)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiDestinationArn)
        apiDestinationArn = apiDestinationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let apiDestinationStateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ApiDestinationState.self, forKey: .apiDestinationState)
        apiDestinationState = apiDestinationStateDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let invocationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationEndpoint)
        invocationEndpoint = invocationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ApiDestinationHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let invocationRateLimitPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .invocationRateLimitPerSecond)
        invocationRateLimitPerSecond = invocationRateLimitPerSecondDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains details about an API destination.
    public struct ApiDestination: Swift.Equatable {
        /// The ARN of the API destination.
        public var apiDestinationArn: Swift.String?
        /// The state of the API destination.
        public var apiDestinationState: EventBridgeClientTypes.ApiDestinationState?
        /// The ARN of the connection specified for the API destination.
        public var connectionArn: Swift.String?
        /// A time stamp for the time that the API destination was created.
        public var creationTime: ClientRuntime.Date?
        /// The method to use to connect to the HTTP endpoint.
        public var httpMethod: EventBridgeClientTypes.ApiDestinationHttpMethod?
        /// The URL to the endpoint for the API destination.
        public var invocationEndpoint: Swift.String?
        /// The maximum number of invocations per second to send to the HTTP endpoint.
        public var invocationRateLimitPerSecond: Swift.Int?
        /// A time stamp for the time that the API destination was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the API destination.
        public var name: Swift.String?

        public init (
            apiDestinationArn: Swift.String? = nil,
            apiDestinationState: EventBridgeClientTypes.ApiDestinationState? = nil,
            connectionArn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            httpMethod: EventBridgeClientTypes.ApiDestinationHttpMethod? = nil,
            invocationEndpoint: Swift.String? = nil,
            invocationRateLimitPerSecond: Swift.Int? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.apiDestinationArn = apiDestinationArn
            self.apiDestinationState = apiDestinationState
            self.connectionArn = connectionArn
            self.creationTime = creationTime
            self.httpMethod = httpMethod
            self.invocationEndpoint = invocationEndpoint
            self.invocationRateLimitPerSecond = invocationRateLimitPerSecond
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension EventBridgeClientTypes {
    public enum ApiDestinationHttpMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiDestinationHttpMethod] {
            return [
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiDestinationHttpMethod(rawValue: rawValue) ?? ApiDestinationHttpMethod.sdkUnknown(rawValue)
        }
    }
}

extension EventBridgeClientTypes {
    public enum ApiDestinationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiDestinationState] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiDestinationState(rawValue: rawValue) ?? ApiDestinationState.sdkUnknown(rawValue)
        }
    }
}

extension EventBridgeClientTypes.Archive: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
        case creationTime = "CreationTime"
        case eventCount = "EventCount"
        case eventSourceArn = "EventSourceArn"
        case retentionDays = "RetentionDays"
        case sizeBytes = "SizeBytes"
        case state = "State"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = self.archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if eventCount != 0 {
            try encodeContainer.encode(eventCount, forKey: .eventCount)
        }
        if let eventSourceArn = self.eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let retentionDays = self.retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
        if sizeBytes != 0 {
            try encodeContainer.encode(sizeBytes, forKey: .sizeBytes)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = self.stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ArchiveState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
        let sizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeBytes) ?? 0
        sizeBytes = sizeBytesDecoded
        let eventCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventCount) ?? 0
        eventCount = eventCountDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension EventBridgeClientTypes {
    /// An Archive object that contains details about an archive.
    public struct Archive: Swift.Equatable {
        /// The name of the archive.
        public var archiveName: Swift.String?
        /// The time stamp for the time that the archive was created.
        public var creationTime: ClientRuntime.Date?
        /// The number of events in the archive.
        public var eventCount: Swift.Int
        /// The ARN of the event bus associated with the archive. Only events from this event bus are sent to the archive.
        public var eventSourceArn: Swift.String?
        /// The number of days to retain events in the archive before they are deleted.
        public var retentionDays: Swift.Int?
        /// The size of the archive, in bytes.
        public var sizeBytes: Swift.Int
        /// The current state of the archive.
        public var state: EventBridgeClientTypes.ArchiveState?
        /// A description for the reason that the archive is in the current state.
        public var stateReason: Swift.String?

        public init (
            archiveName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            eventCount: Swift.Int = 0,
            eventSourceArn: Swift.String? = nil,
            retentionDays: Swift.Int? = nil,
            sizeBytes: Swift.Int = 0,
            state: EventBridgeClientTypes.ArchiveState? = nil,
            stateReason: Swift.String? = nil
        )
        {
            self.archiveName = archiveName
            self.creationTime = creationTime
            self.eventCount = eventCount
            self.eventSourceArn = eventSourceArn
            self.retentionDays = retentionDays
            self.sizeBytes = sizeBytes
            self.state = state
            self.stateReason = stateReason
        }
    }

}

extension EventBridgeClientTypes {
    public enum ArchiveState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case creating
        case disabled
        case enabled
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ArchiveState] {
            return [
                .createFailed,
                .creating,
                .disabled,
                .enabled,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArchiveState(rawValue: rawValue) ?? ArchiveState.sdkUnknown(rawValue)
        }
    }
}

extension EventBridgeClientTypes {
    public enum AssignPublicIp: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AssignPublicIp] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssignPublicIp(rawValue: rawValue) ?? AssignPublicIp.sdkUnknown(rawValue)
        }
    }
}

extension EventBridgeClientTypes.AwsVpcConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignPublicIp = "AssignPublicIp"
        case securityGroups = "SecurityGroups"
        case subnets = "Subnets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignPublicIp = self.assignPublicIp {
            try encodeContainer.encode(assignPublicIp.rawValue, forKey: .assignPublicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for string0 in securityGroups {
                try securityGroupsContainer.encode(string0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for string0 in subnets {
                try subnetsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let assignPublicIpDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.AssignPublicIp.self, forKey: .assignPublicIp)
        assignPublicIp = assignPublicIpDecoded
    }
}

extension EventBridgeClientTypes {
    /// This structure specifies the VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.
    public struct AwsVpcConfiguration: Swift.Equatable {
        /// Specifies whether the task's elastic network interface receives a public IP address. You can specify ENABLED only when LaunchType in EcsParameters is set to FARGATE.
        public var assignPublicIp: EventBridgeClientTypes.AssignPublicIp?
        /// Specifies the security groups associated with the task. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.
        public var securityGroups: [Swift.String]?
        /// Specifies the subnets associated with the task. These subnets must all be in the same VPC. You can specify as many as 16 subnets.
        /// This member is required.
        public var subnets: [Swift.String]?

        public init (
            assignPublicIp: EventBridgeClientTypes.AssignPublicIp? = nil,
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
        }
    }

}

extension EventBridgeClientTypes.BatchArrayProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
    }
}

extension EventBridgeClientTypes {
    /// The array properties for the submitted job, such as the size of the array. The array size can be between 2 and 10,000. If you specify array properties for a job, it becomes an array job. This parameter is used only if the target is an Batch job.
    public struct BatchArrayProperties: Swift.Equatable {
        /// The size of the array, if this is an array batch job. Valid values are integers between 2 and 10,000.
        public var size: Swift.Int

        public init (
            size: Swift.Int = 0
        )
        {
            self.size = size
        }
    }

}

extension EventBridgeClientTypes.BatchParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayProperties = "ArrayProperties"
        case jobDefinition = "JobDefinition"
        case jobName = "JobName"
        case retryStrategy = "RetryStrategy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arrayProperties = self.arrayProperties {
            try encodeContainer.encode(arrayProperties, forKey: .arrayProperties)
        }
        if let jobDefinition = self.jobDefinition {
            try encodeContainer.encode(jobDefinition, forKey: .jobDefinition)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let retryStrategy = self.retryStrategy {
            try encodeContainer.encode(retryStrategy, forKey: .retryStrategy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobDefinition)
        jobDefinition = jobDefinitionDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let arrayPropertiesDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.BatchArrayProperties.self, forKey: .arrayProperties)
        arrayProperties = arrayPropertiesDecoded
        let retryStrategyDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.BatchRetryStrategy.self, forKey: .retryStrategy)
        retryStrategy = retryStrategyDecoded
    }
}

extension EventBridgeClientTypes {
    /// The custom parameters to be used when the target is an Batch job.
    public struct BatchParameters: Swift.Equatable {
        /// The array properties for the submitted job, such as the size of the array. The array size can be between 2 and 10,000. If you specify array properties for a job, it becomes an array job. This parameter is used only if the target is an Batch job.
        public var arrayProperties: EventBridgeClientTypes.BatchArrayProperties?
        /// The ARN or name of the job definition to use if the event target is an Batch job. This job definition must already exist.
        /// This member is required.
        public var jobDefinition: Swift.String?
        /// The name to use for this execution of the job, if the target is an Batch job.
        /// This member is required.
        public var jobName: Swift.String?
        /// The retry strategy to use for failed jobs, if the target is an Batch job. The retry strategy is the number of times to retry the failed job execution. Valid values are 1–10. When you specify a retry strategy here, it overrides the retry strategy defined in the job definition.
        public var retryStrategy: EventBridgeClientTypes.BatchRetryStrategy?

        public init (
            arrayProperties: EventBridgeClientTypes.BatchArrayProperties? = nil,
            jobDefinition: Swift.String? = nil,
            jobName: Swift.String? = nil,
            retryStrategy: EventBridgeClientTypes.BatchRetryStrategy? = nil
        )
        {
            self.arrayProperties = arrayProperties
            self.jobDefinition = jobDefinition
            self.jobName = jobName
            self.retryStrategy = retryStrategy
        }
    }

}

extension EventBridgeClientTypes.BatchRetryStrategy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attempts = "Attempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if attempts != 0 {
            try encodeContainer.encode(attempts, forKey: .attempts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attempts) ?? 0
        attempts = attemptsDecoded
    }
}

extension EventBridgeClientTypes {
    /// The retry strategy to use for failed jobs, if the target is an Batch job. If you specify a retry strategy here, it overrides the retry strategy defined in the job definition.
    public struct BatchRetryStrategy: Swift.Equatable {
        /// The number of times to attempt to retry, if the job fails. Valid values are 1–10.
        public var attempts: Swift.Int

        public init (
            attempts: Swift.Int = 0
        )
        {
            self.attempts = attempts
        }
    }

}

extension CancelReplayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replayName = "ReplayName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replayName = self.replayName {
            try encodeContainer.encode(replayName, forKey: .replayName)
        }
    }
}

extension CancelReplayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelReplayInput: Swift.Equatable {
    /// The name of the replay to cancel.
    /// This member is required.
    public var replayName: Swift.String?

    public init (
        replayName: Swift.String? = nil
    )
    {
        self.replayName = replayName
    }
}

struct CancelReplayInputBody: Swift.Equatable {
    let replayName: Swift.String?
}

extension CancelReplayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replayName = "ReplayName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayName)
        replayName = replayNameDecoded
    }
}

extension CancelReplayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelReplayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalStatusException" : self = .illegalStatusException(try IllegalStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelReplayOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case illegalStatusException(IllegalStatusException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelReplayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CancelReplayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replayArn = output.replayArn
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.replayArn = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct CancelReplayOutputResponse: Swift.Equatable {
    /// The ARN of the replay to cancel.
    public var replayArn: Swift.String?
    /// The current state of the replay.
    public var state: EventBridgeClientTypes.ReplayState?
    /// The reason that the replay is in the current state.
    public var stateReason: Swift.String?

    public init (
        replayArn: Swift.String? = nil,
        state: EventBridgeClientTypes.ReplayState? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.replayArn = replayArn
        self.state = state
        self.stateReason = stateReason
    }
}

struct CancelReplayOutputResponseBody: Swift.Equatable {
    let replayArn: Swift.String?
    let state: EventBridgeClientTypes.ReplayState?
    let stateReason: Swift.String?
}

extension CancelReplayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replayArn = "ReplayArn"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayArn)
        replayArn = replayArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ReplayState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
    }
}

extension EventBridgeClientTypes.CapacityProviderStrategyItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base
        case capacityProvider
        case weight
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if base != 0 {
            try encodeContainer.encode(base, forKey: .base)
        }
        if let capacityProvider = self.capacityProvider {
            try encodeContainer.encode(capacityProvider, forKey: .capacityProvider)
        }
        if weight != 0 {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityProvider)
        capacityProvider = capacityProviderDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight) ?? 0
        weight = weightDecoded
        let baseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .base) ?? 0
        base = baseDecoded
    }
}

extension EventBridgeClientTypes {
    /// The details of a capacity provider strategy. To learn more, see [CapacityProviderStrategyItem](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CapacityProviderStrategyItem.html) in the Amazon ECS API Reference.
    public struct CapacityProviderStrategyItem: Swift.Equatable {
        /// The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of 0 is used.
        public var base: Swift.Int
        /// The short name of the capacity provider.
        /// This member is required.
        public var capacityProvider: Swift.String?
        /// The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.
        public var weight: Swift.Int

        public init (
            base: Swift.Int = 0,
            capacityProvider: Swift.String? = nil,
            weight: Swift.Int = 0
        )
        {
            self.base = base
            self.capacityProvider = capacityProvider
            self.weight = weight
        }
    }

}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is concurrent modification on a rule, target, archive, or replay.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventBridgeClientTypes.Condition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension EventBridgeClientTypes {
    /// A JSON string which you can use to limit the event bus permissions you are granting to only accounts that fulfill the condition. Currently, the only supported condition is membership in a certain Amazon Web Services organization. The string must contain Type, Key, and Value fields. The Value field specifies the ID of the Amazon Web Services organization. Following is an example value for Condition: '{"Type" : "StringEquals", "Key": "aws:PrincipalOrgID", "Value": "o-1234567890"}'
    public struct Condition: Swift.Equatable {
        /// Specifies the key for the condition. Currently the only supported key is aws:PrincipalOrgID.
        /// This member is required.
        public var key: Swift.String?
        /// Specifies the type of condition. Currently the only supported value is StringEquals.
        /// This member is required.
        public var type: Swift.String?
        /// Specifies the value for the key. Currently, this must be the ID of the organization.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.type = type
            self.value = value
        }
    }

}

extension EventBridgeClientTypes.Connection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationType = "AuthorizationType"
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationType = self.authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let connectionArn = self.connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionState = self.connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastAuthorizedTime = self.lastAuthorizedTime {
            try encodeContainer.encodeTimestamp(lastAuthorizedTime, format: .epochSeconds, forKey: .lastAuthorizedTime)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stateReason = self.stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionAuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains information about a connection.
    public struct Connection: Swift.Equatable {
        /// The authorization type specified for the connection.
        public var authorizationType: EventBridgeClientTypes.ConnectionAuthorizationType?
        /// The ARN of the connection.
        public var connectionArn: Swift.String?
        /// The state of the connection.
        public var connectionState: EventBridgeClientTypes.ConnectionState?
        /// A time stamp for the time that the connection was created.
        public var creationTime: ClientRuntime.Date?
        /// A time stamp for the time that the connection was last authorized.
        public var lastAuthorizedTime: ClientRuntime.Date?
        /// A time stamp for the time that the connection was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the connection.
        public var name: Swift.String?
        /// The reason that the connection is in the connection state.
        public var stateReason: Swift.String?

        public init (
            authorizationType: EventBridgeClientTypes.ConnectionAuthorizationType? = nil,
            connectionArn: Swift.String? = nil,
            connectionState: EventBridgeClientTypes.ConnectionState? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastAuthorizedTime: ClientRuntime.Date? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            stateReason: Swift.String? = nil
        )
        {
            self.authorizationType = authorizationType
            self.connectionArn = connectionArn
            self.connectionState = connectionState
            self.creationTime = creationTime
            self.lastAuthorizedTime = lastAuthorizedTime
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.stateReason = stateReason
        }
    }

}

extension EventBridgeClientTypes.ConnectionApiKeyAuthResponseParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyName = "ApiKeyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyName = self.apiKeyName {
            try encodeContainer.encode(apiKeyName, forKey: .apiKeyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeyName)
        apiKeyName = apiKeyNameDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the authorization parameters for the connection if API Key is specified as the authorization type.
    public struct ConnectionApiKeyAuthResponseParameters: Swift.Equatable {
        /// The name of the header to use for the APIKeyValue used for authorization.
        public var apiKeyName: Swift.String?

        public init (
            apiKeyName: Swift.String? = nil
        )
        {
            self.apiKeyName = apiKeyName
        }
    }

}

extension EventBridgeClientTypes.ConnectionAuthResponseParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyAuthParameters = "ApiKeyAuthParameters"
        case basicAuthParameters = "BasicAuthParameters"
        case invocationHttpParameters = "InvocationHttpParameters"
        case oAuthParameters = "OAuthParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyAuthParameters = self.apiKeyAuthParameters {
            try encodeContainer.encode(apiKeyAuthParameters, forKey: .apiKeyAuthParameters)
        }
        if let basicAuthParameters = self.basicAuthParameters {
            try encodeContainer.encode(basicAuthParameters, forKey: .basicAuthParameters)
        }
        if let invocationHttpParameters = self.invocationHttpParameters {
            try encodeContainer.encode(invocationHttpParameters, forKey: .invocationHttpParameters)
        }
        if let oAuthParameters = self.oAuthParameters {
            try encodeContainer.encode(oAuthParameters, forKey: .oAuthParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basicAuthParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionBasicAuthResponseParameters.self, forKey: .basicAuthParameters)
        basicAuthParameters = basicAuthParametersDecoded
        let oAuthParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionOAuthResponseParameters.self, forKey: .oAuthParameters)
        oAuthParameters = oAuthParametersDecoded
        let apiKeyAuthParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionApiKeyAuthResponseParameters.self, forKey: .apiKeyAuthParameters)
        apiKeyAuthParameters = apiKeyAuthParametersDecoded
        let invocationHttpParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionHttpParameters.self, forKey: .invocationHttpParameters)
        invocationHttpParameters = invocationHttpParametersDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the authorization parameters to use for the connection.
    public struct ConnectionAuthResponseParameters: Swift.Equatable {
        /// The API Key parameters to use for authorization.
        public var apiKeyAuthParameters: EventBridgeClientTypes.ConnectionApiKeyAuthResponseParameters?
        /// The authorization parameters for Basic authorization.
        public var basicAuthParameters: EventBridgeClientTypes.ConnectionBasicAuthResponseParameters?
        /// Additional parameters for the connection that are passed through with every invocation to the HTTP endpoint.
        public var invocationHttpParameters: EventBridgeClientTypes.ConnectionHttpParameters?
        /// The OAuth parameters to use for authorization.
        public var oAuthParameters: EventBridgeClientTypes.ConnectionOAuthResponseParameters?

        public init (
            apiKeyAuthParameters: EventBridgeClientTypes.ConnectionApiKeyAuthResponseParameters? = nil,
            basicAuthParameters: EventBridgeClientTypes.ConnectionBasicAuthResponseParameters? = nil,
            invocationHttpParameters: EventBridgeClientTypes.ConnectionHttpParameters? = nil,
            oAuthParameters: EventBridgeClientTypes.ConnectionOAuthResponseParameters? = nil
        )
        {
            self.apiKeyAuthParameters = apiKeyAuthParameters
            self.basicAuthParameters = basicAuthParameters
            self.invocationHttpParameters = invocationHttpParameters
            self.oAuthParameters = oAuthParameters
        }
    }

}

extension EventBridgeClientTypes {
    public enum ConnectionAuthorizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiKey
        case basic
        case oauthClientCredentials
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionAuthorizationType] {
            return [
                .apiKey,
                .basic,
                .oauthClientCredentials,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiKey: return "API_KEY"
            case .basic: return "BASIC"
            case .oauthClientCredentials: return "OAUTH_CLIENT_CREDENTIALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionAuthorizationType(rawValue: rawValue) ?? ConnectionAuthorizationType.sdkUnknown(rawValue)
        }
    }
}

extension EventBridgeClientTypes.ConnectionBasicAuthResponseParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the authorization parameters for the connection if Basic is specified as the authorization type.
    public struct ConnectionBasicAuthResponseParameters: Swift.Equatable {
        /// The user name to use for Basic authorization.
        public var username: Swift.String?

        public init (
            username: Swift.String? = nil
        )
        {
            self.username = username
        }
    }

}

extension EventBridgeClientTypes.ConnectionBodyParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isValueSecret = "IsValueSecret"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isValueSecret != false {
            try encodeContainer.encode(isValueSecret, forKey: .isValueSecret)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let isValueSecretDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isValueSecret) ?? false
        isValueSecret = isValueSecretDecoded
    }
}

extension EventBridgeClientTypes {
    /// Additional parameter included in the body. You can include up to 100 additional body parameters per request. An event payload cannot exceed 64 KB.
    public struct ConnectionBodyParameter: Swift.Equatable {
        /// Specified whether the value is secret.
        public var isValueSecret: Swift.Bool
        /// The key for the parameter.
        public var key: Swift.String?
        /// The value associated with the key.
        public var value: Swift.String?

        public init (
            isValueSecret: Swift.Bool = false,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.isValueSecret = isValueSecret
            self.key = key
            self.value = value
        }
    }

}

extension EventBridgeClientTypes.ConnectionHeaderParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isValueSecret = "IsValueSecret"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isValueSecret != false {
            try encodeContainer.encode(isValueSecret, forKey: .isValueSecret)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let isValueSecretDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isValueSecret) ?? false
        isValueSecret = isValueSecretDecoded
    }
}

extension EventBridgeClientTypes {
    /// Additional parameter included in the header. You can include up to 100 additional header parameters per request. An event payload cannot exceed 64 KB.
    public struct ConnectionHeaderParameter: Swift.Equatable {
        /// Specified whether the value is a secret.
        public var isValueSecret: Swift.Bool
        /// The key for the parameter.
        public var key: Swift.String?
        /// The value associated with the key.
        public var value: Swift.String?

        public init (
            isValueSecret: Swift.Bool = false,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.isValueSecret = isValueSecret
            self.key = key
            self.value = value
        }
    }

}

extension EventBridgeClientTypes.ConnectionHttpParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bodyParameters = "BodyParameters"
        case headerParameters = "HeaderParameters"
        case queryStringParameters = "QueryStringParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bodyParameters = bodyParameters {
            var bodyParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bodyParameters)
            for connectionbodyparameter0 in bodyParameters {
                try bodyParametersContainer.encode(connectionbodyparameter0)
            }
        }
        if let headerParameters = headerParameters {
            var headerParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headerParameters)
            for connectionheaderparameter0 in headerParameters {
                try headerParametersContainer.encode(connectionheaderparameter0)
            }
        }
        if let queryStringParameters = queryStringParameters {
            var queryStringParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queryStringParameters)
            for connectionquerystringparameter0 in queryStringParameters {
                try queryStringParametersContainer.encode(connectionquerystringparameter0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerParametersContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.ConnectionHeaderParameter?].self, forKey: .headerParameters)
        var headerParametersDecoded0:[EventBridgeClientTypes.ConnectionHeaderParameter]? = nil
        if let headerParametersContainer = headerParametersContainer {
            headerParametersDecoded0 = [EventBridgeClientTypes.ConnectionHeaderParameter]()
            for structure0 in headerParametersContainer {
                if let structure0 = structure0 {
                    headerParametersDecoded0?.append(structure0)
                }
            }
        }
        headerParameters = headerParametersDecoded0
        let queryStringParametersContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.ConnectionQueryStringParameter?].self, forKey: .queryStringParameters)
        var queryStringParametersDecoded0:[EventBridgeClientTypes.ConnectionQueryStringParameter]? = nil
        if let queryStringParametersContainer = queryStringParametersContainer {
            queryStringParametersDecoded0 = [EventBridgeClientTypes.ConnectionQueryStringParameter]()
            for structure0 in queryStringParametersContainer {
                if let structure0 = structure0 {
                    queryStringParametersDecoded0?.append(structure0)
                }
            }
        }
        queryStringParameters = queryStringParametersDecoded0
        let bodyParametersContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.ConnectionBodyParameter?].self, forKey: .bodyParameters)
        var bodyParametersDecoded0:[EventBridgeClientTypes.ConnectionBodyParameter]? = nil
        if let bodyParametersContainer = bodyParametersContainer {
            bodyParametersDecoded0 = [EventBridgeClientTypes.ConnectionBodyParameter]()
            for structure0 in bodyParametersContainer {
                if let structure0 = structure0 {
                    bodyParametersDecoded0?.append(structure0)
                }
            }
        }
        bodyParameters = bodyParametersDecoded0
    }
}

extension EventBridgeClientTypes {
    /// Contains additional parameters for the connection.
    public struct ConnectionHttpParameters: Swift.Equatable {
        /// Contains additional body string parameters for the connection.
        public var bodyParameters: [EventBridgeClientTypes.ConnectionBodyParameter]?
        /// Contains additional header parameters for the connection.
        public var headerParameters: [EventBridgeClientTypes.ConnectionHeaderParameter]?
        /// Contains additional query string parameters for the connection.
        public var queryStringParameters: [EventBridgeClientTypes.ConnectionQueryStringParameter]?

        public init (
            bodyParameters: [EventBridgeClientTypes.ConnectionBodyParameter]? = nil,
            headerParameters: [EventBridgeClientTypes.ConnectionHeaderParameter]? = nil,
            queryStringParameters: [EventBridgeClientTypes.ConnectionQueryStringParameter]? = nil
        )
        {
            self.bodyParameters = bodyParameters
            self.headerParameters = headerParameters
            self.queryStringParameters = queryStringParameters
        }
    }

}

extension EventBridgeClientTypes.ConnectionOAuthClientResponseParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientID = "ClientID"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientID = self.clientID {
            try encodeContainer.encode(clientID, forKey: .clientID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientID)
        clientID = clientIDDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the client response parameters for the connection when OAuth is specified as the authorization type.
    public struct ConnectionOAuthClientResponseParameters: Swift.Equatable {
        /// The client ID associated with the response to the connection request.
        public var clientID: Swift.String?

        public init (
            clientID: Swift.String? = nil
        )
        {
            self.clientID = clientID
        }
    }

}

extension EventBridgeClientTypes {
    public enum ConnectionOAuthHttpMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `get`
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionOAuthHttpMethod] {
            return [
                .get,
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .get: return "GET"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionOAuthHttpMethod(rawValue: rawValue) ?? ConnectionOAuthHttpMethod.sdkUnknown(rawValue)
        }
    }
}

extension EventBridgeClientTypes.ConnectionOAuthResponseParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationEndpoint = "AuthorizationEndpoint"
        case clientParameters = "ClientParameters"
        case httpMethod = "HttpMethod"
        case oAuthHttpParameters = "OAuthHttpParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationEndpoint = self.authorizationEndpoint {
            try encodeContainer.encode(authorizationEndpoint, forKey: .authorizationEndpoint)
        }
        if let clientParameters = self.clientParameters {
            try encodeContainer.encode(clientParameters, forKey: .clientParameters)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let oAuthHttpParameters = self.oAuthHttpParameters {
            try encodeContainer.encode(oAuthHttpParameters, forKey: .oAuthHttpParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionOAuthClientResponseParameters.self, forKey: .clientParameters)
        clientParameters = clientParametersDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionOAuthHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let oAuthHttpParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionHttpParameters.self, forKey: .oAuthHttpParameters)
        oAuthHttpParameters = oAuthHttpParametersDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the response parameters when OAuth is specified as the authorization type.
    public struct ConnectionOAuthResponseParameters: Swift.Equatable {
        /// The URL to the HTTP endpoint that authorized the request.
        public var authorizationEndpoint: Swift.String?
        /// A ConnectionOAuthClientResponseParameters object that contains details about the client parameters returned when OAuth is specified as the authorization type.
        public var clientParameters: EventBridgeClientTypes.ConnectionOAuthClientResponseParameters?
        /// The method used to connect to the HTTP endpoint.
        public var httpMethod: EventBridgeClientTypes.ConnectionOAuthHttpMethod?
        /// The additional HTTP parameters used for the OAuth authorization request.
        public var oAuthHttpParameters: EventBridgeClientTypes.ConnectionHttpParameters?

        public init (
            authorizationEndpoint: Swift.String? = nil,
            clientParameters: EventBridgeClientTypes.ConnectionOAuthClientResponseParameters? = nil,
            httpMethod: EventBridgeClientTypes.ConnectionOAuthHttpMethod? = nil,
            oAuthHttpParameters: EventBridgeClientTypes.ConnectionHttpParameters? = nil
        )
        {
            self.authorizationEndpoint = authorizationEndpoint
            self.clientParameters = clientParameters
            self.httpMethod = httpMethod
            self.oAuthHttpParameters = oAuthHttpParameters
        }
    }

}

extension EventBridgeClientTypes.ConnectionQueryStringParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isValueSecret = "IsValueSecret"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isValueSecret != false {
            try encodeContainer.encode(isValueSecret, forKey: .isValueSecret)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let isValueSecretDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isValueSecret) ?? false
        isValueSecret = isValueSecretDecoded
    }
}

extension EventBridgeClientTypes {
    /// Additional query string parameter for the connection. You can include up to 100 additional query string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB.
    public struct ConnectionQueryStringParameter: Swift.Equatable {
        /// Specifies whether the value is secret.
        public var isValueSecret: Swift.Bool
        /// The key for a query string parameter.
        public var key: Swift.String?
        /// The value associated with the key for the query string parameter.
        public var value: Swift.String?

        public init (
            isValueSecret: Swift.Bool = false,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.isValueSecret = isValueSecret
            self.key = key
            self.value = value
        }
    }

}

extension EventBridgeClientTypes {
    public enum ConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authorized
        case authorizing
        case creating
        case deauthorized
        case deauthorizing
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionState] {
            return [
                .authorized,
                .authorizing,
                .creating,
                .deauthorized,
                .deauthorizing,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authorized: return "AUTHORIZED"
            case .authorizing: return "AUTHORIZING"
            case .creating: return "CREATING"
            case .deauthorized: return "DEAUTHORIZED"
            case .deauthorizing: return "DEAUTHORIZING"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionState(rawValue: rawValue) ?? ConnectionState.sdkUnknown(rawValue)
        }
    }
}

extension CreateApiDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = self.connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let invocationEndpoint = self.invocationEndpoint {
            try encodeContainer.encode(invocationEndpoint, forKey: .invocationEndpoint)
        }
        if let invocationRateLimitPerSecond = self.invocationRateLimitPerSecond {
            try encodeContainer.encode(invocationRateLimitPerSecond, forKey: .invocationRateLimitPerSecond)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateApiDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateApiDestinationInput: Swift.Equatable {
    /// The ARN of the connection to use for the API destination. The destination endpoint must support the authorization type specified for the connection.
    /// This member is required.
    public var connectionArn: Swift.String?
    /// A description for the API destination to create.
    public var description: Swift.String?
    /// The method to use for the request to the HTTP invocation endpoint.
    /// This member is required.
    public var httpMethod: EventBridgeClientTypes.ApiDestinationHttpMethod?
    /// The URL to the HTTP invocation endpoint for the API destination.
    /// This member is required.
    public var invocationEndpoint: Swift.String?
    /// The maximum number of requests per second to send to the HTTP invocation endpoint.
    public var invocationRateLimitPerSecond: Swift.Int?
    /// The name for the API destination to create.
    /// This member is required.
    public var name: Swift.String?

    public init (
        connectionArn: Swift.String? = nil,
        description: Swift.String? = nil,
        httpMethod: EventBridgeClientTypes.ApiDestinationHttpMethod? = nil,
        invocationEndpoint: Swift.String? = nil,
        invocationRateLimitPerSecond: Swift.Int? = nil,
        name: Swift.String? = nil
    )
    {
        self.connectionArn = connectionArn
        self.description = description
        self.httpMethod = httpMethod
        self.invocationEndpoint = invocationEndpoint
        self.invocationRateLimitPerSecond = invocationRateLimitPerSecond
        self.name = name
    }
}

struct CreateApiDestinationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let connectionArn: Swift.String?
    let invocationEndpoint: Swift.String?
    let httpMethod: EventBridgeClientTypes.ApiDestinationHttpMethod?
    let invocationRateLimitPerSecond: Swift.Int?
}

extension CreateApiDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let invocationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationEndpoint)
        invocationEndpoint = invocationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ApiDestinationHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let invocationRateLimitPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .invocationRateLimitPerSecond)
        invocationRateLimitPerSecond = invocationRateLimitPerSecondDecoded
    }
}

extension CreateApiDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateApiDestinationOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateApiDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiDestinationArn = output.apiDestinationArn
            self.apiDestinationState = output.apiDestinationState
            self.creationTime = output.creationTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.apiDestinationArn = nil
            self.apiDestinationState = nil
            self.creationTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct CreateApiDestinationOutputResponse: Swift.Equatable {
    /// The ARN of the API destination that was created by the request.
    public var apiDestinationArn: Swift.String?
    /// The state of the API destination that was created by the request.
    public var apiDestinationState: EventBridgeClientTypes.ApiDestinationState?
    /// A time stamp indicating the time that the API destination was created.
    public var creationTime: ClientRuntime.Date?
    /// A time stamp indicating the time that the API destination was last modified.
    public var lastModifiedTime: ClientRuntime.Date?

    public init (
        apiDestinationArn: Swift.String? = nil,
        apiDestinationState: EventBridgeClientTypes.ApiDestinationState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil
    )
    {
        self.apiDestinationArn = apiDestinationArn
        self.apiDestinationState = apiDestinationState
        self.creationTime = creationTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct CreateApiDestinationOutputResponseBody: Swift.Equatable {
    let apiDestinationArn: Swift.String?
    let apiDestinationState: EventBridgeClientTypes.ApiDestinationState?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
}

extension CreateApiDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDestinationArn = "ApiDestinationArn"
        case apiDestinationState = "ApiDestinationState"
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiDestinationArn)
        apiDestinationArn = apiDestinationArnDecoded
        let apiDestinationStateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ApiDestinationState.self, forKey: .apiDestinationState)
        apiDestinationState = apiDestinationStateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension CreateArchiveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
        case description = "Description"
        case eventPattern = "EventPattern"
        case eventSourceArn = "EventSourceArn"
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = self.archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventPattern = self.eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let eventSourceArn = self.eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let retentionDays = self.retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }
}

extension CreateArchiveInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateArchiveInput: Swift.Equatable {
    /// The name for the archive to create.
    /// This member is required.
    public var archiveName: Swift.String?
    /// A description for the archive.
    public var description: Swift.String?
    /// An event pattern to use to filter events sent to the archive.
    public var eventPattern: Swift.String?
    /// The ARN of the event bus that sends events to the archive.
    /// This member is required.
    public var eventSourceArn: Swift.String?
    /// The number of days to retain events for. Default value is 0. If set to 0, events are retained indefinitely
    public var retentionDays: Swift.Int?

    public init (
        archiveName: Swift.String? = nil,
        description: Swift.String? = nil,
        eventPattern: Swift.String? = nil,
        eventSourceArn: Swift.String? = nil,
        retentionDays: Swift.Int? = nil
    )
    {
        self.archiveName = archiveName
        self.description = description
        self.eventPattern = eventPattern
        self.eventSourceArn = eventSourceArn
        self.retentionDays = retentionDays
    }
}

struct CreateArchiveInputBody: Swift.Equatable {
    let archiveName: Swift.String?
    let eventSourceArn: Swift.String?
    let description: Swift.String?
    let eventPattern: Swift.String?
    let retentionDays: Swift.Int?
}

extension CreateArchiveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
        case description = "Description"
        case eventPattern = "EventPattern"
        case eventSourceArn = "EventSourceArn"
        case retentionDays = "RetentionDays"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension CreateArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateArchiveOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateArchiveOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.archiveArn = output.archiveArn
            self.creationTime = output.creationTime
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.archiveArn = nil
            self.creationTime = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct CreateArchiveOutputResponse: Swift.Equatable {
    /// The ARN of the archive that was created.
    public var archiveArn: Swift.String?
    /// The time at which the archive was created.
    public var creationTime: ClientRuntime.Date?
    /// The state of the archive that was created.
    public var state: EventBridgeClientTypes.ArchiveState?
    /// The reason that the archive is in the state.
    public var stateReason: Swift.String?

    public init (
        archiveArn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        state: EventBridgeClientTypes.ArchiveState? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.archiveArn = archiveArn
        self.creationTime = creationTime
        self.state = state
        self.stateReason = stateReason
    }
}

struct CreateArchiveOutputResponseBody: Swift.Equatable {
    let archiveArn: Swift.String?
    let state: EventBridgeClientTypes.ArchiveState?
    let stateReason: Swift.String?
    let creationTime: ClientRuntime.Date?
}

extension CreateArchiveOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveArn = "ArchiveArn"
        case creationTime = "CreationTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveArn)
        archiveArn = archiveArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ArchiveState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension EventBridgeClientTypes.CreateConnectionApiKeyAuthRequestParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyName = "ApiKeyName"
        case apiKeyValue = "ApiKeyValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyName = self.apiKeyName {
            try encodeContainer.encode(apiKeyName, forKey: .apiKeyName)
        }
        if let apiKeyValue = self.apiKeyValue {
            try encodeContainer.encode(apiKeyValue, forKey: .apiKeyValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeyName)
        apiKeyName = apiKeyNameDecoded
        let apiKeyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeyValue)
        apiKeyValue = apiKeyValueDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the API key authorization parameters for the connection.
    public struct CreateConnectionApiKeyAuthRequestParameters: Swift.Equatable {
        /// The name of the API key to use for authorization.
        /// This member is required.
        public var apiKeyName: Swift.String?
        /// The value for the API key to use for authorization.
        /// This member is required.
        public var apiKeyValue: Swift.String?

        public init (
            apiKeyName: Swift.String? = nil,
            apiKeyValue: Swift.String? = nil
        )
        {
            self.apiKeyName = apiKeyName
            self.apiKeyValue = apiKeyValue
        }
    }

}

extension EventBridgeClientTypes.CreateConnectionAuthRequestParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyAuthParameters = "ApiKeyAuthParameters"
        case basicAuthParameters = "BasicAuthParameters"
        case invocationHttpParameters = "InvocationHttpParameters"
        case oAuthParameters = "OAuthParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyAuthParameters = self.apiKeyAuthParameters {
            try encodeContainer.encode(apiKeyAuthParameters, forKey: .apiKeyAuthParameters)
        }
        if let basicAuthParameters = self.basicAuthParameters {
            try encodeContainer.encode(basicAuthParameters, forKey: .basicAuthParameters)
        }
        if let invocationHttpParameters = self.invocationHttpParameters {
            try encodeContainer.encode(invocationHttpParameters, forKey: .invocationHttpParameters)
        }
        if let oAuthParameters = self.oAuthParameters {
            try encodeContainer.encode(oAuthParameters, forKey: .oAuthParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basicAuthParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.CreateConnectionBasicAuthRequestParameters.self, forKey: .basicAuthParameters)
        basicAuthParameters = basicAuthParametersDecoded
        let oAuthParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.CreateConnectionOAuthRequestParameters.self, forKey: .oAuthParameters)
        oAuthParameters = oAuthParametersDecoded
        let apiKeyAuthParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.CreateConnectionApiKeyAuthRequestParameters.self, forKey: .apiKeyAuthParameters)
        apiKeyAuthParameters = apiKeyAuthParametersDecoded
        let invocationHttpParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionHttpParameters.self, forKey: .invocationHttpParameters)
        invocationHttpParameters = invocationHttpParametersDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the authorization parameters for the connection.
    public struct CreateConnectionAuthRequestParameters: Swift.Equatable {
        /// A CreateConnectionApiKeyAuthRequestParameters object that contains the API key authorization parameters to use for the connection.
        public var apiKeyAuthParameters: EventBridgeClientTypes.CreateConnectionApiKeyAuthRequestParameters?
        /// A CreateConnectionBasicAuthRequestParameters object that contains the Basic authorization parameters to use for the connection.
        public var basicAuthParameters: EventBridgeClientTypes.CreateConnectionBasicAuthRequestParameters?
        /// A ConnectionHttpParameters object that contains the API key authorization parameters to use for the connection. Note that if you include additional parameters for the target of a rule via HttpParameters, including query strings, the parameters added for the connection take precedence.
        public var invocationHttpParameters: EventBridgeClientTypes.ConnectionHttpParameters?
        /// A CreateConnectionOAuthRequestParameters object that contains the OAuth authorization parameters to use for the connection.
        public var oAuthParameters: EventBridgeClientTypes.CreateConnectionOAuthRequestParameters?

        public init (
            apiKeyAuthParameters: EventBridgeClientTypes.CreateConnectionApiKeyAuthRequestParameters? = nil,
            basicAuthParameters: EventBridgeClientTypes.CreateConnectionBasicAuthRequestParameters? = nil,
            invocationHttpParameters: EventBridgeClientTypes.ConnectionHttpParameters? = nil,
            oAuthParameters: EventBridgeClientTypes.CreateConnectionOAuthRequestParameters? = nil
        )
        {
            self.apiKeyAuthParameters = apiKeyAuthParameters
            self.basicAuthParameters = basicAuthParameters
            self.invocationHttpParameters = invocationHttpParameters
            self.oAuthParameters = oAuthParameters
        }
    }

}

extension EventBridgeClientTypes.CreateConnectionBasicAuthRequestParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the Basic authorization parameters to use for the connection.
    public struct CreateConnectionBasicAuthRequestParameters: Swift.Equatable {
        /// The password associated with the user name to use for Basic authorization.
        /// This member is required.
        public var password: Swift.String?
        /// The user name to use for Basic authorization.
        /// This member is required.
        public var username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension CreateConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authParameters = self.authParameters {
            try encodeContainer.encode(authParameters, forKey: .authParameters)
        }
        if let authorizationType = self.authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateConnectionInput: Swift.Equatable {
    /// A CreateConnectionAuthRequestParameters object that contains the authorization parameters to use to authorize with the endpoint.
    /// This member is required.
    public var authParameters: EventBridgeClientTypes.CreateConnectionAuthRequestParameters?
    /// The type of authorization to use for the connection.
    /// This member is required.
    public var authorizationType: EventBridgeClientTypes.ConnectionAuthorizationType?
    /// A description for the connection to create.
    public var description: Swift.String?
    /// The name for the connection to create.
    /// This member is required.
    public var name: Swift.String?

    public init (
        authParameters: EventBridgeClientTypes.CreateConnectionAuthRequestParameters? = nil,
        authorizationType: EventBridgeClientTypes.ConnectionAuthorizationType? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.authParameters = authParameters
        self.authorizationType = authorizationType
        self.description = description
        self.name = name
    }
}

struct CreateConnectionInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let authorizationType: EventBridgeClientTypes.ConnectionAuthorizationType?
    let authParameters: EventBridgeClientTypes.CreateConnectionAuthRequestParameters?
}

extension CreateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionAuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.CreateConnectionAuthRequestParameters.self, forKey: .authParameters)
        authParameters = authParametersDecoded
    }
}

extension EventBridgeClientTypes.CreateConnectionOAuthClientRequestParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientID = "ClientID"
        case clientSecret = "ClientSecret"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientID = self.clientID {
            try encodeContainer.encode(clientID, forKey: .clientID)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientID)
        clientID = clientIDDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the Basic authorization parameters to use for the connection.
    public struct CreateConnectionOAuthClientRequestParameters: Swift.Equatable {
        /// The client ID to use for OAuth authorization for the connection.
        /// This member is required.
        public var clientID: Swift.String?
        /// The client secret associated with the client ID to use for OAuth authorization for the connection.
        /// This member is required.
        public var clientSecret: Swift.String?

        public init (
            clientID: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        )
        {
            self.clientID = clientID
            self.clientSecret = clientSecret
        }
    }

}

extension EventBridgeClientTypes.CreateConnectionOAuthRequestParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationEndpoint = "AuthorizationEndpoint"
        case clientParameters = "ClientParameters"
        case httpMethod = "HttpMethod"
        case oAuthHttpParameters = "OAuthHttpParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationEndpoint = self.authorizationEndpoint {
            try encodeContainer.encode(authorizationEndpoint, forKey: .authorizationEndpoint)
        }
        if let clientParameters = self.clientParameters {
            try encodeContainer.encode(clientParameters, forKey: .clientParameters)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let oAuthHttpParameters = self.oAuthHttpParameters {
            try encodeContainer.encode(oAuthHttpParameters, forKey: .oAuthHttpParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.CreateConnectionOAuthClientRequestParameters.self, forKey: .clientParameters)
        clientParameters = clientParametersDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionOAuthHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let oAuthHttpParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionHttpParameters.self, forKey: .oAuthHttpParameters)
        oAuthHttpParameters = oAuthHttpParametersDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the OAuth authorization parameters to use for the connection.
    public struct CreateConnectionOAuthRequestParameters: Swift.Equatable {
        /// The URL to the authorization endpoint when OAuth is specified as the authorization type.
        /// This member is required.
        public var authorizationEndpoint: Swift.String?
        /// A CreateConnectionOAuthClientRequestParameters object that contains the client parameters for OAuth authorization.
        /// This member is required.
        public var clientParameters: EventBridgeClientTypes.CreateConnectionOAuthClientRequestParameters?
        /// The method to use for the authorization request.
        /// This member is required.
        public var httpMethod: EventBridgeClientTypes.ConnectionOAuthHttpMethod?
        /// A ConnectionHttpParameters object that contains details about the additional parameters to use for the connection.
        public var oAuthHttpParameters: EventBridgeClientTypes.ConnectionHttpParameters?

        public init (
            authorizationEndpoint: Swift.String? = nil,
            clientParameters: EventBridgeClientTypes.CreateConnectionOAuthClientRequestParameters? = nil,
            httpMethod: EventBridgeClientTypes.ConnectionOAuthHttpMethod? = nil,
            oAuthHttpParameters: EventBridgeClientTypes.ConnectionHttpParameters? = nil
        )
        {
            self.authorizationEndpoint = authorizationEndpoint
            self.clientParameters = clientParameters
            self.httpMethod = httpMethod
            self.oAuthHttpParameters = oAuthHttpParameters
        }
    }

}

extension CreateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateConnectionOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct CreateConnectionOutputResponse: Swift.Equatable {
    /// The ARN of the connection that was created by the request.
    public var connectionArn: Swift.String?
    /// The state of the connection that was created by the request.
    public var connectionState: EventBridgeClientTypes.ConnectionState?
    /// A time stamp for the time that the connection was created.
    public var creationTime: ClientRuntime.Date?
    /// A time stamp for the time that the connection was last updated.
    public var lastModifiedTime: ClientRuntime.Date?

    public init (
        connectionArn: Swift.String? = nil,
        connectionState: EventBridgeClientTypes.ConnectionState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct CreateConnectionOutputResponseBody: Swift.Equatable {
    let connectionArn: Swift.String?
    let connectionState: EventBridgeClientTypes.ConnectionState?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
}

extension CreateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension CreateEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventBuses = "EventBuses"
        case name = "Name"
        case replicationConfig = "ReplicationConfig"
        case roleArn = "RoleArn"
        case routingConfig = "RoutingConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventBuses = eventBuses {
            var eventBusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventBuses)
            for endpointeventbus0 in eventBuses {
                try eventBusesContainer.encode(endpointeventbus0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicationConfig = self.replicationConfig {
            try encodeContainer.encode(replicationConfig, forKey: .replicationConfig)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let routingConfig = self.routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
    }
}

extension CreateEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEndpointInput: Swift.Equatable {
    /// A description of the global endpoint.
    public var description: Swift.String?
    /// Define the event buses used. The names of the event buses must be identical in each Region.
    /// This member is required.
    public var eventBuses: [EventBridgeClientTypes.EndpointEventBus]?
    /// The name of the global endpoint. For example, "Name":"us-east-2-custom_bus_A-endpoint".
    /// This member is required.
    public var name: Swift.String?
    /// Enable or disable event replication.
    public var replicationConfig: EventBridgeClientTypes.ReplicationConfig?
    /// The ARN of the role used for replication.
    public var roleArn: Swift.String?
    /// Configure the routing policy, including the health check and secondary Region..
    /// This member is required.
    public var routingConfig: EventBridgeClientTypes.RoutingConfig?

    public init (
        description: Swift.String? = nil,
        eventBuses: [EventBridgeClientTypes.EndpointEventBus]? = nil,
        name: Swift.String? = nil,
        replicationConfig: EventBridgeClientTypes.ReplicationConfig? = nil,
        roleArn: Swift.String? = nil,
        routingConfig: EventBridgeClientTypes.RoutingConfig? = nil
    )
    {
        self.description = description
        self.eventBuses = eventBuses
        self.name = name
        self.replicationConfig = replicationConfig
        self.roleArn = roleArn
        self.routingConfig = routingConfig
    }
}

struct CreateEndpointInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let routingConfig: EventBridgeClientTypes.RoutingConfig?
    let replicationConfig: EventBridgeClientTypes.ReplicationConfig?
    let eventBuses: [EventBridgeClientTypes.EndpointEventBus]?
    let roleArn: Swift.String?
}

extension CreateEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventBuses = "EventBuses"
        case name = "Name"
        case replicationConfig = "ReplicationConfig"
        case roleArn = "RoleArn"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.RoutingConfig.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let replicationConfigDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ReplicationConfig.self, forKey: .replicationConfig)
        replicationConfig = replicationConfigDecoded
        let eventBusesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.EndpointEventBus?].self, forKey: .eventBuses)
        var eventBusesDecoded0:[EventBridgeClientTypes.EndpointEventBus]? = nil
        if let eventBusesContainer = eventBusesContainer {
            eventBusesDecoded0 = [EventBridgeClientTypes.EndpointEventBus]()
            for structure0 in eventBusesContainer {
                if let structure0 = structure0 {
                    eventBusesDecoded0?.append(structure0)
                }
            }
        }
        eventBuses = eventBusesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CreateEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.eventBuses = output.eventBuses
            self.name = output.name
            self.replicationConfig = output.replicationConfig
            self.roleArn = output.roleArn
            self.routingConfig = output.routingConfig
            self.state = output.state
        } else {
            self.arn = nil
            self.eventBuses = nil
            self.name = nil
            self.replicationConfig = nil
            self.roleArn = nil
            self.routingConfig = nil
            self.state = nil
        }
    }
}

public struct CreateEndpointOutputResponse: Swift.Equatable {
    /// The ARN of the endpoint that was created by this request.
    public var arn: Swift.String?
    /// The event buses used by this request.
    public var eventBuses: [EventBridgeClientTypes.EndpointEventBus]?
    /// The name of the endpoint that was created by this request.
    public var name: Swift.String?
    /// Whether event replication was enabled or disabled by this request.
    public var replicationConfig: EventBridgeClientTypes.ReplicationConfig?
    /// The ARN of the role used by event replication for this request.
    public var roleArn: Swift.String?
    /// The routing configuration defined by this request.
    public var routingConfig: EventBridgeClientTypes.RoutingConfig?
    /// The state of the endpoint that was created by this request.
    public var state: EventBridgeClientTypes.EndpointState?

    public init (
        arn: Swift.String? = nil,
        eventBuses: [EventBridgeClientTypes.EndpointEventBus]? = nil,
        name: Swift.String? = nil,
        replicationConfig: EventBridgeClientTypes.ReplicationConfig? = nil,
        roleArn: Swift.String? = nil,
        routingConfig: EventBridgeClientTypes.RoutingConfig? = nil,
        state: EventBridgeClientTypes.EndpointState? = nil
    )
    {
        self.arn = arn
        self.eventBuses = eventBuses
        self.name = name
        self.replicationConfig = replicationConfig
        self.roleArn = roleArn
        self.routingConfig = routingConfig
        self.state = state
    }
}

struct CreateEndpointOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let routingConfig: EventBridgeClientTypes.RoutingConfig?
    let replicationConfig: EventBridgeClientTypes.ReplicationConfig?
    let eventBuses: [EventBridgeClientTypes.EndpointEventBus]?
    let roleArn: Swift.String?
    let state: EventBridgeClientTypes.EndpointState?
}

extension CreateEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case eventBuses = "EventBuses"
        case name = "Name"
        case replicationConfig = "ReplicationConfig"
        case roleArn = "RoleArn"
        case routingConfig = "RoutingConfig"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.RoutingConfig.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let replicationConfigDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ReplicationConfig.self, forKey: .replicationConfig)
        replicationConfig = replicationConfigDecoded
        let eventBusesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.EndpointEventBus?].self, forKey: .eventBuses)
        var eventBusesDecoded0:[EventBridgeClientTypes.EndpointEventBus]? = nil
        if let eventBusesContainer = eventBusesContainer {
            eventBusesDecoded0 = [EventBridgeClientTypes.EndpointEventBus]()
            for structure0 in eventBusesContainer {
                if let structure0 = structure0 {
                    eventBusesDecoded0?.append(structure0)
                }
            }
        }
        eventBuses = eventBusesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.EndpointState.self, forKey: .state)
        state = stateDecoded
    }
}

extension CreateEventBusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceName = "EventSourceName"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSourceName = self.eventSourceName {
            try encodeContainer.encode(eventSourceName, forKey: .eventSourceName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateEventBusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEventBusInput: Swift.Equatable {
    /// If you are creating a partner event bus, this specifies the partner event source that the new event bus will be matched with.
    public var eventSourceName: Swift.String?
    /// The name of the new event bus. Event bus names cannot contain the / character. You can't use the name default for a custom event bus, as this name is already used for your account's default event bus. If this is a partner event bus, the name must exactly match the name of the partner event source that this event bus is matched to.
    /// This member is required.
    public var name: Swift.String?
    /// Tags to associate with the event bus.
    public var tags: [EventBridgeClientTypes.Tag]?

    public init (
        eventSourceName: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [EventBridgeClientTypes.Tag]? = nil
    )
    {
        self.eventSourceName = eventSourceName
        self.name = name
        self.tags = tags
    }
}

struct CreateEventBusInputBody: Swift.Equatable {
    let name: Swift.String?
    let eventSourceName: Swift.String?
    let tags: [EventBridgeClientTypes.Tag]?
}

extension CreateEventBusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceName = "EventSourceName"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceName)
        eventSourceName = eventSourceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EventBridgeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EventBridgeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEventBusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventBusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateEventBusOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case operationDisabledException(OperationDisabledException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventBusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateEventBusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventBusArn = output.eventBusArn
        } else {
            self.eventBusArn = nil
        }
    }
}

public struct CreateEventBusOutputResponse: Swift.Equatable {
    /// The ARN of the new event bus.
    public var eventBusArn: Swift.String?

    public init (
        eventBusArn: Swift.String? = nil
    )
    {
        self.eventBusArn = eventBusArn
    }
}

struct CreateEventBusOutputResponseBody: Swift.Equatable {
    let eventBusArn: Swift.String?
}

extension CreateEventBusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusArn = "EventBusArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBusArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusArn)
        eventBusArn = eventBusArnDecoded
    }
}

extension CreatePartnerEventSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = self.account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreatePartnerEventSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePartnerEventSourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID that is permitted to create a matching partner event bus for this partner event source.
    /// This member is required.
    public var account: Swift.String?
    /// The name of the partner event source. This name must be unique and must be in the format  partner_name/event_namespace/event_name . The Amazon Web Services account that wants to use this partner event source must create a partner event bus with a name that matches the name of the partner event source.
    /// This member is required.
    public var name: Swift.String?

    public init (
        account: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.account = account
        self.name = name
    }
}

struct CreatePartnerEventSourceInputBody: Swift.Equatable {
    let name: Swift.String?
    let account: Swift.String?
}

extension CreatePartnerEventSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
    }
}

extension CreatePartnerEventSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePartnerEventSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePartnerEventSourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case operationDisabledException(OperationDisabledException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePartnerEventSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePartnerEventSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSourceArn = output.eventSourceArn
        } else {
            self.eventSourceArn = nil
        }
    }
}

public struct CreatePartnerEventSourceOutputResponse: Swift.Equatable {
    /// The ARN of the partner event source.
    public var eventSourceArn: Swift.String?

    public init (
        eventSourceArn: Swift.String? = nil
    )
    {
        self.eventSourceArn = eventSourceArn
    }
}

struct CreatePartnerEventSourceOutputResponseBody: Swift.Equatable {
    let eventSourceArn: Swift.String?
}

extension CreatePartnerEventSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceArn = "EventSourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
    }
}

extension DeactivateEventSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeactivateEventSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeactivateEventSourceInput: Swift.Equatable {
    /// The name of the partner event source to deactivate.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeactivateEventSourceInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeactivateEventSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeactivateEventSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeactivateEventSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeactivateEventSourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidStateException(InvalidStateException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeactivateEventSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeactivateEventSourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension EventBridgeClientTypes.DeadLetterConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension EventBridgeClientTypes {
    /// A DeadLetterConfig object that contains information about a dead-letter queue configuration.
    public struct DeadLetterConfig: Swift.Equatable {
        /// The ARN of the SQS queue specified as the target for the dead-letter queue.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension DeauthorizeConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeauthorizeConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeauthorizeConnectionInput: Swift.Equatable {
    /// The name of the connection to remove authorization from.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeauthorizeConnectionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeauthorizeConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeauthorizeConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeauthorizeConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeauthorizeConnectionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeauthorizeConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeauthorizeConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.lastAuthorizedTime = output.lastAuthorizedTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.lastAuthorizedTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct DeauthorizeConnectionOutputResponse: Swift.Equatable {
    /// The ARN of the connection that authorization was removed from.
    public var connectionArn: Swift.String?
    /// The state of the connection.
    public var connectionState: EventBridgeClientTypes.ConnectionState?
    /// A time stamp for the time that the connection was created.
    public var creationTime: ClientRuntime.Date?
    /// A time stamp for the time that the connection was last authorized.
    public var lastAuthorizedTime: ClientRuntime.Date?
    /// A time stamp for the time that the connection was last updated.
    public var lastModifiedTime: ClientRuntime.Date?

    public init (
        connectionArn: Swift.String? = nil,
        connectionState: EventBridgeClientTypes.ConnectionState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastAuthorizedTime: ClientRuntime.Date? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.lastAuthorizedTime = lastAuthorizedTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct DeauthorizeConnectionOutputResponseBody: Swift.Equatable {
    let connectionArn: Swift.String?
    let connectionState: EventBridgeClientTypes.ConnectionState?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let lastAuthorizedTime: ClientRuntime.Date?
}

extension DeauthorizeConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}

extension DeleteApiDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteApiDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApiDestinationInput: Swift.Equatable {
    /// The name of the destination to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteApiDestinationInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteApiDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteApiDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApiDestinationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApiDestinationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteArchiveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = self.archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
    }
}

extension DeleteArchiveInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteArchiveInput: Swift.Equatable {
    /// The name of the archive to delete.
    /// This member is required.
    public var archiveName: Swift.String?

    public init (
        archiveName: Swift.String? = nil
    )
    {
        self.archiveName = archiveName
    }
}

struct DeleteArchiveInputBody: Swift.Equatable {
    let archiveName: Swift.String?
}

extension DeleteArchiveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
    }
}

extension DeleteArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteArchiveOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteArchiveOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConnectionInput: Swift.Equatable {
    /// The name of the connection to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteConnectionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConnectionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.lastAuthorizedTime = output.lastAuthorizedTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.lastAuthorizedTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct DeleteConnectionOutputResponse: Swift.Equatable {
    /// The ARN of the connection that was deleted.
    public var connectionArn: Swift.String?
    /// The state of the connection before it was deleted.
    public var connectionState: EventBridgeClientTypes.ConnectionState?
    /// A time stamp for the time that the connection was created.
    public var creationTime: ClientRuntime.Date?
    /// A time stamp for the time that the connection was last authorized before it wa deleted.
    public var lastAuthorizedTime: ClientRuntime.Date?
    /// A time stamp for the time that the connection was last modified before it was deleted.
    public var lastModifiedTime: ClientRuntime.Date?

    public init (
        connectionArn: Swift.String? = nil,
        connectionState: EventBridgeClientTypes.ConnectionState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastAuthorizedTime: ClientRuntime.Date? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.lastAuthorizedTime = lastAuthorizedTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct DeleteConnectionOutputResponseBody: Swift.Equatable {
    let connectionArn: Swift.String?
    let connectionState: EventBridgeClientTypes.ConnectionState?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let lastAuthorizedTime: ClientRuntime.Date?
}

extension DeleteConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}

extension DeleteEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEndpointInput: Swift.Equatable {
    /// The name of the endpoint you want to delete. For example, "Name":"us-east-2-custom_bus_A-endpoint"..
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEndpointInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteEndpointOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEndpointOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteEventBusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteEventBusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEventBusInput: Swift.Equatable {
    /// The name of the event bus to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEventBusInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteEventBusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteEventBusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventBusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteEventBusOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventBusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventBusOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePartnerEventSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = self.account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeletePartnerEventSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePartnerEventSourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Amazon Web Services customer that the event source was created for.
    /// This member is required.
    public var account: Swift.String?
    /// The name of the event source to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        account: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.account = account
        self.name = name
    }
}

struct DeletePartnerEventSourceInputBody: Swift.Equatable {
    let name: Swift.String?
    let account: Swift.String?
}

extension DeletePartnerEventSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
    }
}

extension DeletePartnerEventSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePartnerEventSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePartnerEventSourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePartnerEventSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePartnerEventSourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case force = "Force"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = self.eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRuleInput: Swift.Equatable {
    /// The name or ARN of the event bus associated with the rule. If you omit this, the default event bus is used.
    public var eventBusName: Swift.String?
    /// If this is a managed rule, created by an Amazon Web Services service on your behalf, you must specify Force as True to delete the rule. This parameter is ignored for rules that are not managed rules. You can check whether a rule is a managed rule by using DescribeRule or ListRules and checking the ManagedBy field of the response.
    public var force: Swift.Bool
    /// The name of the rule.
    /// This member is required.
    public var name: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        force: Swift.Bool = false,
        name: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.force = force
        self.name = name
    }
}

struct DeleteRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let eventBusName: Swift.String?
    let force: Swift.Bool
}

extension DeleteRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case force = "Force"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let forceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .force) ?? false
        force = forceDecoded
    }
}

extension DeleteRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRuleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeApiDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DescribeApiDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeApiDestinationInput: Swift.Equatable {
    /// The name of the API destination to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeApiDestinationInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DescribeApiDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeApiDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApiDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeApiDestinationOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApiDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeApiDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiDestinationArn = output.apiDestinationArn
            self.apiDestinationState = output.apiDestinationState
            self.connectionArn = output.connectionArn
            self.creationTime = output.creationTime
            self.description = output.description
            self.httpMethod = output.httpMethod
            self.invocationEndpoint = output.invocationEndpoint
            self.invocationRateLimitPerSecond = output.invocationRateLimitPerSecond
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
        } else {
            self.apiDestinationArn = nil
            self.apiDestinationState = nil
            self.connectionArn = nil
            self.creationTime = nil
            self.description = nil
            self.httpMethod = nil
            self.invocationEndpoint = nil
            self.invocationRateLimitPerSecond = nil
            self.lastModifiedTime = nil
            self.name = nil
        }
    }
}

public struct DescribeApiDestinationOutputResponse: Swift.Equatable {
    /// The ARN of the API destination retrieved.
    public var apiDestinationArn: Swift.String?
    /// The state of the API destination retrieved.
    public var apiDestinationState: EventBridgeClientTypes.ApiDestinationState?
    /// The ARN of the connection specified for the API destination retrieved.
    public var connectionArn: Swift.String?
    /// A time stamp for the time that the API destination was created.
    public var creationTime: ClientRuntime.Date?
    /// The description for the API destination retrieved.
    public var description: Swift.String?
    /// The method to use to connect to the HTTP endpoint.
    public var httpMethod: EventBridgeClientTypes.ApiDestinationHttpMethod?
    /// The URL to use to connect to the HTTP endpoint.
    public var invocationEndpoint: Swift.String?
    /// The maximum number of invocations per second to specified for the API destination. Note that if you set the invocation rate maximum to a value lower the rate necessary to send all events received on to the destination HTTP endpoint, some events may not be delivered within the 24-hour retry window. If you plan to set the rate lower than the rate necessary to deliver all events, consider using a dead-letter queue to catch events that are not delivered within 24 hours.
    public var invocationRateLimitPerSecond: Swift.Int?
    /// A time stamp for the time that the API destination was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the API destination retrieved.
    public var name: Swift.String?

    public init (
        apiDestinationArn: Swift.String? = nil,
        apiDestinationState: EventBridgeClientTypes.ApiDestinationState? = nil,
        connectionArn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        httpMethod: EventBridgeClientTypes.ApiDestinationHttpMethod? = nil,
        invocationEndpoint: Swift.String? = nil,
        invocationRateLimitPerSecond: Swift.Int? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiDestinationArn = apiDestinationArn
        self.apiDestinationState = apiDestinationState
        self.connectionArn = connectionArn
        self.creationTime = creationTime
        self.description = description
        self.httpMethod = httpMethod
        self.invocationEndpoint = invocationEndpoint
        self.invocationRateLimitPerSecond = invocationRateLimitPerSecond
        self.lastModifiedTime = lastModifiedTime
        self.name = name
    }
}

struct DescribeApiDestinationOutputResponseBody: Swift.Equatable {
    let apiDestinationArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let apiDestinationState: EventBridgeClientTypes.ApiDestinationState?
    let connectionArn: Swift.String?
    let invocationEndpoint: Swift.String?
    let httpMethod: EventBridgeClientTypes.ApiDestinationHttpMethod?
    let invocationRateLimitPerSecond: Swift.Int?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
}

extension DescribeApiDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDestinationArn = "ApiDestinationArn"
        case apiDestinationState = "ApiDestinationState"
        case connectionArn = "ConnectionArn"
        case creationTime = "CreationTime"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiDestinationArn)
        apiDestinationArn = apiDestinationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let apiDestinationStateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ApiDestinationState.self, forKey: .apiDestinationState)
        apiDestinationState = apiDestinationStateDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let invocationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationEndpoint)
        invocationEndpoint = invocationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ApiDestinationHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let invocationRateLimitPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .invocationRateLimitPerSecond)
        invocationRateLimitPerSecond = invocationRateLimitPerSecondDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension DescribeArchiveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = self.archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
    }
}

extension DescribeArchiveInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeArchiveInput: Swift.Equatable {
    /// The name of the archive to retrieve.
    /// This member is required.
    public var archiveName: Swift.String?

    public init (
        archiveName: Swift.String? = nil
    )
    {
        self.archiveName = archiveName
    }
}

struct DescribeArchiveInputBody: Swift.Equatable {
    let archiveName: Swift.String?
}

extension DescribeArchiveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
    }
}

extension DescribeArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeArchiveOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeArchiveOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.archiveArn = output.archiveArn
            self.archiveName = output.archiveName
            self.creationTime = output.creationTime
            self.description = output.description
            self.eventCount = output.eventCount
            self.eventPattern = output.eventPattern
            self.eventSourceArn = output.eventSourceArn
            self.retentionDays = output.retentionDays
            self.sizeBytes = output.sizeBytes
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.archiveArn = nil
            self.archiveName = nil
            self.creationTime = nil
            self.description = nil
            self.eventCount = 0
            self.eventPattern = nil
            self.eventSourceArn = nil
            self.retentionDays = nil
            self.sizeBytes = 0
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct DescribeArchiveOutputResponse: Swift.Equatable {
    /// The ARN of the archive.
    public var archiveArn: Swift.String?
    /// The name of the archive.
    public var archiveName: Swift.String?
    /// The time at which the archive was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the archive.
    public var description: Swift.String?
    /// The number of events in the archive.
    public var eventCount: Swift.Int
    /// The event pattern used to filter events sent to the archive.
    public var eventPattern: Swift.String?
    /// The ARN of the event source associated with the archive.
    public var eventSourceArn: Swift.String?
    /// The number of days to retain events for in the archive.
    public var retentionDays: Swift.Int?
    /// The size of the archive in bytes.
    public var sizeBytes: Swift.Int
    /// The state of the archive.
    public var state: EventBridgeClientTypes.ArchiveState?
    /// The reason that the archive is in the state.
    public var stateReason: Swift.String?

    public init (
        archiveArn: Swift.String? = nil,
        archiveName: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        eventCount: Swift.Int = 0,
        eventPattern: Swift.String? = nil,
        eventSourceArn: Swift.String? = nil,
        retentionDays: Swift.Int? = nil,
        sizeBytes: Swift.Int = 0,
        state: EventBridgeClientTypes.ArchiveState? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.archiveArn = archiveArn
        self.archiveName = archiveName
        self.creationTime = creationTime
        self.description = description
        self.eventCount = eventCount
        self.eventPattern = eventPattern
        self.eventSourceArn = eventSourceArn
        self.retentionDays = retentionDays
        self.sizeBytes = sizeBytes
        self.state = state
        self.stateReason = stateReason
    }
}

struct DescribeArchiveOutputResponseBody: Swift.Equatable {
    let archiveArn: Swift.String?
    let archiveName: Swift.String?
    let eventSourceArn: Swift.String?
    let description: Swift.String?
    let eventPattern: Swift.String?
    let state: EventBridgeClientTypes.ArchiveState?
    let stateReason: Swift.String?
    let retentionDays: Swift.Int?
    let sizeBytes: Swift.Int
    let eventCount: Swift.Int
    let creationTime: ClientRuntime.Date?
}

extension DescribeArchiveOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveArn = "ArchiveArn"
        case archiveName = "ArchiveName"
        case creationTime = "CreationTime"
        case description = "Description"
        case eventCount = "EventCount"
        case eventPattern = "EventPattern"
        case eventSourceArn = "EventSourceArn"
        case retentionDays = "RetentionDays"
        case sizeBytes = "SizeBytes"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveArn)
        archiveArn = archiveArnDecoded
        let archiveNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ArchiveState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
        let sizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeBytes) ?? 0
        sizeBytes = sizeBytesDecoded
        let eventCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventCount) ?? 0
        eventCount = eventCountDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension DescribeConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DescribeConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConnectionInput: Swift.Equatable {
    /// The name of the connection to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeConnectionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DescribeConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConnectionOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authParameters = output.authParameters
            self.authorizationType = output.authorizationType
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.description = output.description
            self.lastAuthorizedTime = output.lastAuthorizedTime
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.secretArn = output.secretArn
            self.stateReason = output.stateReason
        } else {
            self.authParameters = nil
            self.authorizationType = nil
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.description = nil
            self.lastAuthorizedTime = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.secretArn = nil
            self.stateReason = nil
        }
    }
}

public struct DescribeConnectionOutputResponse: Swift.Equatable {
    /// The parameters to use for authorization for the connection.
    public var authParameters: EventBridgeClientTypes.ConnectionAuthResponseParameters?
    /// The type of authorization specified for the connection.
    public var authorizationType: EventBridgeClientTypes.ConnectionAuthorizationType?
    /// The ARN of the connection retrieved.
    public var connectionArn: Swift.String?
    /// The state of the connection retrieved.
    public var connectionState: EventBridgeClientTypes.ConnectionState?
    /// A time stamp for the time that the connection was created.
    public var creationTime: ClientRuntime.Date?
    /// The description for the connection retrieved.
    public var description: Swift.String?
    /// A time stamp for the time that the connection was last authorized.
    public var lastAuthorizedTime: ClientRuntime.Date?
    /// A time stamp for the time that the connection was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the connection retrieved.
    public var name: Swift.String?
    /// The ARN of the secret created from the authorization parameters specified for the connection.
    public var secretArn: Swift.String?
    /// The reason that the connection is in the current connection state.
    public var stateReason: Swift.String?

    public init (
        authParameters: EventBridgeClientTypes.ConnectionAuthResponseParameters? = nil,
        authorizationType: EventBridgeClientTypes.ConnectionAuthorizationType? = nil,
        connectionArn: Swift.String? = nil,
        connectionState: EventBridgeClientTypes.ConnectionState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastAuthorizedTime: ClientRuntime.Date? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.authParameters = authParameters
        self.authorizationType = authorizationType
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.description = description
        self.lastAuthorizedTime = lastAuthorizedTime
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.secretArn = secretArn
        self.stateReason = stateReason
    }
}

struct DescribeConnectionOutputResponseBody: Swift.Equatable {
    let connectionArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let connectionState: EventBridgeClientTypes.ConnectionState?
    let stateReason: Swift.String?
    let authorizationType: EventBridgeClientTypes.ConnectionAuthorizationType?
    let secretArn: Swift.String?
    let authParameters: EventBridgeClientTypes.ConnectionAuthResponseParameters?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let lastAuthorizedTime: ClientRuntime.Date?
}

extension DescribeConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case description = "Description"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case secretArn = "SecretArn"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionAuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let authParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionAuthResponseParameters.self, forKey: .authParameters)
        authParameters = authParametersDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}

extension DescribeEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegion = "HomeRegion"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeRegion = self.homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DescribeEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEndpointInput: Swift.Equatable {
    /// The primary Region of the endpoint you want to get information about. For example "HomeRegion": "us-east-1".
    public var homeRegion: Swift.String?
    /// The name of the endpoint you want to get information about. For example, "Name":"us-east-2-custom_bus_A-endpoint".
    /// This member is required.
    public var name: Swift.String?

    public init (
        homeRegion: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.homeRegion = homeRegion
        self.name = name
    }
}

struct DescribeEndpointInputBody: Swift.Equatable {
    let name: Swift.String?
    let homeRegion: Swift.String?
}

extension DescribeEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegion = "HomeRegion"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
    }
}

extension DescribeEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.endpointId = output.endpointId
            self.endpointUrl = output.endpointUrl
            self.eventBuses = output.eventBuses
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.replicationConfig = output.replicationConfig
            self.roleArn = output.roleArn
            self.routingConfig = output.routingConfig
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.endpointId = nil
            self.endpointUrl = nil
            self.eventBuses = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.replicationConfig = nil
            self.roleArn = nil
            self.routingConfig = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct DescribeEndpointOutputResponse: Swift.Equatable {
    /// The ARN of the endpoint you asked for information about.
    public var arn: Swift.String?
    /// The time the endpoint you asked for information about was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the endpoint you asked for information about.
    public var description: Swift.String?
    /// The ID of the endpoint you asked for information about.
    public var endpointId: Swift.String?
    /// The URL of the endpoint you asked for information about.
    public var endpointUrl: Swift.String?
    /// The event buses being used by the endpoint you asked for information about.
    public var eventBuses: [EventBridgeClientTypes.EndpointEventBus]?
    /// The last time the endpoint you asked for information about was modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the endpoint you asked for information about.
    public var name: Swift.String?
    /// Whether replication is enabled or disabled for the endpoint you asked for information about.
    public var replicationConfig: EventBridgeClientTypes.ReplicationConfig?
    /// The ARN of the role used by the endpoint you asked for information about.
    public var roleArn: Swift.String?
    /// The routing configuration of the endpoint you asked for information about.
    public var routingConfig: EventBridgeClientTypes.RoutingConfig?
    /// The current state of the endpoint you asked for information about.
    public var state: EventBridgeClientTypes.EndpointState?
    /// The reason the endpoint you asked for information about is in its current state.
    public var stateReason: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        endpointId: Swift.String? = nil,
        endpointUrl: Swift.String? = nil,
        eventBuses: [EventBridgeClientTypes.EndpointEventBus]? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        replicationConfig: EventBridgeClientTypes.ReplicationConfig? = nil,
        roleArn: Swift.String? = nil,
        routingConfig: EventBridgeClientTypes.RoutingConfig? = nil,
        state: EventBridgeClientTypes.EndpointState? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.endpointId = endpointId
        self.endpointUrl = endpointUrl
        self.eventBuses = eventBuses
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.replicationConfig = replicationConfig
        self.roleArn = roleArn
        self.routingConfig = routingConfig
        self.state = state
        self.stateReason = stateReason
    }
}

struct DescribeEndpointOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let arn: Swift.String?
    let routingConfig: EventBridgeClientTypes.RoutingConfig?
    let replicationConfig: EventBridgeClientTypes.ReplicationConfig?
    let eventBuses: [EventBridgeClientTypes.EndpointEventBus]?
    let roleArn: Swift.String?
    let endpointId: Swift.String?
    let endpointUrl: Swift.String?
    let state: EventBridgeClientTypes.EndpointState?
    let stateReason: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
}

extension DescribeEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case description = "Description"
        case endpointId = "EndpointId"
        case endpointUrl = "EndpointUrl"
        case eventBuses = "EventBuses"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case replicationConfig = "ReplicationConfig"
        case roleArn = "RoleArn"
        case routingConfig = "RoutingConfig"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.RoutingConfig.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let replicationConfigDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ReplicationConfig.self, forKey: .replicationConfig)
        replicationConfig = replicationConfigDecoded
        let eventBusesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.EndpointEventBus?].self, forKey: .eventBuses)
        var eventBusesDecoded0:[EventBridgeClientTypes.EndpointEventBus]? = nil
        if let eventBusesContainer = eventBusesContainer {
            eventBusesDecoded0 = [EventBridgeClientTypes.EndpointEventBus]()
            for structure0 in eventBusesContainer {
                if let structure0 = structure0 {
                    eventBusesDecoded0?.append(structure0)
                }
            }
        }
        eventBuses = eventBusesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let endpointUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointUrl)
        endpointUrl = endpointUrlDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.EndpointState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension DescribeEventBusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DescribeEventBusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventBusInput: Swift.Equatable {
    /// The name or ARN of the event bus to show details for. If you omit this, the default event bus is displayed.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeEventBusInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DescribeEventBusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeEventBusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventBusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEventBusOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventBusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEventBusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
            self.policy = output.policy
        } else {
            self.arn = nil
            self.name = nil
            self.policy = nil
        }
    }
}

public struct DescribeEventBusOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the account permitted to write events to the current account.
    public var arn: Swift.String?
    /// The name of the event bus. Currently, this is always default.
    public var name: Swift.String?
    /// The policy that enables the external account to send events to your account.
    public var policy: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.policy = policy
    }
}

struct DescribeEventBusOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let policy: Swift.String?
}

extension DescribeEventBusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension DescribeEventSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DescribeEventSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventSourceInput: Swift.Equatable {
    /// The name of the partner event source to display the details of.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeEventSourceInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DescribeEventSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeEventSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEventSourceOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEventSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdBy = output.createdBy
            self.creationTime = output.creationTime
            self.expirationTime = output.expirationTime
            self.name = output.name
            self.state = output.state
        } else {
            self.arn = nil
            self.createdBy = nil
            self.creationTime = nil
            self.expirationTime = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct DescribeEventSourceOutputResponse: Swift.Equatable {
    /// The ARN of the partner event source.
    public var arn: Swift.String?
    /// The name of the SaaS partner that created the event source.
    public var createdBy: Swift.String?
    /// The date and time that the event source was created.
    public var creationTime: ClientRuntime.Date?
    /// The date and time that the event source will expire if you do not create a matching event bus.
    public var expirationTime: ClientRuntime.Date?
    /// The name of the partner event source.
    public var name: Swift.String?
    /// The state of the event source. If it is ACTIVE, you have already created a matching event bus for this event source, and that event bus is active. If it is PENDING, either you haven't yet created a matching event bus, or that event bus is deactivated. If it is DELETED, you have created a matching event bus, but the event source has since been deleted.
    public var state: EventBridgeClientTypes.EventSourceState?

    public init (
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        expirationTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        state: EventBridgeClientTypes.EventSourceState? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.creationTime = creationTime
        self.expirationTime = expirationTime
        self.name = name
        self.state = state
    }
}

struct DescribeEventSourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let createdBy: Swift.String?
    let creationTime: ClientRuntime.Date?
    let expirationTime: ClientRuntime.Date?
    let name: Swift.String?
    let state: EventBridgeClientTypes.EventSourceState?
}

extension DescribeEventSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdBy = "CreatedBy"
        case creationTime = "CreationTime"
        case expirationTime = "ExpirationTime"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.EventSourceState.self, forKey: .state)
        state = stateDecoded
    }
}

extension DescribePartnerEventSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DescribePartnerEventSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePartnerEventSourceInput: Swift.Equatable {
    /// The name of the event source to display.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribePartnerEventSourceInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DescribePartnerEventSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribePartnerEventSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePartnerEventSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribePartnerEventSourceOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePartnerEventSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribePartnerEventSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct DescribePartnerEventSourceOutputResponse: Swift.Equatable {
    /// The ARN of the event source.
    public var arn: Swift.String?
    /// The name of the event source.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct DescribePartnerEventSourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
}

extension DescribePartnerEventSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeReplayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replayName = "ReplayName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replayName = self.replayName {
            try encodeContainer.encode(replayName, forKey: .replayName)
        }
    }
}

extension DescribeReplayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeReplayInput: Swift.Equatable {
    /// The name of the replay to retrieve.
    /// This member is required.
    public var replayName: Swift.String?

    public init (
        replayName: Swift.String? = nil
    )
    {
        self.replayName = replayName
    }
}

struct DescribeReplayInputBody: Swift.Equatable {
    let replayName: Swift.String?
}

extension DescribeReplayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replayName = "ReplayName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayName)
        replayName = replayNameDecoded
    }
}

extension DescribeReplayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeReplayOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeReplayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.destination = output.destination
            self.eventEndTime = output.eventEndTime
            self.eventLastReplayedTime = output.eventLastReplayedTime
            self.eventSourceArn = output.eventSourceArn
            self.eventStartTime = output.eventStartTime
            self.replayArn = output.replayArn
            self.replayEndTime = output.replayEndTime
            self.replayName = output.replayName
            self.replayStartTime = output.replayStartTime
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.description = nil
            self.destination = nil
            self.eventEndTime = nil
            self.eventLastReplayedTime = nil
            self.eventSourceArn = nil
            self.eventStartTime = nil
            self.replayArn = nil
            self.replayEndTime = nil
            self.replayName = nil
            self.replayStartTime = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct DescribeReplayOutputResponse: Swift.Equatable {
    /// The description of the replay.
    public var description: Swift.String?
    /// A ReplayDestination object that contains details about the replay.
    public var destination: EventBridgeClientTypes.ReplayDestination?
    /// The time stamp for the last event that was replayed from the archive.
    public var eventEndTime: ClientRuntime.Date?
    /// The time that the event was last replayed.
    public var eventLastReplayedTime: ClientRuntime.Date?
    /// The ARN of the archive events were replayed from.
    public var eventSourceArn: Swift.String?
    /// The time stamp of the first event that was last replayed from the archive.
    public var eventStartTime: ClientRuntime.Date?
    /// The ARN of the replay.
    public var replayArn: Swift.String?
    /// A time stamp for the time that the replay stopped.
    public var replayEndTime: ClientRuntime.Date?
    /// The name of the replay.
    public var replayName: Swift.String?
    /// A time stamp for the time that the replay started.
    public var replayStartTime: ClientRuntime.Date?
    /// The current state of the replay.
    public var state: EventBridgeClientTypes.ReplayState?
    /// The reason that the replay is in the current state.
    public var stateReason: Swift.String?

    public init (
        description: Swift.String? = nil,
        destination: EventBridgeClientTypes.ReplayDestination? = nil,
        eventEndTime: ClientRuntime.Date? = nil,
        eventLastReplayedTime: ClientRuntime.Date? = nil,
        eventSourceArn: Swift.String? = nil,
        eventStartTime: ClientRuntime.Date? = nil,
        replayArn: Swift.String? = nil,
        replayEndTime: ClientRuntime.Date? = nil,
        replayName: Swift.String? = nil,
        replayStartTime: ClientRuntime.Date? = nil,
        state: EventBridgeClientTypes.ReplayState? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.description = description
        self.destination = destination
        self.eventEndTime = eventEndTime
        self.eventLastReplayedTime = eventLastReplayedTime
        self.eventSourceArn = eventSourceArn
        self.eventStartTime = eventStartTime
        self.replayArn = replayArn
        self.replayEndTime = replayEndTime
        self.replayName = replayName
        self.replayStartTime = replayStartTime
        self.state = state
        self.stateReason = stateReason
    }
}

struct DescribeReplayOutputResponseBody: Swift.Equatable {
    let replayName: Swift.String?
    let replayArn: Swift.String?
    let description: Swift.String?
    let state: EventBridgeClientTypes.ReplayState?
    let stateReason: Swift.String?
    let eventSourceArn: Swift.String?
    let destination: EventBridgeClientTypes.ReplayDestination?
    let eventStartTime: ClientRuntime.Date?
    let eventEndTime: ClientRuntime.Date?
    let eventLastReplayedTime: ClientRuntime.Date?
    let replayStartTime: ClientRuntime.Date?
    let replayEndTime: ClientRuntime.Date?
}

extension DescribeReplayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destination = "Destination"
        case eventEndTime = "EventEndTime"
        case eventLastReplayedTime = "EventLastReplayedTime"
        case eventSourceArn = "EventSourceArn"
        case eventStartTime = "EventStartTime"
        case replayArn = "ReplayArn"
        case replayEndTime = "ReplayEndTime"
        case replayName = "ReplayName"
        case replayStartTime = "ReplayStartTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayName)
        replayName = replayNameDecoded
        let replayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayArn)
        replayArn = replayArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ReplayState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ReplayDestination.self, forKey: .destination)
        destination = destinationDecoded
        let eventStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventStartTime)
        eventStartTime = eventStartTimeDecoded
        let eventEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventEndTime)
        eventEndTime = eventEndTimeDecoded
        let eventLastReplayedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventLastReplayedTime)
        eventLastReplayedTime = eventLastReplayedTimeDecoded
        let replayStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replayStartTime)
        replayStartTime = replayStartTimeDecoded
        let replayEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replayEndTime)
        replayEndTime = replayEndTimeDecoded
    }
}

extension DescribeRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = self.eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DescribeRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRuleInput: Swift.Equatable {
    /// The name or ARN of the event bus associated with the rule. If you omit this, the default event bus is used.
    public var eventBusName: Swift.String?
    /// The name of the rule.
    /// This member is required.
    public var name: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.name = name
    }
}

struct DescribeRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let eventBusName: Swift.String?
}

extension DescribeRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension DescribeRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRuleOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdBy = output.createdBy
            self.description = output.description
            self.eventBusName = output.eventBusName
            self.eventPattern = output.eventPattern
            self.managedBy = output.managedBy
            self.name = output.name
            self.roleArn = output.roleArn
            self.scheduleExpression = output.scheduleExpression
            self.state = output.state
        } else {
            self.arn = nil
            self.createdBy = nil
            self.description = nil
            self.eventBusName = nil
            self.eventPattern = nil
            self.managedBy = nil
            self.name = nil
            self.roleArn = nil
            self.scheduleExpression = nil
            self.state = nil
        }
    }
}

public struct DescribeRuleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the rule.
    public var arn: Swift.String?
    /// The account ID of the user that created the rule. If you use PutRule to put a rule on an event bus in another account, the other account is the owner of the rule, and the rule ARN includes the account ID for that account. However, the value for CreatedBy is the account ID as the account that created the rule in the other account.
    public var createdBy: Swift.String?
    /// The description of the rule.
    public var description: Swift.String?
    /// The name of the event bus associated with the rule.
    public var eventBusName: Swift.String?
    /// The event pattern. For more information, see [Events and Event Patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-and-event-patterns.html) in the Amazon EventBridge User Guide.
    public var eventPattern: Swift.String?
    /// If this is a managed rule, created by an Amazon Web Services service on your behalf, this field displays the principal name of the Amazon Web Services service that created the rule.
    public var managedBy: Swift.String?
    /// The name of the rule.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role associated with the rule.
    public var roleArn: Swift.String?
    /// The scheduling expression. For example, "cron(0 20 * * ? *)", "rate(5 minutes)".
    public var scheduleExpression: Swift.String?
    /// Specifies whether the rule is enabled or disabled.
    public var state: EventBridgeClientTypes.RuleState?

    public init (
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        eventBusName: Swift.String? = nil,
        eventPattern: Swift.String? = nil,
        managedBy: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        scheduleExpression: Swift.String? = nil,
        state: EventBridgeClientTypes.RuleState? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.description = description
        self.eventBusName = eventBusName
        self.eventPattern = eventPattern
        self.managedBy = managedBy
        self.name = name
        self.roleArn = roleArn
        self.scheduleExpression = scheduleExpression
        self.state = state
    }
}

struct DescribeRuleOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let eventPattern: Swift.String?
    let scheduleExpression: Swift.String?
    let state: EventBridgeClientTypes.RuleState?
    let description: Swift.String?
    let roleArn: Swift.String?
    let managedBy: Swift.String?
    let eventBusName: Swift.String?
    let createdBy: Swift.String?
}

extension DescribeRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdBy = "CreatedBy"
        case description = "Description"
        case eventBusName = "EventBusName"
        case eventPattern = "EventPattern"
        case managedBy = "ManagedBy"
        case name = "Name"
        case roleArn = "RoleArn"
        case scheduleExpression = "ScheduleExpression"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.RuleState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let managedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedBy)
        managedBy = managedByDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension DisableRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = self.eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DisableRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisableRuleInput: Swift.Equatable {
    /// The name or ARN of the event bus associated with the rule. If you omit this, the default event bus is used.
    public var eventBusName: Swift.String?
    /// The name of the rule.
    /// This member is required.
    public var name: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.name = name
    }
}

struct DisableRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let eventBusName: Swift.String?
}

extension DisableRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension DisableRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableRuleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension EventBridgeClientTypes.EcsParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityProviderStrategy = "CapacityProviderStrategy"
        case enableECSManagedTags = "EnableECSManagedTags"
        case enableExecuteCommand = "EnableExecuteCommand"
        case group = "Group"
        case launchType = "LaunchType"
        case networkConfiguration = "NetworkConfiguration"
        case placementConstraints = "PlacementConstraints"
        case placementStrategy = "PlacementStrategy"
        case platformVersion = "PlatformVersion"
        case propagateTags = "PropagateTags"
        case referenceId = "ReferenceId"
        case tags = "Tags"
        case taskCount = "TaskCount"
        case taskDefinitionArn = "TaskDefinitionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityProviderStrategy = capacityProviderStrategy {
            var capacityProviderStrategyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capacityProviderStrategy)
            for capacityproviderstrategyitem0 in capacityProviderStrategy {
                try capacityProviderStrategyContainer.encode(capacityproviderstrategyitem0)
            }
        }
        if enableECSManagedTags != false {
            try encodeContainer.encode(enableECSManagedTags, forKey: .enableECSManagedTags)
        }
        if enableExecuteCommand != false {
            try encodeContainer.encode(enableExecuteCommand, forKey: .enableExecuteCommand)
        }
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let launchType = self.launchType {
            try encodeContainer.encode(launchType.rawValue, forKey: .launchType)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let placementConstraints = placementConstraints {
            var placementConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .placementConstraints)
            for placementconstraint0 in placementConstraints {
                try placementConstraintsContainer.encode(placementconstraint0)
            }
        }
        if let placementStrategy = placementStrategy {
            var placementStrategyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .placementStrategy)
            for placementstrategy0 in placementStrategy {
                try placementStrategyContainer.encode(placementstrategy0)
            }
        }
        if let platformVersion = self.platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let propagateTags = self.propagateTags {
            try encodeContainer.encode(propagateTags.rawValue, forKey: .propagateTags)
        }
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let taskCount = self.taskCount {
            try encodeContainer.encode(taskCount, forKey: .taskCount)
        }
        if let taskDefinitionArn = self.taskDefinitionArn {
            try encodeContainer.encode(taskDefinitionArn, forKey: .taskDefinitionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskDefinitionArn)
        taskDefinitionArn = taskDefinitionArnDecoded
        let taskCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .taskCount)
        taskCount = taskCountDecoded
        let launchTypeDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.LaunchType.self, forKey: .launchType)
        launchType = launchTypeDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let capacityProviderStrategyContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.CapacityProviderStrategyItem?].self, forKey: .capacityProviderStrategy)
        var capacityProviderStrategyDecoded0:[EventBridgeClientTypes.CapacityProviderStrategyItem]? = nil
        if let capacityProviderStrategyContainer = capacityProviderStrategyContainer {
            capacityProviderStrategyDecoded0 = [EventBridgeClientTypes.CapacityProviderStrategyItem]()
            for structure0 in capacityProviderStrategyContainer {
                if let structure0 = structure0 {
                    capacityProviderStrategyDecoded0?.append(structure0)
                }
            }
        }
        capacityProviderStrategy = capacityProviderStrategyDecoded0
        let enableECSManagedTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableECSManagedTags) ?? false
        enableECSManagedTags = enableECSManagedTagsDecoded
        let enableExecuteCommandDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableExecuteCommand) ?? false
        enableExecuteCommand = enableExecuteCommandDecoded
        let placementConstraintsContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.PlacementConstraint?].self, forKey: .placementConstraints)
        var placementConstraintsDecoded0:[EventBridgeClientTypes.PlacementConstraint]? = nil
        if let placementConstraintsContainer = placementConstraintsContainer {
            placementConstraintsDecoded0 = [EventBridgeClientTypes.PlacementConstraint]()
            for structure0 in placementConstraintsContainer {
                if let structure0 = structure0 {
                    placementConstraintsDecoded0?.append(structure0)
                }
            }
        }
        placementConstraints = placementConstraintsDecoded0
        let placementStrategyContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.PlacementStrategy?].self, forKey: .placementStrategy)
        var placementStrategyDecoded0:[EventBridgeClientTypes.PlacementStrategy]? = nil
        if let placementStrategyContainer = placementStrategyContainer {
            placementStrategyDecoded0 = [EventBridgeClientTypes.PlacementStrategy]()
            for structure0 in placementStrategyContainer {
                if let structure0 = structure0 {
                    placementStrategyDecoded0?.append(structure0)
                }
            }
        }
        placementStrategy = placementStrategyDecoded0
        let propagateTagsDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.PropagateTags.self, forKey: .propagateTags)
        propagateTags = propagateTagsDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EventBridgeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EventBridgeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EventBridgeClientTypes {
    /// The custom parameters to be used when the target is an Amazon ECS task.
    public struct EcsParameters: Swift.Equatable {
        /// The capacity provider strategy to use for the task. If a capacityProviderStrategy is specified, the launchType parameter must be omitted. If no capacityProviderStrategy or launchType is specified, the defaultCapacityProviderStrategy for the cluster is used.
        public var capacityProviderStrategy: [EventBridgeClientTypes.CapacityProviderStrategyItem]?
        /// Specifies whether to enable Amazon ECS managed tags for the task. For more information, see [Tagging Your Amazon ECS Resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html) in the Amazon Elastic Container Service Developer Guide.
        public var enableECSManagedTags: Swift.Bool
        /// Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.
        public var enableExecuteCommand: Swift.Bool
        /// Specifies an ECS task group for the task. The maximum length is 255 characters.
        public var group: Swift.String?
        /// Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The FARGATE value is supported only in the Regions where Fargate with Amazon ECS is supported. For more information, see [Fargate on Amazon ECS](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS-Fargate.html) in the Amazon Elastic Container Service Developer Guide.
        public var launchType: EventBridgeClientTypes.LaunchType?
        /// Use this structure if the Amazon ECS task uses the awsvpc network mode. This structure specifies the VPC subnets and security groups associated with the task, and whether a public IP address is to be used. This structure is required if LaunchType is FARGATE because the awsvpc mode is required for Fargate tasks. If you specify NetworkConfiguration when the target ECS task does not use the awsvpc network mode, the task fails.
        public var networkConfiguration: EventBridgeClientTypes.NetworkConfiguration?
        /// An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime).
        public var placementConstraints: [EventBridgeClientTypes.PlacementConstraint]?
        /// The placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task.
        public var placementStrategy: [EventBridgeClientTypes.PlacementStrategy]?
        /// Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0. This structure is used only if LaunchType is FARGATE. For more information about valid platform versions, see [Fargate Platform Versions](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html) in the Amazon Elastic Container Service Developer Guide.
        public var platformVersion: Swift.String?
        /// Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the TagResource API action.
        public var propagateTags: EventBridgeClientTypes.PropagateTags?
        /// The reference ID to use for the task.
        public var referenceId: Swift.String?
        /// The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. To learn more, see [RunTask](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html#ECS-RunTask-request-tags) in the Amazon ECS API Reference.
        public var tags: [EventBridgeClientTypes.Tag]?
        /// The number of tasks to create based on TaskDefinition. The default is 1.
        public var taskCount: Swift.Int?
        /// The ARN of the task definition to use if the event target is an Amazon ECS task.
        /// This member is required.
        public var taskDefinitionArn: Swift.String?

        public init (
            capacityProviderStrategy: [EventBridgeClientTypes.CapacityProviderStrategyItem]? = nil,
            enableECSManagedTags: Swift.Bool = false,
            enableExecuteCommand: Swift.Bool = false,
            group: Swift.String? = nil,
            launchType: EventBridgeClientTypes.LaunchType? = nil,
            networkConfiguration: EventBridgeClientTypes.NetworkConfiguration? = nil,
            placementConstraints: [EventBridgeClientTypes.PlacementConstraint]? = nil,
            placementStrategy: [EventBridgeClientTypes.PlacementStrategy]? = nil,
            platformVersion: Swift.String? = nil,
            propagateTags: EventBridgeClientTypes.PropagateTags? = nil,
            referenceId: Swift.String? = nil,
            tags: [EventBridgeClientTypes.Tag]? = nil,
            taskCount: Swift.Int? = nil,
            taskDefinitionArn: Swift.String? = nil
        )
        {
            self.capacityProviderStrategy = capacityProviderStrategy
            self.enableECSManagedTags = enableECSManagedTags
            self.enableExecuteCommand = enableExecuteCommand
            self.group = group
            self.launchType = launchType
            self.networkConfiguration = networkConfiguration
            self.placementConstraints = placementConstraints
            self.placementStrategy = placementStrategy
            self.platformVersion = platformVersion
            self.propagateTags = propagateTags
            self.referenceId = referenceId
            self.tags = tags
            self.taskCount = taskCount
            self.taskDefinitionArn = taskDefinitionArn
        }
    }

}

extension EnableRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = self.eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension EnableRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableRuleInput: Swift.Equatable {
    /// The name or ARN of the event bus associated with the rule. If you omit this, the default event bus is used.
    public var eventBusName: Swift.String?
    /// The name of the rule.
    /// This member is required.
    public var name: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.name = name
    }
}

struct EnableRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let eventBusName: Swift.String?
}

extension EnableRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension EnableRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableRuleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension EventBridgeClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case description = "Description"
        case endpointId = "EndpointId"
        case endpointUrl = "EndpointUrl"
        case eventBuses = "EventBuses"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case replicationConfig = "ReplicationConfig"
        case roleArn = "RoleArn"
        case routingConfig = "RoutingConfig"
        case state = "State"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let endpointUrl = self.endpointUrl {
            try encodeContainer.encode(endpointUrl, forKey: .endpointUrl)
        }
        if let eventBuses = eventBuses {
            var eventBusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventBuses)
            for endpointeventbus0 in eventBuses {
                try eventBusesContainer.encode(endpointeventbus0)
            }
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicationConfig = self.replicationConfig {
            try encodeContainer.encode(replicationConfig, forKey: .replicationConfig)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let routingConfig = self.routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = self.stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.RoutingConfig.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let replicationConfigDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ReplicationConfig.self, forKey: .replicationConfig)
        replicationConfig = replicationConfigDecoded
        let eventBusesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.EndpointEventBus?].self, forKey: .eventBuses)
        var eventBusesDecoded0:[EventBridgeClientTypes.EndpointEventBus]? = nil
        if let eventBusesContainer = eventBusesContainer {
            eventBusesDecoded0 = [EventBridgeClientTypes.EndpointEventBus]()
            for structure0 in eventBusesContainer {
                if let structure0 = structure0 {
                    eventBusesDecoded0?.append(structure0)
                }
            }
        }
        eventBuses = eventBusesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let endpointUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointUrl)
        endpointUrl = endpointUrlDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.EndpointState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension EventBridgeClientTypes {
    /// An global endpoint used to improve your application's availability by making it regional-fault tolerant. For more information about global endpoints, see [Making applications Regional-fault tolerant with global endpoints and event replication](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-global-endpoints.html) in the Amazon EventBridge User Guide..
    public struct Endpoint: Swift.Equatable {
        /// The ARN of the endpoint.
        public var arn: Swift.String?
        /// The time the endpoint was created.
        public var creationTime: ClientRuntime.Date?
        /// A description for the endpoint.
        public var description: Swift.String?
        /// The URL subdomain of the endpoint. For example, if the URL for Endpoint is abcde.veo.endpoints.event.amazonaws.com, then the EndpointId is abcde.veo.
        public var endpointId: Swift.String?
        /// The URL of the endpoint.
        public var endpointUrl: Swift.String?
        /// The event buses being used by the endpoint.
        public var eventBuses: [EventBridgeClientTypes.EndpointEventBus]?
        /// The last time the endpoint was modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// Whether event replication was enabled or disabled for this endpoint.
        public var replicationConfig: EventBridgeClientTypes.ReplicationConfig?
        /// The ARN of the role used by event replication for the endpoint.
        public var roleArn: Swift.String?
        /// The routing configuration of the endpoint.
        public var routingConfig: EventBridgeClientTypes.RoutingConfig?
        /// The current state of the endpoint.
        public var state: EventBridgeClientTypes.EndpointState?
        /// The reason the endpoint is in its current state.
        public var stateReason: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            endpointUrl: Swift.String? = nil,
            eventBuses: [EventBridgeClientTypes.EndpointEventBus]? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            replicationConfig: EventBridgeClientTypes.ReplicationConfig? = nil,
            roleArn: Swift.String? = nil,
            routingConfig: EventBridgeClientTypes.RoutingConfig? = nil,
            state: EventBridgeClientTypes.EndpointState? = nil,
            stateReason: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.endpointId = endpointId
            self.endpointUrl = endpointUrl
            self.eventBuses = eventBuses
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.replicationConfig = replicationConfig
            self.roleArn = roleArn
            self.routingConfig = routingConfig
            self.state = state
            self.stateReason = stateReason
        }
    }

}

extension EventBridgeClientTypes.EndpointEventBus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusArn = "EventBusArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusArn = self.eventBusArn {
            try encodeContainer.encode(eventBusArn, forKey: .eventBusArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBusArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusArn)
        eventBusArn = eventBusArnDecoded
    }
}

extension EventBridgeClientTypes {
    /// The event buses the endpoint is associated with.
    public struct EndpointEventBus: Swift.Equatable {
        /// The ARN of the event bus the endpoint is associated with.
        /// This member is required.
        public var eventBusArn: Swift.String?

        public init (
            eventBusArn: Swift.String? = nil
        )
        {
            self.eventBusArn = eventBusArn
        }
    }

}

extension EventBridgeClientTypes {
    public enum EndpointState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleteFailed
        case deleting
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointState] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleteFailed,
                .deleting,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointState(rawValue: rawValue) ?? EndpointState.sdkUnknown(rawValue)
        }
    }
}

extension EventBridgeClientTypes.EventBus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension EventBridgeClientTypes {
    /// An event bus receives events from a source and routes them to rules associated with that event bus. Your account's default event bus receives events from Amazon Web Services services. A custom event bus can receive events from your custom applications and services. A partner event bus receives events from an event source created by an SaaS partner. These events come from the partners services or applications.
    public struct EventBus: Swift.Equatable {
        /// The ARN of the event bus.
        public var arn: Swift.String?
        /// The name of the event bus.
        public var name: Swift.String?
        /// The permissions policy of the event bus, describing which other Amazon Web Services accounts can write events to this event bus.
        public var policy: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            policy: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.policy = policy
        }
    }

}

extension EventBridgeClientTypes.EventSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdBy = "CreatedBy"
        case creationTime = "CreationTime"
        case expirationTime = "ExpirationTime"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encodeTimestamp(expirationTime, format: .epochSeconds, forKey: .expirationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.EventSourceState.self, forKey: .state)
        state = stateDecoded
    }
}

extension EventBridgeClientTypes {
    /// A partner event source is created by an SaaS partner. If a customer creates a partner event bus that matches this event source, that Amazon Web Services account can receive events from the partner's applications or services.
    public struct EventSource: Swift.Equatable {
        /// The ARN of the event source.
        public var arn: Swift.String?
        /// The name of the partner that created the event source.
        public var createdBy: Swift.String?
        /// The date and time the event source was created.
        public var creationTime: ClientRuntime.Date?
        /// The date and time that the event source will expire, if the Amazon Web Services account doesn't create a matching event bus for it.
        public var expirationTime: ClientRuntime.Date?
        /// The name of the event source.
        public var name: Swift.String?
        /// The state of the event source. If it is ACTIVE, you have already created a matching event bus for this event source, and that event bus is active. If it is PENDING, either you haven't yet created a matching event bus, or that event bus is deactivated. If it is DELETED, you have created a matching event bus, but the event source has since been deleted.
        public var state: EventBridgeClientTypes.EventSourceState?

        public init (
            arn: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            state: EventBridgeClientTypes.EventSourceState? = nil
        )
        {
            self.arn = arn
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.expirationTime = expirationTime
            self.name = name
            self.state = state
        }
    }

}

extension EventBridgeClientTypes {
    public enum EventSourceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSourceState] {
            return [
                .active,
                .deleted,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventSourceState(rawValue: rawValue) ?? EventSourceState.sdkUnknown(rawValue)
        }
    }
}

extension EventBridgeClientTypes.FailoverConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case primary = "Primary"
        case secondary = "Secondary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let primary = self.primary {
            try encodeContainer.encode(primary, forKey: .primary)
        }
        if let secondary = self.secondary {
            try encodeContainer.encode(secondary, forKey: .secondary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.Primary.self, forKey: .primary)
        primary = primaryDecoded
        let secondaryDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.Secondary.self, forKey: .secondary)
        secondary = secondaryDecoded
    }
}

extension EventBridgeClientTypes {
    /// The failover configuration for an endpoint. This includes what triggers failover and what happens when it's triggered.
    public struct FailoverConfig: Swift.Equatable {
        /// The main Region of the endpoint.
        /// This member is required.
        public var primary: EventBridgeClientTypes.Primary?
        /// The Region that events are routed to when failover is triggered or event replication is enabled.
        /// This member is required.
        public var secondary: EventBridgeClientTypes.Secondary?

        public init (
            primary: EventBridgeClientTypes.Primary? = nil,
            secondary: EventBridgeClientTypes.Secondary? = nil
        )
        {
            self.primary = primary
            self.secondary = secondary
        }
    }

}

extension EventBridgeClientTypes.HttpParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerParameters = "HeaderParameters"
        case pathParameterValues = "PathParameterValues"
        case queryStringParameters = "QueryStringParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headerParameters = headerParameters {
            var headerParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .headerParameters)
            for (dictKey0, headerParametersMap0) in headerParameters {
                try headerParametersContainer.encode(headerParametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let pathParameterValues = pathParameterValues {
            var pathParameterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pathParameterValues)
            for pathparameter0 in pathParameterValues {
                try pathParameterValuesContainer.encode(pathparameter0)
            }
        }
        if let queryStringParameters = queryStringParameters {
            var queryStringParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .queryStringParameters)
            for (dictKey0, queryStringParametersMap0) in queryStringParameters {
                try queryStringParametersContainer.encode(queryStringParametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathParameterValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pathParameterValues)
        var pathParameterValuesDecoded0:[Swift.String]? = nil
        if let pathParameterValuesContainer = pathParameterValuesContainer {
            pathParameterValuesDecoded0 = [Swift.String]()
            for string0 in pathParameterValuesContainer {
                if let string0 = string0 {
                    pathParameterValuesDecoded0?.append(string0)
                }
            }
        }
        pathParameterValues = pathParameterValuesDecoded0
        let headerParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headerParameters)
        var headerParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let headerParametersContainer = headerParametersContainer {
            headerParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, headervalue0) in headerParametersContainer {
                if let headervalue0 = headervalue0 {
                    headerParametersDecoded0?[key0] = headervalue0
                }
            }
        }
        headerParameters = headerParametersDecoded0
        let queryStringParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .queryStringParameters)
        var queryStringParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let queryStringParametersContainer = queryStringParametersContainer {
            queryStringParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, querystringvalue0) in queryStringParametersContainer {
                if let querystringvalue0 = querystringvalue0 {
                    queryStringParametersDecoded0?[key0] = querystringvalue0
                }
            }
        }
        queryStringParameters = queryStringParametersDecoded0
    }
}

extension EventBridgeClientTypes {
    /// These are custom parameter to be used when the target is an API Gateway REST APIs or EventBridge ApiDestinations. In the latter case, these are merged with any InvocationParameters specified on the Connection, with any values from the Connection taking precedence.
    public struct HttpParameters: Swift.Equatable {
        /// The headers that need to be sent as part of request invoking the API Gateway REST API or EventBridge ApiDestination.
        public var headerParameters: [Swift.String:Swift.String]?
        /// The path parameter values to be used to populate API Gateway REST API or EventBridge ApiDestination path wildcards ("*").
        public var pathParameterValues: [Swift.String]?
        /// The query string keys/values that need to be sent as part of request invoking the API Gateway REST API or EventBridge ApiDestination.
        public var queryStringParameters: [Swift.String:Swift.String]?

        public init (
            headerParameters: [Swift.String:Swift.String]? = nil,
            pathParameterValues: [Swift.String]? = nil,
            queryStringParameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.headerParameters = headerParameters
            self.pathParameterValues = pathParameterValues
            self.queryStringParameters = queryStringParameters
        }
    }

}

extension IllegalStatusException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: IllegalStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred because a replay can be canceled only when the state is Running or Starting.
public struct IllegalStatusException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IllegalStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventBridgeClientTypes.InputTransformer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputPathsMap = "InputPathsMap"
        case inputTemplate = "InputTemplate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputPathsMap = inputPathsMap {
            var inputPathsMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .inputPathsMap)
            for (dictKey0, transformerPaths0) in inputPathsMap {
                try inputPathsMapContainer.encode(transformerPaths0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let inputTemplate = self.inputTemplate {
            try encodeContainer.encode(inputTemplate, forKey: .inputTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputPathsMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .inputPathsMap)
        var inputPathsMapDecoded0: [Swift.String:Swift.String]? = nil
        if let inputPathsMapContainer = inputPathsMapContainer {
            inputPathsMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, targetinputpath0) in inputPathsMapContainer {
                if let targetinputpath0 = targetinputpath0 {
                    inputPathsMapDecoded0?[key0] = targetinputpath0
                }
            }
        }
        inputPathsMap = inputPathsMapDecoded0
        let inputTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputTemplate)
        inputTemplate = inputTemplateDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the parameters needed for you to provide custom input to a target based on one or more pieces of data extracted from the event.
    public struct InputTransformer: Swift.Equatable {
        /// Map of JSON paths to be extracted from the event. You can then insert these in the template in InputTemplate to produce the output you want to be sent to the target. InputPathsMap is an array key-value pairs, where each value is a valid JSON path. You can have as many as 100 key-value pairs. You must use JSON dot notation, not bracket notation. The keys cannot start with "Amazon Web Services."
        public var inputPathsMap: [Swift.String:Swift.String]?
        /// Input template where you specify placeholders that will be filled with the values of the keys from InputPathsMap to customize the data sent to the target. Enclose each InputPathsMaps value in brackets: <value> The InputTemplate must be valid JSON. If InputTemplate is a JSON object (surrounded by curly braces), the following restrictions apply:
        ///
        /// * The placeholder cannot be used as an object key.
        ///
        ///
        /// The following example shows the syntax for using InputPathsMap and InputTemplate.  "InputTransformer":
        ///     {
        ///
        ///
        ///     "InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},
        ///
        ///
        ///     "InputTemplate": " is in state "
        ///
        /// } To have the InputTemplate include quote marks within a JSON string, escape each quote marks with a slash, as in the following example:  "InputTransformer":
        ///     {
        ///
        ///
        ///     "InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},
        ///
        ///
        ///     "InputTemplate": " is in state """
        ///
        /// } The InputTemplate can also be valid JSON with varibles in quotes or out, as in the following example:  "InputTransformer":
        ///     {
        ///
        ///
        ///     "InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},
        ///
        ///
        ///     "InputTemplate": '{"myInstance": ,"myStatus": " is in state """}'
        ///
        ///
        ///     }
        /// This member is required.
        public var inputTemplate: Swift.String?

        public init (
            inputPathsMap: [Swift.String:Swift.String]? = nil,
            inputTemplate: Swift.String? = nil
        )
        {
            self.inputPathsMap = inputPathsMap
            self.inputTemplate = inputTemplate
        }
    }

}

extension InternalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception occurs due to unexpected causes.
public struct InternalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventPatternException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidEventPatternExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The event pattern is not valid.
public struct InvalidEventPatternException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventPatternExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEventPatternExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified state is not a valid state for an event source.
public struct InvalidStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventBridgeClientTypes.KinesisParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case partitionKeyPath = "PartitionKeyPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let partitionKeyPath = self.partitionKeyPath {
            try encodeContainer.encode(partitionKeyPath, forKey: .partitionKeyPath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partitionKeyPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partitionKeyPath)
        partitionKeyPath = partitionKeyPathDecoded
    }
}

extension EventBridgeClientTypes {
    /// This object enables you to specify a JSON path to extract from the event and use as the partition key for the Amazon Kinesis data stream, so that you can control the shard to which the event goes. If you do not include this parameter, the default is to use the eventId as the partition key.
    public struct KinesisParameters: Swift.Equatable {
        /// The JSON path to be extracted from the event and used as the partition key. For more information, see [Amazon Kinesis Streams Key Concepts](https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html#partition-key) in the Amazon Kinesis Streams Developer Guide.
        /// This member is required.
        public var partitionKeyPath: Swift.String?

        public init (
            partitionKeyPath: Swift.String? = nil
        )
        {
            self.partitionKeyPath = partitionKeyPath
        }
    }

}

extension EventBridgeClientTypes {
    public enum LaunchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2
        case external
        case fargate
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchType] {
            return [
                .ec2,
                .external,
                .fargate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .external: return "EXTERNAL"
            case .fargate: return "FARGATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchType(rawValue: rawValue) ?? LaunchType.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed because it attempted to create resource beyond the allowed service quota.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApiDestinationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = self.connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApiDestinationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListApiDestinationsInput: Swift.Equatable {
    /// The ARN of the connection specified for the API destination.
    public var connectionArn: Swift.String?
    /// The maximum number of API destinations to include in the response.
    public var limit: Swift.Int?
    /// A name prefix to filter results returned. Only API destinations with a name that starts with the prefix are returned.
    public var namePrefix: Swift.String?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        connectionArn: Swift.String? = nil,
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionArn = connectionArn
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListApiDestinationsInputBody: Swift.Equatable {
    let namePrefix: Swift.String?
    let connectionArn: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListApiDestinationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListApiDestinationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApiDestinationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListApiDestinationsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApiDestinationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListApiDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiDestinations = output.apiDestinations
            self.nextToken = output.nextToken
        } else {
            self.apiDestinations = nil
            self.nextToken = nil
        }
    }
}

public struct ListApiDestinationsOutputResponse: Swift.Equatable {
    /// An array of ApiDestination objects that include information about an API destination.
    public var apiDestinations: [EventBridgeClientTypes.ApiDestination]?
    /// A token you can use in a subsequent request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        apiDestinations: [EventBridgeClientTypes.ApiDestination]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiDestinations = apiDestinations
        self.nextToken = nextToken
    }
}

struct ListApiDestinationsOutputResponseBody: Swift.Equatable {
    let apiDestinations: [EventBridgeClientTypes.ApiDestination]?
    let nextToken: Swift.String?
}

extension ListApiDestinationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDestinations = "ApiDestinations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationsContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.ApiDestination?].self, forKey: .apiDestinations)
        var apiDestinationsDecoded0:[EventBridgeClientTypes.ApiDestination]? = nil
        if let apiDestinationsContainer = apiDestinationsContainer {
            apiDestinationsDecoded0 = [EventBridgeClientTypes.ApiDestination]()
            for structure0 in apiDestinationsContainer {
                if let structure0 = structure0 {
                    apiDestinationsDecoded0?.append(structure0)
                }
            }
        }
        apiDestinations = apiDestinationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListArchivesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceArn = "EventSourceArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSourceArn = self.eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension ListArchivesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListArchivesInput: Swift.Equatable {
    /// The ARN of the event source associated with the archive.
    public var eventSourceArn: Swift.String?
    /// The maximum number of results to return.
    public var limit: Swift.Int?
    /// A name prefix to filter the archives returned. Only archives with name that match the prefix are returned.
    public var namePrefix: Swift.String?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The state of the archive.
    public var state: EventBridgeClientTypes.ArchiveState?

    public init (
        eventSourceArn: Swift.String? = nil,
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        state: EventBridgeClientTypes.ArchiveState? = nil
    )
    {
        self.eventSourceArn = eventSourceArn
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
        self.state = state
    }
}

struct ListArchivesInputBody: Swift.Equatable {
    let namePrefix: Swift.String?
    let eventSourceArn: Swift.String?
    let state: EventBridgeClientTypes.ArchiveState?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListArchivesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceArn = "EventSourceArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ArchiveState.self, forKey: .state)
        state = stateDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListArchivesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListArchivesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListArchivesOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListArchivesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListArchivesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.archives = output.archives
            self.nextToken = output.nextToken
        } else {
            self.archives = nil
            self.nextToken = nil
        }
    }
}

public struct ListArchivesOutputResponse: Swift.Equatable {
    /// An array of Archive objects that include details about an archive.
    public var archives: [EventBridgeClientTypes.Archive]?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        archives: [EventBridgeClientTypes.Archive]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.archives = archives
        self.nextToken = nextToken
    }
}

struct ListArchivesOutputResponseBody: Swift.Equatable {
    let archives: [EventBridgeClientTypes.Archive]?
    let nextToken: Swift.String?
}

extension ListArchivesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archives = "Archives"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archivesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.Archive?].self, forKey: .archives)
        var archivesDecoded0:[EventBridgeClientTypes.Archive]? = nil
        if let archivesContainer = archivesContainer {
            archivesDecoded0 = [EventBridgeClientTypes.Archive]()
            for structure0 in archivesContainer {
                if let structure0 = structure0 {
                    archivesDecoded0?.append(structure0)
                }
            }
        }
        archives = archivesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionState = "ConnectionState"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionState = self.connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListConnectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListConnectionsInput: Swift.Equatable {
    /// The state of the connection.
    public var connectionState: EventBridgeClientTypes.ConnectionState?
    /// The maximum number of connections to return.
    public var limit: Swift.Int?
    /// A name prefix to filter results returned. Only connections with a name that starts with the prefix are returned.
    public var namePrefix: Swift.String?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        connectionState: EventBridgeClientTypes.ConnectionState? = nil,
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionState = connectionState
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListConnectionsInputBody: Swift.Equatable {
    let namePrefix: Swift.String?
    let connectionState: EventBridgeClientTypes.ConnectionState?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionState = "ConnectionState"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListConnectionsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
            self.nextToken = output.nextToken
        } else {
            self.connections = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectionsOutputResponse: Swift.Equatable {
    /// An array of connections objects that include details about the connections.
    public var connections: [EventBridgeClientTypes.Connection]?
    /// A token you can use in a subsequent request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        connections: [EventBridgeClientTypes.Connection]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connections = connections
        self.nextToken = nextToken
    }
}

struct ListConnectionsOutputResponseBody: Swift.Equatable {
    let connections: [EventBridgeClientTypes.Connection]?
    let nextToken: Swift.String?
}

extension ListConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections = "Connections"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[EventBridgeClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [EventBridgeClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegion = "HomeRegion"
        case maxResults = "MaxResults"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeRegion = self.homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEndpointsInput: Swift.Equatable {
    /// The primary Region of the endpoints associated with this account. For example "HomeRegion": "us-east-1".
    public var homeRegion: Swift.String?
    /// The maximum number of results returned by the call.
    public var maxResults: Swift.Int?
    /// A value that will return a subset of the endpoints associated with this account. For example, "NamePrefix": "ABC" will return all endpoints with "ABC" in the name.
    public var namePrefix: Swift.String?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init (
        homeRegion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.homeRegion = homeRegion
        self.maxResults = maxResults
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListEndpointsInputBody: Swift.Equatable {
    let namePrefix: Swift.String?
    let homeRegion: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegion = "HomeRegion"
        case maxResults = "MaxResults"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEndpointsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
            self.nextToken = output.nextToken
        } else {
            self.endpoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListEndpointsOutputResponse: Swift.Equatable {
    /// The endpoints returned by the call.
    public var endpoints: [EventBridgeClientTypes.Endpoint]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init (
        endpoints: [EventBridgeClientTypes.Endpoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

struct ListEndpointsOutputResponseBody: Swift.Equatable {
    let endpoints: [EventBridgeClientTypes.Endpoint]?
    let nextToken: Swift.String?
}

extension ListEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[EventBridgeClientTypes.Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [EventBridgeClientTypes.Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEventBusesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEventBusesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEventBusesInput: Swift.Equatable {
    /// Specifying this limits the number of results returned by this operation. The operation also returns a NextToken which you can use in a subsequent operation to retrieve the next set of results.
    public var limit: Swift.Int?
    /// Specifying this limits the results to only those event buses with names that start with the specified prefix.
    public var namePrefix: Swift.String?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListEventBusesInputBody: Swift.Equatable {
    let namePrefix: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListEventBusesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListEventBusesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventBusesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEventBusesOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventBusesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEventBusesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventBuses = output.eventBuses
            self.nextToken = output.nextToken
        } else {
            self.eventBuses = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventBusesOutputResponse: Swift.Equatable {
    /// This list of event buses.
    public var eventBuses: [EventBridgeClientTypes.EventBus]?
    /// A token you can use in a subsequent operation to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        eventBuses: [EventBridgeClientTypes.EventBus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventBuses = eventBuses
        self.nextToken = nextToken
    }
}

struct ListEventBusesOutputResponseBody: Swift.Equatable {
    let eventBuses: [EventBridgeClientTypes.EventBus]?
    let nextToken: Swift.String?
}

extension ListEventBusesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBuses = "EventBuses"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBusesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.EventBus?].self, forKey: .eventBuses)
        var eventBusesDecoded0:[EventBridgeClientTypes.EventBus]? = nil
        if let eventBusesContainer = eventBusesContainer {
            eventBusesDecoded0 = [EventBridgeClientTypes.EventBus]()
            for structure0 in eventBusesContainer {
                if let structure0 = structure0 {
                    eventBusesDecoded0?.append(structure0)
                }
            }
        }
        eventBuses = eventBusesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEventSourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEventSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEventSourcesInput: Swift.Equatable {
    /// Specifying this limits the number of results returned by this operation. The operation also returns a NextToken which you can use in a subsequent operation to retrieve the next set of results.
    public var limit: Swift.Int?
    /// Specifying this limits the results to only those partner event sources with names that start with the specified prefix.
    public var namePrefix: Swift.String?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListEventSourcesInputBody: Swift.Equatable {
    let namePrefix: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListEventSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListEventSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEventSourcesOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEventSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSources = output.eventSources
            self.nextToken = output.nextToken
        } else {
            self.eventSources = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventSourcesOutputResponse: Swift.Equatable {
    /// The list of event sources.
    public var eventSources: [EventBridgeClientTypes.EventSource]?
    /// A token you can use in a subsequent operation to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        eventSources: [EventBridgeClientTypes.EventSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventSources = eventSources
        self.nextToken = nextToken
    }
}

struct ListEventSourcesOutputResponseBody: Swift.Equatable {
    let eventSources: [EventBridgeClientTypes.EventSource]?
    let nextToken: Swift.String?
}

extension ListEventSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSources = "EventSources"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourcesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.EventSource?].self, forKey: .eventSources)
        var eventSourcesDecoded0:[EventBridgeClientTypes.EventSource]? = nil
        if let eventSourcesContainer = eventSourcesContainer {
            eventSourcesDecoded0 = [EventBridgeClientTypes.EventSource]()
            for structure0 in eventSourcesContainer {
                if let structure0 = structure0 {
                    eventSourcesDecoded0?.append(structure0)
                }
            }
        }
        eventSources = eventSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPartnerEventSourceAccountsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceName = "EventSourceName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSourceName = self.eventSourceName {
            try encodeContainer.encode(eventSourceName, forKey: .eventSourceName)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPartnerEventSourceAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPartnerEventSourceAccountsInput: Swift.Equatable {
    /// The name of the partner event source to display account information about.
    /// This member is required.
    public var eventSourceName: Swift.String?
    /// Specifying this limits the number of results returned by this operation. The operation also returns a NextToken which you can use in a subsequent operation to retrieve the next set of results.
    public var limit: Swift.Int?
    /// The token returned by a previous call to this operation. Specifying this retrieves the next set of results.
    public var nextToken: Swift.String?

    public init (
        eventSourceName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventSourceName = eventSourceName
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListPartnerEventSourceAccountsInputBody: Swift.Equatable {
    let eventSourceName: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListPartnerEventSourceAccountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceName = "EventSourceName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceName)
        eventSourceName = eventSourceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListPartnerEventSourceAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPartnerEventSourceAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPartnerEventSourceAccountsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartnerEventSourceAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPartnerEventSourceAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.partnerEventSourceAccounts = output.partnerEventSourceAccounts
        } else {
            self.nextToken = nil
            self.partnerEventSourceAccounts = nil
        }
    }
}

public struct ListPartnerEventSourceAccountsOutputResponse: Swift.Equatable {
    /// A token you can use in a subsequent operation to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of partner event sources returned by the operation.
    public var partnerEventSourceAccounts: [EventBridgeClientTypes.PartnerEventSourceAccount]?

    public init (
        nextToken: Swift.String? = nil,
        partnerEventSourceAccounts: [EventBridgeClientTypes.PartnerEventSourceAccount]? = nil
    )
    {
        self.nextToken = nextToken
        self.partnerEventSourceAccounts = partnerEventSourceAccounts
    }
}

struct ListPartnerEventSourceAccountsOutputResponseBody: Swift.Equatable {
    let partnerEventSourceAccounts: [EventBridgeClientTypes.PartnerEventSourceAccount]?
    let nextToken: Swift.String?
}

extension ListPartnerEventSourceAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case partnerEventSourceAccounts = "PartnerEventSourceAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partnerEventSourceAccountsContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.PartnerEventSourceAccount?].self, forKey: .partnerEventSourceAccounts)
        var partnerEventSourceAccountsDecoded0:[EventBridgeClientTypes.PartnerEventSourceAccount]? = nil
        if let partnerEventSourceAccountsContainer = partnerEventSourceAccountsContainer {
            partnerEventSourceAccountsDecoded0 = [EventBridgeClientTypes.PartnerEventSourceAccount]()
            for structure0 in partnerEventSourceAccountsContainer {
                if let structure0 = structure0 {
                    partnerEventSourceAccountsDecoded0?.append(structure0)
                }
            }
        }
        partnerEventSourceAccounts = partnerEventSourceAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPartnerEventSourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPartnerEventSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPartnerEventSourcesInput: Swift.Equatable {
    /// pecifying this limits the number of results returned by this operation. The operation also returns a NextToken which you can use in a subsequent operation to retrieve the next set of results.
    public var limit: Swift.Int?
    /// If you specify this, the results are limited to only those partner event sources that start with the string you specify.
    /// This member is required.
    public var namePrefix: Swift.String?
    /// The token returned by a previous call to this operation. Specifying this retrieves the next set of results.
    public var nextToken: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListPartnerEventSourcesInputBody: Swift.Equatable {
    let namePrefix: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListPartnerEventSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListPartnerEventSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPartnerEventSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPartnerEventSourcesOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartnerEventSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPartnerEventSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.partnerEventSources = output.partnerEventSources
        } else {
            self.nextToken = nil
            self.partnerEventSources = nil
        }
    }
}

public struct ListPartnerEventSourcesOutputResponse: Swift.Equatable {
    /// A token you can use in a subsequent operation to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of partner event sources returned by the operation.
    public var partnerEventSources: [EventBridgeClientTypes.PartnerEventSource]?

    public init (
        nextToken: Swift.String? = nil,
        partnerEventSources: [EventBridgeClientTypes.PartnerEventSource]? = nil
    )
    {
        self.nextToken = nextToken
        self.partnerEventSources = partnerEventSources
    }
}

struct ListPartnerEventSourcesOutputResponseBody: Swift.Equatable {
    let partnerEventSources: [EventBridgeClientTypes.PartnerEventSource]?
    let nextToken: Swift.String?
}

extension ListPartnerEventSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case partnerEventSources = "PartnerEventSources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partnerEventSourcesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.PartnerEventSource?].self, forKey: .partnerEventSources)
        var partnerEventSourcesDecoded0:[EventBridgeClientTypes.PartnerEventSource]? = nil
        if let partnerEventSourcesContainer = partnerEventSourcesContainer {
            partnerEventSourcesDecoded0 = [EventBridgeClientTypes.PartnerEventSource]()
            for structure0 in partnerEventSourcesContainer {
                if let structure0 = structure0 {
                    partnerEventSourcesDecoded0?.append(structure0)
                }
            }
        }
        partnerEventSources = partnerEventSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListReplaysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceArn = "EventSourceArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSourceArn = self.eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension ListReplaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListReplaysInput: Swift.Equatable {
    /// The ARN of the archive from which the events are replayed.
    public var eventSourceArn: Swift.String?
    /// The maximum number of replays to retrieve.
    public var limit: Swift.Int?
    /// A name prefix to filter the replays returned. Only replays with name that match the prefix are returned.
    public var namePrefix: Swift.String?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The state of the replay.
    public var state: EventBridgeClientTypes.ReplayState?

    public init (
        eventSourceArn: Swift.String? = nil,
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        state: EventBridgeClientTypes.ReplayState? = nil
    )
    {
        self.eventSourceArn = eventSourceArn
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
        self.state = state
    }
}

struct ListReplaysInputBody: Swift.Equatable {
    let namePrefix: Swift.String?
    let state: EventBridgeClientTypes.ReplayState?
    let eventSourceArn: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListReplaysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceArn = "EventSourceArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ReplayState.self, forKey: .state)
        state = stateDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListReplaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReplaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReplaysOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReplaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReplaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.replays = output.replays
        } else {
            self.nextToken = nil
            self.replays = nil
        }
    }
}

public struct ListReplaysOutputResponse: Swift.Equatable {
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An array of Replay objects that contain information about the replay.
    public var replays: [EventBridgeClientTypes.Replay]?

    public init (
        nextToken: Swift.String? = nil,
        replays: [EventBridgeClientTypes.Replay]? = nil
    )
    {
        self.nextToken = nextToken
        self.replays = replays
    }
}

struct ListReplaysOutputResponseBody: Swift.Equatable {
    let replays: [EventBridgeClientTypes.Replay]?
    let nextToken: Swift.String?
}

extension ListReplaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case replays = "Replays"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replaysContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.Replay?].self, forKey: .replays)
        var replaysDecoded0:[EventBridgeClientTypes.Replay]? = nil
        if let replaysContainer = replaysContainer {
            replaysDecoded0 = [EventBridgeClientTypes.Replay]()
            for structure0 in replaysContainer {
                if let structure0 = structure0 {
                    replaysDecoded0?.append(structure0)
                }
            }
        }
        replays = replaysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRuleNamesByTargetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = self.eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

extension ListRuleNamesByTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRuleNamesByTargetInput: Swift.Equatable {
    /// The name or ARN of the event bus to list rules for. If you omit this, the default event bus is used.
    public var eventBusName: Swift.String?
    /// The maximum number of results to return.
    public var limit: Swift.Int?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the target resource.
    /// This member is required.
    public var targetArn: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.limit = limit
        self.nextToken = nextToken
        self.targetArn = targetArn
    }
}

struct ListRuleNamesByTargetInputBody: Swift.Equatable {
    let targetArn: Swift.String?
    let eventBusName: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListRuleNamesByTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case targetArn = "TargetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListRuleNamesByTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRuleNamesByTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRuleNamesByTargetOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRuleNamesByTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRuleNamesByTargetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.ruleNames = output.ruleNames
        } else {
            self.nextToken = nil
            self.ruleNames = nil
        }
    }
}

public struct ListRuleNamesByTargetOutputResponse: Swift.Equatable {
    /// Indicates whether there are additional results to retrieve. If there are no more results, the value is null.
    public var nextToken: Swift.String?
    /// The names of the rules that can invoke the given target.
    public var ruleNames: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        ruleNames: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleNames = ruleNames
    }
}

struct ListRuleNamesByTargetOutputResponseBody: Swift.Equatable {
    let ruleNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListRuleNamesByTargetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case ruleNames = "RuleNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ruleNames)
        var ruleNamesDecoded0:[Swift.String]? = nil
        if let ruleNamesContainer = ruleNamesContainer {
            ruleNamesDecoded0 = [Swift.String]()
            for string0 in ruleNamesContainer {
                if let string0 = string0 {
                    ruleNamesDecoded0?.append(string0)
                }
            }
        }
        ruleNames = ruleNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = self.eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRulesInput: Swift.Equatable {
    /// The name or ARN of the event bus to list the rules for. If you omit this, the default event bus is used.
    public var eventBusName: Swift.String?
    /// The maximum number of results to return.
    public var limit: Swift.Int?
    /// The prefix matching the rule name.
    public var namePrefix: Swift.String?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListRulesInputBody: Swift.Equatable {
    let namePrefix: Swift.String?
    let eventBusName: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRulesOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rules = output.rules
        } else {
            self.nextToken = nil
            self.rules = nil
        }
    }
}

public struct ListRulesOutputResponse: Swift.Equatable {
    /// Indicates whether there are additional results to retrieve. If there are no more results, the value is null.
    public var nextToken: Swift.String?
    /// The rules that match the specified criteria.
    public var rules: [EventBridgeClientTypes.Rule]?

    public init (
        nextToken: Swift.String? = nil,
        rules: [EventBridgeClientTypes.Rule]? = nil
    )
    {
        self.nextToken = nextToken
        self.rules = rules
    }
}

struct ListRulesOutputResponseBody: Swift.Equatable {
    let rules: [EventBridgeClientTypes.Rule]?
    let nextToken: Swift.String?
}

extension ListRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rules = "Rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[EventBridgeClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [EventBridgeClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the EventBridge resource for which you want to view tags.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tag keys and values associated with the resource you specified
    public var tags: [EventBridgeClientTypes.Tag]?

    public init (
        tags: [EventBridgeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [EventBridgeClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EventBridgeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EventBridgeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTargetsByRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case rule = "Rule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = self.eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rule = self.rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
    }
}

extension ListTargetsByRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTargetsByRuleInput: Swift.Equatable {
    /// The name or ARN of the event bus associated with the rule. If you omit this, the default event bus is used.
    public var eventBusName: Swift.String?
    /// The maximum number of results to return.
    public var limit: Swift.Int?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The name of the rule.
    /// This member is required.
    public var rule: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        rule: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.limit = limit
        self.nextToken = nextToken
        self.rule = rule
    }
}

struct ListTargetsByRuleInputBody: Swift.Equatable {
    let rule: Swift.String?
    let eventBusName: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListTargetsByRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case rule = "Rule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rule)
        rule = ruleDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTargetsByRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTargetsByRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTargetsByRuleOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTargetsByRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTargetsByRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.targets = output.targets
        } else {
            self.nextToken = nil
            self.targets = nil
        }
    }
}

public struct ListTargetsByRuleOutputResponse: Swift.Equatable {
    /// Indicates whether there are additional results to retrieve. If there are no more results, the value is null.
    public var nextToken: Swift.String?
    /// The targets assigned to the rule.
    public var targets: [EventBridgeClientTypes.Target]?

    public init (
        nextToken: Swift.String? = nil,
        targets: [EventBridgeClientTypes.Target]? = nil
    )
    {
        self.nextToken = nextToken
        self.targets = targets
    }
}

struct ListTargetsByRuleOutputResponseBody: Swift.Equatable {
    let targets: [EventBridgeClientTypes.Target]?
    let nextToken: Swift.String?
}

extension ListTargetsByRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[EventBridgeClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [EventBridgeClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ManagedRuleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ManagedRuleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This rule was created by an Amazon Web Services service on behalf of your account. It is managed by that service. If you see this error in response to DeleteRule or RemoveTargets, you can use the Force parameter in those calls to delete the rule or remove targets from the rule. You cannot modify these managed rules by using DisableRule, EnableRule, PutTargets, PutRule, TagResource, or UntagResource.
public struct ManagedRuleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ManagedRuleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ManagedRuleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventBridgeClientTypes.NetworkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsvpcConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsvpcConfiguration = self.awsvpcConfiguration {
            try encodeContainer.encode(awsvpcConfiguration, forKey: .awsvpcConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsvpcConfigurationDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.AwsVpcConfiguration.self, forKey: .awsvpcConfiguration)
        awsvpcConfiguration = awsvpcConfigurationDecoded
    }
}

extension EventBridgeClientTypes {
    /// This structure specifies the network configuration for an ECS task.
    public struct NetworkConfiguration: Swift.Equatable {
        /// Use this structure to specify the VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.
        public var awsvpcConfiguration: EventBridgeClientTypes.AwsVpcConfiguration?

        public init (
            awsvpcConfiguration: EventBridgeClientTypes.AwsVpcConfiguration? = nil
        )
        {
            self.awsvpcConfiguration = awsvpcConfiguration
        }
    }

}

extension OperationDisabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OperationDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation you are attempting is not available in this region.
public struct OperationDisabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationDisabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventBridgeClientTypes.PartnerEventSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension EventBridgeClientTypes {
    /// A partner event source is created by an SaaS partner. If a customer creates a partner event bus that matches this event source, that Amazon Web Services account can receive events from the partner's applications or services.
    public struct PartnerEventSource: Swift.Equatable {
        /// The ARN of the partner event source.
        public var arn: Swift.String?
        /// The name of the partner event source.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension EventBridgeClientTypes.PartnerEventSourceAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case creationTime = "CreationTime"
        case expirationTime = "ExpirationTime"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = self.account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encodeTimestamp(expirationTime, format: .epochSeconds, forKey: .expirationTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.EventSourceState.self, forKey: .state)
        state = stateDecoded
    }
}

extension EventBridgeClientTypes {
    /// The Amazon Web Services account that a partner event source has been offered to.
    public struct PartnerEventSourceAccount: Swift.Equatable {
        /// The Amazon Web Services account ID that the partner event source was offered to.
        public var account: Swift.String?
        /// The date and time the event source was created.
        public var creationTime: ClientRuntime.Date?
        /// The date and time that the event source will expire, if the Amazon Web Services account doesn't create a matching event bus for it.
        public var expirationTime: ClientRuntime.Date?
        /// The state of the event source. If it is ACTIVE, you have already created a matching event bus for this event source, and that event bus is active. If it is PENDING, either you haven't yet created a matching event bus, or that event bus is deactivated. If it is DELETED, you have created a matching event bus, but the event source has since been deleted.
        public var state: EventBridgeClientTypes.EventSourceState?

        public init (
            account: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            state: EventBridgeClientTypes.EventSourceState? = nil
        )
        {
            self.account = account
            self.creationTime = creationTime
            self.expirationTime = expirationTime
            self.state = state
        }
    }

}

extension EventBridgeClientTypes.PlacementConstraint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.PlacementConstraintType.self, forKey: .type)
        type = typeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension EventBridgeClientTypes {
    /// An object representing a constraint on task placement. To learn more, see [Task Placement Constraints](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html) in the Amazon Elastic Container Service Developer Guide.
    public struct PlacementConstraint: Swift.Equatable {
        /// A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance. To learn more, see [Cluster Query Language](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html) in the Amazon Elastic Container Service Developer Guide.
        public var expression: Swift.String?
        /// The type of constraint. Use distinctInstance to ensure that each task in a particular group is running on a different container instance. Use memberOf to restrict the selection to a group of valid candidates.
        public var type: EventBridgeClientTypes.PlacementConstraintType?

        public init (
            expression: Swift.String? = nil,
            type: EventBridgeClientTypes.PlacementConstraintType? = nil
        )
        {
            self.expression = expression
            self.type = type
        }
    }

}

extension EventBridgeClientTypes {
    public enum PlacementConstraintType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case distinctInstance
        case memberOf
        case sdkUnknown(Swift.String)

        public static var allCases: [PlacementConstraintType] {
            return [
                .distinctInstance,
                .memberOf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .distinctInstance: return "distinctInstance"
            case .memberOf: return "memberOf"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlacementConstraintType(rawValue: rawValue) ?? PlacementConstraintType.sdkUnknown(rawValue)
        }
    }
}

extension EventBridgeClientTypes.PlacementStrategy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.PlacementStrategyType.self, forKey: .type)
        type = typeDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
    }
}

extension EventBridgeClientTypes {
    /// The task placement strategy for a task or service. To learn more, see [Task Placement Strategies](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html) in the Amazon Elastic Container Service Service Developer Guide.
    public struct PlacementStrategy: Swift.Equatable {
        /// The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this field is not used.
        public var field: Swift.String?
        /// The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).
        public var type: EventBridgeClientTypes.PlacementStrategyType?

        public init (
            field: Swift.String? = nil,
            type: EventBridgeClientTypes.PlacementStrategyType? = nil
        )
        {
            self.field = field
            self.type = type
        }
    }

}

extension EventBridgeClientTypes {
    public enum PlacementStrategyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binpack
        case random
        case spread
        case sdkUnknown(Swift.String)

        public static var allCases: [PlacementStrategyType] {
            return [
                .binpack,
                .random,
                .spread,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binpack: return "binpack"
            case .random: return "random"
            case .spread: return "spread"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlacementStrategyType(rawValue: rawValue) ?? PlacementStrategyType.sdkUnknown(rawValue)
        }
    }
}

extension PolicyLengthExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PolicyLengthExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The event bus policy is too long. For more information, see the limits.
public struct PolicyLengthExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyLengthExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PolicyLengthExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventBridgeClientTypes.Primary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheck = "HealthCheck"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthCheck = self.healthCheck {
            try encodeContainer.encode(healthCheck, forKey: .healthCheck)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let healthCheckDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
    }
}

extension EventBridgeClientTypes {
    /// The primary Region of the endpoint.
    public struct Primary: Swift.Equatable {
        /// The ARN of the health check used by the endpoint to determine whether failover is triggered.
        /// This member is required.
        public var healthCheck: Swift.String?

        public init (
            healthCheck: Swift.String? = nil
        )
        {
            self.healthCheck = healthCheck
        }
    }

}

extension EventBridgeClientTypes {
    public enum PropagateTags: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case taskDefinition
        case sdkUnknown(Swift.String)

        public static var allCases: [PropagateTags] {
            return [
                .taskDefinition,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .taskDefinition: return "TASK_DEFINITION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropagateTags(rawValue: rawValue) ?? PropagateTags.sdkUnknown(rawValue)
        }
    }
}

extension PutEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointId = "EndpointId"
        case entries = "Entries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for puteventsrequestentry0 in entries {
                try entriesContainer.encode(puteventsrequestentry0)
            }
        }
    }
}

extension PutEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutEventsInput: Swift.Equatable {
    /// The URL subdomain of the endpoint. For example, if the URL for Endpoint is abcde.veo.endpoints.event.amazonaws.com, then the EndpointId is abcde.veo. When using Java, you must include auth-crt on the class path.
    public var endpointId: Swift.String?
    /// The entry that defines an event in your system. You can specify several parameters for the entry such as the source and type of the event, resources associated with the event, and so on.
    /// This member is required.
    public var entries: [EventBridgeClientTypes.PutEventsRequestEntry]?

    public init (
        endpointId: Swift.String? = nil,
        entries: [EventBridgeClientTypes.PutEventsRequestEntry]? = nil
    )
    {
        self.endpointId = endpointId
        self.entries = entries
    }
}

struct PutEventsInputBody: Swift.Equatable {
    let entries: [EventBridgeClientTypes.PutEventsRequestEntry]?
    let endpointId: Swift.String?
}

extension PutEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointId = "EndpointId"
        case entries = "Entries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.PutEventsRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[EventBridgeClientTypes.PutEventsRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [EventBridgeClientTypes.PutEventsRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

extension PutEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutEventsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.failedEntryCount = output.failedEntryCount
        } else {
            self.entries = nil
            self.failedEntryCount = 0
        }
    }
}

public struct PutEventsOutputResponse: Swift.Equatable {
    /// The successfully and unsuccessfully ingested events results. If the ingestion was successful, the entry has the event ID in it. Otherwise, you can use the error code and error message to identify the problem with the entry.
    public var entries: [EventBridgeClientTypes.PutEventsResultEntry]?
    /// The number of failed entries.
    public var failedEntryCount: Swift.Int

    public init (
        entries: [EventBridgeClientTypes.PutEventsResultEntry]? = nil,
        failedEntryCount: Swift.Int = 0
    )
    {
        self.entries = entries
        self.failedEntryCount = failedEntryCount
    }
}

struct PutEventsOutputResponseBody: Swift.Equatable {
    let failedEntryCount: Swift.Int
    let entries: [EventBridgeClientTypes.PutEventsResultEntry]?
}

extension PutEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case failedEntryCount = "FailedEntryCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEntryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedEntryCount) ?? 0
        failedEntryCount = failedEntryCountDecoded
        let entriesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.PutEventsResultEntry?].self, forKey: .entries)
        var entriesDecoded0:[EventBridgeClientTypes.PutEventsResultEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [EventBridgeClientTypes.PutEventsResultEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension EventBridgeClientTypes.PutEventsRequestEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detail = "Detail"
        case detailType = "DetailType"
        case eventBusName = "EventBusName"
        case resources = "Resources"
        case source = "Source"
        case time = "Time"
        case traceHeader = "TraceHeader"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detail = self.detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let detailType = self.detailType {
            try encodeContainer.encode(detailType, forKey: .detailType)
        }
        if let eventBusName = self.eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for eventresource0 in resources {
                try resourcesContainer.encode(eventresource0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let time = self.time {
            try encodeContainer.encodeTimestamp(time, format: .epochSeconds, forKey: .time)
        }
        if let traceHeader = self.traceHeader {
            try encodeContainer.encode(traceHeader, forKey: .traceHeader)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .time)
        time = timeDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resources)
        var resourcesDecoded0:[Swift.String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Swift.String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
        let detailTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailType)
        detailType = detailTypeDecoded
        let detailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detail)
        detail = detailDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let traceHeaderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceHeader)
        traceHeader = traceHeaderDecoded
    }
}

extension EventBridgeClientTypes {
    /// Represents an event to be submitted.
    public struct PutEventsRequestEntry: Swift.Equatable {
        /// A valid JSON object. There is no other schema imposed. The JSON object may contain fields and nested subobjects.
        public var detail: Swift.String?
        /// Free-form string used to decide what fields to expect in the event detail.
        public var detailType: Swift.String?
        /// The name or ARN of the event bus to receive the event. Only the rules that are associated with this event bus are used to match the event. If you omit this, the default event bus is used. If you're using a global endpoint with a custom bus, you must enter the name, not the ARN, of the event bus in either the primary or secondary Region here and the corresponding event bus in the other Region will be determined based on the endpoint referenced by the EndpointId.
        public var eventBusName: Swift.String?
        /// Amazon Web Services resources, identified by Amazon Resource Name (ARN), which the event primarily concerns. Any number, including zero, may be present.
        public var resources: [Swift.String]?
        /// The source of the event.
        public var source: Swift.String?
        /// The time stamp of the event, per [RFC3339](https://www.rfc-editor.org/rfc/rfc3339.txt). If no time stamp is provided, the time stamp of the [PutEvents](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html) call is used.
        public var time: ClientRuntime.Date?
        /// An X-Ray trace header, which is an http header (X-Amzn-Trace-Id) that contains the trace-id associated with the event. To learn more about X-Ray trace headers, see [Tracing header](https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader) in the X-Ray Developer Guide.
        public var traceHeader: Swift.String?

        public init (
            detail: Swift.String? = nil,
            detailType: Swift.String? = nil,
            eventBusName: Swift.String? = nil,
            resources: [Swift.String]? = nil,
            source: Swift.String? = nil,
            time: ClientRuntime.Date? = nil,
            traceHeader: Swift.String? = nil
        )
        {
            self.detail = detail
            self.detailType = detailType
            self.eventBusName = eventBusName
            self.resources = resources
            self.source = source
            self.time = time
            self.traceHeader = traceHeader
        }
    }

}

extension EventBridgeClientTypes.PutEventsResultEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case eventId = "EventId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension EventBridgeClientTypes {
    /// Represents an event that failed to be submitted. For information about the errors that are common to all actions, see [Common Errors](https://docs.aws.amazon.com/eventbridge/latest/APIReference/CommonErrors.html).
    public struct PutEventsResultEntry: Swift.Equatable {
        /// The error code that indicates why the event submission failed.
        public var errorCode: Swift.String?
        /// The error message that explains why the event submission failed.
        public var errorMessage: Swift.String?
        /// The ID of the event.
        public var eventId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            eventId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.eventId = eventId
        }
    }

}

extension PutPartnerEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for putpartnereventsrequestentry0 in entries {
                try entriesContainer.encode(putpartnereventsrequestentry0)
            }
        }
    }
}

extension PutPartnerEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutPartnerEventsInput: Swift.Equatable {
    /// The list of events to write to the event bus.
    /// This member is required.
    public var entries: [EventBridgeClientTypes.PutPartnerEventsRequestEntry]?

    public init (
        entries: [EventBridgeClientTypes.PutPartnerEventsRequestEntry]? = nil
    )
    {
        self.entries = entries
    }
}

struct PutPartnerEventsInputBody: Swift.Equatable {
    let entries: [EventBridgeClientTypes.PutPartnerEventsRequestEntry]?
}

extension PutPartnerEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.PutPartnerEventsRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[EventBridgeClientTypes.PutPartnerEventsRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [EventBridgeClientTypes.PutPartnerEventsRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension PutPartnerEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPartnerEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutPartnerEventsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPartnerEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutPartnerEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.failedEntryCount = output.failedEntryCount
        } else {
            self.entries = nil
            self.failedEntryCount = 0
        }
    }
}

public struct PutPartnerEventsOutputResponse: Swift.Equatable {
    /// The list of events from this operation that were successfully written to the partner event bus.
    public var entries: [EventBridgeClientTypes.PutPartnerEventsResultEntry]?
    /// The number of events from this operation that could not be written to the partner event bus.
    public var failedEntryCount: Swift.Int

    public init (
        entries: [EventBridgeClientTypes.PutPartnerEventsResultEntry]? = nil,
        failedEntryCount: Swift.Int = 0
    )
    {
        self.entries = entries
        self.failedEntryCount = failedEntryCount
    }
}

struct PutPartnerEventsOutputResponseBody: Swift.Equatable {
    let failedEntryCount: Swift.Int
    let entries: [EventBridgeClientTypes.PutPartnerEventsResultEntry]?
}

extension PutPartnerEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case failedEntryCount = "FailedEntryCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEntryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedEntryCount) ?? 0
        failedEntryCount = failedEntryCountDecoded
        let entriesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.PutPartnerEventsResultEntry?].self, forKey: .entries)
        var entriesDecoded0:[EventBridgeClientTypes.PutPartnerEventsResultEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [EventBridgeClientTypes.PutPartnerEventsResultEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension EventBridgeClientTypes.PutPartnerEventsRequestEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detail = "Detail"
        case detailType = "DetailType"
        case resources = "Resources"
        case source = "Source"
        case time = "Time"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detail = self.detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let detailType = self.detailType {
            try encodeContainer.encode(detailType, forKey: .detailType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for eventresource0 in resources {
                try resourcesContainer.encode(eventresource0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let time = self.time {
            try encodeContainer.encodeTimestamp(time, format: .epochSeconds, forKey: .time)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .time)
        time = timeDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resources)
        var resourcesDecoded0:[Swift.String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Swift.String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
        let detailTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailType)
        detailType = detailTypeDecoded
        let detailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detail)
        detail = detailDecoded
    }
}

extension EventBridgeClientTypes {
    /// The details about an event generated by an SaaS partner.
    public struct PutPartnerEventsRequestEntry: Swift.Equatable {
        /// A valid JSON string. There is no other schema imposed. The JSON string may contain fields and nested subobjects.
        public var detail: Swift.String?
        /// A free-form string used to decide what fields to expect in the event detail.
        public var detailType: Swift.String?
        /// Amazon Web Services resources, identified by Amazon Resource Name (ARN), which the event primarily concerns. Any number, including zero, may be present.
        public var resources: [Swift.String]?
        /// The event source that is generating the entry.
        public var source: Swift.String?
        /// The date and time of the event.
        public var time: ClientRuntime.Date?

        public init (
            detail: Swift.String? = nil,
            detailType: Swift.String? = nil,
            resources: [Swift.String]? = nil,
            source: Swift.String? = nil,
            time: ClientRuntime.Date? = nil
        )
        {
            self.detail = detail
            self.detailType = detailType
            self.resources = resources
            self.source = source
            self.time = time
        }
    }

}

extension EventBridgeClientTypes.PutPartnerEventsResultEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case eventId = "EventId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension EventBridgeClientTypes {
    /// Represents an event that a partner tried to generate, but failed.
    public struct PutPartnerEventsResultEntry: Swift.Equatable {
        /// The error code that indicates why the event submission failed.
        public var errorCode: Swift.String?
        /// The error message that explains why the event submission failed.
        public var errorMessage: Swift.String?
        /// The ID of the event.
        public var eventId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            eventId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.eventId = eventId
        }
    }

}

extension PutPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case condition = "Condition"
        case eventBusName = "EventBusName"
        case policy = "Policy"
        case principal = "Principal"
        case statementId = "StatementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let eventBusName = self.eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let statementId = self.statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

extension PutPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutPermissionInput: Swift.Equatable {
    /// The action that you are enabling the other account to perform.
    public var action: Swift.String?
    /// This parameter enables you to limit the permission to accounts that fulfill a certain condition, such as being a member of a certain Amazon Web Services organization. For more information about Amazon Web Services Organizations, see [What Is Amazon Web Services Organizations](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_introduction.html) in the Amazon Web Services Organizations User Guide. If you specify Condition with an Amazon Web Services organization ID, and specify "*" as the value for Principal, you grant permission to all the accounts in the named organization. The Condition is a JSON string which must contain Type, Key, and Value fields.
    public var condition: EventBridgeClientTypes.Condition?
    /// The name of the event bus associated with the rule. If you omit this, the default event bus is used.
    public var eventBusName: Swift.String?
    /// A JSON string that describes the permission policy statement. You can include a Policy parameter in the request instead of using the StatementId, Action, Principal, or Condition parameters.
    public var policy: Swift.String?
    /// The 12-digit Amazon Web Services account ID that you are permitting to put events to your default event bus. Specify "*" to permit any account to put events to your default event bus. If you specify "*" without specifying Condition, avoid creating rules that may match undesirable events. To create more secure rules, make sure that the event pattern for each rule contains an account field with a specific account ID from which to receive events. Rules with an account field do not match any events sent from other accounts.
    public var principal: Swift.String?
    /// An identifier string for the external account that you are granting permissions to. If you later want to revoke the permission for this external account, specify this StatementId when you run [RemovePermission](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_RemovePermission.html). Each StatementId must be unique.
    public var statementId: Swift.String?

    public init (
        action: Swift.String? = nil,
        condition: EventBridgeClientTypes.Condition? = nil,
        eventBusName: Swift.String? = nil,
        policy: Swift.String? = nil,
        principal: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.action = action
        self.condition = condition
        self.eventBusName = eventBusName
        self.policy = policy
        self.principal = principal
        self.statementId = statementId
    }
}

struct PutPermissionInputBody: Swift.Equatable {
    let eventBusName: Swift.String?
    let action: Swift.String?
    let principal: Swift.String?
    let statementId: Swift.String?
    let condition: EventBridgeClientTypes.Condition?
    let policy: Swift.String?
}

extension PutPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case condition = "Condition"
        case eventBusName = "EventBusName"
        case policy = "Policy"
        case principal = "Principal"
        case statementId = "StatementId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.Condition.self, forKey: .condition)
        condition = conditionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyLengthExceededException" : self = .policyLengthExceededException(try PolicyLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutPermissionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case policyLengthExceededException(PolicyLengthExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutPermissionOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventBusName = "EventBusName"
        case eventPattern = "EventPattern"
        case name = "Name"
        case roleArn = "RoleArn"
        case scheduleExpression = "ScheduleExpression"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventBusName = self.eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let eventPattern = self.eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension PutRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRuleInput: Swift.Equatable {
    /// A description of the rule.
    public var description: Swift.String?
    /// The name or ARN of the event bus to associate with this rule. If you omit this, the default event bus is used.
    public var eventBusName: Swift.String?
    /// The event pattern. For more information, see [EventBridge event patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html.html) in the Amazon EventBridge User Guide.
    public var eventPattern: Swift.String?
    /// The name of the rule that you are creating or updating.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role associated with the rule. If you're setting an event bus in another account as the target and that account granted permission to your account through an organization instead of directly by the account ID, you must specify a RoleArn with proper permissions in the Target structure, instead of here in this parameter.
    public var roleArn: Swift.String?
    /// The scheduling expression. For example, "cron(0 20 * * ? *)" or "rate(5 minutes)".
    public var scheduleExpression: Swift.String?
    /// Indicates whether the rule is enabled or disabled.
    public var state: EventBridgeClientTypes.RuleState?
    /// The list of key-value pairs to associate with the rule.
    public var tags: [EventBridgeClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        eventBusName: Swift.String? = nil,
        eventPattern: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        scheduleExpression: Swift.String? = nil,
        state: EventBridgeClientTypes.RuleState? = nil,
        tags: [EventBridgeClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.eventBusName = eventBusName
        self.eventPattern = eventPattern
        self.name = name
        self.roleArn = roleArn
        self.scheduleExpression = scheduleExpression
        self.state = state
        self.tags = tags
    }
}

struct PutRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let scheduleExpression: Swift.String?
    let eventPattern: Swift.String?
    let state: EventBridgeClientTypes.RuleState?
    let description: Swift.String?
    let roleArn: Swift.String?
    let tags: [EventBridgeClientTypes.Tag]?
    let eventBusName: Swift.String?
}

extension PutRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventBusName = "EventBusName"
        case eventPattern = "EventPattern"
        case name = "Name"
        case roleArn = "RoleArn"
        case scheduleExpression = "ScheduleExpression"
        case state = "State"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.RuleState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EventBridgeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EventBridgeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension PutRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutRuleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case limitExceededException(LimitExceededException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ruleArn = output.ruleArn
        } else {
            self.ruleArn = nil
        }
    }
}

public struct PutRuleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the rule.
    public var ruleArn: Swift.String?

    public init (
        ruleArn: Swift.String? = nil
    )
    {
        self.ruleArn = ruleArn
    }
}

struct PutRuleOutputResponseBody: Swift.Equatable {
    let ruleArn: Swift.String?
}

extension PutRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ruleArn = "RuleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleArn)
        ruleArn = ruleArnDecoded
    }
}

extension PutTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case rule = "Rule"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = self.eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let rule = self.rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for target0 in targets {
                try targetsContainer.encode(target0)
            }
        }
    }
}

extension PutTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutTargetsInput: Swift.Equatable {
    /// The name or ARN of the event bus associated with the rule. If you omit this, the default event bus is used.
    public var eventBusName: Swift.String?
    /// The name of the rule.
    /// This member is required.
    public var rule: Swift.String?
    /// The targets to update or add to the rule.
    /// This member is required.
    public var targets: [EventBridgeClientTypes.Target]?

    public init (
        eventBusName: Swift.String? = nil,
        rule: Swift.String? = nil,
        targets: [EventBridgeClientTypes.Target]? = nil
    )
    {
        self.eventBusName = eventBusName
        self.rule = rule
        self.targets = targets
    }
}

struct PutTargetsInputBody: Swift.Equatable {
    let rule: Swift.String?
    let eventBusName: Swift.String?
    let targets: [EventBridgeClientTypes.Target]?
}

extension PutTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case rule = "Rule"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rule)
        rule = ruleDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[EventBridgeClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [EventBridgeClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension PutTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutTargetsOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedEntries = output.failedEntries
            self.failedEntryCount = output.failedEntryCount
        } else {
            self.failedEntries = nil
            self.failedEntryCount = 0
        }
    }
}

public struct PutTargetsOutputResponse: Swift.Equatable {
    /// The failed target entries.
    public var failedEntries: [EventBridgeClientTypes.PutTargetsResultEntry]?
    /// The number of failed entries.
    public var failedEntryCount: Swift.Int

    public init (
        failedEntries: [EventBridgeClientTypes.PutTargetsResultEntry]? = nil,
        failedEntryCount: Swift.Int = 0
    )
    {
        self.failedEntries = failedEntries
        self.failedEntryCount = failedEntryCount
    }
}

struct PutTargetsOutputResponseBody: Swift.Equatable {
    let failedEntryCount: Swift.Int
    let failedEntries: [EventBridgeClientTypes.PutTargetsResultEntry]?
}

extension PutTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedEntries = "FailedEntries"
        case failedEntryCount = "FailedEntryCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEntryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedEntryCount) ?? 0
        failedEntryCount = failedEntryCountDecoded
        let failedEntriesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.PutTargetsResultEntry?].self, forKey: .failedEntries)
        var failedEntriesDecoded0:[EventBridgeClientTypes.PutTargetsResultEntry]? = nil
        if let failedEntriesContainer = failedEntriesContainer {
            failedEntriesDecoded0 = [EventBridgeClientTypes.PutTargetsResultEntry]()
            for structure0 in failedEntriesContainer {
                if let structure0 = structure0 {
                    failedEntriesDecoded0?.append(structure0)
                }
            }
        }
        failedEntries = failedEntriesDecoded0
    }
}

extension EventBridgeClientTypes.PutTargetsResultEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case targetId = "TargetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let targetId = self.targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension EventBridgeClientTypes {
    /// Represents a target that failed to be added to a rule.
    public struct PutTargetsResultEntry: Swift.Equatable {
        /// The error code that indicates why the target addition failed. If the value is ConcurrentModificationException, too many requests were made at the same time.
        public var errorCode: Swift.String?
        /// The error message that explains why the target addition failed.
        public var errorMessage: Swift.String?
        /// The ID of the target.
        public var targetId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            targetId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.targetId = targetId
        }
    }

}

extension EventBridgeClientTypes.RedshiftDataParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case dbUser = "DbUser"
        case secretManagerArn = "SecretManagerArn"
        case sql = "Sql"
        case statementName = "StatementName"
        case withEvent = "WithEvent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbUser = self.dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let secretManagerArn = self.secretManagerArn {
            try encodeContainer.encode(secretManagerArn, forKey: .secretManagerArn)
        }
        if let sql = self.sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if withEvent != false {
            try encodeContainer.encode(withEvent, forKey: .withEvent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretManagerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretManagerArn)
        secretManagerArn = secretManagerArnDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let sqlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sql)
        sql = sqlDecoded
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let withEventDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .withEvent) ?? false
        withEvent = withEventDecoded
    }
}

extension EventBridgeClientTypes {
    /// These are custom parameters to be used when the target is a Amazon Redshift cluster to invoke the Amazon Redshift Data API ExecuteStatement based on EventBridge events.
    public struct RedshiftDataParameters: Swift.Equatable {
        /// The name of the database. Required when authenticating using temporary credentials.
        /// This member is required.
        public var database: Swift.String?
        /// The database user name. Required when authenticating using temporary credentials.
        public var dbUser: Swift.String?
        /// The name or ARN of the secret that enables access to the database. Required when authenticating using Amazon Web Services Secrets Manager.
        public var secretManagerArn: Swift.String?
        /// The SQL statement text to run.
        /// This member is required.
        public var sql: Swift.String?
        /// The name of the SQL statement. You can name the SQL statement when you create it to identify the query.
        public var statementName: Swift.String?
        /// Indicates whether to send an event back to EventBridge after the SQL statement runs.
        public var withEvent: Swift.Bool

        public init (
            database: Swift.String? = nil,
            dbUser: Swift.String? = nil,
            secretManagerArn: Swift.String? = nil,
            sql: Swift.String? = nil,
            statementName: Swift.String? = nil,
            withEvent: Swift.Bool = false
        )
        {
            self.database = database
            self.dbUser = dbUser
            self.secretManagerArn = secretManagerArn
            self.sql = sql
            self.statementName = statementName
            self.withEvent = withEvent
        }
    }

}

extension RemovePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case removeAllPermissions = "RemoveAllPermissions"
        case statementId = "StatementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = self.eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if removeAllPermissions != false {
            try encodeContainer.encode(removeAllPermissions, forKey: .removeAllPermissions)
        }
        if let statementId = self.statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

extension RemovePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemovePermissionInput: Swift.Equatable {
    /// The name of the event bus to revoke permissions for. If you omit this, the default event bus is used.
    public var eventBusName: Swift.String?
    /// Specifies whether to remove all permissions.
    public var removeAllPermissions: Swift.Bool
    /// The statement ID corresponding to the account that is no longer allowed to put events to the default event bus.
    public var statementId: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        removeAllPermissions: Swift.Bool = false,
        statementId: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.removeAllPermissions = removeAllPermissions
        self.statementId = statementId
    }
}

struct RemovePermissionInputBody: Swift.Equatable {
    let statementId: Swift.String?
    let removeAllPermissions: Swift.Bool
    let eventBusName: Swift.String?
}

extension RemovePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case removeAllPermissions = "RemoveAllPermissions"
        case statementId = "StatementId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let removeAllPermissionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeAllPermissions) ?? false
        removeAllPermissions = removeAllPermissionsDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension RemovePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemovePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemovePermissionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemovePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemovePermissionOutputResponse: Swift.Equatable {

    public init () { }
}

extension RemoveTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case force = "Force"
        case ids = "Ids"
        case rule = "Rule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = self.eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for targetid0 in ids {
                try idsContainer.encode(targetid0)
            }
        }
        if let rule = self.rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
    }
}

extension RemoveTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveTargetsInput: Swift.Equatable {
    /// The name or ARN of the event bus associated with the rule. If you omit this, the default event bus is used.
    public var eventBusName: Swift.String?
    /// If this is a managed rule, created by an Amazon Web Services service on your behalf, you must specify Force as True to remove targets. This parameter is ignored for rules that are not managed rules. You can check whether a rule is a managed rule by using DescribeRule or ListRules and checking the ManagedBy field of the response.
    public var force: Swift.Bool
    /// The IDs of the targets to remove from the rule.
    /// This member is required.
    public var ids: [Swift.String]?
    /// The name of the rule.
    /// This member is required.
    public var rule: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        force: Swift.Bool = false,
        ids: [Swift.String]? = nil,
        rule: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.force = force
        self.ids = ids
        self.rule = rule
    }
}

struct RemoveTargetsInputBody: Swift.Equatable {
    let rule: Swift.String?
    let eventBusName: Swift.String?
    let ids: [Swift.String]?
    let force: Swift.Bool
}

extension RemoveTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case force = "Force"
        case ids = "Ids"
        case rule = "Rule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rule)
        rule = ruleDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let forceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .force) ?? false
        force = forceDecoded
    }
}

extension RemoveTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveTargetsOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RemoveTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedEntries = output.failedEntries
            self.failedEntryCount = output.failedEntryCount
        } else {
            self.failedEntries = nil
            self.failedEntryCount = 0
        }
    }
}

public struct RemoveTargetsOutputResponse: Swift.Equatable {
    /// The failed target entries.
    public var failedEntries: [EventBridgeClientTypes.RemoveTargetsResultEntry]?
    /// The number of failed entries.
    public var failedEntryCount: Swift.Int

    public init (
        failedEntries: [EventBridgeClientTypes.RemoveTargetsResultEntry]? = nil,
        failedEntryCount: Swift.Int = 0
    )
    {
        self.failedEntries = failedEntries
        self.failedEntryCount = failedEntryCount
    }
}

struct RemoveTargetsOutputResponseBody: Swift.Equatable {
    let failedEntryCount: Swift.Int
    let failedEntries: [EventBridgeClientTypes.RemoveTargetsResultEntry]?
}

extension RemoveTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedEntries = "FailedEntries"
        case failedEntryCount = "FailedEntryCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEntryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedEntryCount) ?? 0
        failedEntryCount = failedEntryCountDecoded
        let failedEntriesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.RemoveTargetsResultEntry?].self, forKey: .failedEntries)
        var failedEntriesDecoded0:[EventBridgeClientTypes.RemoveTargetsResultEntry]? = nil
        if let failedEntriesContainer = failedEntriesContainer {
            failedEntriesDecoded0 = [EventBridgeClientTypes.RemoveTargetsResultEntry]()
            for structure0 in failedEntriesContainer {
                if let structure0 = structure0 {
                    failedEntriesDecoded0?.append(structure0)
                }
            }
        }
        failedEntries = failedEntriesDecoded0
    }
}

extension EventBridgeClientTypes.RemoveTargetsResultEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case targetId = "TargetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let targetId = self.targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension EventBridgeClientTypes {
    /// Represents a target that failed to be removed from a rule.
    public struct RemoveTargetsResultEntry: Swift.Equatable {
        /// The error code that indicates why the target removal failed. If the value is ConcurrentModificationException, too many requests were made at the same time.
        public var errorCode: Swift.String?
        /// The error message that explains why the target removal failed.
        public var errorMessage: Swift.String?
        /// The ID of the target.
        public var targetId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            targetId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.targetId = targetId
        }
    }

}

extension EventBridgeClientTypes.Replay: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventEndTime = "EventEndTime"
        case eventLastReplayedTime = "EventLastReplayedTime"
        case eventSourceArn = "EventSourceArn"
        case eventStartTime = "EventStartTime"
        case replayEndTime = "ReplayEndTime"
        case replayName = "ReplayName"
        case replayStartTime = "ReplayStartTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventEndTime = self.eventEndTime {
            try encodeContainer.encodeTimestamp(eventEndTime, format: .epochSeconds, forKey: .eventEndTime)
        }
        if let eventLastReplayedTime = self.eventLastReplayedTime {
            try encodeContainer.encodeTimestamp(eventLastReplayedTime, format: .epochSeconds, forKey: .eventLastReplayedTime)
        }
        if let eventSourceArn = self.eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let eventStartTime = self.eventStartTime {
            try encodeContainer.encodeTimestamp(eventStartTime, format: .epochSeconds, forKey: .eventStartTime)
        }
        if let replayEndTime = self.replayEndTime {
            try encodeContainer.encodeTimestamp(replayEndTime, format: .epochSeconds, forKey: .replayEndTime)
        }
        if let replayName = self.replayName {
            try encodeContainer.encode(replayName, forKey: .replayName)
        }
        if let replayStartTime = self.replayStartTime {
            try encodeContainer.encodeTimestamp(replayStartTime, format: .epochSeconds, forKey: .replayStartTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = self.stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayName)
        replayName = replayNameDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ReplayState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let eventStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventStartTime)
        eventStartTime = eventStartTimeDecoded
        let eventEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventEndTime)
        eventEndTime = eventEndTimeDecoded
        let eventLastReplayedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventLastReplayedTime)
        eventLastReplayedTime = eventLastReplayedTimeDecoded
        let replayStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replayStartTime)
        replayStartTime = replayStartTimeDecoded
        let replayEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replayEndTime)
        replayEndTime = replayEndTimeDecoded
    }
}

extension EventBridgeClientTypes {
    /// A Replay object that contains details about a replay.
    public struct Replay: Swift.Equatable {
        /// A time stamp for the time to start replaying events. Any event with a creation time prior to the EventEndTime specified is replayed.
        public var eventEndTime: ClientRuntime.Date?
        /// A time stamp for the time that the last event was replayed.
        public var eventLastReplayedTime: ClientRuntime.Date?
        /// The ARN of the archive to replay event from.
        public var eventSourceArn: Swift.String?
        /// A time stamp for the time to start replaying events. This is determined by the time in the event as described in [Time](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEventsRequestEntry.html#eventbridge-Type-PutEventsRequestEntry-Time).
        public var eventStartTime: ClientRuntime.Date?
        /// A time stamp for the time that the replay completed.
        public var replayEndTime: ClientRuntime.Date?
        /// The name of the replay.
        public var replayName: Swift.String?
        /// A time stamp for the time that the replay started.
        public var replayStartTime: ClientRuntime.Date?
        /// The current state of the replay.
        public var state: EventBridgeClientTypes.ReplayState?
        /// A description of why the replay is in the current state.
        public var stateReason: Swift.String?

        public init (
            eventEndTime: ClientRuntime.Date? = nil,
            eventLastReplayedTime: ClientRuntime.Date? = nil,
            eventSourceArn: Swift.String? = nil,
            eventStartTime: ClientRuntime.Date? = nil,
            replayEndTime: ClientRuntime.Date? = nil,
            replayName: Swift.String? = nil,
            replayStartTime: ClientRuntime.Date? = nil,
            state: EventBridgeClientTypes.ReplayState? = nil,
            stateReason: Swift.String? = nil
        )
        {
            self.eventEndTime = eventEndTime
            self.eventLastReplayedTime = eventLastReplayedTime
            self.eventSourceArn = eventSourceArn
            self.eventStartTime = eventStartTime
            self.replayEndTime = replayEndTime
            self.replayName = replayName
            self.replayStartTime = replayStartTime
            self.state = state
            self.stateReason = stateReason
        }
    }

}

extension EventBridgeClientTypes.ReplayDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case filterArns = "FilterArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let filterArns = filterArns {
            var filterArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterArns)
            for arn0 in filterArns {
                try filterArnsContainer.encode(arn0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let filterArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterArns)
        var filterArnsDecoded0:[Swift.String]? = nil
        if let filterArnsContainer = filterArnsContainer {
            filterArnsDecoded0 = [Swift.String]()
            for string0 in filterArnsContainer {
                if let string0 = string0 {
                    filterArnsDecoded0?.append(string0)
                }
            }
        }
        filterArns = filterArnsDecoded0
    }
}

extension EventBridgeClientTypes {
    /// A ReplayDestination object that contains details about a replay.
    public struct ReplayDestination: Swift.Equatable {
        /// The ARN of the event bus to replay event to. You can replay events only to the event bus specified to create the archive.
        /// This member is required.
        public var arn: Swift.String?
        /// A list of ARNs for rules to replay events to.
        public var filterArns: [Swift.String]?

        public init (
            arn: Swift.String? = nil,
            filterArns: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.filterArns = filterArns
        }
    }

}

extension EventBridgeClientTypes {
    public enum ReplayState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case failed
        case running
        case starting
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplayState] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .running,
                .starting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplayState(rawValue: rawValue) ?? ReplayState.sdkUnknown(rawValue)
        }
    }
}

extension EventBridgeClientTypes.ReplicationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ReplicationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension EventBridgeClientTypes {
    /// Endpoints can replicate all events to the secondary Region.
    public struct ReplicationConfig: Swift.Equatable {
        /// The state of event replication.
        public var state: EventBridgeClientTypes.ReplicationState?

        public init (
            state: EventBridgeClientTypes.ReplicationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension EventBridgeClientTypes {
    public enum ReplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationState(rawValue: rawValue) ?? ReplicationState.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource you are trying to create already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An entity that you specified does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventBridgeClientTypes.RetryPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximumEventAgeInSeconds = self.maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = self.maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
    }
}

extension EventBridgeClientTypes {
    /// A RetryPolicy object that includes information about the retry policy settings.
    public struct RetryPolicy: Swift.Equatable {
        /// The maximum amount of time, in seconds, to continue to make retry attempts.
        public var maximumEventAgeInSeconds: Swift.Int?
        /// The maximum number of retry attempts to make before the request fails. Retry attempts continue until either the maximum number of attempts is made or until the duration of the MaximumEventAgeInSeconds is met.
        public var maximumRetryAttempts: Swift.Int?

        public init (
            maximumEventAgeInSeconds: Swift.Int? = nil,
            maximumRetryAttempts: Swift.Int? = nil
        )
        {
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
        }
    }

}

extension EventBridgeClientTypes.RoutingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failoverConfig = "FailoverConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failoverConfig = self.failoverConfig {
            try encodeContainer.encode(failoverConfig, forKey: .failoverConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failoverConfigDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.FailoverConfig.self, forKey: .failoverConfig)
        failoverConfig = failoverConfigDecoded
    }
}

extension EventBridgeClientTypes {
    /// The routing configuration of the endpoint.
    public struct RoutingConfig: Swift.Equatable {
        /// The failover configuration for an endpoint. This includes what triggers failover and what happens when it's triggered.
        /// This member is required.
        public var failoverConfig: EventBridgeClientTypes.FailoverConfig?

        public init (
            failoverConfig: EventBridgeClientTypes.FailoverConfig? = nil
        )
        {
            self.failoverConfig = failoverConfig
        }
    }

}

extension EventBridgeClientTypes.Rule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case eventBusName = "EventBusName"
        case eventPattern = "EventPattern"
        case managedBy = "ManagedBy"
        case name = "Name"
        case roleArn = "RoleArn"
        case scheduleExpression = "ScheduleExpression"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventBusName = self.eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let eventPattern = self.eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let managedBy = self.managedBy {
            try encodeContainer.encode(managedBy, forKey: .managedBy)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.RuleState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let managedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedBy)
        managedBy = managedByDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains information about a rule in Amazon EventBridge.
    public struct Rule: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the rule.
        public var arn: Swift.String?
        /// The description of the rule.
        public var description: Swift.String?
        /// The name or ARN of the event bus associated with the rule. If you omit this, the default event bus is used.
        public var eventBusName: Swift.String?
        /// The event pattern of the rule. For more information, see [Events and Event Patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-and-event-patterns.html) in the Amazon EventBridge User Guide.
        public var eventPattern: Swift.String?
        /// If the rule was created on behalf of your account by an Amazon Web Services service, this field displays the principal name of the service that created the rule.
        public var managedBy: Swift.String?
        /// The name of the rule.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the role that is used for target invocation. If you're setting an event bus in another account as the target and that account granted permission to your account through an organization instead of directly by the account ID, you must specify a RoleArn with proper permissions in the Target structure, instead of here in this parameter.
        public var roleArn: Swift.String?
        /// The scheduling expression. For example, "cron(0 20 * * ? *)", "rate(5 minutes)". For more information, see [Creating an Amazon EventBridge rule that runs on a schedule](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-create-rule-schedule.html).
        public var scheduleExpression: Swift.String?
        /// The state of the rule.
        public var state: EventBridgeClientTypes.RuleState?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            eventBusName: Swift.String? = nil,
            eventPattern: Swift.String? = nil,
            managedBy: Swift.String? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            state: EventBridgeClientTypes.RuleState? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.eventBusName = eventBusName
            self.eventPattern = eventPattern
            self.managedBy = managedBy
            self.name = name
            self.roleArn = roleArn
            self.scheduleExpression = scheduleExpression
            self.state = state
        }
    }

}

extension EventBridgeClientTypes {
    public enum RuleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleState(rawValue: rawValue) ?? RuleState.sdkUnknown(rawValue)
        }
    }
}

extension EventBridgeClientTypes.RunCommandParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case runCommandTargets = "RunCommandTargets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let runCommandTargets = runCommandTargets {
            var runCommandTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runCommandTargets)
            for runcommandtarget0 in runCommandTargets {
                try runCommandTargetsContainer.encode(runcommandtarget0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runCommandTargetsContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.RunCommandTarget?].self, forKey: .runCommandTargets)
        var runCommandTargetsDecoded0:[EventBridgeClientTypes.RunCommandTarget]? = nil
        if let runCommandTargetsContainer = runCommandTargetsContainer {
            runCommandTargetsDecoded0 = [EventBridgeClientTypes.RunCommandTarget]()
            for structure0 in runCommandTargetsContainer {
                if let structure0 = structure0 {
                    runCommandTargetsDecoded0?.append(structure0)
                }
            }
        }
        runCommandTargets = runCommandTargetsDecoded0
    }
}

extension EventBridgeClientTypes {
    /// This parameter contains the criteria (either InstanceIds or a tag) used to specify which EC2 instances are to be sent the command.
    public struct RunCommandParameters: Swift.Equatable {
        /// Currently, we support including only one RunCommandTarget block, which specifies either an array of InstanceIds or a tag.
        /// This member is required.
        public var runCommandTargets: [EventBridgeClientTypes.RunCommandTarget]?

        public init (
            runCommandTargets: [EventBridgeClientTypes.RunCommandTarget]? = nil
        )
        {
            self.runCommandTargets = runCommandTargets
        }
    }

}

extension EventBridgeClientTypes.RunCommandTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for runcommandtargetvalue0 in values {
                try valuesContainer.encode(runcommandtargetvalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension EventBridgeClientTypes {
    /// Information about the EC2 instances that are to be sent the command, specified as key-value pairs. Each RunCommandTarget block can include only one key, but this key may specify multiple values.
    public struct RunCommandTarget: Swift.Equatable {
        /// Can be either tag: tag-key or InstanceIds.
        /// This member is required.
        public var key: Swift.String?
        /// If Key is tag: tag-key, Values is a list of tag values. If Key is InstanceIds, Values is a list of Amazon EC2 instance IDs.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension EventBridgeClientTypes.SageMakerPipelineParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension EventBridgeClientTypes {
    /// Name/Value pair of a parameter to start execution of a SageMaker Model Building Pipeline.
    public struct SageMakerPipelineParameter: Swift.Equatable {
        /// Name of parameter to start execution of a SageMaker Model Building Pipeline.
        /// This member is required.
        public var name: Swift.String?
        /// Value of parameter to start execution of a SageMaker Model Building Pipeline.
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension EventBridgeClientTypes.SageMakerPipelineParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineParameterList = "PipelineParameterList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineParameterList = pipelineParameterList {
            var pipelineParameterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineParameterList)
            for sagemakerpipelineparameter0 in pipelineParameterList {
                try pipelineParameterListContainer.encode(sagemakerpipelineparameter0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineParameterListContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.SageMakerPipelineParameter?].self, forKey: .pipelineParameterList)
        var pipelineParameterListDecoded0:[EventBridgeClientTypes.SageMakerPipelineParameter]? = nil
        if let pipelineParameterListContainer = pipelineParameterListContainer {
            pipelineParameterListDecoded0 = [EventBridgeClientTypes.SageMakerPipelineParameter]()
            for structure0 in pipelineParameterListContainer {
                if let structure0 = structure0 {
                    pipelineParameterListDecoded0?.append(structure0)
                }
            }
        }
        pipelineParameterList = pipelineParameterListDecoded0
    }
}

extension EventBridgeClientTypes {
    /// These are custom parameters to use when the target is a SageMaker Model Building Pipeline that starts based on EventBridge events.
    public struct SageMakerPipelineParameters: Swift.Equatable {
        /// List of Parameter names and values for SageMaker Model Building Pipeline execution.
        public var pipelineParameterList: [EventBridgeClientTypes.SageMakerPipelineParameter]?

        public init (
            pipelineParameterList: [EventBridgeClientTypes.SageMakerPipelineParameter]? = nil
        )
        {
            self.pipelineParameterList = pipelineParameterList
        }
    }

}

extension EventBridgeClientTypes.Secondary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case route = "Route"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let route = self.route {
            try encodeContainer.encode(route, forKey: .route)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .route)
        route = routeDecoded
    }
}

extension EventBridgeClientTypes {
    /// The secondary Region that processes events when failover is triggered or replication is enabled.
    public struct Secondary: Swift.Equatable {
        /// Defines the secondary Region.
        /// This member is required.
        public var route: Swift.String?

        public init (
            route: Swift.String? = nil
        )
        {
            self.route = route
        }
    }

}

extension EventBridgeClientTypes.SqsParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageGroupId = "MessageGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageGroupId = self.messageGroupId {
            try encodeContainer.encode(messageGroupId, forKey: .messageGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageGroupId)
        messageGroupId = messageGroupIdDecoded
    }
}

extension EventBridgeClientTypes {
    /// This structure includes the custom parameter to be used when the target is an SQS FIFO queue.
    public struct SqsParameters: Swift.Equatable {
        /// The FIFO message group ID to use as the target.
        public var messageGroupId: Swift.String?

        public init (
            messageGroupId: Swift.String? = nil
        )
        {
            self.messageGroupId = messageGroupId
        }
    }

}

extension StartReplayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destination = "Destination"
        case eventEndTime = "EventEndTime"
        case eventSourceArn = "EventSourceArn"
        case eventStartTime = "EventStartTime"
        case replayName = "ReplayName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let eventEndTime = self.eventEndTime {
            try encodeContainer.encodeTimestamp(eventEndTime, format: .epochSeconds, forKey: .eventEndTime)
        }
        if let eventSourceArn = self.eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let eventStartTime = self.eventStartTime {
            try encodeContainer.encodeTimestamp(eventStartTime, format: .epochSeconds, forKey: .eventStartTime)
        }
        if let replayName = self.replayName {
            try encodeContainer.encode(replayName, forKey: .replayName)
        }
    }
}

extension StartReplayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartReplayInput: Swift.Equatable {
    /// A description for the replay to start.
    public var description: Swift.String?
    /// A ReplayDestination object that includes details about the destination for the replay.
    /// This member is required.
    public var destination: EventBridgeClientTypes.ReplayDestination?
    /// A time stamp for the time to stop replaying events. Only events that occurred between the EventStartTime and EventEndTime are replayed.
    /// This member is required.
    public var eventEndTime: ClientRuntime.Date?
    /// The ARN of the archive to replay events from.
    /// This member is required.
    public var eventSourceArn: Swift.String?
    /// A time stamp for the time to start replaying events. Only events that occurred between the EventStartTime and EventEndTime are replayed.
    /// This member is required.
    public var eventStartTime: ClientRuntime.Date?
    /// The name of the replay to start.
    /// This member is required.
    public var replayName: Swift.String?

    public init (
        description: Swift.String? = nil,
        destination: EventBridgeClientTypes.ReplayDestination? = nil,
        eventEndTime: ClientRuntime.Date? = nil,
        eventSourceArn: Swift.String? = nil,
        eventStartTime: ClientRuntime.Date? = nil,
        replayName: Swift.String? = nil
    )
    {
        self.description = description
        self.destination = destination
        self.eventEndTime = eventEndTime
        self.eventSourceArn = eventSourceArn
        self.eventStartTime = eventStartTime
        self.replayName = replayName
    }
}

struct StartReplayInputBody: Swift.Equatable {
    let replayName: Swift.String?
    let description: Swift.String?
    let eventSourceArn: Swift.String?
    let eventStartTime: ClientRuntime.Date?
    let eventEndTime: ClientRuntime.Date?
    let destination: EventBridgeClientTypes.ReplayDestination?
}

extension StartReplayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destination = "Destination"
        case eventEndTime = "EventEndTime"
        case eventSourceArn = "EventSourceArn"
        case eventStartTime = "EventStartTime"
        case replayName = "ReplayName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayName)
        replayName = replayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let eventStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventStartTime)
        eventStartTime = eventStartTimeDecoded
        let eventEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventEndTime)
        eventEndTime = eventEndTimeDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ReplayDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension StartReplayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReplayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartReplayOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReplayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartReplayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replayArn = output.replayArn
            self.replayStartTime = output.replayStartTime
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.replayArn = nil
            self.replayStartTime = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct StartReplayOutputResponse: Swift.Equatable {
    /// The ARN of the replay.
    public var replayArn: Swift.String?
    /// The time at which the replay started.
    public var replayStartTime: ClientRuntime.Date?
    /// The state of the replay.
    public var state: EventBridgeClientTypes.ReplayState?
    /// The reason that the replay is in the state.
    public var stateReason: Swift.String?

    public init (
        replayArn: Swift.String? = nil,
        replayStartTime: ClientRuntime.Date? = nil,
        state: EventBridgeClientTypes.ReplayState? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.replayArn = replayArn
        self.replayStartTime = replayStartTime
        self.state = state
        self.stateReason = stateReason
    }
}

struct StartReplayOutputResponseBody: Swift.Equatable {
    let replayArn: Swift.String?
    let state: EventBridgeClientTypes.ReplayState?
    let stateReason: Swift.String?
    let replayStartTime: ClientRuntime.Date?
}

extension StartReplayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replayArn = "ReplayArn"
        case replayStartTime = "ReplayStartTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayArn)
        replayArn = replayArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ReplayState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let replayStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replayStartTime)
        replayStartTime = replayStartTimeDecoded
    }
}

extension EventBridgeClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension EventBridgeClientTypes {
    /// A key-value pair associated with an Amazon Web Services resource. In EventBridge, rules and event buses support tagging.
    public struct Tag: Swift.Equatable {
        /// A string you can use to assign a value. The combination of tag keys and values can help you organize and categorize your resources.
        /// This member is required.
        public var key: Swift.String?
        /// The value for the specified tag key.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the EventBridge resource that you're adding tags to.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The list of key-value pairs to associate with the resource.
    /// This member is required.
    public var tags: [EventBridgeClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [EventBridgeClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [EventBridgeClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EventBridgeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EventBridgeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension EventBridgeClientTypes.Target: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case batchParameters = "BatchParameters"
        case deadLetterConfig = "DeadLetterConfig"
        case ecsParameters = "EcsParameters"
        case httpParameters = "HttpParameters"
        case id = "Id"
        case input = "Input"
        case inputPath = "InputPath"
        case inputTransformer = "InputTransformer"
        case kinesisParameters = "KinesisParameters"
        case redshiftDataParameters = "RedshiftDataParameters"
        case retryPolicy = "RetryPolicy"
        case roleArn = "RoleArn"
        case runCommandParameters = "RunCommandParameters"
        case sageMakerPipelineParameters = "SageMakerPipelineParameters"
        case sqsParameters = "SqsParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let batchParameters = self.batchParameters {
            try encodeContainer.encode(batchParameters, forKey: .batchParameters)
        }
        if let deadLetterConfig = self.deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let ecsParameters = self.ecsParameters {
            try encodeContainer.encode(ecsParameters, forKey: .ecsParameters)
        }
        if let httpParameters = self.httpParameters {
            try encodeContainer.encode(httpParameters, forKey: .httpParameters)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let input = self.input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputPath = self.inputPath {
            try encodeContainer.encode(inputPath, forKey: .inputPath)
        }
        if let inputTransformer = self.inputTransformer {
            try encodeContainer.encode(inputTransformer, forKey: .inputTransformer)
        }
        if let kinesisParameters = self.kinesisParameters {
            try encodeContainer.encode(kinesisParameters, forKey: .kinesisParameters)
        }
        if let redshiftDataParameters = self.redshiftDataParameters {
            try encodeContainer.encode(redshiftDataParameters, forKey: .redshiftDataParameters)
        }
        if let retryPolicy = self.retryPolicy {
            try encodeContainer.encode(retryPolicy, forKey: .retryPolicy)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let runCommandParameters = self.runCommandParameters {
            try encodeContainer.encode(runCommandParameters, forKey: .runCommandParameters)
        }
        if let sageMakerPipelineParameters = self.sageMakerPipelineParameters {
            try encodeContainer.encode(sageMakerPipelineParameters, forKey: .sageMakerPipelineParameters)
        }
        if let sqsParameters = self.sqsParameters {
            try encodeContainer.encode(sqsParameters, forKey: .sqsParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .input)
        input = inputDecoded
        let inputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputPath)
        inputPath = inputPathDecoded
        let inputTransformerDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.InputTransformer.self, forKey: .inputTransformer)
        inputTransformer = inputTransformerDecoded
        let kinesisParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.KinesisParameters.self, forKey: .kinesisParameters)
        kinesisParameters = kinesisParametersDecoded
        let runCommandParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.RunCommandParameters.self, forKey: .runCommandParameters)
        runCommandParameters = runCommandParametersDecoded
        let ecsParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.EcsParameters.self, forKey: .ecsParameters)
        ecsParameters = ecsParametersDecoded
        let batchParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.BatchParameters.self, forKey: .batchParameters)
        batchParameters = batchParametersDecoded
        let sqsParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.SqsParameters.self, forKey: .sqsParameters)
        sqsParameters = sqsParametersDecoded
        let httpParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.HttpParameters.self, forKey: .httpParameters)
        httpParameters = httpParametersDecoded
        let redshiftDataParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.RedshiftDataParameters.self, forKey: .redshiftDataParameters)
        redshiftDataParameters = redshiftDataParametersDecoded
        let sageMakerPipelineParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.SageMakerPipelineParameters.self, forKey: .sageMakerPipelineParameters)
        sageMakerPipelineParameters = sageMakerPipelineParametersDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let retryPolicyDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.RetryPolicy.self, forKey: .retryPolicy)
        retryPolicy = retryPolicyDecoded
    }
}

extension EventBridgeClientTypes {
    /// Targets are the resources to be invoked when a rule is triggered. For a complete list of services and resources that can be set as a target, see [PutTargets](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutTargets.html). If you are setting the event bus of another account as the target, and that account granted permission to your account through an organization instead of directly by the account ID, then you must specify a RoleArn with proper permissions in the Target structure. For more information, see [Sending and Receiving Events Between Amazon Web Services Accounts](https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-cross-account-event-delivery.html) in the Amazon EventBridge User Guide.
    public struct Target: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the target.
        /// This member is required.
        public var arn: Swift.String?
        /// If the event target is an Batch job, this contains the job definition, job name, and other parameters. For more information, see [Jobs](https://docs.aws.amazon.com/batch/latest/userguide/jobs.html) in the Batch User Guide.
        public var batchParameters: EventBridgeClientTypes.BatchParameters?
        /// The DeadLetterConfig that defines the target queue to send dead-letter queue events to.
        public var deadLetterConfig: EventBridgeClientTypes.DeadLetterConfig?
        /// Contains the Amazon ECS task definition and task count to be used, if the event target is an Amazon ECS task. For more information about Amazon ECS tasks, see [Task Definitions ](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_defintions.html) in the Amazon EC2 Container Service Developer Guide.
        public var ecsParameters: EventBridgeClientTypes.EcsParameters?
        /// Contains the HTTP parameters to use when the target is a API Gateway REST endpoint or EventBridge ApiDestination. If you specify an API Gateway REST API or EventBridge ApiDestination as a target, you can use this parameter to specify headers, path parameters, and query string keys/values as part of your target invoking request. If you're using ApiDestinations, the corresponding Connection can also have these values configured. In case of any conflicting keys, values from the Connection take precedence.
        public var httpParameters: EventBridgeClientTypes.HttpParameters?
        /// The ID of the target within the specified rule. Use this ID to reference the target when updating the rule. We recommend using a memorable and unique string.
        /// This member is required.
        public var id: Swift.String?
        /// Valid JSON text passed to the target. In this case, nothing from the event itself is passed to the target. For more information, see [The JavaScript Object Notation (JSON) Data Interchange Format](http://www.rfc-editor.org/rfc/rfc7159.txt).
        public var input: Swift.String?
        /// The value of the JSONPath that is used for extracting part of the matched event when passing it to the target. You must use JSON dot notation, not bracket notation. For more information about JSON paths, see [JSONPath](http://goessner.net/articles/JsonPath/).
        public var inputPath: Swift.String?
        /// Settings to enable you to provide custom input to a target based on certain event data. You can extract one or more key-value pairs from the event and then use that data to send customized input to the target.
        public var inputTransformer: EventBridgeClientTypes.InputTransformer?
        /// The custom parameter you can use to control the shard assignment, when the target is a Kinesis data stream. If you do not include this parameter, the default is to use the eventId as the partition key.
        public var kinesisParameters: EventBridgeClientTypes.KinesisParameters?
        /// Contains the Amazon Redshift Data API parameters to use when the target is a Amazon Redshift cluster. If you specify a Amazon Redshift Cluster as a Target, you can use this to specify parameters to invoke the Amazon Redshift Data API ExecuteStatement based on EventBridge events.
        public var redshiftDataParameters: EventBridgeClientTypes.RedshiftDataParameters?
        /// The RetryPolicy object that contains the retry policy configuration to use for the dead-letter queue.
        public var retryPolicy: EventBridgeClientTypes.RetryPolicy?
        /// The Amazon Resource Name (ARN) of the IAM role to be used for this target when the rule is triggered. If one rule triggers multiple targets, you can use a different IAM role for each target.
        public var roleArn: Swift.String?
        /// Parameters used when you are using the rule to invoke Amazon EC2 Run Command.
        public var runCommandParameters: EventBridgeClientTypes.RunCommandParameters?
        /// Contains the SageMaker Model Building Pipeline parameters to start execution of a SageMaker Model Building Pipeline. If you specify a SageMaker Model Building Pipeline as a target, you can use this to specify parameters to start a pipeline execution based on EventBridge events.
        public var sageMakerPipelineParameters: EventBridgeClientTypes.SageMakerPipelineParameters?
        /// Contains the message group ID to use when the target is a FIFO queue. If you specify an SQS FIFO queue as a target, the queue must have content-based deduplication enabled.
        public var sqsParameters: EventBridgeClientTypes.SqsParameters?

        public init (
            arn: Swift.String? = nil,
            batchParameters: EventBridgeClientTypes.BatchParameters? = nil,
            deadLetterConfig: EventBridgeClientTypes.DeadLetterConfig? = nil,
            ecsParameters: EventBridgeClientTypes.EcsParameters? = nil,
            httpParameters: EventBridgeClientTypes.HttpParameters? = nil,
            id: Swift.String? = nil,
            input: Swift.String? = nil,
            inputPath: Swift.String? = nil,
            inputTransformer: EventBridgeClientTypes.InputTransformer? = nil,
            kinesisParameters: EventBridgeClientTypes.KinesisParameters? = nil,
            redshiftDataParameters: EventBridgeClientTypes.RedshiftDataParameters? = nil,
            retryPolicy: EventBridgeClientTypes.RetryPolicy? = nil,
            roleArn: Swift.String? = nil,
            runCommandParameters: EventBridgeClientTypes.RunCommandParameters? = nil,
            sageMakerPipelineParameters: EventBridgeClientTypes.SageMakerPipelineParameters? = nil,
            sqsParameters: EventBridgeClientTypes.SqsParameters? = nil
        )
        {
            self.arn = arn
            self.batchParameters = batchParameters
            self.deadLetterConfig = deadLetterConfig
            self.ecsParameters = ecsParameters
            self.httpParameters = httpParameters
            self.id = id
            self.input = input
            self.inputPath = inputPath
            self.inputTransformer = inputTransformer
            self.kinesisParameters = kinesisParameters
            self.redshiftDataParameters = redshiftDataParameters
            self.retryPolicy = retryPolicy
            self.roleArn = roleArn
            self.runCommandParameters = runCommandParameters
            self.sageMakerPipelineParameters = sageMakerPipelineParameters
            self.sqsParameters = sqsParameters
        }
    }

}

extension TestEventPatternInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event = "Event"
        case eventPattern = "EventPattern"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let eventPattern = self.eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
    }
}

extension TestEventPatternInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TestEventPatternInput: Swift.Equatable {
    /// The event, in JSON format, to test against the event pattern. The JSON must follow the format specified in [Amazon Web Services Events](https://docs.aws.amazon.com/eventbridge/latest/userguide/aws-events.html), and the following fields are mandatory:
    ///
    /// * id
    ///
    /// * account
    ///
    /// * source
    ///
    /// * time
    ///
    /// * region
    ///
    /// * resources
    ///
    /// * detail-type
    /// This member is required.
    public var event: Swift.String?
    /// The event pattern. For more information, see [Events and Event Patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-and-event-patterns.html) in the Amazon EventBridge User Guide.
    /// This member is required.
    public var eventPattern: Swift.String?

    public init (
        event: Swift.String? = nil,
        eventPattern: Swift.String? = nil
    )
    {
        self.event = event
        self.eventPattern = eventPattern
    }
}

struct TestEventPatternInputBody: Swift.Equatable {
    let eventPattern: Swift.String?
    let event: Swift.String?
}

extension TestEventPatternInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event = "Event"
        case eventPattern = "EventPattern"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let eventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .event)
        event = eventDecoded
    }
}

extension TestEventPatternOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestEventPatternOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TestEventPatternOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestEventPatternOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TestEventPatternOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = false
        }
    }
}

public struct TestEventPatternOutputResponse: Swift.Equatable {
    /// Indicates whether the event matches the event pattern.
    public var result: Swift.Bool

    public init (
        result: Swift.Bool = false
    )
    {
        self.result = result
    }
}

struct TestEventPatternOutputResponseBody: Swift.Equatable {
    let result: Swift.Bool
}

extension TestEventPatternOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case result = "Result"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .result) ?? false
        result = resultDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the EventBridge resource from which you are removing tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateApiDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = self.connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let invocationEndpoint = self.invocationEndpoint {
            try encodeContainer.encode(invocationEndpoint, forKey: .invocationEndpoint)
        }
        if let invocationRateLimitPerSecond = self.invocationRateLimitPerSecond {
            try encodeContainer.encode(invocationRateLimitPerSecond, forKey: .invocationRateLimitPerSecond)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateApiDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApiDestinationInput: Swift.Equatable {
    /// The ARN of the connection to use for the API destination.
    public var connectionArn: Swift.String?
    /// The name of the API destination to update.
    public var description: Swift.String?
    /// The method to use for the API destination.
    public var httpMethod: EventBridgeClientTypes.ApiDestinationHttpMethod?
    /// The URL to the endpoint to use for the API destination.
    public var invocationEndpoint: Swift.String?
    /// The maximum number of invocations per second to send to the API destination.
    public var invocationRateLimitPerSecond: Swift.Int?
    /// The name of the API destination to update.
    /// This member is required.
    public var name: Swift.String?

    public init (
        connectionArn: Swift.String? = nil,
        description: Swift.String? = nil,
        httpMethod: EventBridgeClientTypes.ApiDestinationHttpMethod? = nil,
        invocationEndpoint: Swift.String? = nil,
        invocationRateLimitPerSecond: Swift.Int? = nil,
        name: Swift.String? = nil
    )
    {
        self.connectionArn = connectionArn
        self.description = description
        self.httpMethod = httpMethod
        self.invocationEndpoint = invocationEndpoint
        self.invocationRateLimitPerSecond = invocationRateLimitPerSecond
        self.name = name
    }
}

struct UpdateApiDestinationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let connectionArn: Swift.String?
    let invocationEndpoint: Swift.String?
    let httpMethod: EventBridgeClientTypes.ApiDestinationHttpMethod?
    let invocationRateLimitPerSecond: Swift.Int?
}

extension UpdateApiDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let invocationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationEndpoint)
        invocationEndpoint = invocationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ApiDestinationHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let invocationRateLimitPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .invocationRateLimitPerSecond)
        invocationRateLimitPerSecond = invocationRateLimitPerSecondDecoded
    }
}

extension UpdateApiDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateApiDestinationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateApiDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiDestinationArn = output.apiDestinationArn
            self.apiDestinationState = output.apiDestinationState
            self.creationTime = output.creationTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.apiDestinationArn = nil
            self.apiDestinationState = nil
            self.creationTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct UpdateApiDestinationOutputResponse: Swift.Equatable {
    /// The ARN of the API destination that was updated.
    public var apiDestinationArn: Swift.String?
    /// The state of the API destination that was updated.
    public var apiDestinationState: EventBridgeClientTypes.ApiDestinationState?
    /// A time stamp for the time that the API destination was created.
    public var creationTime: ClientRuntime.Date?
    /// A time stamp for the time that the API destination was last modified.
    public var lastModifiedTime: ClientRuntime.Date?

    public init (
        apiDestinationArn: Swift.String? = nil,
        apiDestinationState: EventBridgeClientTypes.ApiDestinationState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil
    )
    {
        self.apiDestinationArn = apiDestinationArn
        self.apiDestinationState = apiDestinationState
        self.creationTime = creationTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct UpdateApiDestinationOutputResponseBody: Swift.Equatable {
    let apiDestinationArn: Swift.String?
    let apiDestinationState: EventBridgeClientTypes.ApiDestinationState?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
}

extension UpdateApiDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDestinationArn = "ApiDestinationArn"
        case apiDestinationState = "ApiDestinationState"
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiDestinationArn)
        apiDestinationArn = apiDestinationArnDecoded
        let apiDestinationStateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ApiDestinationState.self, forKey: .apiDestinationState)
        apiDestinationState = apiDestinationStateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension UpdateArchiveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
        case description = "Description"
        case eventPattern = "EventPattern"
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = self.archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventPattern = self.eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let retentionDays = self.retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }
}

extension UpdateArchiveInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateArchiveInput: Swift.Equatable {
    /// The name of the archive to update.
    /// This member is required.
    public var archiveName: Swift.String?
    /// The description for the archive.
    public var description: Swift.String?
    /// The event pattern to use to filter events sent to the archive.
    public var eventPattern: Swift.String?
    /// The number of days to retain events in the archive.
    public var retentionDays: Swift.Int?

    public init (
        archiveName: Swift.String? = nil,
        description: Swift.String? = nil,
        eventPattern: Swift.String? = nil,
        retentionDays: Swift.Int? = nil
    )
    {
        self.archiveName = archiveName
        self.description = description
        self.eventPattern = eventPattern
        self.retentionDays = retentionDays
    }
}

struct UpdateArchiveInputBody: Swift.Equatable {
    let archiveName: Swift.String?
    let description: Swift.String?
    let eventPattern: Swift.String?
    let retentionDays: Swift.Int?
}

extension UpdateArchiveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
        case description = "Description"
        case eventPattern = "EventPattern"
        case retentionDays = "RetentionDays"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension UpdateArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateArchiveOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateArchiveOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.archiveArn = output.archiveArn
            self.creationTime = output.creationTime
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.archiveArn = nil
            self.creationTime = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct UpdateArchiveOutputResponse: Swift.Equatable {
    /// The ARN of the archive.
    public var archiveArn: Swift.String?
    /// The time at which the archive was updated.
    public var creationTime: ClientRuntime.Date?
    /// The state of the archive.
    public var state: EventBridgeClientTypes.ArchiveState?
    /// The reason that the archive is in the current state.
    public var stateReason: Swift.String?

    public init (
        archiveArn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        state: EventBridgeClientTypes.ArchiveState? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.archiveArn = archiveArn
        self.creationTime = creationTime
        self.state = state
        self.stateReason = stateReason
    }
}

struct UpdateArchiveOutputResponseBody: Swift.Equatable {
    let archiveArn: Swift.String?
    let state: EventBridgeClientTypes.ArchiveState?
    let stateReason: Swift.String?
    let creationTime: ClientRuntime.Date?
}

extension UpdateArchiveOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveArn = "ArchiveArn"
        case creationTime = "CreationTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveArn)
        archiveArn = archiveArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ArchiveState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension EventBridgeClientTypes.UpdateConnectionApiKeyAuthRequestParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyName = "ApiKeyName"
        case apiKeyValue = "ApiKeyValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyName = self.apiKeyName {
            try encodeContainer.encode(apiKeyName, forKey: .apiKeyName)
        }
        if let apiKeyValue = self.apiKeyValue {
            try encodeContainer.encode(apiKeyValue, forKey: .apiKeyValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeyName)
        apiKeyName = apiKeyNameDecoded
        let apiKeyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeyValue)
        apiKeyValue = apiKeyValueDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the API key authorization parameters to use to update the connection.
    public struct UpdateConnectionApiKeyAuthRequestParameters: Swift.Equatable {
        /// The name of the API key to use for authorization.
        public var apiKeyName: Swift.String?
        /// The value associated with teh API key to use for authorization.
        public var apiKeyValue: Swift.String?

        public init (
            apiKeyName: Swift.String? = nil,
            apiKeyValue: Swift.String? = nil
        )
        {
            self.apiKeyName = apiKeyName
            self.apiKeyValue = apiKeyValue
        }
    }

}

extension EventBridgeClientTypes.UpdateConnectionAuthRequestParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyAuthParameters = "ApiKeyAuthParameters"
        case basicAuthParameters = "BasicAuthParameters"
        case invocationHttpParameters = "InvocationHttpParameters"
        case oAuthParameters = "OAuthParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyAuthParameters = self.apiKeyAuthParameters {
            try encodeContainer.encode(apiKeyAuthParameters, forKey: .apiKeyAuthParameters)
        }
        if let basicAuthParameters = self.basicAuthParameters {
            try encodeContainer.encode(basicAuthParameters, forKey: .basicAuthParameters)
        }
        if let invocationHttpParameters = self.invocationHttpParameters {
            try encodeContainer.encode(invocationHttpParameters, forKey: .invocationHttpParameters)
        }
        if let oAuthParameters = self.oAuthParameters {
            try encodeContainer.encode(oAuthParameters, forKey: .oAuthParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basicAuthParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.UpdateConnectionBasicAuthRequestParameters.self, forKey: .basicAuthParameters)
        basicAuthParameters = basicAuthParametersDecoded
        let oAuthParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.UpdateConnectionOAuthRequestParameters.self, forKey: .oAuthParameters)
        oAuthParameters = oAuthParametersDecoded
        let apiKeyAuthParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.UpdateConnectionApiKeyAuthRequestParameters.self, forKey: .apiKeyAuthParameters)
        apiKeyAuthParameters = apiKeyAuthParametersDecoded
        let invocationHttpParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionHttpParameters.self, forKey: .invocationHttpParameters)
        invocationHttpParameters = invocationHttpParametersDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the additional parameters to use for the connection.
    public struct UpdateConnectionAuthRequestParameters: Swift.Equatable {
        /// A UpdateConnectionApiKeyAuthRequestParameters object that contains the authorization parameters for API key authorization.
        public var apiKeyAuthParameters: EventBridgeClientTypes.UpdateConnectionApiKeyAuthRequestParameters?
        /// A UpdateConnectionBasicAuthRequestParameters object that contains the authorization parameters for Basic authorization.
        public var basicAuthParameters: EventBridgeClientTypes.UpdateConnectionBasicAuthRequestParameters?
        /// A ConnectionHttpParameters object that contains the additional parameters to use for the connection.
        public var invocationHttpParameters: EventBridgeClientTypes.ConnectionHttpParameters?
        /// A UpdateConnectionOAuthRequestParameters object that contains the authorization parameters for OAuth authorization.
        public var oAuthParameters: EventBridgeClientTypes.UpdateConnectionOAuthRequestParameters?

        public init (
            apiKeyAuthParameters: EventBridgeClientTypes.UpdateConnectionApiKeyAuthRequestParameters? = nil,
            basicAuthParameters: EventBridgeClientTypes.UpdateConnectionBasicAuthRequestParameters? = nil,
            invocationHttpParameters: EventBridgeClientTypes.ConnectionHttpParameters? = nil,
            oAuthParameters: EventBridgeClientTypes.UpdateConnectionOAuthRequestParameters? = nil
        )
        {
            self.apiKeyAuthParameters = apiKeyAuthParameters
            self.basicAuthParameters = basicAuthParameters
            self.invocationHttpParameters = invocationHttpParameters
            self.oAuthParameters = oAuthParameters
        }
    }

}

extension EventBridgeClientTypes.UpdateConnectionBasicAuthRequestParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the Basic authorization parameters for the connection.
    public struct UpdateConnectionBasicAuthRequestParameters: Swift.Equatable {
        /// The password associated with the user name to use for Basic authorization.
        public var password: Swift.String?
        /// The user name to use for Basic authorization.
        public var username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension UpdateConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authParameters = self.authParameters {
            try encodeContainer.encode(authParameters, forKey: .authParameters)
        }
        if let authorizationType = self.authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateConnectionInput: Swift.Equatable {
    /// The authorization parameters to use for the connection.
    public var authParameters: EventBridgeClientTypes.UpdateConnectionAuthRequestParameters?
    /// The type of authorization to use for the connection.
    public var authorizationType: EventBridgeClientTypes.ConnectionAuthorizationType?
    /// A description for the connection.
    public var description: Swift.String?
    /// The name of the connection to update.
    /// This member is required.
    public var name: Swift.String?

    public init (
        authParameters: EventBridgeClientTypes.UpdateConnectionAuthRequestParameters? = nil,
        authorizationType: EventBridgeClientTypes.ConnectionAuthorizationType? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.authParameters = authParameters
        self.authorizationType = authorizationType
        self.description = description
        self.name = name
    }
}

struct UpdateConnectionInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let authorizationType: EventBridgeClientTypes.ConnectionAuthorizationType?
    let authParameters: EventBridgeClientTypes.UpdateConnectionAuthRequestParameters?
}

extension UpdateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionAuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.UpdateConnectionAuthRequestParameters.self, forKey: .authParameters)
        authParameters = authParametersDecoded
    }
}

extension EventBridgeClientTypes.UpdateConnectionOAuthClientRequestParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientID = "ClientID"
        case clientSecret = "ClientSecret"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientID = self.clientID {
            try encodeContainer.encode(clientID, forKey: .clientID)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientID)
        clientID = clientIDDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the OAuth authorization parameters to use for the connection.
    public struct UpdateConnectionOAuthClientRequestParameters: Swift.Equatable {
        /// The client ID to use for OAuth authorization.
        public var clientID: Swift.String?
        /// The client secret assciated with the client ID to use for OAuth authorization.
        public var clientSecret: Swift.String?

        public init (
            clientID: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        )
        {
            self.clientID = clientID
            self.clientSecret = clientSecret
        }
    }

}

extension EventBridgeClientTypes.UpdateConnectionOAuthRequestParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationEndpoint = "AuthorizationEndpoint"
        case clientParameters = "ClientParameters"
        case httpMethod = "HttpMethod"
        case oAuthHttpParameters = "OAuthHttpParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationEndpoint = self.authorizationEndpoint {
            try encodeContainer.encode(authorizationEndpoint, forKey: .authorizationEndpoint)
        }
        if let clientParameters = self.clientParameters {
            try encodeContainer.encode(clientParameters, forKey: .clientParameters)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let oAuthHttpParameters = self.oAuthHttpParameters {
            try encodeContainer.encode(oAuthHttpParameters, forKey: .oAuthHttpParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.UpdateConnectionOAuthClientRequestParameters.self, forKey: .clientParameters)
        clientParameters = clientParametersDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionOAuthHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let oAuthHttpParametersDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionHttpParameters.self, forKey: .oAuthHttpParameters)
        oAuthHttpParameters = oAuthHttpParametersDecoded
    }
}

extension EventBridgeClientTypes {
    /// Contains the OAuth request parameters to use for the connection.
    public struct UpdateConnectionOAuthRequestParameters: Swift.Equatable {
        /// The URL to the authorization endpoint when OAuth is specified as the authorization type.
        public var authorizationEndpoint: Swift.String?
        /// A UpdateConnectionOAuthClientRequestParameters object that contains the client parameters to use for the connection when OAuth is specified as the authorization type.
        public var clientParameters: EventBridgeClientTypes.UpdateConnectionOAuthClientRequestParameters?
        /// The method used to connect to the HTTP endpoint.
        public var httpMethod: EventBridgeClientTypes.ConnectionOAuthHttpMethod?
        /// The additional HTTP parameters used for the OAuth authorization request.
        public var oAuthHttpParameters: EventBridgeClientTypes.ConnectionHttpParameters?

        public init (
            authorizationEndpoint: Swift.String? = nil,
            clientParameters: EventBridgeClientTypes.UpdateConnectionOAuthClientRequestParameters? = nil,
            httpMethod: EventBridgeClientTypes.ConnectionOAuthHttpMethod? = nil,
            oAuthHttpParameters: EventBridgeClientTypes.ConnectionHttpParameters? = nil
        )
        {
            self.authorizationEndpoint = authorizationEndpoint
            self.clientParameters = clientParameters
            self.httpMethod = httpMethod
            self.oAuthHttpParameters = oAuthHttpParameters
        }
    }

}

extension UpdateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateConnectionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.lastAuthorizedTime = output.lastAuthorizedTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.lastAuthorizedTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct UpdateConnectionOutputResponse: Swift.Equatable {
    /// The ARN of the connection that was updated.
    public var connectionArn: Swift.String?
    /// The state of the connection that was updated.
    public var connectionState: EventBridgeClientTypes.ConnectionState?
    /// A time stamp for the time that the connection was created.
    public var creationTime: ClientRuntime.Date?
    /// A time stamp for the time that the connection was last authorized.
    public var lastAuthorizedTime: ClientRuntime.Date?
    /// A time stamp for the time that the connection was last modified.
    public var lastModifiedTime: ClientRuntime.Date?

    public init (
        connectionArn: Swift.String? = nil,
        connectionState: EventBridgeClientTypes.ConnectionState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastAuthorizedTime: ClientRuntime.Date? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.lastAuthorizedTime = lastAuthorizedTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct UpdateConnectionOutputResponseBody: Swift.Equatable {
    let connectionArn: Swift.String?
    let connectionState: EventBridgeClientTypes.ConnectionState?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let lastAuthorizedTime: ClientRuntime.Date?
}

extension UpdateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}

extension UpdateEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventBuses = "EventBuses"
        case name = "Name"
        case replicationConfig = "ReplicationConfig"
        case roleArn = "RoleArn"
        case routingConfig = "RoutingConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventBuses = eventBuses {
            var eventBusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventBuses)
            for endpointeventbus0 in eventBuses {
                try eventBusesContainer.encode(endpointeventbus0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicationConfig = self.replicationConfig {
            try encodeContainer.encode(replicationConfig, forKey: .replicationConfig)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let routingConfig = self.routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
    }
}

extension UpdateEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEndpointInput: Swift.Equatable {
    /// A description for the endpoint.
    public var description: Swift.String?
    /// Define event buses used for replication.
    public var eventBuses: [EventBridgeClientTypes.EndpointEventBus]?
    /// The name of the endpoint you want to update.
    /// This member is required.
    public var name: Swift.String?
    /// Whether event replication was enabled or disabled by this request.
    public var replicationConfig: EventBridgeClientTypes.ReplicationConfig?
    /// The ARN of the role used by event replication for this request.
    public var roleArn: Swift.String?
    /// Configure the routing policy, including the health check and secondary Region..
    public var routingConfig: EventBridgeClientTypes.RoutingConfig?

    public init (
        description: Swift.String? = nil,
        eventBuses: [EventBridgeClientTypes.EndpointEventBus]? = nil,
        name: Swift.String? = nil,
        replicationConfig: EventBridgeClientTypes.ReplicationConfig? = nil,
        roleArn: Swift.String? = nil,
        routingConfig: EventBridgeClientTypes.RoutingConfig? = nil
    )
    {
        self.description = description
        self.eventBuses = eventBuses
        self.name = name
        self.replicationConfig = replicationConfig
        self.roleArn = roleArn
        self.routingConfig = routingConfig
    }
}

struct UpdateEndpointInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let routingConfig: EventBridgeClientTypes.RoutingConfig?
    let replicationConfig: EventBridgeClientTypes.ReplicationConfig?
    let eventBuses: [EventBridgeClientTypes.EndpointEventBus]?
    let roleArn: Swift.String?
}

extension UpdateEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventBuses = "EventBuses"
        case name = "Name"
        case replicationConfig = "ReplicationConfig"
        case roleArn = "RoleArn"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.RoutingConfig.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let replicationConfigDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ReplicationConfig.self, forKey: .replicationConfig)
        replicationConfig = replicationConfigDecoded
        let eventBusesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.EndpointEventBus?].self, forKey: .eventBuses)
        var eventBusesDecoded0:[EventBridgeClientTypes.EndpointEventBus]? = nil
        if let eventBusesContainer = eventBusesContainer {
            eventBusesDecoded0 = [EventBridgeClientTypes.EndpointEventBus]()
            for structure0 in eventBusesContainer {
                if let structure0 = structure0 {
                    eventBusesDecoded0?.append(structure0)
                }
            }
        }
        eventBuses = eventBusesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateEndpointOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.endpointId = output.endpointId
            self.endpointUrl = output.endpointUrl
            self.eventBuses = output.eventBuses
            self.name = output.name
            self.replicationConfig = output.replicationConfig
            self.roleArn = output.roleArn
            self.routingConfig = output.routingConfig
            self.state = output.state
        } else {
            self.arn = nil
            self.endpointId = nil
            self.endpointUrl = nil
            self.eventBuses = nil
            self.name = nil
            self.replicationConfig = nil
            self.roleArn = nil
            self.routingConfig = nil
            self.state = nil
        }
    }
}

public struct UpdateEndpointOutputResponse: Swift.Equatable {
    /// The ARN of the endpoint you updated in this request.
    public var arn: Swift.String?
    /// The ID of the endpoint you updated in this request.
    public var endpointId: Swift.String?
    /// The URL of the endpoint you updated in this request.
    public var endpointUrl: Swift.String?
    /// The event buses used for replication for the endpoint you updated in this request.
    public var eventBuses: [EventBridgeClientTypes.EndpointEventBus]?
    /// The name of the endpoint you updated in this request.
    public var name: Swift.String?
    /// Whether event replication was enabled or disabled for the endpoint you updated in this request.
    public var replicationConfig: EventBridgeClientTypes.ReplicationConfig?
    /// The ARN of the role used by event replication for the endpoint you updated in this request.
    public var roleArn: Swift.String?
    /// The routing configuration you updated in this request.
    public var routingConfig: EventBridgeClientTypes.RoutingConfig?
    /// The state of the endpoint you updated in this request.
    public var state: EventBridgeClientTypes.EndpointState?

    public init (
        arn: Swift.String? = nil,
        endpointId: Swift.String? = nil,
        endpointUrl: Swift.String? = nil,
        eventBuses: [EventBridgeClientTypes.EndpointEventBus]? = nil,
        name: Swift.String? = nil,
        replicationConfig: EventBridgeClientTypes.ReplicationConfig? = nil,
        roleArn: Swift.String? = nil,
        routingConfig: EventBridgeClientTypes.RoutingConfig? = nil,
        state: EventBridgeClientTypes.EndpointState? = nil
    )
    {
        self.arn = arn
        self.endpointId = endpointId
        self.endpointUrl = endpointUrl
        self.eventBuses = eventBuses
        self.name = name
        self.replicationConfig = replicationConfig
        self.roleArn = roleArn
        self.routingConfig = routingConfig
        self.state = state
    }
}

struct UpdateEndpointOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let routingConfig: EventBridgeClientTypes.RoutingConfig?
    let replicationConfig: EventBridgeClientTypes.ReplicationConfig?
    let eventBuses: [EventBridgeClientTypes.EndpointEventBus]?
    let roleArn: Swift.String?
    let endpointId: Swift.String?
    let endpointUrl: Swift.String?
    let state: EventBridgeClientTypes.EndpointState?
}

extension UpdateEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case endpointId = "EndpointId"
        case endpointUrl = "EndpointUrl"
        case eventBuses = "EventBuses"
        case name = "Name"
        case replicationConfig = "ReplicationConfig"
        case roleArn = "RoleArn"
        case routingConfig = "RoutingConfig"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.RoutingConfig.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let replicationConfigDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.ReplicationConfig.self, forKey: .replicationConfig)
        replicationConfig = replicationConfigDecoded
        let eventBusesContainer = try containerValues.decodeIfPresent([EventBridgeClientTypes.EndpointEventBus?].self, forKey: .eventBuses)
        var eventBusesDecoded0:[EventBridgeClientTypes.EndpointEventBus]? = nil
        if let eventBusesContainer = eventBusesContainer {
            eventBusesDecoded0 = [EventBridgeClientTypes.EndpointEventBus]()
            for structure0 in eventBusesContainer {
                if let structure0 = structure0 {
                    eventBusesDecoded0?.append(structure0)
                }
            }
        }
        eventBuses = eventBusesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let endpointUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointUrl)
        endpointUrl = endpointUrlDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventBridgeClientTypes.EndpointState.self, forKey: .state)
        state = stateDecoded
    }
}
