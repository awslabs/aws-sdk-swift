//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

public struct DeleteAccessOutput {

    public init() { }
}

public struct DeleteAgreementOutput {

    public init() { }
}

public struct DeleteCertificateOutput {

    public init() { }
}

public struct DeleteConnectorOutput {

    public init() { }
}

public struct DeleteHostKeyOutput {

    public init() { }
}

public struct DeleteProfileOutput {

    public init() { }
}

public struct DeleteServerOutput {

    public init() { }
}

public struct DeleteSshPublicKeyOutput {

    public init() { }
}

public struct DeleteUserOutput {

    public init() { }
}

public struct DeleteWorkflowOutput {

    public init() { }
}

public struct StartServerOutput {

    public init() { }
}

public struct StopServerOutput {

    public init() { }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceOutput {

    public init() { }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDenied" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when an error occurs in the Transfer Family service.
public struct InternalServiceError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the client submits a malformed request.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested resource does not exist, or exists in a region other than the one specified for the command.
public struct ResourceExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// This member is required.
        public internal(set) var resource: Swift.String? = nil
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resource = resource
        self.properties.resourceType = resourceType
    }
}

/// This exception is thrown when a resource is not found by the Amazon Web ServicesTransfer Family service.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// This member is required.
        public internal(set) var resource: Swift.String? = nil
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resource = resource
        self.properties.resourceType = resourceType
    }
}

/// The request has failed because the Amazon Web ServicesTransfer Family service is not available.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailable" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var retryAfterSeconds: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

extension TransferClientTypes {

    public enum AgreementStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AgreementStatusType] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// Creates a key-value pair for a specific resource. Tags are metadata that you can use to search for and group a resource for various purposes. You can apply tags to servers, users, and roles. A tag key can take more than one value. For example, to group servers for accounting purposes, you might create a tag called Group and assign the values Research and Accounting to that group.
    public struct Tag {
        /// The name assigned to the tag that you create.
        /// This member is required.
        public var key: Swift.String?
        /// Contains one or more values that you assigned to the key name you create.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateAgreementInput {
    /// Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use. For AS2 connectors With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the file’s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer. If you are using Basic authentication for your AS2 connector, the access role requires the secretsmanager:GetSecretValue permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the kms:Decrypt permission for that key. For SFTP connectors Make sure that the access role provides read and write access to the parent directory of the file location that's used in the StartFileTransfer request. Additionally, make sure that the role provides secretsmanager:GetSecretValue permission to Secrets Manager.
    /// This member is required.
    public var accessRole: Swift.String?
    /// The landing directory (folder) for files transferred by using the AS2 protocol. A BaseDirectory example is /DOC-EXAMPLE-BUCKET/home/mydirectory.
    /// This member is required.
    public var baseDirectory: Swift.String?
    /// A name or short description to identify the agreement.
    public var description: Swift.String?
    /// A unique identifier for the AS2 local profile.
    /// This member is required.
    public var localProfileId: Swift.String?
    /// A unique identifier for the partner profile used in the agreement.
    /// This member is required.
    public var partnerProfileId: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that the agreement uses.
    /// This member is required.
    public var serverId: Swift.String?
    /// The status of the agreement. The agreement can be either ACTIVE or INACTIVE.
    public var status: TransferClientTypes.AgreementStatusType?
    /// Key-value pairs that can be used to group and search for agreements.
    public var tags: [TransferClientTypes.Tag]?

    public init(
        accessRole: Swift.String? = nil,
        baseDirectory: Swift.String? = nil,
        description: Swift.String? = nil,
        localProfileId: Swift.String? = nil,
        partnerProfileId: Swift.String? = nil,
        serverId: Swift.String? = nil,
        status: TransferClientTypes.AgreementStatusType? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.accessRole = accessRole
        self.baseDirectory = baseDirectory
        self.description = description
        self.localProfileId = localProfileId
        self.partnerProfileId = partnerProfileId
        self.serverId = serverId
        self.status = status
        self.tags = tags
    }
}

public struct CreateAgreementOutput {
    /// The unique identifier for the agreement. Use this ID for deleting, or updating an agreement, as well as in any other API calls that require that you specify the agreement ID.
    /// This member is required.
    public var agreementId: Swift.String?

    public init(
        agreementId: Swift.String? = nil
    )
    {
        self.agreementId = agreementId
    }
}

public struct DeleteAgreementInput {
    /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
    /// This member is required.
    public var agreementId: Swift.String?
    /// The server identifier associated with the agreement that you are deleting.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        agreementId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.agreementId = agreementId
        self.serverId = serverId
    }
}

public struct DescribeAgreementInput {
    /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
    /// This member is required.
    public var agreementId: Swift.String?
    /// The server identifier that's associated with the agreement.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        agreementId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.agreementId = agreementId
        self.serverId = serverId
    }
}

extension TransferClientTypes {
    /// Describes the properties of an agreement.
    public struct DescribedAgreement {
        /// Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use. For AS2 connectors With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the file’s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer. If you are using Basic authentication for your AS2 connector, the access role requires the secretsmanager:GetSecretValue permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the kms:Decrypt permission for that key. For SFTP connectors Make sure that the access role provides read and write access to the parent directory of the file location that's used in the StartFileTransfer request. Additionally, make sure that the role provides secretsmanager:GetSecretValue permission to Secrets Manager.
        public var accessRole: Swift.String?
        /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
        public var agreementId: Swift.String?
        /// The unique Amazon Resource Name (ARN) for the agreement.
        /// This member is required.
        public var arn: Swift.String?
        /// The landing directory (folder) for files that are transferred by using the AS2 protocol.
        public var baseDirectory: Swift.String?
        /// The name or short description that's used to identify the agreement.
        public var description: Swift.String?
        /// A unique identifier for the AS2 local profile.
        public var localProfileId: Swift.String?
        /// A unique identifier for the partner profile used in the agreement.
        public var partnerProfileId: Swift.String?
        /// A system-assigned unique identifier for a server instance. This identifier indicates the specific server that the agreement uses.
        public var serverId: Swift.String?
        /// The current status of the agreement, either ACTIVE or INACTIVE.
        public var status: TransferClientTypes.AgreementStatusType?
        /// Key-value pairs that can be used to group and search for agreements.
        public var tags: [TransferClientTypes.Tag]?

        public init(
            accessRole: Swift.String? = nil,
            agreementId: Swift.String? = nil,
            arn: Swift.String? = nil,
            baseDirectory: Swift.String? = nil,
            description: Swift.String? = nil,
            localProfileId: Swift.String? = nil,
            partnerProfileId: Swift.String? = nil,
            serverId: Swift.String? = nil,
            status: TransferClientTypes.AgreementStatusType? = nil,
            tags: [TransferClientTypes.Tag]? = nil
        )
        {
            self.accessRole = accessRole
            self.agreementId = agreementId
            self.arn = arn
            self.baseDirectory = baseDirectory
            self.description = description
            self.localProfileId = localProfileId
            self.partnerProfileId = partnerProfileId
            self.serverId = serverId
            self.status = status
            self.tags = tags
        }
    }

}

public struct DescribeAgreementOutput {
    /// The details for the specified agreement, returned as a DescribedAgreement object.
    /// This member is required.
    public var agreement: TransferClientTypes.DescribedAgreement?

    public init(
        agreement: TransferClientTypes.DescribedAgreement? = nil
    )
    {
        self.agreement = agreement
    }
}

/// The NextToken parameter that was passed is invalid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListAgreementsInput {
    /// The maximum number of agreements to return.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListAgreements call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional agreements.
    public var nextToken: Swift.String?
    /// The identifier of the server for which you want a list of agreements.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

extension TransferClientTypes {
    /// Describes the properties of an agreement.
    public struct ListedAgreement {
        /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
        public var agreementId: Swift.String?
        /// The Amazon Resource Name (ARN) of the specified agreement.
        public var arn: Swift.String?
        /// The current description for the agreement. You can change it by calling the UpdateAgreement operation and providing a new description.
        public var description: Swift.String?
        /// A unique identifier for the AS2 local profile.
        public var localProfileId: Swift.String?
        /// A unique identifier for the partner profile.
        public var partnerProfileId: Swift.String?
        /// The unique identifier for the agreement.
        public var serverId: Swift.String?
        /// The agreement can be either ACTIVE or INACTIVE.
        public var status: TransferClientTypes.AgreementStatusType?

        public init(
            agreementId: Swift.String? = nil,
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            localProfileId: Swift.String? = nil,
            partnerProfileId: Swift.String? = nil,
            serverId: Swift.String? = nil,
            status: TransferClientTypes.AgreementStatusType? = nil
        )
        {
            self.agreementId = agreementId
            self.arn = arn
            self.description = description
            self.localProfileId = localProfileId
            self.partnerProfileId = partnerProfileId
            self.serverId = serverId
            self.status = status
        }
    }

}

public struct ListAgreementsOutput {
    /// Returns an array, where each item contains the details of an agreement.
    /// This member is required.
    public var agreements: [TransferClientTypes.ListedAgreement]?
    /// Returns a token that you can use to call ListAgreements again and receive additional results, if there are any.
    public var nextToken: Swift.String?

    public init(
        agreements: [TransferClientTypes.ListedAgreement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agreements = agreements
        self.nextToken = nextToken
    }
}

public struct UpdateAgreementInput {
    /// Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use. For AS2 connectors With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the file’s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer. If you are using Basic authentication for your AS2 connector, the access role requires the secretsmanager:GetSecretValue permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the kms:Decrypt permission for that key. For SFTP connectors Make sure that the access role provides read and write access to the parent directory of the file location that's used in the StartFileTransfer request. Additionally, make sure that the role provides secretsmanager:GetSecretValue permission to Secrets Manager.
    public var accessRole: Swift.String?
    /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
    /// This member is required.
    public var agreementId: Swift.String?
    /// To change the landing directory (folder) for files that are transferred, provide the bucket folder that you want to use; for example, /DOC-EXAMPLE-BUCKET/home/mydirectory .
    public var baseDirectory: Swift.String?
    /// To replace the existing description, provide a short description for the agreement.
    public var description: Swift.String?
    /// A unique identifier for the AS2 local profile. To change the local profile identifier, provide a new value here.
    public var localProfileId: Swift.String?
    /// A unique identifier for the partner profile. To change the partner profile identifier, provide a new value here.
    public var partnerProfileId: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that the agreement uses.
    /// This member is required.
    public var serverId: Swift.String?
    /// You can update the status for the agreement, either activating an inactive agreement or the reverse.
    public var status: TransferClientTypes.AgreementStatusType?

    public init(
        accessRole: Swift.String? = nil,
        agreementId: Swift.String? = nil,
        baseDirectory: Swift.String? = nil,
        description: Swift.String? = nil,
        localProfileId: Swift.String? = nil,
        partnerProfileId: Swift.String? = nil,
        serverId: Swift.String? = nil,
        status: TransferClientTypes.AgreementStatusType? = nil
    )
    {
        self.accessRole = accessRole
        self.agreementId = agreementId
        self.baseDirectory = baseDirectory
        self.description = description
        self.localProfileId = localProfileId
        self.partnerProfileId = partnerProfileId
        self.serverId = serverId
        self.status = status
    }
}

public struct UpdateAgreementOutput {
    /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
    /// This member is required.
    public var agreementId: Swift.String?

    public init(
        agreementId: Swift.String? = nil
    )
    {
        self.agreementId = agreementId
    }
}

extension TransferClientTypes {

    public enum CompressionEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case zlib
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionEnum] {
            return [
                .disabled,
                .zlib
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .zlib: return "ZLIB"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {

    public enum EncryptionAlg: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aes128Cbc
        case aes192Cbc
        case aes256Cbc
        case desEde3Cbc
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionAlg] {
            return [
                .aes128Cbc,
                .aes192Cbc,
                .aes256Cbc,
                .desEde3Cbc,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aes128Cbc: return "AES128_CBC"
            case .aes192Cbc: return "AES192_CBC"
            case .aes256Cbc: return "AES256_CBC"
            case .desEde3Cbc: return "DES_EDE3_CBC"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {

    public enum MdnResponse: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case sync
        case sdkUnknown(Swift.String)

        public static var allCases: [MdnResponse] {
            return [
                .none,
                .sync
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .sync: return "SYNC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {

    public enum MdnSigningAlg: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case `none`
        case sha1
        case sha256
        case sha384
        case sha512
        case sdkUnknown(Swift.String)

        public static var allCases: [MdnSigningAlg] {
            return [
                .default,
                .none,
                .sha1,
                .sha256,
                .sha384,
                .sha512
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .none: return "NONE"
            case .sha1: return "SHA1"
            case .sha256: return "SHA256"
            case .sha384: return "SHA384"
            case .sha512: return "SHA512"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {

    public enum SigningAlg: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case sha1
        case sha256
        case sha384
        case sha512
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningAlg] {
            return [
                .none,
                .sha1,
                .sha256,
                .sha384,
                .sha512
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .sha1: return "SHA1"
            case .sha256: return "SHA256"
            case .sha384: return "SHA384"
            case .sha512: return "SHA512"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// Contains the details for an AS2 connector object. The connector object is used for AS2 outbound processes, to connect the Transfer Family customer with the trading partner.
    public struct As2ConnectorConfig {
        /// Provides Basic authentication support to the AS2 Connectors API. To use Basic authentication, you must provide the name or Amazon Resource Name (ARN) of a secret in Secrets Manager. The default value for this parameter is null, which indicates that Basic authentication is not enabled for the connector. If the connector should use Basic authentication, the secret needs to be in the following format: { "Username": "user-name", "Password": "user-password" } Replace user-name and user-password with the credentials for the actual user that is being authenticated. Note the following:
        ///
        /// * You are storing these credentials in Secrets Manager, not passing them directly into this API.
        ///
        /// * If you are using the API, SDKs, or CloudFormation to configure your connector, then you must create the secret before you can enable Basic authentication. However, if you are using the Amazon Web Services management console, you can have the system create the secret for you.
        ///
        ///
        /// If you have previously enabled Basic authentication for a connector, you can disable it by using the UpdateConnector API call. For example, if you are using the CLI, you can run the following command to remove Basic authentication: update-connector --connector-id my-connector-id --as2-config 'BasicAuthSecretId=""'
        public var basicAuthSecretId: Swift.String?
        /// Specifies whether the AS2 file is compressed.
        public var compression: TransferClientTypes.CompressionEnum?
        /// The algorithm that is used to encrypt the file. Note the following:
        ///
        /// * Do not use the DES_EDE3_CBC algorithm unless you must support a legacy client that requires it, as it is a weak encryption algorithm.
        ///
        /// * You can only specify NONE if the URL for your connector uses HTTPS. Using HTTPS ensures that no traffic is sent in clear text.
        public var encryptionAlgorithm: TransferClientTypes.EncryptionAlg?
        /// A unique identifier for the AS2 local profile.
        public var localProfileId: Swift.String?
        /// Used for outbound requests (from an Transfer Family server to a partner AS2 server) to determine whether the partner response for transfers is synchronous or asynchronous. Specify either of the following values:
        ///
        /// * SYNC: The system expects a synchronous MDN response, confirming that the file was transferred successfully (or not).
        ///
        /// * NONE: Specifies that no MDN response is required.
        public var mdnResponse: TransferClientTypes.MdnResponse?
        /// The signing algorithm for the MDN response. If set to DEFAULT (or not set at all), the value for SigningAlgorithm is used.
        public var mdnSigningAlgorithm: TransferClientTypes.MdnSigningAlg?
        /// Used as the Subject HTTP header attribute in AS2 messages that are being sent with the connector.
        public var messageSubject: Swift.String?
        /// A unique identifier for the partner profile for the connector.
        public var partnerProfileId: Swift.String?
        /// The algorithm that is used to sign the AS2 messages sent with the connector.
        public var signingAlgorithm: TransferClientTypes.SigningAlg?

        public init(
            basicAuthSecretId: Swift.String? = nil,
            compression: TransferClientTypes.CompressionEnum? = nil,
            encryptionAlgorithm: TransferClientTypes.EncryptionAlg? = nil,
            localProfileId: Swift.String? = nil,
            mdnResponse: TransferClientTypes.MdnResponse? = nil,
            mdnSigningAlgorithm: TransferClientTypes.MdnSigningAlg? = nil,
            messageSubject: Swift.String? = nil,
            partnerProfileId: Swift.String? = nil,
            signingAlgorithm: TransferClientTypes.SigningAlg? = nil
        )
        {
            self.basicAuthSecretId = basicAuthSecretId
            self.compression = compression
            self.encryptionAlgorithm = encryptionAlgorithm
            self.localProfileId = localProfileId
            self.mdnResponse = mdnResponse
            self.mdnSigningAlgorithm = mdnSigningAlgorithm
            self.messageSubject = messageSubject
            self.partnerProfileId = partnerProfileId
            self.signingAlgorithm = signingAlgorithm
        }
    }

}

extension TransferClientTypes {

    public enum As2Transport: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [As2Transport] {
            return [
                .http
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteCertificateInput {
    /// The identifier of the certificate object that you are deleting.
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

public struct DescribeCertificateInput {
    /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

extension TransferClientTypes {

    public enum CertificateStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case pendingRotation
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateStatusType] {
            return [
                .active,
                .inactive,
                .pendingRotation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .pendingRotation: return "PENDING_ROTATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {

    public enum CertificateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case certificate
        case certificateWithPrivateKey
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateType] {
            return [
                .certificate,
                .certificateWithPrivateKey
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .certificate: return "CERTIFICATE"
            case .certificateWithPrivateKey: return "CERTIFICATE_WITH_PRIVATE_KEY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {

    public enum CertificateUsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case encryption
        case signing
        case tls
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateUsageType] {
            return [
                .encryption,
                .signing,
                .tls
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .encryption: return "ENCRYPTION"
            case .signing: return "SIGNING"
            case .tls: return "TLS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// Describes the properties of a certificate.
    public struct DescribedCertificate {
        /// An optional date that specifies when the certificate becomes active.
        public var activeDate: Foundation.Date?
        /// The unique Amazon Resource Name (ARN) for the certificate.
        /// This member is required.
        public var arn: Swift.String?
        /// The file name for the certificate.
        public var certificate: Swift.String?
        /// The list of certificates that make up the chain for the certificate.
        public var certificateChain: Swift.String?
        /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
        public var certificateId: Swift.String?
        /// The name or description that's used to identity the certificate.
        public var description: Swift.String?
        /// An optional date that specifies when the certificate becomes inactive.
        public var inactiveDate: Foundation.Date?
        /// The final date that the certificate is valid.
        public var notAfterDate: Foundation.Date?
        /// The earliest date that the certificate is valid.
        public var notBeforeDate: Foundation.Date?
        /// The serial number for the certificate.
        public var serial: Swift.String?
        /// The certificate can be either ACTIVE, PENDING_ROTATION, or INACTIVE. PENDING_ROTATION means that this certificate will replace the current certificate when it expires.
        public var status: TransferClientTypes.CertificateStatusType?
        /// Key-value pairs that can be used to group and search for certificates.
        public var tags: [TransferClientTypes.Tag]?
        /// If a private key has been specified for the certificate, its type is CERTIFICATE_WITH_PRIVATE_KEY. If there is no private key, the type is CERTIFICATE.
        public var type: TransferClientTypes.CertificateType?
        /// Specifies how this certificate is used. It can be used in the following ways:
        ///
        /// * SIGNING: For signing AS2 messages
        ///
        /// * ENCRYPTION: For encrypting AS2 messages
        ///
        /// * TLS: For securing AS2 communications sent over HTTPS
        public var usage: TransferClientTypes.CertificateUsageType?

        public init(
            activeDate: Foundation.Date? = nil,
            arn: Swift.String? = nil,
            certificate: Swift.String? = nil,
            certificateChain: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            description: Swift.String? = nil,
            inactiveDate: Foundation.Date? = nil,
            notAfterDate: Foundation.Date? = nil,
            notBeforeDate: Foundation.Date? = nil,
            serial: Swift.String? = nil,
            status: TransferClientTypes.CertificateStatusType? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            type: TransferClientTypes.CertificateType? = nil,
            usage: TransferClientTypes.CertificateUsageType? = nil
        )
        {
            self.activeDate = activeDate
            self.arn = arn
            self.certificate = certificate
            self.certificateChain = certificateChain
            self.certificateId = certificateId
            self.description = description
            self.inactiveDate = inactiveDate
            self.notAfterDate = notAfterDate
            self.notBeforeDate = notBeforeDate
            self.serial = serial
            self.status = status
            self.tags = tags
            self.type = type
            self.usage = usage
        }
    }

}

extension TransferClientTypes.DescribedCertificate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribedCertificate(activeDate: \(Swift.String(describing: activeDate)), arn: \(Swift.String(describing: arn)), certificateId: \(Swift.String(describing: certificateId)), description: \(Swift.String(describing: description)), inactiveDate: \(Swift.String(describing: inactiveDate)), notAfterDate: \(Swift.String(describing: notAfterDate)), notBeforeDate: \(Swift.String(describing: notBeforeDate)), serial: \(Swift.String(describing: serial)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), usage: \(Swift.String(describing: usage)), certificate: \"CONTENT_REDACTED\", certificateChain: \"CONTENT_REDACTED\")"}
}

public struct DescribeCertificateOutput {
    /// The details for the specified certificate, returned as an object.
    /// This member is required.
    public var certificate: TransferClientTypes.DescribedCertificate?

    public init(
        certificate: TransferClientTypes.DescribedCertificate? = nil
    )
    {
        self.certificate = certificate
    }
}

public struct ImportCertificateInput {
    /// An optional date that specifies when the certificate becomes active.
    public var activeDate: Foundation.Date?
    /// * For the CLI, provide a file path for a certificate in URI format. For example, --certificate file://encryption-cert.pem. Alternatively, you can provide the raw content.
    ///
    /// * For the SDK, specify the raw content of a certificate file. For example, --certificate "`cat encryption-cert.pem`".
    /// This member is required.
    public var certificate: Swift.String?
    /// An optional list of certificates that make up the chain for the certificate that's being imported.
    public var certificateChain: Swift.String?
    /// A short description that helps identify the certificate.
    public var description: Swift.String?
    /// An optional date that specifies when the certificate becomes inactive.
    public var inactiveDate: Foundation.Date?
    /// * For the CLI, provide a file path for a private key in URI format.For example, --private-key file://encryption-key.pem. Alternatively, you can provide the raw content of the private key file.
    ///
    /// * For the SDK, specify the raw content of a private key file. For example, --private-key "`cat encryption-key.pem`"
    public var privateKey: Swift.String?
    /// Key-value pairs that can be used to group and search for certificates.
    public var tags: [TransferClientTypes.Tag]?
    /// Specifies how this certificate is used. It can be used in the following ways:
    ///
    /// * SIGNING: For signing AS2 messages
    ///
    /// * ENCRYPTION: For encrypting AS2 messages
    ///
    /// * TLS: For securing AS2 communications sent over HTTPS
    /// This member is required.
    public var usage: TransferClientTypes.CertificateUsageType?

    public init(
        activeDate: Foundation.Date? = nil,
        certificate: Swift.String? = nil,
        certificateChain: Swift.String? = nil,
        description: Swift.String? = nil,
        inactiveDate: Foundation.Date? = nil,
        privateKey: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        usage: TransferClientTypes.CertificateUsageType? = nil
    )
    {
        self.activeDate = activeDate
        self.certificate = certificate
        self.certificateChain = certificateChain
        self.description = description
        self.inactiveDate = inactiveDate
        self.privateKey = privateKey
        self.tags = tags
        self.usage = usage
    }
}

extension ImportCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportCertificateInput(activeDate: \(Swift.String(describing: activeDate)), description: \(Swift.String(describing: description)), inactiveDate: \(Swift.String(describing: inactiveDate)), tags: \(Swift.String(describing: tags)), usage: \(Swift.String(describing: usage)), certificate: \"CONTENT_REDACTED\", certificateChain: \"CONTENT_REDACTED\", privateKey: \"CONTENT_REDACTED\")"}
}

public struct ImportCertificateOutput {
    /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

public struct ListCertificatesInput {
    /// The maximum number of certificates to return.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListCertificates call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional certificates.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension TransferClientTypes {
    /// Describes the properties of a certificate.
    public struct ListedCertificate {
        /// An optional date that specifies when the certificate becomes active.
        public var activeDate: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the specified certificate.
        public var arn: Swift.String?
        /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
        public var certificateId: Swift.String?
        /// The name or short description that's used to identify the certificate.
        public var description: Swift.String?
        /// An optional date that specifies when the certificate becomes inactive.
        public var inactiveDate: Foundation.Date?
        /// The certificate can be either ACTIVE, PENDING_ROTATION, or INACTIVE. PENDING_ROTATION means that this certificate will replace the current certificate when it expires.
        public var status: TransferClientTypes.CertificateStatusType?
        /// The type for the certificate. If a private key has been specified for the certificate, its type is CERTIFICATE_WITH_PRIVATE_KEY. If there is no private key, the type is CERTIFICATE.
        public var type: TransferClientTypes.CertificateType?
        /// Specifies how this certificate is used. It can be used in the following ways:
        ///
        /// * SIGNING: For signing AS2 messages
        ///
        /// * ENCRYPTION: For encrypting AS2 messages
        ///
        /// * TLS: For securing AS2 communications sent over HTTPS
        public var usage: TransferClientTypes.CertificateUsageType?

        public init(
            activeDate: Foundation.Date? = nil,
            arn: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            description: Swift.String? = nil,
            inactiveDate: Foundation.Date? = nil,
            status: TransferClientTypes.CertificateStatusType? = nil,
            type: TransferClientTypes.CertificateType? = nil,
            usage: TransferClientTypes.CertificateUsageType? = nil
        )
        {
            self.activeDate = activeDate
            self.arn = arn
            self.certificateId = certificateId
            self.description = description
            self.inactiveDate = inactiveDate
            self.status = status
            self.type = type
            self.usage = usage
        }
    }

}

public struct ListCertificatesOutput {
    /// Returns an array of the certificates that are specified in the ListCertificates call.
    /// This member is required.
    public var certificates: [TransferClientTypes.ListedCertificate]?
    /// Returns the next token, which you can use to list the next certificate.
    public var nextToken: Swift.String?

    public init(
        certificates: [TransferClientTypes.ListedCertificate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.nextToken = nextToken
    }
}

public struct UpdateCertificateInput {
    /// An optional date that specifies when the certificate becomes active.
    public var activeDate: Foundation.Date?
    /// The identifier of the certificate object that you are updating.
    /// This member is required.
    public var certificateId: Swift.String?
    /// A short description to help identify the certificate.
    public var description: Swift.String?
    /// An optional date that specifies when the certificate becomes inactive.
    public var inactiveDate: Foundation.Date?

    public init(
        activeDate: Foundation.Date? = nil,
        certificateId: Swift.String? = nil,
        description: Swift.String? = nil,
        inactiveDate: Foundation.Date? = nil
    )
    {
        self.activeDate = activeDate
        self.certificateId = certificateId
        self.description = description
        self.inactiveDate = inactiveDate
    }
}

public struct UpdateCertificateOutput {
    /// Returns the identifier of the certificate object that you are updating.
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

/// This exception is thrown when the UpdateServer is called for a file transfer protocol-enabled server that has VPC as the endpoint type and the server's VpcEndpointID is not in the available state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TransferClientTypes {
    /// Contains the details for an SFTP connector object. The connector object is used for transferring files to and from a partner's SFTP server. Because the SftpConnectorConfig data type is used for both creating and updating SFTP connectors, its parameters, TrustedHostKeys and UserSecretId are marked as not required. This is a bit misleading, as they are not required when you are updating an existing SFTP connector, but are required when you are creating a new SFTP connector.
    public struct SftpConnectorConfig {
        /// The public portion of the host key, or keys, that are used to identify the external server to which you are connecting. You can use the ssh-keyscan command against the SFTP server to retrieve the necessary key. The three standard SSH public key format elements are <key type>, <body base64>, and an optional <comment>, with spaces between each element. Specify only the <key type> and <body base64>: do not enter the <comment> portion of the key. For the trusted host key, Transfer Family accepts RSA and ECDSA keys.
        ///
        /// * For RSA keys, the <key type> string is ssh-rsa.
        ///
        /// * For ECDSA keys, the <key type> string is either ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, or ecdsa-sha2-nistp521, depending on the size of the key you generated.
        ///
        ///
        /// Run this command to retrieve the SFTP server host key, where your SFTP server name is ftp.host.com. ssh-keyscan ftp.host.com This prints the public host key to standard output. ftp.host.com ssh-rsa AAAAB3Nza...<long-string-for-public-key Copy and paste this string into the TrustedHostKeys field for the create-connector command or into the Trusted host keys field in the console.
        public var trustedHostKeys: [Swift.String]?
        /// The identifier for the secret (in Amazon Web Services Secrets Manager) that contains the SFTP user's private key, password, or both. The identifier must be the Amazon Resource Name (ARN) of the secret.
        public var userSecretId: Swift.String?

        public init(
            trustedHostKeys: [Swift.String]? = nil,
            userSecretId: Swift.String? = nil
        )
        {
            self.trustedHostKeys = trustedHostKeys
            self.userSecretId = userSecretId
        }
    }

}

public struct CreateConnectorInput {
    /// Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use. For AS2 connectors With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the file’s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer. If you are using Basic authentication for your AS2 connector, the access role requires the secretsmanager:GetSecretValue permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the kms:Decrypt permission for that key. For SFTP connectors Make sure that the access role provides read and write access to the parent directory of the file location that's used in the StartFileTransfer request. Additionally, make sure that the role provides secretsmanager:GetSecretValue permission to Secrets Manager.
    /// This member is required.
    public var accessRole: Swift.String?
    /// A structure that contains the parameters for an AS2 connector object.
    public var as2Config: TransferClientTypes.As2ConnectorConfig?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a connector to turn on CloudWatch logging for Amazon S3 events. When set, you can view connector activity in your CloudWatch logs.
    public var loggingRole: Swift.String?
    /// Specifies the name of the security policy for the connector.
    public var securityPolicyName: Swift.String?
    /// A structure that contains the parameters for an SFTP connector object.
    public var sftpConfig: TransferClientTypes.SftpConnectorConfig?
    /// Key-value pairs that can be used to group and search for connectors. Tags are metadata attached to connectors for any purpose.
    public var tags: [TransferClientTypes.Tag]?
    /// The URL of the partner's AS2 or SFTP endpoint.
    /// This member is required.
    public var url: Swift.String?

    public init(
        accessRole: Swift.String? = nil,
        as2Config: TransferClientTypes.As2ConnectorConfig? = nil,
        loggingRole: Swift.String? = nil,
        securityPolicyName: Swift.String? = nil,
        sftpConfig: TransferClientTypes.SftpConnectorConfig? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        url: Swift.String? = nil
    )
    {
        self.accessRole = accessRole
        self.as2Config = as2Config
        self.loggingRole = loggingRole
        self.securityPolicyName = securityPolicyName
        self.sftpConfig = sftpConfig
        self.tags = tags
        self.url = url
    }
}

public struct CreateConnectorOutput {
    /// The unique identifier for the connector, returned after the API call succeeds.
    /// This member is required.
    public var connectorId: Swift.String?

    public init(
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

public struct DeleteConnectorInput {
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?

    public init(
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

public struct DescribeConnectorInput {
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?

    public init(
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

extension TransferClientTypes {
    /// Describes the parameters for the connector, as identified by the ConnectorId.
    public struct DescribedConnector {
        /// Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use. For AS2 connectors With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the file’s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer. If you are using Basic authentication for your AS2 connector, the access role requires the secretsmanager:GetSecretValue permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the kms:Decrypt permission for that key. For SFTP connectors Make sure that the access role provides read and write access to the parent directory of the file location that's used in the StartFileTransfer request. Additionally, make sure that the role provides secretsmanager:GetSecretValue permission to Secrets Manager.
        public var accessRole: Swift.String?
        /// The unique Amazon Resource Name (ARN) for the connector.
        /// This member is required.
        public var arn: Swift.String?
        /// A structure that contains the parameters for an AS2 connector object.
        public var as2Config: TransferClientTypes.As2ConnectorConfig?
        /// The unique identifier for the connector.
        public var connectorId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a connector to turn on CloudWatch logging for Amazon S3 events. When set, you can view connector activity in your CloudWatch logs.
        public var loggingRole: Swift.String?
        /// The text name of the security policy for the specified connector.
        public var securityPolicyName: Swift.String?
        /// The list of egress IP addresses of this connector. These IP addresses are assigned automatically when you create the connector.
        public var serviceManagedEgressIpAddresses: [Swift.String]?
        /// A structure that contains the parameters for an SFTP connector object.
        public var sftpConfig: TransferClientTypes.SftpConnectorConfig?
        /// Key-value pairs that can be used to group and search for connectors.
        public var tags: [TransferClientTypes.Tag]?
        /// The URL of the partner's AS2 or SFTP endpoint.
        public var url: Swift.String?

        public init(
            accessRole: Swift.String? = nil,
            arn: Swift.String? = nil,
            as2Config: TransferClientTypes.As2ConnectorConfig? = nil,
            connectorId: Swift.String? = nil,
            loggingRole: Swift.String? = nil,
            securityPolicyName: Swift.String? = nil,
            serviceManagedEgressIpAddresses: [Swift.String]? = nil,
            sftpConfig: TransferClientTypes.SftpConnectorConfig? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            url: Swift.String? = nil
        )
        {
            self.accessRole = accessRole
            self.arn = arn
            self.as2Config = as2Config
            self.connectorId = connectorId
            self.loggingRole = loggingRole
            self.securityPolicyName = securityPolicyName
            self.serviceManagedEgressIpAddresses = serviceManagedEgressIpAddresses
            self.sftpConfig = sftpConfig
            self.tags = tags
            self.url = url
        }
    }

}

public struct DescribeConnectorOutput {
    /// The structure that contains the details of the connector.
    /// This member is required.
    public var connector: TransferClientTypes.DescribedConnector?

    public init(
        connector: TransferClientTypes.DescribedConnector? = nil
    )
    {
        self.connector = connector
    }
}

public struct ListConnectorsInput {
    /// The maximum number of connectors to return.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListConnectors call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional connectors.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension TransferClientTypes {
    /// Returns details of the connector that is specified.
    public struct ListedConnector {
        /// The Amazon Resource Name (ARN) of the specified connector.
        public var arn: Swift.String?
        /// The unique identifier for the connector.
        public var connectorId: Swift.String?
        /// The URL of the partner's AS2 or SFTP endpoint.
        public var url: Swift.String?

        public init(
            arn: Swift.String? = nil,
            connectorId: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.arn = arn
            self.connectorId = connectorId
            self.url = url
        }
    }

}

public struct ListConnectorsOutput {
    /// Returns an array, where each item contains the details of a connector.
    /// This member is required.
    public var connectors: [TransferClientTypes.ListedConnector]?
    /// Returns a token that you can use to call ListConnectors again and receive additional results, if there are any.
    public var nextToken: Swift.String?

    public init(
        connectors: [TransferClientTypes.ListedConnector]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectors = connectors
        self.nextToken = nextToken
    }
}

public struct UpdateConnectorInput {
    /// Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use. For AS2 connectors With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the file’s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer. If you are using Basic authentication for your AS2 connector, the access role requires the secretsmanager:GetSecretValue permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the kms:Decrypt permission for that key. For SFTP connectors Make sure that the access role provides read and write access to the parent directory of the file location that's used in the StartFileTransfer request. Additionally, make sure that the role provides secretsmanager:GetSecretValue permission to Secrets Manager.
    public var accessRole: Swift.String?
    /// A structure that contains the parameters for an AS2 connector object.
    public var as2Config: TransferClientTypes.As2ConnectorConfig?
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a connector to turn on CloudWatch logging for Amazon S3 events. When set, you can view connector activity in your CloudWatch logs.
    public var loggingRole: Swift.String?
    /// Specifies the name of the security policy for the connector.
    public var securityPolicyName: Swift.String?
    /// A structure that contains the parameters for an SFTP connector object.
    public var sftpConfig: TransferClientTypes.SftpConnectorConfig?
    /// The URL of the partner's AS2 or SFTP endpoint.
    public var url: Swift.String?

    public init(
        accessRole: Swift.String? = nil,
        as2Config: TransferClientTypes.As2ConnectorConfig? = nil,
        connectorId: Swift.String? = nil,
        loggingRole: Swift.String? = nil,
        securityPolicyName: Swift.String? = nil,
        sftpConfig: TransferClientTypes.SftpConnectorConfig? = nil,
        url: Swift.String? = nil
    )
    {
        self.accessRole = accessRole
        self.as2Config = as2Config
        self.connectorId = connectorId
        self.loggingRole = loggingRole
        self.securityPolicyName = securityPolicyName
        self.sftpConfig = sftpConfig
        self.url = url
    }
}

public struct UpdateConnectorOutput {
    /// Returns the identifier of the connector object that you are updating.
    /// This member is required.
    public var connectorId: Swift.String?

    public init(
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

extension TransferClientTypes {
    /// Specifies the details for the file location for the file that's being used in the workflow. Only applicable if you are using Amazon Elastic File Systems (Amazon EFS) for storage.
    public struct EfsFileLocation {
        /// The identifier of the file system, assigned by Amazon EFS.
        public var fileSystemId: Swift.String?
        /// The pathname for the folder being used by a workflow.
        public var path: Swift.String?

        public init(
            fileSystemId: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.fileSystemId = fileSystemId
            self.path = path
        }
    }

}

extension TransferClientTypes {
    /// Specifies the customer input Amazon S3 file location. If it is used inside copyStepDetails.DestinationFileLocation, it should be the S3 copy destination. You need to provide the bucket and key. The key can represent either a path or a file. This is determined by whether or not you end the key value with the forward slash (/) character. If the final character is "/", then your file is copied to the folder, and its name does not change. If, rather, the final character is alphanumeric, your uploaded file is renamed to the path value. In this case, if a file with that name already exists, it is overwritten. For example, if your path is shared-files/bob/, your uploaded files are copied to the shared-files/bob/, folder. If your path is shared-files/today, each uploaded file is copied to the shared-files folder and named today: each upload overwrites the previous version of the bob file.
    public struct S3InputFileLocation {
        /// Specifies the S3 bucket for the customer input file.
        public var bucket: Swift.String?
        /// The name assigned to the file when it was created in Amazon S3. You use the object key to retrieve the object.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension TransferClientTypes {
    /// Specifies the location for the file that's being processed.
    public struct InputFileLocation {
        /// Specifies the details for the Amazon Elastic File System (Amazon EFS) file that's being decrypted.
        public var efsFileLocation: TransferClientTypes.EfsFileLocation?
        /// Specifies the details for the Amazon S3 file that's being copied or decrypted.
        public var s3FileLocation: TransferClientTypes.S3InputFileLocation?

        public init(
            efsFileLocation: TransferClientTypes.EfsFileLocation? = nil,
            s3FileLocation: TransferClientTypes.S3InputFileLocation? = nil
        )
        {
            self.efsFileLocation = efsFileLocation
            self.s3FileLocation = s3FileLocation
        }
    }

}

extension TransferClientTypes {

    public enum OverwriteExisting: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [OverwriteExisting] {
            return [
                .false,
                .true
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure.
    public struct CopyStepDetails {
        /// Specifies the location for the file being copied. Use ${Transfer:UserName} or ${Transfer:UploadDate} in this field to parametrize the destination prefix by username or uploaded date.
        ///
        /// * Set the value of DestinationFileLocation to ${Transfer:UserName} to copy uploaded files to an Amazon S3 bucket that is prefixed with the name of the Transfer Family user that uploaded the file.
        ///
        /// * Set the value of DestinationFileLocation to ${Transfer:UploadDate} to copy uploaded files to an Amazon S3 bucket that is prefixed with the date of the upload. The system resolves UploadDate to a date format of YYYY-MM-DD, based on the date the file is uploaded in UTC.
        public var destinationFileLocation: TransferClientTypes.InputFileLocation?
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// A flag that indicates whether to overwrite an existing file of the same name. The default is FALSE. If the workflow is processing a file that has the same name as an existing file, the behavior is as follows:
        ///
        /// * If OverwriteExisting is TRUE, the existing file is replaced with the file being processed.
        ///
        /// * If OverwriteExisting is FALSE, nothing happens, and the workflow processing stops.
        public var overwriteExisting: TransferClientTypes.OverwriteExisting?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?

        public init(
            destinationFileLocation: TransferClientTypes.InputFileLocation? = nil,
            name: Swift.String? = nil,
            overwriteExisting: TransferClientTypes.OverwriteExisting? = nil,
            sourceFileLocation: Swift.String? = nil
        )
        {
            self.destinationFileLocation = destinationFileLocation
            self.name = name
            self.overwriteExisting = overwriteExisting
            self.sourceFileLocation = sourceFileLocation
        }
    }

}

extension TransferClientTypes {

    public enum MapType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case directory
        case file
        case sdkUnknown(Swift.String)

        public static var allCases: [MapType] {
            return [
                .directory,
                .file
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .directory: return "DIRECTORY"
            case .file: return "FILE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// Represents an object that contains entries and targets for HomeDirectoryMappings. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public struct HomeDirectoryMapEntry {
        /// Represents an entry for HomeDirectoryMappings.
        /// This member is required.
        public var entry: Swift.String?
        /// Represents the map target that is used in a HomeDirectoryMapEntry.
        /// This member is required.
        public var target: Swift.String?
        /// Specifies the type of mapping. Set the type to FILE if you want the mapping to point to a file, or DIRECTORY for the directory to point to a directory. By default, home directory mappings have a Type of DIRECTORY when you create a Transfer Family server. You would need to explicitly set Type to FILE if you want a mapping to have a file target.
        public var type: TransferClientTypes.MapType?

        public init(
            entry: Swift.String? = nil,
            target: Swift.String? = nil,
            type: TransferClientTypes.MapType? = nil
        )
        {
            self.entry = entry
            self.target = target
            self.type = type
        }
    }

}

extension TransferClientTypes {

    public enum HomeDirectoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case logical
        case path
        case sdkUnknown(Swift.String)

        public static var allCases: [HomeDirectoryType] {
            return [
                .logical,
                .path
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .logical: return "LOGICAL"
            case .path: return "PATH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public struct PosixProfile {
        /// The POSIX group ID used for all EFS operations by this user.
        /// This member is required.
        public var gid: Swift.Int?
        /// The secondary POSIX group IDs used for all EFS operations by this user.
        public var secondaryGids: [Swift.Int]?
        /// The POSIX user ID used for all EFS operations by this user.
        /// This member is required.
        public var uid: Swift.Int?

        public init(
            gid: Swift.Int? = nil,
            secondaryGids: [Swift.Int]? = nil,
            uid: Swift.Int? = nil
        )
        {
            self.gid = gid
            self.secondaryGids = secondaryGids
            self.uid = uid
        }
    }

}

public struct CreateAccessInput {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock down your user to the designated home directory ("chroot"). To do this, you can set Entry to / and set Target to the HomeDirectory parameter value. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use session policies. For session policies, Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Example session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Security Token Service API Reference.
    public var policy: Swift.String?
    /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    /// This member is required.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        externalId: Swift.String? = nil,
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
    }
}

public struct CreateAccessOutput {
    /// The external identifier of the group whose users have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family.
    /// This member is required.
    public var externalId: Swift.String?
    /// The identifier of the server that the user is attached to.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

extension TransferClientTypes {

    public enum ProfileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case local
        case partner
        case sdkUnknown(Swift.String)

        public static var allCases: [ProfileType] {
            return [
                .local,
                .partner
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .local: return "LOCAL"
            case .partner: return "PARTNER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProfileInput {
    /// The As2Id is the AS2-name, as defined in the [RFC 4130](https://datatracker.ietf.org/doc/html/rfc4130). For inbound transfers, this is the AS2-From header for the AS2 messages sent from the partner. For outbound connectors, this is the AS2-To header for the AS2 messages sent to the partner using the StartFileTransfer API operation. This ID cannot include spaces.
    /// This member is required.
    public var as2Id: Swift.String?
    /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
    public var certificateIds: [Swift.String]?
    /// Determines the type of profile to create:
    ///
    /// * Specify LOCAL to create a local profile. A local profile represents the AS2-enabled Transfer Family server organization or party.
    ///
    /// * Specify PARTNER to create a partner profile. A partner profile represents a remote organization, external to Transfer Family.
    /// This member is required.
    public var profileType: TransferClientTypes.ProfileType?
    /// Key-value pairs that can be used to group and search for AS2 profiles.
    public var tags: [TransferClientTypes.Tag]?

    public init(
        as2Id: Swift.String? = nil,
        certificateIds: [Swift.String]? = nil,
        profileType: TransferClientTypes.ProfileType? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.as2Id = as2Id
        self.certificateIds = certificateIds
        self.profileType = profileType
        self.tags = tags
    }
}

public struct CreateProfileOutput {
    /// The unique identifier for the AS2 profile, returned after the API call succeeds.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

extension TransferClientTypes {

    public enum Domain: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case efs
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [Domain] {
            return [
                .efs,
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .efs: return "EFS"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// The virtual private cloud (VPC) endpoint settings that are configured for your file transfer protocol-enabled server. With a VPC endpoint, you can restrict access to your server and resources only within your VPC. To control incoming internet traffic, invoke the UpdateServer API and attach an Elastic IP address to your server's endpoint. After May 19, 2021, you won't be able to create a server using EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount if your account hasn't already done so before May 19, 2021. If you have already created servers with EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount on or before May 19, 2021, you will not be affected. After this date, use EndpointType=VPC. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.
    public struct EndpointDetails {
        /// A list of address allocation IDs that are required to attach an Elastic IP address to your server's endpoint. An address allocation ID corresponds to the allocation ID of an Elastic IP address. This value can be retrieved from the allocationId field from the Amazon EC2 [Address](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Address.html) data type. One way to retrieve this value is by calling the EC2 [DescribeAddresses](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAddresses.html) API. This parameter is optional. Set this parameter if you want to make your VPC endpoint public-facing. For details, see [Create an internet-facing endpoint for your server](https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#create-internet-facing-endpoint). This property can only be set as follows:
        ///
        /// * EndpointType must be set to VPC
        ///
        /// * The Transfer Family server must be offline.
        ///
        /// * You cannot set this parameter for Transfer Family servers that use the FTP protocol.
        ///
        /// * The server must already have SubnetIds populated (SubnetIds and AddressAllocationIds cannot be updated simultaneously).
        ///
        /// * AddressAllocationIds can't contain duplicates, and must be equal in length to SubnetIds. For example, if you have three subnet IDs, you must also specify three address allocation IDs.
        ///
        /// * Call the UpdateServer API to set or change this parameter.
        public var addressAllocationIds: [Swift.String]?
        /// A list of security groups IDs that are available to attach to your server's endpoint. This property can only be set when EndpointType is set to VPC. You can edit the SecurityGroupIds property in the [UpdateServer](https://docs.aws.amazon.com/transfer/latest/userguide/API_UpdateServer.html) API only if you are changing the EndpointType from PUBLIC or VPC_ENDPOINT to VPC. To change security groups associated with your server's VPC endpoint after creation, use the Amazon EC2 [ModifyVpcEndpoint](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyVpcEndpoint.html) API.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs that are required to host your server endpoint in your VPC. This property can only be set when EndpointType is set to VPC.
        public var subnetIds: [Swift.String]?
        /// The identifier of the VPC endpoint. This property can only be set when EndpointType is set to VPC_ENDPOINT. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.
        public var vpcEndpointId: Swift.String?
        /// The VPC identifier of the VPC in which a server's endpoint will be hosted. This property can only be set when EndpointType is set to VPC.
        public var vpcId: Swift.String?

        public init(
            addressAllocationIds: [Swift.String]? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.addressAllocationIds = addressAllocationIds
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }

}

extension TransferClientTypes {

    public enum EndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `public`
        case vpc
        case vpcEndpoint
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .public,
                .vpc,
                .vpcEndpoint
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .public: return "PUBLIC"
            case .vpc: return "VPC"
            case .vpcEndpoint: return "VPC_ENDPOINT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {

    public enum SftpAuthenticationMethods: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case password
        case publicKey
        case publicKeyAndPassword
        case publicKeyOrPassword
        case sdkUnknown(Swift.String)

        public static var allCases: [SftpAuthenticationMethods] {
            return [
                .password,
                .publicKey,
                .publicKeyAndPassword,
                .publicKeyOrPassword
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .password: return "PASSWORD"
            case .publicKey: return "PUBLIC_KEY"
            case .publicKeyAndPassword: return "PUBLIC_KEY_AND_PASSWORD"
            case .publicKeyOrPassword: return "PUBLIC_KEY_OR_PASSWORD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. A server can have only one method of authentication.
    public struct IdentityProviderDetails {
        /// The identifier of the Directory Service directory that you want to use as your identity provider.
        public var directoryId: Swift.String?
        /// The ARN for a Lambda function to use for the Identity provider.
        public var function: Swift.String?
        /// This parameter is only applicable if your IdentityProviderType is API_GATEWAY. Provides the type of InvocationRole used to authenticate the user account.
        public var invocationRole: Swift.String?
        /// For SFTP-enabled servers, and for custom identity providers only, you can specify whether to authenticate using a password, SSH key pair, or both.
        ///
        /// * PASSWORD - users must provide their password to connect.
        ///
        /// * PUBLIC_KEY - users must provide their private key to connect.
        ///
        /// * PUBLIC_KEY_OR_PASSWORD - users can authenticate with either their password or their key. This is the default value.
        ///
        /// * PUBLIC_KEY_AND_PASSWORD - users must provide both their private key and their password to connect. The server checks the key first, and then if the key is valid, the system prompts for a password. If the private key provided does not match the public key that is stored, authentication fails.
        public var sftpAuthenticationMethods: TransferClientTypes.SftpAuthenticationMethods?
        /// Provides the location of the service endpoint used to authenticate users.
        public var url: Swift.String?

        public init(
            directoryId: Swift.String? = nil,
            function: Swift.String? = nil,
            invocationRole: Swift.String? = nil,
            sftpAuthenticationMethods: TransferClientTypes.SftpAuthenticationMethods? = nil,
            url: Swift.String? = nil
        )
        {
            self.directoryId = directoryId
            self.function = function
            self.invocationRole = invocationRole
            self.sftpAuthenticationMethods = sftpAuthenticationMethods
            self.url = url
        }
    }

}

extension TransferClientTypes {

    /// The mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Transfer Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the IdentityProviderDetails parameter. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the IdentityProviderDetails parameter. Use the AWS_LAMBDA value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the Function parameter for the IdentityProviderDetails data type.
    public enum IdentityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case apiGateway
        case awsDirectoryService
        case awsLambda
        case serviceManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityProviderType] {
            return [
                .apiGateway,
                .awsDirectoryService,
                .awsLambda,
                .serviceManaged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .apiGateway: return "API_GATEWAY"
            case .awsDirectoryService: return "AWS_DIRECTORY_SERVICE"
            case .awsLambda: return "AWS_LAMBDA"
            case .serviceManaged: return "SERVICE_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {

    public enum SetStatOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case enableNoOp
        case sdkUnknown(Swift.String)

        public static var allCases: [SetStatOption] {
            return [
                .default,
                .enableNoOp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .enableNoOp: return "ENABLE_NO_OP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {

    public enum TlsSessionResumptionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case enforced
        case sdkUnknown(Swift.String)

        public static var allCases: [TlsSessionResumptionMode] {
            return [
                .disabled,
                .enabled,
                .enforced
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .enforced: return "ENFORCED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// The protocol settings that are configured for your server.
    public struct ProtocolDetails {
        /// Indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
        public var as2Transports: [TransferClientTypes.As2Transport]?
        /// Indicates passive mode, for FTP and FTPS protocols. Enter a single IPv4 address, such as the public IP address of a firewall, router, or load balancer. For example: aws transfer update-server --protocol-details PassiveIp=0.0.0.0 Replace 0.0.0.0 in the example above with the actual IP address you want to use. If you change the PassiveIp value, you must stop and then restart your Transfer Family server for the change to take effect. For details on using passive mode (PASV) in a NAT environment, see [Configuring your FTPS server behind a firewall or NAT with Transfer Family](http://aws.amazon.com/blogs/storage/configuring-your-ftps-server-behind-a-firewall-or-nat-with-aws-transfer-family/). Special values The AUTO and 0.0.0.0 are special values for the PassiveIp parameter. The value PassiveIp=AUTO is assigned by default to FTP and FTPS type servers. In this case, the server automatically responds with one of the endpoint IPs within the PASV response. PassiveIp=0.0.0.0 has a more unique application for its usage. For example, if you have a High Availability (HA) Network Load Balancer (NLB) environment, where you have 3 subnets, you can only specify a single IP address using the PassiveIp parameter. This reduces the effectiveness of having High Availability. In this case, you can specify PassiveIp=0.0.0.0. This tells the client to use the same IP address as the Control connection and utilize all AZs for their connections. Note, however, that not all FTP clients support the PassiveIp=0.0.0.0 response. FileZilla and WinSCP do support it. If you are using other clients, check to see if your client supports the PassiveIp=0.0.0.0 response.
        public var passiveIp: Swift.String?
        /// Use the SetStatOption to ignore the error that is generated when the client attempts to use SETSTAT on a file you are uploading to an S3 bucket. Some SFTP file transfer clients can attempt to change the attributes of remote files, including timestamp and permissions, using commands, such as SETSTAT when uploading the file. However, these commands are not compatible with object storage systems, such as Amazon S3. Due to this incompatibility, file uploads from these clients can result in errors even when the file is otherwise successfully uploaded. Set the value to ENABLE_NO_OP to have the Transfer Family server ignore the SETSTAT command, and upload files without needing to make any changes to your SFTP client. While the SetStatOptionENABLE_NO_OP setting ignores the error, it does generate a log entry in Amazon CloudWatch Logs, so you can determine when the client is making a SETSTAT call. If you want to preserve the original timestamp for your file, and modify other file attributes using SETSTAT, you can use Amazon EFS as backend storage with Transfer Family.
        public var setStatOption: TransferClientTypes.SetStatOption?
        /// A property used with Transfer Family servers that use the FTPS protocol. TLS Session Resumption provides a mechanism to resume or share a negotiated secret key between the control and data connection for an FTPS session. TlsSessionResumptionMode determines whether or not the server resumes recent, negotiated sessions through a unique session ID. This property is available during CreateServer and UpdateServer calls. If a TlsSessionResumptionMode value is not specified during CreateServer, it is set to ENFORCED by default.
        ///
        /// * DISABLED: the server does not process TLS session resumption client requests and creates a new TLS session for each request.
        ///
        /// * ENABLED: the server processes and accepts clients that are performing TLS session resumption. The server doesn't reject client data connections that do not perform the TLS session resumption client processing.
        ///
        /// * ENFORCED: the server processes and accepts clients that are performing TLS session resumption. The server rejects client data connections that do not perform the TLS session resumption client processing. Before you set the value to ENFORCED, test your clients. Not all FTPS clients perform TLS session resumption. So, if you choose to enforce TLS session resumption, you prevent any connections from FTPS clients that don't perform the protocol negotiation. To determine whether or not you can use the ENFORCED value, you need to test your clients.
        public var tlsSessionResumptionMode: TransferClientTypes.TlsSessionResumptionMode?

        public init(
            as2Transports: [TransferClientTypes.As2Transport]? = nil,
            passiveIp: Swift.String? = nil,
            setStatOption: TransferClientTypes.SetStatOption? = nil,
            tlsSessionResumptionMode: TransferClientTypes.TlsSessionResumptionMode? = nil
        )
        {
            self.as2Transports = as2Transports
            self.passiveIp = passiveIp
            self.setStatOption = setStatOption
            self.tlsSessionResumptionMode = tlsSessionResumptionMode
        }
    }

}

extension TransferClientTypes {

    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case as2
        case ftp
        case ftps
        case sftp
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .as2,
                .ftp,
                .ftps,
                .sftp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .as2: return "AS2"
            case .ftp: return "FTP"
            case .ftps: return "FTPS"
            case .sftp: return "SFTP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {

    /// Indicates whether optimization to directory listing on S3 servers is used. Disabled by default for compatibility.
    public enum DirectoryListingOptimization: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectoryListingOptimization] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// The Amazon S3 storage options that are configured for your server.
    public struct S3StorageOptions {
        /// Specifies whether or not performance for your Amazon S3 directories is optimized. This is disabled by default. By default, home directory mappings have a TYPE of DIRECTORY. If you enable this option, you would then need to explicitly set the HomeDirectoryMapEntryType to FILE if you want a mapping to have a file target.
        public var directoryListingOptimization: TransferClientTypes.DirectoryListingOptimization?

        public init(
            directoryListingOptimization: TransferClientTypes.DirectoryListingOptimization? = nil
        )
        {
            self.directoryListingOptimization = directoryListingOptimization
        }
    }

}

extension TransferClientTypes {
    /// Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow. In addition to a workflow to execute when a file is uploaded completely, WorkflowDetails can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when the server session disconnects while the file is still being uploaded.
    public struct WorkflowDetail {
        /// Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources
        /// This member is required.
        public var executionRole: Swift.String?
        /// A unique identifier for the workflow.
        /// This member is required.
        public var workflowId: Swift.String?

        public init(
            executionRole: Swift.String? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.executionRole = executionRole
            self.workflowId = workflowId
        }
    }

}

extension TransferClientTypes {
    /// Container for the WorkflowDetail data type. It is used by actions that trigger a workflow to begin execution.
    public struct WorkflowDetails {
        /// A trigger that starts a workflow if a file is only partially uploaded. You can attach a workflow to a server that executes whenever there is a partial upload. A partial upload occurs when a file is open when the session disconnects.
        public var onPartialUpload: [TransferClientTypes.WorkflowDetail]?
        /// A trigger that starts a workflow: the workflow begins to execute after a file is uploaded. To remove an associated workflow from a server, you can provide an empty OnUpload object, as in the following example. aws transfer update-server --server-id s-01234567890abcdef --workflow-details '{"OnUpload":[]}'
        public var onUpload: [TransferClientTypes.WorkflowDetail]?

        public init(
            onPartialUpload: [TransferClientTypes.WorkflowDetail]? = nil,
            onUpload: [TransferClientTypes.WorkflowDetail]? = nil
        )
        {
            self.onPartialUpload = onPartialUpload
            self.onUpload = onUpload
        }
    }

}

public struct CreateServerInput {
    /// The Amazon Resource Name (ARN) of the Certificate Manager (ACM) certificate. Required when Protocols is set to FTPS. To request a new public certificate, see [Request a public certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html) in the Certificate Manager User Guide. To import an existing certificate into ACM, see [Importing certificates into ACM](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the Certificate Manager User Guide. To request a private certificate to use FTPS through private IP addresses, see [Request a private certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html) in the Certificate Manager User Guide. Certificates with the following cryptographic algorithms and key sizes are supported:
    ///
    /// * 2048-bit RSA (RSA_2048)
    ///
    /// * 4096-bit RSA (RSA_4096)
    ///
    /// * Elliptic Prime Curve 256 bit (EC_prime256v1)
    ///
    /// * Elliptic Prime Curve 384 bit (EC_secp384r1)
    ///
    /// * Elliptic Prime Curve 521 bit (EC_secp521r1)
    ///
    ///
    /// The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP address specified and information about the issuer.
    public var certificate: Swift.String?
    /// The domain of the storage system that is used for file transfers. There are two domains available: Amazon Simple Storage Service (Amazon S3) and Amazon Elastic File System (Amazon EFS). The default value is S3. After the server is created, the domain cannot be changed.
    public var domain: TransferClientTypes.Domain?
    /// The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make your endpoint accessible only to resources within your VPC, or you can attach Elastic IP addresses and make your endpoint accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.
    public var endpointDetails: TransferClientTypes.EndpointDetails?
    /// The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC) or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it. After May 19, 2021, you won't be able to create a server using EndpointType=VPC_ENDPOINT in your Amazon Web Services account if your account hasn't already done so before May 19, 2021. If you have already created servers with EndpointType=VPC_ENDPOINT in your Amazon Web Services account on or before May 19, 2021, you will not be affected. After this date, use EndpointType=VPC. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint. It is recommended that you use VPC as the EndpointType. With this endpoint type, you have the option to directly associate up to three Elastic IPv4 addresses (BYO IP included) with your server's endpoint and use VPC security groups to restrict traffic by the client's public IP address. This is not possible with EndpointType set to VPC_ENDPOINT.
    public var endpointType: TransferClientTypes.EndpointType?
    /// The RSA, ECDSA, or ED25519 private key to use for your SFTP-enabled server. You can add multiple host keys, in case you want to rotate keys, or have a set of active keys that use different algorithms. Use the following command to generate an RSA 2048 bit key with no passphrase: ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key. Use a minimum value of 2048 for the -b option. You can create a stronger key by using 3072 or 4096. Use the following command to generate an ECDSA 256 bit key with no passphrase: ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key. Valid values for the -b option for ECDSA are 256, 384, and 521. Use the following command to generate an ED25519 key with no passphrase: ssh-keygen -t ed25519 -N "" -f my-new-server-key. For all of these commands, you can replace my-new-server-key with a string of your choice. If you aren't planning to migrate existing users from an existing SFTP-enabled server to a new server, don't update the host key. Accidentally changing a server's host key can be disruptive. For more information, see [Manage host keys for your SFTP-enabled server](https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key) in the Transfer Family User Guide.
    public var hostKey: Swift.String?
    /// Required when IdentityProviderType is set to AWS_DIRECTORY_SERVICE, Amazon Web Services_LAMBDA or API_GATEWAY. Accepts an array containing all of the information required to use a directory in AWS_DIRECTORY_SERVICE or invoke a customer-supplied authentication API, including the API Gateway URL. Not required when IdentityProviderType is set to SERVICE_MANAGED.
    public var identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    /// The mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Transfer Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the IdentityProviderDetails parameter. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the IdentityProviderDetails parameter. Use the AWS_LAMBDA value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the Function parameter for the IdentityProviderDetails data type.
    public var identityProviderType: TransferClientTypes.IdentityProviderType?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
    public var loggingRole: Swift.String?
    /// Specifies a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
    public var postAuthenticationLoginBanner: Swift.String?
    /// Specifies a string to display when users connect to a server. This string is displayed before the user authenticates. For example, the following banner displays details about using the system: This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel.
    public var preAuthenticationLoginBanner: Swift.String?
    /// The protocol settings that are configured for your server.
    ///
    /// * To indicate passive mode (for FTP and FTPS protocols), use the PassiveIp parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
    ///
    /// * To ignore the error that is generated when the client attempts to use the SETSTAT command on a file that you are uploading to an Amazon S3 bucket, use the SetStatOption parameter. To have the Transfer Family server ignore the SETSTAT command and upload files without needing to make any changes to your SFTP client, set the value to ENABLE_NO_OP. If you set the SetStatOption parameter to ENABLE_NO_OP, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a SETSTAT call.
    ///
    /// * To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the TlsSessionResumptionMode parameter.
    ///
    /// * As2Transports indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
    public var protocolDetails: TransferClientTypes.ProtocolDetails?
    /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:
    ///
    /// * SFTP (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH
    ///
    /// * FTPS (File Transfer Protocol Secure): File transfer with TLS encryption
    ///
    /// * FTP (File Transfer Protocol): Unencrypted file transfer
    ///
    /// * AS2 (Applicability Statement 2): used for transporting structured business-to-business data
    ///
    ///
    ///
    ///
    /// * If you select FTPS, you must choose a certificate stored in Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS.
    ///
    /// * If Protocol includes either FTP or FTPS, then the EndpointType must be VPC and the IdentityProviderType must be either AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
    ///
    /// * If Protocol includes FTP, then AddressAllocationIds cannot be associated.
    ///
    /// * If Protocol is set only to SFTP, the EndpointType can be set to PUBLIC and the IdentityProviderType can be set any of the supported identity types: SERVICE_MANAGED, AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
    ///
    /// * If Protocol includes AS2, then the EndpointType must be VPC, and domain must be Amazon S3.
    public var protocols: [TransferClientTypes.ModelProtocol]?
    /// Specifies whether or not performance for your Amazon S3 directories is optimized. This is disabled by default. By default, home directory mappings have a TYPE of DIRECTORY. If you enable this option, you would then need to explicitly set the HomeDirectoryMapEntryType to FILE if you want a mapping to have a file target.
    public var s3StorageOptions: TransferClientTypes.S3StorageOptions?
    /// Specifies the name of the security policy for the server.
    public var securityPolicyName: Swift.String?
    /// Specifies the log groups to which your server logs are sent. To specify a log group, you must provide the ARN for an existing log group. In this case, the format of the log group is as follows: arn:aws:logs:region-name:amazon-account-id:log-group:log-group-name:* For example, arn:aws:logs:us-east-1:111122223333:log-group:mytestgroup:* If you have previously specified a log group for a server, you can clear it, and in effect turn off structured logging, by providing an empty value for this parameter in an update-server call. For example: update-server --server-id s-1234567890abcdef0 --structured-log-destinations
    public var structuredLogDestinations: [Swift.String]?
    /// Key-value pairs that can be used to group and search for servers.
    public var tags: [TransferClientTypes.Tag]?
    /// Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow. In addition to a workflow to execute when a file is uploaded completely, WorkflowDetails can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when the server session disconnects while the file is still being uploaded.
    public var workflowDetails: TransferClientTypes.WorkflowDetails?

    public init(
        certificate: Swift.String? = nil,
        domain: TransferClientTypes.Domain? = nil,
        endpointDetails: TransferClientTypes.EndpointDetails? = nil,
        endpointType: TransferClientTypes.EndpointType? = nil,
        hostKey: Swift.String? = nil,
        identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
        identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
        loggingRole: Swift.String? = nil,
        postAuthenticationLoginBanner: Swift.String? = nil,
        preAuthenticationLoginBanner: Swift.String? = nil,
        protocolDetails: TransferClientTypes.ProtocolDetails? = nil,
        protocols: [TransferClientTypes.ModelProtocol]? = nil,
        s3StorageOptions: TransferClientTypes.S3StorageOptions? = nil,
        securityPolicyName: Swift.String? = nil,
        structuredLogDestinations: [Swift.String]? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        workflowDetails: TransferClientTypes.WorkflowDetails? = nil
    )
    {
        self.certificate = certificate
        self.domain = domain
        self.endpointDetails = endpointDetails
        self.endpointType = endpointType
        self.hostKey = hostKey
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderType = identityProviderType
        self.loggingRole = loggingRole
        self.postAuthenticationLoginBanner = postAuthenticationLoginBanner
        self.preAuthenticationLoginBanner = preAuthenticationLoginBanner
        self.protocolDetails = protocolDetails
        self.protocols = protocols
        self.s3StorageOptions = s3StorageOptions
        self.securityPolicyName = securityPolicyName
        self.structuredLogDestinations = structuredLogDestinations
        self.tags = tags
        self.workflowDetails = workflowDetails
    }
}

extension CreateServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServerInput(certificate: \(Swift.String(describing: certificate)), domain: \(Swift.String(describing: domain)), endpointDetails: \(Swift.String(describing: endpointDetails)), endpointType: \(Swift.String(describing: endpointType)), identityProviderDetails: \(Swift.String(describing: identityProviderDetails)), identityProviderType: \(Swift.String(describing: identityProviderType)), loggingRole: \(Swift.String(describing: loggingRole)), postAuthenticationLoginBanner: \(Swift.String(describing: postAuthenticationLoginBanner)), preAuthenticationLoginBanner: \(Swift.String(describing: preAuthenticationLoginBanner)), protocolDetails: \(Swift.String(describing: protocolDetails)), protocols: \(Swift.String(describing: protocols)), s3StorageOptions: \(Swift.String(describing: s3StorageOptions)), securityPolicyName: \(Swift.String(describing: securityPolicyName)), structuredLogDestinations: \(Swift.String(describing: structuredLogDestinations)), tags: \(Swift.String(describing: tags)), workflowDetails: \(Swift.String(describing: workflowDetails)), hostKey: \"CONTENT_REDACTED\")"}
}

public struct CreateServerOutput {
    /// The service-assigned identifier of the server that is created.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

public struct CreateUserInput {
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock your user down to the designated home directory ("chroot"). To do this, you can set Entry to / and set Target to the value the user should see for their home directory when they log in. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use session policies. For session policies, Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Example session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Amazon Web Services Security Token Service API Reference.
    public var policy: Swift.String?
    /// Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in Amazon EFS determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    /// This member is required.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.
    /// This member is required.
    public var serverId: Swift.String?
    /// The public portion of the Secure Shell (SSH) key used to authenticate the user to the server. The three standard SSH public key format elements are <key type>, <body base64>, and an optional <comment>, with spaces between each element. Transfer Family accepts RSA, ECDSA, and ED25519 keys.
    ///
    /// * For RSA keys, the key type is ssh-rsa.
    ///
    /// * For ED25519 keys, the key type is ssh-ed25519.
    ///
    /// * For ECDSA keys, the key type is either ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, or ecdsa-sha2-nistp521, depending on the size of the key you generated.
    public var sshPublicKeyBody: Swift.String?
    /// Key-value pairs that can be used to group and search for users. Tags are metadata attached to users for any purpose.
    public var tags: [TransferClientTypes.Tag]?
    /// A unique string that identifies a user and is associated with a ServerId. This user name must be a minimum of 3 and a maximum of 100 characters long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen '-', period '.', and at sign '@'. The user name can't start with a hyphen, period, or at sign.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil,
        sshPublicKeyBody: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
        self.sshPublicKeyBody = sshPublicKeyBody
        self.tags = tags
        self.userName = userName
    }
}

public struct CreateUserOutput {
    /// The identifier of the server that the user is attached to.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique string that identifies a Transfer Family user.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure.
    public struct CustomStepDetails {
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?
        /// The ARN for the Lambda function that is being called.
        public var target: Swift.String?
        /// Timeout, in seconds, for the step.
        public var timeoutSeconds: Swift.Int?

        public init(
            name: Swift.String? = nil,
            sourceFileLocation: Swift.String? = nil,
            target: Swift.String? = nil,
            timeoutSeconds: Swift.Int? = nil
        )
        {
            self.name = name
            self.sourceFileLocation = sourceFileLocation
            self.target = target
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension TransferClientTypes {

    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pgp
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .pgp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pgp: return "PGP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure.
    public struct DecryptStepDetails {
        /// Specifies the location for the file being decrypted. Use ${Transfer:UserName} or ${Transfer:UploadDate} in this field to parametrize the destination prefix by username or uploaded date.
        ///
        /// * Set the value of DestinationFileLocation to ${Transfer:UserName} to decrypt uploaded files to an Amazon S3 bucket that is prefixed with the name of the Transfer Family user that uploaded the file.
        ///
        /// * Set the value of DestinationFileLocation to ${Transfer:UploadDate} to decrypt uploaded files to an Amazon S3 bucket that is prefixed with the date of the upload. The system resolves UploadDate to a date format of YYYY-MM-DD, based on the date the file is uploaded in UTC.
        /// This member is required.
        public var destinationFileLocation: TransferClientTypes.InputFileLocation?
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// A flag that indicates whether to overwrite an existing file of the same name. The default is FALSE. If the workflow is processing a file that has the same name as an existing file, the behavior is as follows:
        ///
        /// * If OverwriteExisting is TRUE, the existing file is replaced with the file being processed.
        ///
        /// * If OverwriteExisting is FALSE, nothing happens, and the workflow processing stops.
        public var overwriteExisting: TransferClientTypes.OverwriteExisting?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?
        /// The type of encryption used. Currently, this value must be PGP.
        /// This member is required.
        public var type: TransferClientTypes.EncryptionType?

        public init(
            destinationFileLocation: TransferClientTypes.InputFileLocation? = nil,
            name: Swift.String? = nil,
            overwriteExisting: TransferClientTypes.OverwriteExisting? = nil,
            sourceFileLocation: Swift.String? = nil,
            type: TransferClientTypes.EncryptionType? = nil
        )
        {
            self.destinationFileLocation = destinationFileLocation
            self.name = name
            self.overwriteExisting = overwriteExisting
            self.sourceFileLocation = sourceFileLocation
            self.type = type
        }
    }

}

extension TransferClientTypes {
    /// The name of the step, used to identify the delete step.
    public struct DeleteStepDetails {
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?

        public init(
            name: Swift.String? = nil,
            sourceFileLocation: Swift.String? = nil
        )
        {
            self.name = name
            self.sourceFileLocation = sourceFileLocation
        }
    }

}

extension TransferClientTypes {
    /// Specifies the key-value pair that are assigned to a file during the execution of a Tagging step.
    public struct S3Tag {
        /// The name assigned to the tag that you create.
        /// This member is required.
        public var key: Swift.String?
        /// The value that corresponds to the key.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure. The key/value pairs used to tag a file during the execution of a workflow step.
    public struct TagStepDetails {
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?
        /// Array that contains from 1 to 10 key/value pairs.
        public var tags: [TransferClientTypes.S3Tag]?

        public init(
            name: Swift.String? = nil,
            sourceFileLocation: Swift.String? = nil,
            tags: [TransferClientTypes.S3Tag]? = nil
        )
        {
            self.name = name
            self.sourceFileLocation = sourceFileLocation
            self.tags = tags
        }
    }

}

extension TransferClientTypes {

    public enum WorkflowStepType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case copy
        case custom
        case decrypt
        case delete
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStepType] {
            return [
                .copy,
                .custom,
                .decrypt,
                .delete,
                .tag
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .copy: return "COPY"
            case .custom: return "CUSTOM"
            case .decrypt: return "DECRYPT"
            case .delete: return "DELETE"
            case .tag: return "TAG"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// The basic building block of a workflow.
    public struct WorkflowStep {
        /// Details for a step that performs a file copy. Consists of the following values:
        ///
        /// * A description
        ///
        /// * An Amazon S3 location for the destination of the file copy.
        ///
        /// * A flag that indicates whether to overwrite an existing file of the same name. The default is FALSE.
        public var copyStepDetails: TransferClientTypes.CopyStepDetails?
        /// Details for a step that invokes an Lambda function. Consists of the Lambda function's name, target, and timeout (in seconds).
        public var customStepDetails: TransferClientTypes.CustomStepDetails?
        /// Details for a step that decrypts an encrypted file. Consists of the following values:
        ///
        /// * A descriptive name
        ///
        /// * An Amazon S3 or Amazon Elastic File System (Amazon EFS) location for the source file to decrypt.
        ///
        /// * An S3 or Amazon EFS location for the destination of the file decryption.
        ///
        /// * A flag that indicates whether to overwrite an existing file of the same name. The default is FALSE.
        ///
        /// * The type of encryption that's used. Currently, only PGP encryption is supported.
        public var decryptStepDetails: TransferClientTypes.DecryptStepDetails?
        /// Details for a step that deletes the file.
        public var deleteStepDetails: TransferClientTypes.DeleteStepDetails?
        /// Details for a step that creates one or more tags. You specify one or more tags. Each tag contains a key-value pair.
        public var tagStepDetails: TransferClientTypes.TagStepDetails?
        /// Currently, the following step types are supported.
        ///
        /// * COPY - Copy the file to another location.
        ///
        /// * CUSTOM - Perform a custom step with an Lambda function target.
        ///
        /// * DECRYPT - Decrypt a file that was encrypted before it was uploaded.
        ///
        /// * DELETE - Delete the file.
        ///
        /// * TAG - Add a tag to the file.
        public var type: TransferClientTypes.WorkflowStepType?

        public init(
            copyStepDetails: TransferClientTypes.CopyStepDetails? = nil,
            customStepDetails: TransferClientTypes.CustomStepDetails? = nil,
            decryptStepDetails: TransferClientTypes.DecryptStepDetails? = nil,
            deleteStepDetails: TransferClientTypes.DeleteStepDetails? = nil,
            tagStepDetails: TransferClientTypes.TagStepDetails? = nil,
            type: TransferClientTypes.WorkflowStepType? = nil
        )
        {
            self.copyStepDetails = copyStepDetails
            self.customStepDetails = customStepDetails
            self.decryptStepDetails = decryptStepDetails
            self.deleteStepDetails = deleteStepDetails
            self.tagStepDetails = tagStepDetails
            self.type = type
        }
    }

}

public struct CreateWorkflowInput {
    /// A textual description for the workflow.
    public var description: Swift.String?
    /// Specifies the steps (actions) to take if errors are encountered during execution of the workflow. For custom steps, the Lambda function needs to send FAILURE to the call back API to kick off the exception steps. Additionally, if the Lambda does not send SUCCESS before it times out, the exception steps are executed.
    public var onExceptionSteps: [TransferClientTypes.WorkflowStep]?
    /// Specifies the details for the steps that are in the specified workflow. The TYPE specifies which of the following actions is being taken for this step.
    ///
    /// * COPY - Copy the file to another location.
    ///
    /// * CUSTOM - Perform a custom step with an Lambda function target.
    ///
    /// * DECRYPT - Decrypt a file that was encrypted before it was uploaded.
    ///
    /// * DELETE - Delete the file.
    ///
    /// * TAG - Add a tag to the file.
    ///
    ///
    /// Currently, copying and tagging are supported only on S3. For file location, you specify either the Amazon S3 bucket and key, or the Amazon EFS file system ID and path.
    /// This member is required.
    public var steps: [TransferClientTypes.WorkflowStep]?
    /// Key-value pairs that can be used to group and search for workflows. Tags are metadata attached to workflows for any purpose.
    public var tags: [TransferClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        onExceptionSteps: [TransferClientTypes.WorkflowStep]? = nil,
        steps: [TransferClientTypes.WorkflowStep]? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.onExceptionSteps = onExceptionSteps
        self.steps = steps
        self.tags = tags
    }
}

public struct CreateWorkflowOutput {
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        workflowId: Swift.String? = nil
    )
    {
        self.workflowId = workflowId
    }
}

extension TransferClientTypes {

    public enum CustomStepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failure
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomStepStatus] {
            return [
                .failure,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failure: return "FAILURE"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteAccessInput {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// A system-assigned unique identifier for a server that has this user assigned.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

public struct DeleteHostKeyInput {
    /// The identifier of the host key that you are deleting.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// The identifier of the server that contains the host key that you are deleting.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

public struct DeleteProfileInput {
    /// The identifier of the profile that you are deleting.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

public struct DeleteServerInput {
    /// A unique system-assigned identifier for a server instance.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

public struct DeleteSshPublicKeyInput {
    /// A system-assigned unique identifier for a file transfer protocol-enabled server instance that has the user assigned to it.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique identifier used to reference your user's specific SSH key.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// A unique string that identifies a user whose public key is being deleted.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

public struct DeleteUserInput {
    /// A system-assigned unique identifier for a server instance that has the user assigned to it.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique string that identifies a user that is being deleted from a server.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

public struct DeleteWorkflowInput {
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        workflowId: Swift.String? = nil
    )
    {
        self.workflowId = workflowId
    }
}

public struct DescribeAccessInput {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// A system-assigned unique identifier for a server that has this access assigned.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

extension TransferClientTypes {
    /// Describes the properties of the access that was specified.
    public struct DescribedAccess {
        /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
        public var externalId: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
        public var homeDirectory: Swift.String?
        /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. In most cases, you can use this value instead of the session policy to lock down the associated access to the designated home directory ("chroot"). To do this, you can set Entry to '/' and set Target to the HomeDirectory parameter value.
        public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
        /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}.
        public var policy: Swift.String?
        /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
        public var posixProfile: TransferClientTypes.PosixProfile?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
        public var role: Swift.String?

        public init(
            externalId: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            policy: Swift.String? = nil,
            posixProfile: TransferClientTypes.PosixProfile? = nil,
            role: Swift.String? = nil
        )
        {
            self.externalId = externalId
            self.homeDirectory = homeDirectory
            self.homeDirectoryMappings = homeDirectoryMappings
            self.homeDirectoryType = homeDirectoryType
            self.policy = policy
            self.posixProfile = posixProfile
            self.role = role
        }
    }

}

public struct DescribeAccessOutput {
    /// The external identifier of the server that the access is attached to.
    /// This member is required.
    public var access: TransferClientTypes.DescribedAccess?
    /// A system-assigned unique identifier for a server that has this access assigned.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        access: TransferClientTypes.DescribedAccess? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.access = access
        self.serverId = serverId
    }
}

extension TransferClientTypes {
    /// Specifies the details for the file location for the file that's being used in the workflow. Only applicable if you are using S3 storage.
    public struct S3FileLocation {
        /// Specifies the S3 bucket that contains the file being used.
        public var bucket: Swift.String?
        /// The entity tag is a hash of the object. The ETag reflects changes only to the contents of an object, not its metadata.
        public var etag: Swift.String?
        /// The name assigned to the file when it was created in Amazon S3. You use the object key to retrieve the object.
        public var key: Swift.String?
        /// Specifies the file version.
        public var versionId: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            etag: Swift.String? = nil,
            key: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.etag = etag
            self.key = key
            self.versionId = versionId
        }
    }

}

extension TransferClientTypes {
    /// Specifies the Amazon S3 or EFS file details to be used in the step.
    public struct FileLocation {
        /// Specifies the Amazon EFS identifier and the path for the file being used.
        public var efsFileLocation: TransferClientTypes.EfsFileLocation?
        /// Specifies the S3 details for the file being used, such as bucket, ETag, and so forth.
        public var s3FileLocation: TransferClientTypes.S3FileLocation?

        public init(
            efsFileLocation: TransferClientTypes.EfsFileLocation? = nil,
            s3FileLocation: TransferClientTypes.S3FileLocation? = nil
        )
        {
            self.efsFileLocation = efsFileLocation
            self.s3FileLocation = s3FileLocation
        }
    }

}

extension TransferClientTypes {
    /// Consists of the logging role and the log group name.
    public struct LoggingConfiguration {
        /// The name of the CloudWatch logging group for the Transfer Family server to which this workflow belongs.
        public var logGroupName: Swift.String?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
        public var loggingRole: Swift.String?

        public init(
            logGroupName: Swift.String? = nil,
            loggingRole: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
            self.loggingRole = loggingRole
        }
    }

}

extension TransferClientTypes {

    public enum ExecutionErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alreadyExists
        case badRequest
        case customStepFailed
        case internalServerError
        case notFound
        case permissionDenied
        case throttled
        case timeout
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionErrorType] {
            return [
                .alreadyExists,
                .badRequest,
                .customStepFailed,
                .internalServerError,
                .notFound,
                .permissionDenied,
                .throttled,
                .timeout
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alreadyExists: return "ALREADY_EXISTS"
            case .badRequest: return "BAD_REQUEST"
            case .customStepFailed: return "CUSTOM_STEP_FAILED"
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case .notFound: return "NOT_FOUND"
            case .permissionDenied: return "PERMISSION_DENIED"
            case .throttled: return "THROTTLED"
            case .timeout: return "TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// Specifies the error message and type, for an error that occurs during the execution of the workflow.
    public struct ExecutionError {
        /// Specifies the descriptive message that corresponds to the ErrorType.
        /// This member is required.
        public var message: Swift.String?
        /// Specifies the error type.
        ///
        /// * ALREADY_EXISTS: occurs for a copy step, if the overwrite option is not selected and a file with the same name already exists in the target location.
        ///
        /// * BAD_REQUEST: a general bad request: for example, a step that attempts to tag an EFS file returns BAD_REQUEST, as only S3 files can be tagged.
        ///
        /// * CUSTOM_STEP_FAILED: occurs when the custom step provided a callback that indicates failure.
        ///
        /// * INTERNAL_SERVER_ERROR: a catch-all error that can occur for a variety of reasons.
        ///
        /// * NOT_FOUND: occurs when a requested entity, for example a source file for a copy step, does not exist.
        ///
        /// * PERMISSION_DENIED: occurs if your policy does not contain the correct permissions to complete one or more of the steps in the workflow.
        ///
        /// * TIMEOUT: occurs when the execution times out. You can set the TimeoutSeconds for a custom step, anywhere from 1 second to 1800 seconds (30 minutes).
        ///
        /// * THROTTLED: occurs if you exceed the new execution refill rate of one workflow per second.
        /// This member is required.
        public var type: TransferClientTypes.ExecutionErrorType?

        public init(
            message: Swift.String? = nil,
            type: TransferClientTypes.ExecutionErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension TransferClientTypes {
    /// Specifies the following details for the step: error (if any), outputs (if any), and the step type.
    public struct ExecutionStepResult {
        /// Specifies the details for an error, if it occurred during execution of the specified workflow step.
        public var error: TransferClientTypes.ExecutionError?
        /// The values for the key/value pair applied as a tag to the file. Only applicable if the step type is TAG.
        public var outputs: Swift.String?
        /// One of the available step types.
        ///
        /// * COPY - Copy the file to another location.
        ///
        /// * CUSTOM - Perform a custom step with an Lambda function target.
        ///
        /// * DECRYPT - Decrypt a file that was encrypted before it was uploaded.
        ///
        /// * DELETE - Delete the file.
        ///
        /// * TAG - Add a tag to the file.
        public var stepType: TransferClientTypes.WorkflowStepType?

        public init(
            error: TransferClientTypes.ExecutionError? = nil,
            outputs: Swift.String? = nil,
            stepType: TransferClientTypes.WorkflowStepType? = nil
        )
        {
            self.error = error
            self.outputs = outputs
            self.stepType = stepType
        }
    }

}

extension TransferClientTypes {
    /// Specifies the steps in the workflow, as well as the steps to execute in case of any errors during workflow execution.
    public struct ExecutionResults {
        /// Specifies the steps (actions) to take if errors are encountered during execution of the workflow.
        public var onExceptionSteps: [TransferClientTypes.ExecutionStepResult]?
        /// Specifies the details for the steps that are in the specified workflow.
        public var steps: [TransferClientTypes.ExecutionStepResult]?

        public init(
            onExceptionSteps: [TransferClientTypes.ExecutionStepResult]? = nil,
            steps: [TransferClientTypes.ExecutionStepResult]? = nil
        )
        {
            self.onExceptionSteps = onExceptionSteps
            self.steps = steps
        }
    }

}

extension TransferClientTypes {
    /// Specifies the user name, server ID, and session ID for a workflow.
    public struct UserDetails {
        /// The system-assigned unique identifier for a Transfer server instance.
        /// This member is required.
        public var serverId: Swift.String?
        /// The system-assigned unique identifier for a session that corresponds to the workflow.
        public var sessionId: Swift.String?
        /// A unique string that identifies a Transfer Family user associated with a server.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            serverId: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.serverId = serverId
            self.sessionId = sessionId
            self.userName = userName
        }
    }

}

extension TransferClientTypes {
    /// A container object for the session details that are associated with a workflow.
    public struct ServiceMetadata {
        /// The Server ID (ServerId), Session ID (SessionId) and user (UserName) make up the UserDetails.
        /// This member is required.
        public var userDetails: TransferClientTypes.UserDetails?

        public init(
            userDetails: TransferClientTypes.UserDetails? = nil
        )
        {
            self.userDetails = userDetails
        }
    }

}

extension TransferClientTypes {

    public enum ExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case exception
        case handlingException
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .completed,
                .exception,
                .handlingException,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .exception: return "EXCEPTION"
            case .handlingException: return "HANDLING_EXCEPTION"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// The details for an execution object.
    public struct DescribedExecution {
        /// A unique identifier for the execution of a workflow.
        public var executionId: Swift.String?
        /// The IAM role associated with the execution.
        public var executionRole: Swift.String?
        /// A structure that describes the Amazon S3 or EFS file location. This is the file location when the execution begins: if the file is being copied, this is the initial (as opposed to destination) file location.
        public var initialFileLocation: TransferClientTypes.FileLocation?
        /// The IAM logging role associated with the execution.
        public var loggingConfiguration: TransferClientTypes.LoggingConfiguration?
        /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
        public var posixProfile: TransferClientTypes.PosixProfile?
        /// A structure that describes the execution results. This includes a list of the steps along with the details of each step, error type and message (if any), and the OnExceptionSteps structure.
        public var results: TransferClientTypes.ExecutionResults?
        /// A container object for the session details that are associated with a workflow.
        public var serviceMetadata: TransferClientTypes.ServiceMetadata?
        /// The status is one of the execution. Can be in progress, completed, exception encountered, or handling the exception.
        public var status: TransferClientTypes.ExecutionStatus?

        public init(
            executionId: Swift.String? = nil,
            executionRole: Swift.String? = nil,
            initialFileLocation: TransferClientTypes.FileLocation? = nil,
            loggingConfiguration: TransferClientTypes.LoggingConfiguration? = nil,
            posixProfile: TransferClientTypes.PosixProfile? = nil,
            results: TransferClientTypes.ExecutionResults? = nil,
            serviceMetadata: TransferClientTypes.ServiceMetadata? = nil,
            status: TransferClientTypes.ExecutionStatus? = nil
        )
        {
            self.executionId = executionId
            self.executionRole = executionRole
            self.initialFileLocation = initialFileLocation
            self.loggingConfiguration = loggingConfiguration
            self.posixProfile = posixProfile
            self.results = results
            self.serviceMetadata = serviceMetadata
            self.status = status
        }
    }

}

extension TransferClientTypes {
    /// The details for a server host key.
    public struct DescribedHostKey {
        /// The unique Amazon Resource Name (ARN) for the host key.
        /// This member is required.
        public var arn: Swift.String?
        /// The date on which the host key was added to the server.
        public var dateImported: Foundation.Date?
        /// The text description for this host key.
        public var description: Swift.String?
        /// The public key fingerprint, which is a short sequence of bytes used to identify the longer public key.
        public var hostKeyFingerprint: Swift.String?
        /// A unique identifier for the host key.
        public var hostKeyId: Swift.String?
        /// Key-value pairs that can be used to group and search for host keys.
        public var tags: [TransferClientTypes.Tag]?
        /// The encryption algorithm that is used for the host key. The Type parameter is specified by using one of the following values:
        ///
        /// * ssh-rsa
        ///
        /// * ssh-ed25519
        ///
        /// * ecdsa-sha2-nistp256
        ///
        /// * ecdsa-sha2-nistp384
        ///
        /// * ecdsa-sha2-nistp521
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            dateImported: Foundation.Date? = nil,
            description: Swift.String? = nil,
            hostKeyFingerprint: Swift.String? = nil,
            hostKeyId: Swift.String? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.dateImported = dateImported
            self.description = description
            self.hostKeyFingerprint = hostKeyFingerprint
            self.hostKeyId = hostKeyId
            self.tags = tags
            self.type = type
        }
    }

}

extension TransferClientTypes {
    /// The details for a local or partner AS2 profile.
    public struct DescribedProfile {
        /// The unique Amazon Resource Name (ARN) for the profile.
        /// This member is required.
        public var arn: Swift.String?
        /// The As2Id is the AS2-name, as defined in the [RFC 4130](https://datatracker.ietf.org/doc/html/rfc4130). For inbound transfers, this is the AS2-From header for the AS2 messages sent from the partner. For outbound connectors, this is the AS2-To header for the AS2 messages sent to the partner using the StartFileTransfer API operation. This ID cannot include spaces.
        public var as2Id: Swift.String?
        /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
        public var certificateIds: [Swift.String]?
        /// A unique identifier for the local or partner AS2 profile.
        public var profileId: Swift.String?
        /// Indicates whether to list only LOCAL type profiles or only PARTNER type profiles. If not supplied in the request, the command lists all types of profiles.
        public var profileType: TransferClientTypes.ProfileType?
        /// Key-value pairs that can be used to group and search for profiles.
        public var tags: [TransferClientTypes.Tag]?

        public init(
            arn: Swift.String? = nil,
            as2Id: Swift.String? = nil,
            certificateIds: [Swift.String]? = nil,
            profileId: Swift.String? = nil,
            profileType: TransferClientTypes.ProfileType? = nil,
            tags: [TransferClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.as2Id = as2Id
            self.certificateIds = certificateIds
            self.profileId = profileId
            self.profileType = profileType
            self.tags = tags
        }
    }

}

extension TransferClientTypes {

    public enum SecurityPolicyProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ftps
        case sftp
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityPolicyProtocol] {
            return [
                .ftps,
                .sftp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ftps: return "FTPS"
            case .sftp: return "SFTP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {

    public enum SecurityPolicyResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connector
        case server
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityPolicyResourceType] {
            return [
                .connector,
                .server
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connector: return "CONNECTOR"
            case .server: return "SERVER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// Describes the properties of a security policy that you specify. For more information about security policies, see [Working with security policies for servers](https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html) or [Working with security policies for SFTP connectors](https://docs.aws.amazon.com/transfer/latest/userguide/security-policies-connectors.html).
    public struct DescribedSecurityPolicy {
        /// Specifies whether this policy enables Federal Information Processing Standards (FIPS). This parameter applies to both server and connector security policies.
        public var fips: Swift.Bool?
        /// Lists the file transfer protocols that the security policy applies to.
        public var protocols: [TransferClientTypes.SecurityPolicyProtocol]?
        /// The text name of the specified security policy.
        /// This member is required.
        public var securityPolicyName: Swift.String?
        /// Lists the enabled Secure Shell (SSH) cipher encryption algorithms in the security policy that is attached to the server or connector. This parameter applies to both server and connector security policies.
        public var sshCiphers: [Swift.String]?
        /// Lists the host key algorithms for the security policy. This parameter only applies to security policies for connectors.
        public var sshHostKeyAlgorithms: [Swift.String]?
        /// Lists the enabled SSH key exchange (KEX) encryption algorithms in the security policy that is attached to the server or connector. This parameter applies to both server and connector security policies.
        public var sshKexs: [Swift.String]?
        /// Lists the enabled SSH message authentication code (MAC) encryption algorithms in the security policy that is attached to the server or connector. This parameter applies to both server and connector security policies.
        public var sshMacs: [Swift.String]?
        /// Lists the enabled Transport Layer Security (TLS) cipher encryption algorithms in the security policy that is attached to the server. This parameter only applies to security policies for servers.
        public var tlsCiphers: [Swift.String]?
        /// The resource type to which the security policy applies, either server or connector.
        public var type: TransferClientTypes.SecurityPolicyResourceType?

        public init(
            fips: Swift.Bool? = nil,
            protocols: [TransferClientTypes.SecurityPolicyProtocol]? = nil,
            securityPolicyName: Swift.String? = nil,
            sshCiphers: [Swift.String]? = nil,
            sshHostKeyAlgorithms: [Swift.String]? = nil,
            sshKexs: [Swift.String]? = nil,
            sshMacs: [Swift.String]? = nil,
            tlsCiphers: [Swift.String]? = nil,
            type: TransferClientTypes.SecurityPolicyResourceType? = nil
        )
        {
            self.fips = fips
            self.protocols = protocols
            self.securityPolicyName = securityPolicyName
            self.sshCiphers = sshCiphers
            self.sshHostKeyAlgorithms = sshHostKeyAlgorithms
            self.sshKexs = sshKexs
            self.sshMacs = sshMacs
            self.tlsCiphers = tlsCiphers
            self.type = type
        }
    }

}

extension TransferClientTypes {

    /// Describes the condition of a file transfer protocol-enabled server with respect to its ability to perform file operations. There are six possible states: OFFLINE, ONLINE, STARTING, STOPPING, START_FAILED, and STOP_FAILED. OFFLINE indicates that the server exists, but that it is not available for file operations. ONLINE indicates that the server is available to perform file operations. STARTING indicates that the server's was instantiated, but the server is not yet available to perform file operations. Under normal conditions, it can take a couple of minutes for the server to be completely operational. Both START_FAILED and STOP_FAILED are error conditions.
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case offline
        case online
        case starting
        case startFailed
        case stopping
        case stopFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .offline,
                .online,
                .starting,
                .startFailed,
                .stopping,
                .stopFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .starting: return "STARTING"
            case .startFailed: return "START_FAILED"
            case .stopping: return "STOPPING"
            case .stopFailed: return "STOP_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TransferClientTypes {
    /// Describes the properties of a file transfer protocol-enabled server that was specified.
    public struct DescribedServer {
        /// Specifies the unique Amazon Resource Name (ARN) of the server.
        /// This member is required.
        public var arn: Swift.String?
        /// The list of egress IP addresses of this server. These IP addresses are only relevant for servers that use the AS2 protocol. They are used for sending asynchronous MDNs. These IP addresses are assigned automatically when you create an AS2 server. Additionally, if you update an existing server and add the AS2 protocol, static IP addresses are assigned as well.
        public var as2ServiceManagedEgressIpAddresses: [Swift.String]?
        /// Specifies the ARN of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when Protocols is set to FTPS.
        public var certificate: Swift.String?
        /// Specifies the domain of the storage system that is used for file transfers. There are two domains available: Amazon Simple Storage Service (Amazon S3) and Amazon Elastic File System (Amazon EFS). The default value is S3.
        public var domain: TransferClientTypes.Domain?
        /// The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make your endpoint accessible only to resources within your VPC, or you can attach Elastic IP addresses and make your endpoint accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.
        public var endpointDetails: TransferClientTypes.EndpointDetails?
        /// Defines the type of endpoint that your server is connected to. If your server is connected to a VPC endpoint, your server isn't accessible over the public internet.
        public var endpointType: TransferClientTypes.EndpointType?
        /// Specifies the Base64-encoded SHA256 fingerprint of the server's host key. This value is equivalent to the output of the ssh-keygen -l -f my-new-server-key command.
        public var hostKeyFingerprint: Swift.String?
        /// Specifies information to call a customer-supplied authentication API. This field is not populated when the IdentityProviderType of a server is AWS_DIRECTORY_SERVICE or SERVICE_MANAGED.
        public var identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
        /// The mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Transfer Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the IdentityProviderDetails parameter. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the IdentityProviderDetails parameter. Use the AWS_LAMBDA value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the Function parameter for the IdentityProviderDetails data type.
        public var identityProviderType: TransferClientTypes.IdentityProviderType?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
        public var loggingRole: Swift.String?
        /// Specifies a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
        public var postAuthenticationLoginBanner: Swift.String?
        /// Specifies a string to display when users connect to a server. This string is displayed before the user authenticates. For example, the following banner displays details about using the system: This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel.
        public var preAuthenticationLoginBanner: Swift.String?
        /// The protocol settings that are configured for your server.
        ///
        /// * To indicate passive mode (for FTP and FTPS protocols), use the PassiveIp parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
        ///
        /// * To ignore the error that is generated when the client attempts to use the SETSTAT command on a file that you are uploading to an Amazon S3 bucket, use the SetStatOption parameter. To have the Transfer Family server ignore the SETSTAT command and upload files without needing to make any changes to your SFTP client, set the value to ENABLE_NO_OP. If you set the SetStatOption parameter to ENABLE_NO_OP, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a SETSTAT call.
        ///
        /// * To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the TlsSessionResumptionMode parameter.
        ///
        /// * As2Transports indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
        public var protocolDetails: TransferClientTypes.ProtocolDetails?
        /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:
        ///
        /// * SFTP (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH
        ///
        /// * FTPS (File Transfer Protocol Secure): File transfer with TLS encryption
        ///
        /// * FTP (File Transfer Protocol): Unencrypted file transfer
        ///
        /// * AS2 (Applicability Statement 2): used for transporting structured business-to-business data
        ///
        ///
        ///
        ///
        /// * If you select FTPS, you must choose a certificate stored in Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS.
        ///
        /// * If Protocol includes either FTP or FTPS, then the EndpointType must be VPC and the IdentityProviderType must be either AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
        ///
        /// * If Protocol includes FTP, then AddressAllocationIds cannot be associated.
        ///
        /// * If Protocol is set only to SFTP, the EndpointType can be set to PUBLIC and the IdentityProviderType can be set any of the supported identity types: SERVICE_MANAGED, AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
        ///
        /// * If Protocol includes AS2, then the EndpointType must be VPC, and domain must be Amazon S3.
        public var protocols: [TransferClientTypes.ModelProtocol]?
        /// Specifies whether or not performance for your Amazon S3 directories is optimized. This is disabled by default. By default, home directory mappings have a TYPE of DIRECTORY. If you enable this option, you would then need to explicitly set the HomeDirectoryMapEntryType to FILE if you want a mapping to have a file target.
        public var s3StorageOptions: TransferClientTypes.S3StorageOptions?
        /// Specifies the name of the security policy for the server.
        public var securityPolicyName: Swift.String?
        /// Specifies the unique system-assigned identifier for a server that you instantiate.
        public var serverId: Swift.String?
        /// The condition of the server that was described. A value of ONLINE indicates that the server can accept jobs and transfer files. A State value of OFFLINE means that the server cannot perform file transfer operations. The states of STARTING and STOPPING indicate that the server is in an intermediate state, either not fully able to respond, or not fully offline. The values of START_FAILED or STOP_FAILED can indicate an error condition.
        public var state: TransferClientTypes.State?
        /// Specifies the log groups to which your server logs are sent. To specify a log group, you must provide the ARN for an existing log group. In this case, the format of the log group is as follows: arn:aws:logs:region-name:amazon-account-id:log-group:log-group-name:* For example, arn:aws:logs:us-east-1:111122223333:log-group:mytestgroup:* If you have previously specified a log group for a server, you can clear it, and in effect turn off structured logging, by providing an empty value for this parameter in an update-server call. For example: update-server --server-id s-1234567890abcdef0 --structured-log-destinations
        public var structuredLogDestinations: [Swift.String]?
        /// Specifies the key-value pairs that you can use to search for and group servers that were assigned to the server that was described.
        public var tags: [TransferClientTypes.Tag]?
        /// Specifies the number of users that are assigned to a server you specified with the ServerId.
        public var userCount: Swift.Int?
        /// Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow. In addition to a workflow to execute when a file is uploaded completely, WorkflowDetails can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when the server session disconnects while the file is still being uploaded.
        public var workflowDetails: TransferClientTypes.WorkflowDetails?

        public init(
            arn: Swift.String? = nil,
            as2ServiceManagedEgressIpAddresses: [Swift.String]? = nil,
            certificate: Swift.String? = nil,
            domain: TransferClientTypes.Domain? = nil,
            endpointDetails: TransferClientTypes.EndpointDetails? = nil,
            endpointType: TransferClientTypes.EndpointType? = nil,
            hostKeyFingerprint: Swift.String? = nil,
            identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
            identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
            loggingRole: Swift.String? = nil,
            postAuthenticationLoginBanner: Swift.String? = nil,
            preAuthenticationLoginBanner: Swift.String? = nil,
            protocolDetails: TransferClientTypes.ProtocolDetails? = nil,
            protocols: [TransferClientTypes.ModelProtocol]? = nil,
            s3StorageOptions: TransferClientTypes.S3StorageOptions? = nil,
            securityPolicyName: Swift.String? = nil,
            serverId: Swift.String? = nil,
            state: TransferClientTypes.State? = nil,
            structuredLogDestinations: [Swift.String]? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            userCount: Swift.Int? = nil,
            workflowDetails: TransferClientTypes.WorkflowDetails? = nil
        )
        {
            self.arn = arn
            self.as2ServiceManagedEgressIpAddresses = as2ServiceManagedEgressIpAddresses
            self.certificate = certificate
            self.domain = domain
            self.endpointDetails = endpointDetails
            self.endpointType = endpointType
            self.hostKeyFingerprint = hostKeyFingerprint
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderType = identityProviderType
            self.loggingRole = loggingRole
            self.postAuthenticationLoginBanner = postAuthenticationLoginBanner
            self.preAuthenticationLoginBanner = preAuthenticationLoginBanner
            self.protocolDetails = protocolDetails
            self.protocols = protocols
            self.s3StorageOptions = s3StorageOptions
            self.securityPolicyName = securityPolicyName
            self.serverId = serverId
            self.state = state
            self.structuredLogDestinations = structuredLogDestinations
            self.tags = tags
            self.userCount = userCount
            self.workflowDetails = workflowDetails
        }
    }

}

extension TransferClientTypes {
    /// Provides information about the public Secure Shell (SSH) key that is associated with a Transfer Family user for the specific file transfer protocol-enabled server (as identified by ServerId). The information returned includes the date the key was imported, the public key contents, and the public key ID. A user can store more than one SSH public key associated with their user name on a specific server.
    public struct SshPublicKey {
        /// Specifies the date that the public key was added to the Transfer Family user.
        /// This member is required.
        public var dateImported: Foundation.Date?
        /// Specifies the content of the SSH public key as specified by the PublicKeyId. Transfer Family accepts RSA, ECDSA, and ED25519 keys.
        /// This member is required.
        public var sshPublicKeyBody: Swift.String?
        /// Specifies the SshPublicKeyId parameter contains the identifier of the public key.
        /// This member is required.
        public var sshPublicKeyId: Swift.String?

        public init(
            dateImported: Foundation.Date? = nil,
            sshPublicKeyBody: Swift.String? = nil,
            sshPublicKeyId: Swift.String? = nil
        )
        {
            self.dateImported = dateImported
            self.sshPublicKeyBody = sshPublicKeyBody
            self.sshPublicKeyId = sshPublicKeyId
        }
    }

}

extension TransferClientTypes {
    /// Describes the properties of a user that was specified.
    public struct DescribedUser {
        /// Specifies the unique Amazon Resource Name (ARN) for the user that was requested to be described.
        /// This member is required.
        public var arn: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
        public var homeDirectory: Swift.String?
        /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. In most cases, you can use this value instead of the session policy to lock your user down to the designated home directory ("chroot"). To do this, you can set Entry to '/' and set Target to the HomeDirectory parameter value.
        public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
        /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}.
        public var policy: Swift.String?
        /// Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon Elastic File System (Amazon EFS) file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
        public var posixProfile: TransferClientTypes.PosixProfile?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
        public var role: Swift.String?
        /// Specifies the public key portion of the Secure Shell (SSH) keys stored for the described user.
        public var sshPublicKeys: [TransferClientTypes.SshPublicKey]?
        /// Specifies the key-value pairs for the user requested. Tag can be used to search for and group users for a variety of purposes.
        public var tags: [TransferClientTypes.Tag]?
        /// Specifies the name of the user that was requested to be described. User names are used for authentication purposes. This is the string that will be used by your user when they log in to your server.
        public var userName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            policy: Swift.String? = nil,
            posixProfile: TransferClientTypes.PosixProfile? = nil,
            role: Swift.String? = nil,
            sshPublicKeys: [TransferClientTypes.SshPublicKey]? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.homeDirectory = homeDirectory
            self.homeDirectoryMappings = homeDirectoryMappings
            self.homeDirectoryType = homeDirectoryType
            self.policy = policy
            self.posixProfile = posixProfile
            self.role = role
            self.sshPublicKeys = sshPublicKeys
            self.tags = tags
            self.userName = userName
        }
    }

}

extension TransferClientTypes {
    /// Describes the properties of the specified workflow
    public struct DescribedWorkflow {
        /// Specifies the unique Amazon Resource Name (ARN) for the workflow.
        /// This member is required.
        public var arn: Swift.String?
        /// Specifies the text description for the workflow.
        public var description: Swift.String?
        /// Specifies the steps (actions) to take if errors are encountered during execution of the workflow.
        public var onExceptionSteps: [TransferClientTypes.WorkflowStep]?
        /// Specifies the details for the steps that are in the specified workflow.
        public var steps: [TransferClientTypes.WorkflowStep]?
        /// Key-value pairs that can be used to group and search for workflows. Tags are metadata attached to workflows for any purpose.
        public var tags: [TransferClientTypes.Tag]?
        /// A unique identifier for the workflow.
        public var workflowId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            onExceptionSteps: [TransferClientTypes.WorkflowStep]? = nil,
            steps: [TransferClientTypes.WorkflowStep]? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.onExceptionSteps = onExceptionSteps
            self.steps = steps
            self.tags = tags
            self.workflowId = workflowId
        }
    }

}

public struct DescribeExecutionInput {
    /// A unique identifier for the execution of a workflow.
    /// This member is required.
    public var executionId: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        executionId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.executionId = executionId
        self.workflowId = workflowId
    }
}

public struct DescribeExecutionOutput {
    /// The structure that contains the details of the workflow' execution.
    /// This member is required.
    public var execution: TransferClientTypes.DescribedExecution?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        execution: TransferClientTypes.DescribedExecution? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.execution = execution
        self.workflowId = workflowId
    }
}

public struct DescribeHostKeyInput {
    /// The identifier of the host key that you want described.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// The identifier of the server that contains the host key that you want described.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

public struct DescribeHostKeyOutput {
    /// Returns the details for the specified host key.
    /// This member is required.
    public var hostKey: TransferClientTypes.DescribedHostKey?

    public init(
        hostKey: TransferClientTypes.DescribedHostKey? = nil
    )
    {
        self.hostKey = hostKey
    }
}

public struct DescribeProfileInput {
    /// The identifier of the profile that you want described.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

public struct DescribeProfileOutput {
    /// The details of the specified profile, returned as an object.
    /// This member is required.
    public var profile: TransferClientTypes.DescribedProfile?

    public init(
        profile: TransferClientTypes.DescribedProfile? = nil
    )
    {
        self.profile = profile
    }
}

public struct DescribeSecurityPolicyInput {
    /// Specify the text name of the security policy for which you want the details.
    /// This member is required.
    public var securityPolicyName: Swift.String?

    public init(
        securityPolicyName: Swift.String? = nil
    )
    {
        self.securityPolicyName = securityPolicyName
    }
}

public struct DescribeSecurityPolicyOutput {
    /// An array containing the properties of the security policy.
    /// This member is required.
    public var securityPolicy: TransferClientTypes.DescribedSecurityPolicy?

    public init(
        securityPolicy: TransferClientTypes.DescribedSecurityPolicy? = nil
    )
    {
        self.securityPolicy = securityPolicy
    }
}

public struct DescribeServerInput {
    /// A system-assigned unique identifier for a server.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

public struct DescribeServerOutput {
    /// An array containing the properties of a server with the ServerID you specified.
    /// This member is required.
    public var server: TransferClientTypes.DescribedServer?

    public init(
        server: TransferClientTypes.DescribedServer? = nil
    )
    {
        self.server = server
    }
}

public struct DescribeUserInput {
    /// A system-assigned unique identifier for a server that has this user assigned.
    /// This member is required.
    public var serverId: Swift.String?
    /// The name of the user assigned to one or more servers. User names are part of the sign-in credentials to use the Transfer Family service and perform file transfer tasks.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

public struct DescribeUserOutput {
    /// A system-assigned unique identifier for a server that has this user assigned.
    /// This member is required.
    public var serverId: Swift.String?
    /// An array containing the properties of the Transfer Family user for the ServerID value that you specified.
    /// This member is required.
    public var user: TransferClientTypes.DescribedUser?

    public init(
        serverId: Swift.String? = nil,
        user: TransferClientTypes.DescribedUser? = nil
    )
    {
        self.serverId = serverId
        self.user = user
    }
}

public struct DescribeWorkflowInput {
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        workflowId: Swift.String? = nil
    )
    {
        self.workflowId = workflowId
    }
}

public struct DescribeWorkflowOutput {
    /// The structure that contains the details of the workflow.
    /// This member is required.
    public var workflow: TransferClientTypes.DescribedWorkflow?

    public init(
        workflow: TransferClientTypes.DescribedWorkflow? = nil
    )
    {
        self.workflow = workflow
    }
}

public struct ImportHostKeyInput {
    /// The text description that identifies this host key.
    public var description: Swift.String?
    /// The private key portion of an SSH key pair. Transfer Family accepts RSA, ECDSA, and ED25519 keys.
    /// This member is required.
    public var hostKeyBody: Swift.String?
    /// The identifier of the server that contains the host key that you are importing.
    /// This member is required.
    public var serverId: Swift.String?
    /// Key-value pairs that can be used to group and search for host keys.
    public var tags: [TransferClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        hostKeyBody: Swift.String? = nil,
        serverId: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.hostKeyBody = hostKeyBody
        self.serverId = serverId
        self.tags = tags
    }
}

extension ImportHostKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportHostKeyInput(description: \(Swift.String(describing: description)), serverId: \(Swift.String(describing: serverId)), tags: \(Swift.String(describing: tags)), hostKeyBody: \"CONTENT_REDACTED\")"}
}

public struct ImportHostKeyOutput {
    /// Returns the host key identifier for the imported key.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// Returns the server identifier that contains the imported key.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

public struct ImportSshPublicKeyInput {
    /// A system-assigned unique identifier for a server.
    /// This member is required.
    public var serverId: Swift.String?
    /// The public key portion of an SSH key pair. Transfer Family accepts RSA, ECDSA, and ED25519 keys.
    /// This member is required.
    public var sshPublicKeyBody: Swift.String?
    /// The name of the Transfer Family user that is assigned to one or more servers.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        sshPublicKeyBody: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyBody = sshPublicKeyBody
        self.userName = userName
    }
}

/// Identifies the user, the server they belong to, and the identifier of the SSH public key associated with that user. A user can have more than one key on each server that they are associated with.
public struct ImportSshPublicKeyOutput {
    /// A system-assigned unique identifier for a server.
    /// This member is required.
    public var serverId: Swift.String?
    /// The name given to a public key by the system that was imported.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// A user name assigned to the ServerID value that you specified.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

public struct ListAccessesInput {
    /// Specifies the maximum number of access SIDs to return.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListAccesses call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional accesses.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that has users assigned to it.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

extension TransferClientTypes {
    /// Lists the properties for one or more specified associated accesses.
    public struct ListedAccess {
        /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
        public var externalId: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
        public var homeDirectory: Swift.String?
        /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
        public var role: Swift.String?

        public init(
            externalId: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            role: Swift.String? = nil
        )
        {
            self.externalId = externalId
            self.homeDirectory = homeDirectory
            self.homeDirectoryType = homeDirectoryType
            self.role = role
        }
    }

}

public struct ListAccessesOutput {
    /// Returns the accesses and their properties for the ServerId value that you specify.
    /// This member is required.
    public var accesses: [TransferClientTypes.ListedAccess]?
    /// When you can get additional results from the ListAccesses call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional accesses.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that has users assigned to it.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        accesses: [TransferClientTypes.ListedAccess]? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.accesses = accesses
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

extension TransferClientTypes {
    /// Returns properties of the execution that is specified.
    public struct ListedExecution {
        /// A unique identifier for the execution of a workflow.
        public var executionId: Swift.String?
        /// A structure that describes the Amazon S3 or EFS file location. This is the file location when the execution begins: if the file is being copied, this is the initial (as opposed to destination) file location.
        public var initialFileLocation: TransferClientTypes.FileLocation?
        /// A container object for the session details that are associated with a workflow.
        public var serviceMetadata: TransferClientTypes.ServiceMetadata?
        /// The status is one of the execution. Can be in progress, completed, exception encountered, or handling the exception.
        public var status: TransferClientTypes.ExecutionStatus?

        public init(
            executionId: Swift.String? = nil,
            initialFileLocation: TransferClientTypes.FileLocation? = nil,
            serviceMetadata: TransferClientTypes.ServiceMetadata? = nil,
            status: TransferClientTypes.ExecutionStatus? = nil
        )
        {
            self.executionId = executionId
            self.initialFileLocation = initialFileLocation
            self.serviceMetadata = serviceMetadata
            self.status = status
        }
    }

}

extension TransferClientTypes {
    /// Returns properties of the host key that's specified.
    public struct ListedHostKey {
        /// The unique Amazon Resource Name (ARN) of the host key.
        /// This member is required.
        public var arn: Swift.String?
        /// The date on which the host key was added to the server.
        public var dateImported: Foundation.Date?
        /// The current description for the host key. You can change it by calling the UpdateHostKey operation and providing a new description.
        public var description: Swift.String?
        /// The public key fingerprint, which is a short sequence of bytes used to identify the longer public key.
        public var fingerprint: Swift.String?
        /// A unique identifier for the host key.
        public var hostKeyId: Swift.String?
        /// The encryption algorithm that is used for the host key. The Type parameter is specified by using one of the following values:
        ///
        /// * ssh-rsa
        ///
        /// * ssh-ed25519
        ///
        /// * ecdsa-sha2-nistp256
        ///
        /// * ecdsa-sha2-nistp384
        ///
        /// * ecdsa-sha2-nistp521
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            dateImported: Foundation.Date? = nil,
            description: Swift.String? = nil,
            fingerprint: Swift.String? = nil,
            hostKeyId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.dateImported = dateImported
            self.description = description
            self.fingerprint = fingerprint
            self.hostKeyId = hostKeyId
            self.type = type
        }
    }

}

extension TransferClientTypes {
    /// Returns the properties of the profile that was specified.
    public struct ListedProfile {
        /// The Amazon Resource Name (ARN) of the specified profile.
        public var arn: Swift.String?
        /// The As2Id is the AS2-name, as defined in the [RFC 4130](https://datatracker.ietf.org/doc/html/rfc4130). For inbound transfers, this is the AS2-From header for the AS2 messages sent from the partner. For outbound connectors, this is the AS2-To header for the AS2 messages sent to the partner using the StartFileTransfer API operation. This ID cannot include spaces.
        public var as2Id: Swift.String?
        /// A unique identifier for the local or partner AS2 profile.
        public var profileId: Swift.String?
        /// Indicates whether to list only LOCAL type profiles or only PARTNER type profiles. If not supplied in the request, the command lists all types of profiles.
        public var profileType: TransferClientTypes.ProfileType?

        public init(
            arn: Swift.String? = nil,
            as2Id: Swift.String? = nil,
            profileId: Swift.String? = nil,
            profileType: TransferClientTypes.ProfileType? = nil
        )
        {
            self.arn = arn
            self.as2Id = as2Id
            self.profileId = profileId
            self.profileType = profileType
        }
    }

}

extension TransferClientTypes {
    /// Returns properties of a file transfer protocol-enabled server that was specified.
    public struct ListedServer {
        /// Specifies the unique Amazon Resource Name (ARN) for a server to be listed.
        /// This member is required.
        public var arn: Swift.String?
        /// Specifies the domain of the storage system that is used for file transfers. There are two domains available: Amazon Simple Storage Service (Amazon S3) and Amazon Elastic File System (Amazon EFS). The default value is S3.
        public var domain: TransferClientTypes.Domain?
        /// Specifies the type of VPC endpoint that your server is connected to. If your server is connected to a VPC endpoint, your server isn't accessible over the public internet.
        public var endpointType: TransferClientTypes.EndpointType?
        /// The mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Transfer Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the IdentityProviderDetails parameter. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the IdentityProviderDetails parameter. Use the AWS_LAMBDA value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the Function parameter for the IdentityProviderDetails data type.
        public var identityProviderType: TransferClientTypes.IdentityProviderType?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
        public var loggingRole: Swift.String?
        /// Specifies the unique system assigned identifier for the servers that were listed.
        public var serverId: Swift.String?
        /// The condition of the server that was described. A value of ONLINE indicates that the server can accept jobs and transfer files. A State value of OFFLINE means that the server cannot perform file transfer operations. The states of STARTING and STOPPING indicate that the server is in an intermediate state, either not fully able to respond, or not fully offline. The values of START_FAILED or STOP_FAILED can indicate an error condition.
        public var state: TransferClientTypes.State?
        /// Specifies the number of users that are assigned to a server you specified with the ServerId.
        public var userCount: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            domain: TransferClientTypes.Domain? = nil,
            endpointType: TransferClientTypes.EndpointType? = nil,
            identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
            loggingRole: Swift.String? = nil,
            serverId: Swift.String? = nil,
            state: TransferClientTypes.State? = nil,
            userCount: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.domain = domain
            self.endpointType = endpointType
            self.identityProviderType = identityProviderType
            self.loggingRole = loggingRole
            self.serverId = serverId
            self.state = state
            self.userCount = userCount
        }
    }

}

extension TransferClientTypes {
    /// Returns properties of the user that you specify.
    public struct ListedUser {
        /// Provides the unique Amazon Resource Name (ARN) for the user that you want to learn about.
        /// This member is required.
        public var arn: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
        public var homeDirectory: Swift.String?
        /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests. The IAM role that controls your users' access to your Amazon S3 bucket for servers with Domain=S3, or your EFS file system for servers with Domain=EFS. The policies attached to this role determine the level of access you want to provide your users when transferring files into and out of your S3 buckets or EFS file systems.
        public var role: Swift.String?
        /// Specifies the number of SSH public keys stored for the user you specified.
        public var sshPublicKeyCount: Swift.Int?
        /// Specifies the name of the user whose ARN was specified. User names are used for authentication purposes.
        public var userName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            role: Swift.String? = nil,
            sshPublicKeyCount: Swift.Int? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.homeDirectory = homeDirectory
            self.homeDirectoryType = homeDirectoryType
            self.role = role
            self.sshPublicKeyCount = sshPublicKeyCount
            self.userName = userName
        }
    }

}

extension TransferClientTypes {
    /// Contains the identifier, text description, and Amazon Resource Name (ARN) for the workflow.
    public struct ListedWorkflow {
        /// Specifies the unique Amazon Resource Name (ARN) for the workflow.
        public var arn: Swift.String?
        /// Specifies the text description for the workflow.
        public var description: Swift.String?
        /// A unique identifier for the workflow.
        public var workflowId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.workflowId = workflowId
        }
    }

}

public struct ListExecutionsInput {
    /// Specifies the maximum number of executions to return.
    public var maxResults: Swift.Int?
    /// ListExecutions returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional executions. This is useful for pagination, for instance. If you have 100 executions for a workflow, you might only want to list first 10. If so, call the API by specifying the max-results: aws transfer list-executions --max-results 10 This returns details for the first 10 executions, as well as the pointer (NextToken) to the eleventh execution. You can now call the API again, supplying the NextToken value you received: aws transfer list-executions --max-results 10 --next-token $somePointerReturnedFromPreviousListResult This call returns the next 10 executions, the 11th through the 20th. You can then repeat the call until the details for all 100 executions have been returned.
    public var nextToken: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowId = workflowId
    }
}

public struct ListExecutionsOutput {
    /// Returns the details for each execution, in a ListedExecution array.
    /// This member is required.
    public var executions: [TransferClientTypes.ListedExecution]?
    /// ListExecutions returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional executions.
    public var nextToken: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        executions: [TransferClientTypes.ListedExecution]? = nil,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.executions = executions
        self.nextToken = nextToken
        self.workflowId = workflowId
    }
}

public struct ListHostKeysInput {
    /// The maximum number of host keys to return.
    public var maxResults: Swift.Int?
    /// When there are additional results that were not returned, a NextToken parameter is returned. You can use that value for a subsequent call to ListHostKeys to continue listing results.
    public var nextToken: Swift.String?
    /// The identifier of the server that contains the host keys that you want to view.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

public struct ListHostKeysOutput {
    /// Returns an array, where each item contains the details of a host key.
    /// This member is required.
    public var hostKeys: [TransferClientTypes.ListedHostKey]?
    /// Returns a token that you can use to call ListHostKeys again and receive additional results, if there are any.
    public var nextToken: Swift.String?
    /// Returns the server identifier that contains the listed host keys.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        hostKeys: [TransferClientTypes.ListedHostKey]? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeys = hostKeys
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

public struct ListProfilesInput {
    /// The maximum number of profiles to return.
    public var maxResults: Swift.Int?
    /// When there are additional results that were not returned, a NextToken parameter is returned. You can use that value for a subsequent call to ListProfiles to continue listing results.
    public var nextToken: Swift.String?
    /// Indicates whether to list only LOCAL type profiles or only PARTNER type profiles. If not supplied in the request, the command lists all types of profiles.
    public var profileType: TransferClientTypes.ProfileType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileType: TransferClientTypes.ProfileType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileType = profileType
    }
}

public struct ListProfilesOutput {
    /// Returns a token that you can use to call ListProfiles again and receive additional results, if there are any.
    public var nextToken: Swift.String?
    /// Returns an array, where each item contains the details of a profile.
    /// This member is required.
    public var profiles: [TransferClientTypes.ListedProfile]?

    public init(
        nextToken: Swift.String? = nil,
        profiles: [TransferClientTypes.ListedProfile]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

public struct ListSecurityPoliciesInput {
    /// Specifies the number of security policies to return as a response to the ListSecurityPolicies query.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the ListSecurityPolicies command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional security policies.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListSecurityPoliciesOutput {
    /// When you can get additional results from the ListSecurityPolicies operation, a NextToken parameter is returned in the output. In a following command, you can pass in the NextToken parameter to continue listing security policies.
    public var nextToken: Swift.String?
    /// An array of security policies that were listed.
    /// This member is required.
    public var securityPolicyNames: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        securityPolicyNames: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityPolicyNames = securityPolicyNames
    }
}

public struct ListServersInput {
    /// Specifies the number of servers to return as a response to the ListServers query.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the ListServers command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional servers.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListServersOutput {
    /// When you can get additional results from the ListServers operation, a NextToken parameter is returned in the output. In a following command, you can pass in the NextToken parameter to continue listing additional servers.
    public var nextToken: Swift.String?
    /// An array of servers that were listed.
    /// This member is required.
    public var servers: [TransferClientTypes.ListedServer]?

    public init(
        nextToken: Swift.String? = nil,
        servers: [TransferClientTypes.ListedServer]? = nil
    )
    {
        self.nextToken = nextToken
        self.servers = servers
    }
}

public struct ListTagsForResourceInput {
    /// Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an identifier for a specific Amazon Web Services resource, such as a server, user, or role.
    /// This member is required.
    public var arn: Swift.String?
    /// Specifies the number of tags to return as a response to the ListTagsForResource request.
    public var maxResults: Swift.Int?
    /// When you request additional results from the ListTagsForResource operation, a NextToken parameter is returned in the input. You can then pass in a subsequent command to the NextToken parameter to continue listing additional tags.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceOutput {
    /// The ARN you specified to list the tags of.
    public var arn: Swift.String?
    /// When you can get additional results from the ListTagsForResource call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional tags.
    public var nextToken: Swift.String?
    /// Key-value pairs that are assigned to a resource, usually for the purpose of grouping and searching for items. Tags are metadata that you define.
    public var tags: [TransferClientTypes.Tag]?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct ListUsersInput {
    /// Specifies the number of users to return as a response to the ListUsers request.
    public var maxResults: Swift.Int?
    /// If there are additional results from the ListUsers call, a NextToken parameter is returned in the output. You can then pass the NextToken to a subsequent ListUsers command, to continue listing additional users.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that has users assigned to it.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

public struct ListUsersOutput {
    /// When you can get additional results from the ListUsers call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional users.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that the users are assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// Returns the Transfer Family users and their properties for the ServerId value that you specify.
    /// This member is required.
    public var users: [TransferClientTypes.ListedUser]?

    public init(
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil,
        users: [TransferClientTypes.ListedUser]? = nil
    )
    {
        self.nextToken = nextToken
        self.serverId = serverId
        self.users = users
    }
}

public struct ListWorkflowsInput {
    /// Specifies the maximum number of workflows to return.
    public var maxResults: Swift.Int?
    /// ListWorkflows returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional workflows.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListWorkflowsOutput {
    /// ListWorkflows returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional workflows.
    public var nextToken: Swift.String?
    /// Returns the Arn, WorkflowId, and Description for each workflow.
    /// This member is required.
    public var workflows: [TransferClientTypes.ListedWorkflow]?

    public init(
        nextToken: Swift.String? = nil,
        workflows: [TransferClientTypes.ListedWorkflow]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflows = workflows
    }
}

public struct UpdateProfileInput {
    /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
    public var certificateIds: [Swift.String]?
    /// The identifier of the profile object that you are updating.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        certificateIds: [Swift.String]? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.certificateIds = certificateIds
        self.profileId = profileId
    }
}

public struct UpdateProfileOutput {
    /// Returns the identifier for the profile that's being updated.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

public struct SendWorkflowStepStateInput {
    /// A unique identifier for the execution of a workflow.
    /// This member is required.
    public var executionId: Swift.String?
    /// Indicates whether the specified step succeeded or failed.
    /// This member is required.
    public var status: TransferClientTypes.CustomStepStatus?
    /// Used to distinguish between multiple callbacks for multiple Lambda steps within the same execution.
    /// This member is required.
    public var token: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        executionId: Swift.String? = nil,
        status: TransferClientTypes.CustomStepStatus? = nil,
        token: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.executionId = executionId
        self.status = status
        self.token = token
        self.workflowId = workflowId
    }
}

public struct SendWorkflowStepStateOutput {

    public init() { }
}

public struct UpdateServerInput {
    /// The Amazon Resource Name (ARN) of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when Protocols is set to FTPS. To request a new public certificate, see [Request a public certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html) in the Amazon Web ServicesCertificate Manager User Guide. To import an existing certificate into ACM, see [Importing certificates into ACM](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the Amazon Web ServicesCertificate Manager User Guide. To request a private certificate to use FTPS through private IP addresses, see [Request a private certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html) in the Amazon Web ServicesCertificate Manager User Guide. Certificates with the following cryptographic algorithms and key sizes are supported:
    ///
    /// * 2048-bit RSA (RSA_2048)
    ///
    /// * 4096-bit RSA (RSA_4096)
    ///
    /// * Elliptic Prime Curve 256 bit (EC_prime256v1)
    ///
    /// * Elliptic Prime Curve 384 bit (EC_secp384r1)
    ///
    /// * Elliptic Prime Curve 521 bit (EC_secp521r1)
    ///
    ///
    /// The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP address specified and information about the issuer.
    public var certificate: Swift.String?
    /// The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make your endpoint accessible only to resources within your VPC, or you can attach Elastic IP addresses and make your endpoint accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.
    public var endpointDetails: TransferClientTypes.EndpointDetails?
    /// The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC) or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it. After May 19, 2021, you won't be able to create a server using EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount if your account hasn't already done so before May 19, 2021. If you have already created servers with EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount on or before May 19, 2021, you will not be affected. After this date, use EndpointType=VPC. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint. It is recommended that you use VPC as the EndpointType. With this endpoint type, you have the option to directly associate up to three Elastic IPv4 addresses (BYO IP included) with your server's endpoint and use VPC security groups to restrict traffic by the client's public IP address. This is not possible with EndpointType set to VPC_ENDPOINT.
    public var endpointType: TransferClientTypes.EndpointType?
    /// The RSA, ECDSA, or ED25519 private key to use for your SFTP-enabled server. You can add multiple host keys, in case you want to rotate keys, or have a set of active keys that use different algorithms. Use the following command to generate an RSA 2048 bit key with no passphrase: ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key. Use a minimum value of 2048 for the -b option. You can create a stronger key by using 3072 or 4096. Use the following command to generate an ECDSA 256 bit key with no passphrase: ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key. Valid values for the -b option for ECDSA are 256, 384, and 521. Use the following command to generate an ED25519 key with no passphrase: ssh-keygen -t ed25519 -N "" -f my-new-server-key. For all of these commands, you can replace my-new-server-key with a string of your choice. If you aren't planning to migrate existing users from an existing SFTP-enabled server to a new server, don't update the host key. Accidentally changing a server's host key can be disruptive. For more information, see [Manage host keys for your SFTP-enabled server](https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key) in the Transfer Family User Guide.
    public var hostKey: Swift.String?
    /// An array containing all of the information required to call a customer's authentication API method.
    public var identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
    public var loggingRole: Swift.String?
    /// Specifies a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
    public var postAuthenticationLoginBanner: Swift.String?
    /// Specifies a string to display when users connect to a server. This string is displayed before the user authenticates. For example, the following banner displays details about using the system: This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel.
    public var preAuthenticationLoginBanner: Swift.String?
    /// The protocol settings that are configured for your server.
    ///
    /// * To indicate passive mode (for FTP and FTPS protocols), use the PassiveIp parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
    ///
    /// * To ignore the error that is generated when the client attempts to use the SETSTAT command on a file that you are uploading to an Amazon S3 bucket, use the SetStatOption parameter. To have the Transfer Family server ignore the SETSTAT command and upload files without needing to make any changes to your SFTP client, set the value to ENABLE_NO_OP. If you set the SetStatOption parameter to ENABLE_NO_OP, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a SETSTAT call.
    ///
    /// * To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the TlsSessionResumptionMode parameter.
    ///
    /// * As2Transports indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
    public var protocolDetails: TransferClientTypes.ProtocolDetails?
    /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:
    ///
    /// * SFTP (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH
    ///
    /// * FTPS (File Transfer Protocol Secure): File transfer with TLS encryption
    ///
    /// * FTP (File Transfer Protocol): Unencrypted file transfer
    ///
    /// * AS2 (Applicability Statement 2): used for transporting structured business-to-business data
    ///
    ///
    ///
    ///
    /// * If you select FTPS, you must choose a certificate stored in Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS.
    ///
    /// * If Protocol includes either FTP or FTPS, then the EndpointType must be VPC and the IdentityProviderType must be either AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
    ///
    /// * If Protocol includes FTP, then AddressAllocationIds cannot be associated.
    ///
    /// * If Protocol is set only to SFTP, the EndpointType can be set to PUBLIC and the IdentityProviderType can be set any of the supported identity types: SERVICE_MANAGED, AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
    ///
    /// * If Protocol includes AS2, then the EndpointType must be VPC, and domain must be Amazon S3.
    public var protocols: [TransferClientTypes.ModelProtocol]?
    /// Specifies whether or not performance for your Amazon S3 directories is optimized. This is disabled by default. By default, home directory mappings have a TYPE of DIRECTORY. If you enable this option, you would then need to explicitly set the HomeDirectoryMapEntryType to FILE if you want a mapping to have a file target.
    public var s3StorageOptions: TransferClientTypes.S3StorageOptions?
    /// Specifies the name of the security policy for the server.
    public var securityPolicyName: Swift.String?
    /// A system-assigned unique identifier for a server instance that the Transfer Family user is assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// Specifies the log groups to which your server logs are sent. To specify a log group, you must provide the ARN for an existing log group. In this case, the format of the log group is as follows: arn:aws:logs:region-name:amazon-account-id:log-group:log-group-name:* For example, arn:aws:logs:us-east-1:111122223333:log-group:mytestgroup:* If you have previously specified a log group for a server, you can clear it, and in effect turn off structured logging, by providing an empty value for this parameter in an update-server call. For example: update-server --server-id s-1234567890abcdef0 --structured-log-destinations
    public var structuredLogDestinations: [Swift.String]?
    /// Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow. In addition to a workflow to execute when a file is uploaded completely, WorkflowDetails can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when the server session disconnects while the file is still being uploaded. To remove an associated workflow from a server, you can provide an empty OnUpload object, as in the following example. aws transfer update-server --server-id s-01234567890abcdef --workflow-details '{"OnUpload":[]}'
    public var workflowDetails: TransferClientTypes.WorkflowDetails?

    public init(
        certificate: Swift.String? = nil,
        endpointDetails: TransferClientTypes.EndpointDetails? = nil,
        endpointType: TransferClientTypes.EndpointType? = nil,
        hostKey: Swift.String? = nil,
        identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
        loggingRole: Swift.String? = nil,
        postAuthenticationLoginBanner: Swift.String? = nil,
        preAuthenticationLoginBanner: Swift.String? = nil,
        protocolDetails: TransferClientTypes.ProtocolDetails? = nil,
        protocols: [TransferClientTypes.ModelProtocol]? = nil,
        s3StorageOptions: TransferClientTypes.S3StorageOptions? = nil,
        securityPolicyName: Swift.String? = nil,
        serverId: Swift.String? = nil,
        structuredLogDestinations: [Swift.String]? = nil,
        workflowDetails: TransferClientTypes.WorkflowDetails? = nil
    )
    {
        self.certificate = certificate
        self.endpointDetails = endpointDetails
        self.endpointType = endpointType
        self.hostKey = hostKey
        self.identityProviderDetails = identityProviderDetails
        self.loggingRole = loggingRole
        self.postAuthenticationLoginBanner = postAuthenticationLoginBanner
        self.preAuthenticationLoginBanner = preAuthenticationLoginBanner
        self.protocolDetails = protocolDetails
        self.protocols = protocols
        self.s3StorageOptions = s3StorageOptions
        self.securityPolicyName = securityPolicyName
        self.serverId = serverId
        self.structuredLogDestinations = structuredLogDestinations
        self.workflowDetails = workflowDetails
    }
}

extension UpdateServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServerInput(certificate: \(Swift.String(describing: certificate)), endpointDetails: \(Swift.String(describing: endpointDetails)), endpointType: \(Swift.String(describing: endpointType)), identityProviderDetails: \(Swift.String(describing: identityProviderDetails)), loggingRole: \(Swift.String(describing: loggingRole)), postAuthenticationLoginBanner: \(Swift.String(describing: postAuthenticationLoginBanner)), preAuthenticationLoginBanner: \(Swift.String(describing: preAuthenticationLoginBanner)), protocolDetails: \(Swift.String(describing: protocolDetails)), protocols: \(Swift.String(describing: protocols)), s3StorageOptions: \(Swift.String(describing: s3StorageOptions)), securityPolicyName: \(Swift.String(describing: securityPolicyName)), serverId: \(Swift.String(describing: serverId)), structuredLogDestinations: \(Swift.String(describing: structuredLogDestinations)), workflowDetails: \(Swift.String(describing: workflowDetails)), hostKey: \"CONTENT_REDACTED\")"}
}

public struct UpdateServerOutput {
    /// A system-assigned unique identifier for a server that the Transfer Family user is assigned to.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

public struct StartDirectoryListingInput {
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?
    /// An optional parameter where you can specify the maximum number of file/directory names to retrieve. The default value is 1,000.
    public var maxItems: Swift.Int?
    /// Specifies the path (bucket and prefix) in Amazon S3 storage to store the results of the directory listing.
    /// This member is required.
    public var outputDirectoryPath: Swift.String?
    /// Specifies the directory on the remote SFTP server for which you want to list its contents.
    /// This member is required.
    public var remoteDirectoryPath: Swift.String?

    public init(
        connectorId: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        outputDirectoryPath: Swift.String? = nil,
        remoteDirectoryPath: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
        self.maxItems = maxItems
        self.outputDirectoryPath = outputDirectoryPath
        self.remoteDirectoryPath = remoteDirectoryPath
    }
}

public struct StartDirectoryListingOutput {
    /// Returns a unique identifier for the directory listing call.
    /// This member is required.
    public var listingId: Swift.String?
    /// Returns the file name where the results are stored. This is a combination of the connector ID and the listing ID: <connector-id>-<listing-id>.json.
    /// This member is required.
    public var outputFileName: Swift.String?

    public init(
        listingId: Swift.String? = nil,
        outputFileName: Swift.String? = nil
    )
    {
        self.listingId = listingId
        self.outputFileName = outputFileName
    }
}

public struct StartFileTransferInput {
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?
    /// For an inbound transfer, the LocaDirectoryPath specifies the destination for one or more files that are transferred from the partner's SFTP server.
    public var localDirectoryPath: Swift.String?
    /// For an outbound transfer, the RemoteDirectoryPath specifies the destination for one or more files that are transferred to the partner's SFTP server. If you don't specify a RemoteDirectoryPath, the destination for transferred files is the SFTP user's home directory.
    public var remoteDirectoryPath: Swift.String?
    /// One or more source paths for the partner's SFTP server. Each string represents a source file path for one inbound file transfer.
    public var retrieveFilePaths: [Swift.String]?
    /// One or more source paths for the Amazon S3 storage. Each string represents a source file path for one outbound file transfer. For example,  DOC-EXAMPLE-BUCKET/myfile.txt . Replace  DOC-EXAMPLE-BUCKET  with one of your actual buckets.
    public var sendFilePaths: [Swift.String]?

    public init(
        connectorId: Swift.String? = nil,
        localDirectoryPath: Swift.String? = nil,
        remoteDirectoryPath: Swift.String? = nil,
        retrieveFilePaths: [Swift.String]? = nil,
        sendFilePaths: [Swift.String]? = nil
    )
    {
        self.connectorId = connectorId
        self.localDirectoryPath = localDirectoryPath
        self.remoteDirectoryPath = remoteDirectoryPath
        self.retrieveFilePaths = retrieveFilePaths
        self.sendFilePaths = sendFilePaths
    }
}

public struct StartFileTransferOutput {
    /// Returns the unique identifier for the file transfer.
    /// This member is required.
    public var transferId: Swift.String?

    public init(
        transferId: Swift.String? = nil
    )
    {
        self.transferId = transferId
    }
}

public struct StartServerInput {
    /// A system-assigned unique identifier for a server that you start.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

public struct StopServerInput {
    /// A system-assigned unique identifier for a server that you stopped.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

public struct TagResourceInput {
    /// An Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a server, user, or role.
    /// This member is required.
    public var arn: Swift.String?
    /// Key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (servers, users, workflows, and so on) for any purpose.
    /// This member is required.
    public var tags: [TransferClientTypes.Tag]?

    public init(
        arn: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

public struct TestConnectionInput {
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?

    public init(
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

public struct TestConnectionOutput {
    /// Returns the identifier of the connector object that you are testing.
    public var connectorId: Swift.String?
    /// Returns OK for successful test, or ERROR if the test fails.
    public var status: Swift.String?
    /// Returns Connection succeeded if the test is successful. Or, returns a descriptive error message if the test fails. The following list provides troubleshooting details, depending on the error message that you receive.
    ///
    /// * Verify that your secret name aligns with the one in Transfer Role permissions.
    ///
    /// * Verify the server URL in the connector configuration , and verify that the login credentials work successfully outside of the connector.
    ///
    /// * Verify that the secret exists and is formatted correctly.
    ///
    /// * Verify that the trusted host key in the connector configuration matches the ssh-keyscan output.
    public var statusMessage: Swift.String?

    public init(
        connectorId: Swift.String? = nil,
        status: Swift.String? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
        self.status = status
        self.statusMessage = statusMessage
    }
}

public struct TestIdentityProviderInput {
    /// A system-assigned identifier for a specific server. That server's user authentication method is tested with a user name and password.
    /// This member is required.
    public var serverId: Swift.String?
    /// The type of file transfer protocol to be tested. The available protocols are:
    ///
    /// * Secure Shell (SSH) File Transfer Protocol (SFTP)
    ///
    /// * File Transfer Protocol Secure (FTPS)
    ///
    /// * File Transfer Protocol (FTP)
    ///
    /// * Applicability Statement 2 (AS2)
    public var serverProtocol: TransferClientTypes.ModelProtocol?
    /// The source IP address of the account to be tested.
    public var sourceIp: Swift.String?
    /// The name of the account to be tested.
    /// This member is required.
    public var userName: Swift.String?
    /// The password of the account to be tested.
    public var userPassword: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        serverProtocol: TransferClientTypes.ModelProtocol? = nil,
        sourceIp: Swift.String? = nil,
        userName: Swift.String? = nil,
        userPassword: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.serverProtocol = serverProtocol
        self.sourceIp = sourceIp
        self.userName = userName
        self.userPassword = userPassword
    }
}

extension TestIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestIdentityProviderInput(serverId: \(Swift.String(describing: serverId)), serverProtocol: \(Swift.String(describing: serverProtocol)), sourceIp: \(Swift.String(describing: sourceIp)), userName: \(Swift.String(describing: userName)), userPassword: \"CONTENT_REDACTED\")"}
}

public struct TestIdentityProviderOutput {
    /// A message that indicates whether the test was successful or not. If an empty string is returned, the most likely cause is that the authentication failed due to an incorrect username or password.
    public var message: Swift.String?
    /// The response that is returned from your API Gateway or your Lambda function.
    public var response: Swift.String?
    /// The HTTP status code that is the response from your API Gateway or your Lambda function.
    /// This member is required.
    public var statusCode: Swift.Int
    /// The endpoint of the service used to authenticate a user.
    /// This member is required.
    public var url: Swift.String?

    public init(
        message: Swift.String? = nil,
        response: Swift.String? = nil,
        statusCode: Swift.Int = 0,
        url: Swift.String? = nil
    )
    {
        self.message = message
        self.response = response
        self.statusCode = statusCode
        self.url = url
    }
}

public struct UntagResourceInput {
    /// The value of the resource that will have the tag removed. An Amazon Resource Name (ARN) is an identifier for a specific Amazon Web Services resource, such as a server, user, or role.
    /// This member is required.
    public var arn: Swift.String?
    /// TagKeys are key-value pairs assigned to ARNs that can be used to group and search for resources by type. This metadata can be attached to resources for any purpose.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

public struct UpdateAccessInput {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock down your user to the designated home directory ("chroot"). To do this, you can set Entry to / and set Target to the HomeDirectory parameter value. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use session policies. For session policies, Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Example session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Amazon Web ServicesSecurity Token Service API Reference.
    public var policy: Swift.String?
    /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        externalId: Swift.String? = nil,
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
    }
}

public struct UpdateAccessOutput {
    /// The external identifier of the group whose users have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Amazon Web ServicesTransfer Family.
    /// This member is required.
    public var externalId: Swift.String?
    /// The identifier of the server that the user is attached to.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

public struct UpdateHostKeyInput {
    /// An updated description for the host key.
    /// This member is required.
    public var description: Swift.String?
    /// The identifier of the host key that you are updating.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// The identifier of the server that contains the host key that you are updating.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        description: Swift.String? = nil,
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.description = description
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

public struct UpdateHostKeyOutput {
    /// Returns the host key identifier for the updated host key.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// Returns the server identifier for the server that contains the updated host key.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

public struct UpdateUserInput {
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock down your user to the designated home directory ("chroot"). To do this, you can set Entry to '/' and set Target to the HomeDirectory parameter value. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use session policies. For session policies, Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Creating a session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Amazon Web Services Security Token Service API Reference.
    public var policy: Swift.String?
    /// Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon Elastic File Systems (Amazon EFS). The POSIX permissions that are set on files and directories in your file system determines the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a Transfer Family server instance that the user is assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique string that identifies a user and is associated with a server as specified by the ServerId. This user name must be a minimum of 3 and a maximum of 100 characters long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen '-', period '.', and at sign '@'. The user name can't start with a hyphen, period, or at sign.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
        self.userName = userName
    }
}

/// UpdateUserResponse returns the user name and identifier for the request to update a user's properties.
public struct UpdateUserOutput {
    /// A system-assigned unique identifier for a Transfer Family server instance that the account is assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// The unique identifier for a user that is assigned to a server instance that was specified in the request.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

extension CreateAccessInput {

    static func urlPathProvider(_ value: CreateAccessInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAgreementInput {

    static func urlPathProvider(_ value: CreateAgreementInput) -> Swift.String? {
        return "/"
    }
}

extension CreateConnectorInput {

    static func urlPathProvider(_ value: CreateConnectorInput) -> Swift.String? {
        return "/"
    }
}

extension CreateProfileInput {

    static func urlPathProvider(_ value: CreateProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateServerInput {

    static func urlPathProvider(_ value: CreateServerInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUserInput {

    static func urlPathProvider(_ value: CreateUserInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWorkflowInput {

    static func urlPathProvider(_ value: CreateWorkflowInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAccessInput {

    static func urlPathProvider(_ value: DeleteAccessInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAgreementInput {

    static func urlPathProvider(_ value: DeleteAgreementInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCertificateInput {

    static func urlPathProvider(_ value: DeleteCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteConnectorInput {

    static func urlPathProvider(_ value: DeleteConnectorInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteHostKeyInput {

    static func urlPathProvider(_ value: DeleteHostKeyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProfileInput {

    static func urlPathProvider(_ value: DeleteProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteServerInput {

    static func urlPathProvider(_ value: DeleteServerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSshPublicKeyInput {

    static func urlPathProvider(_ value: DeleteSshPublicKeyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUserInput {

    static func urlPathProvider(_ value: DeleteUserInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWorkflowInput {

    static func urlPathProvider(_ value: DeleteWorkflowInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAccessInput {

    static func urlPathProvider(_ value: DescribeAccessInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAgreementInput {

    static func urlPathProvider(_ value: DescribeAgreementInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCertificateInput {

    static func urlPathProvider(_ value: DescribeCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConnectorInput {

    static func urlPathProvider(_ value: DescribeConnectorInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeExecutionInput {

    static func urlPathProvider(_ value: DescribeExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeHostKeyInput {

    static func urlPathProvider(_ value: DescribeHostKeyInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeProfileInput {

    static func urlPathProvider(_ value: DescribeProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSecurityPolicyInput {

    static func urlPathProvider(_ value: DescribeSecurityPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeServerInput {

    static func urlPathProvider(_ value: DescribeServerInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeUserInput {

    static func urlPathProvider(_ value: DescribeUserInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWorkflowInput {

    static func urlPathProvider(_ value: DescribeWorkflowInput) -> Swift.String? {
        return "/"
    }
}

extension ImportCertificateInput {

    static func urlPathProvider(_ value: ImportCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension ImportHostKeyInput {

    static func urlPathProvider(_ value: ImportHostKeyInput) -> Swift.String? {
        return "/"
    }
}

extension ImportSshPublicKeyInput {

    static func urlPathProvider(_ value: ImportSshPublicKeyInput) -> Swift.String? {
        return "/"
    }
}

extension ListAccessesInput {

    static func urlPathProvider(_ value: ListAccessesInput) -> Swift.String? {
        return "/"
    }
}

extension ListAgreementsInput {

    static func urlPathProvider(_ value: ListAgreementsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCertificatesInput {

    static func urlPathProvider(_ value: ListCertificatesInput) -> Swift.String? {
        return "/"
    }
}

extension ListConnectorsInput {

    static func urlPathProvider(_ value: ListConnectorsInput) -> Swift.String? {
        return "/"
    }
}

extension ListExecutionsInput {

    static func urlPathProvider(_ value: ListExecutionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListHostKeysInput {

    static func urlPathProvider(_ value: ListHostKeysInput) -> Swift.String? {
        return "/"
    }
}

extension ListProfilesInput {

    static func urlPathProvider(_ value: ListProfilesInput) -> Swift.String? {
        return "/"
    }
}

extension ListSecurityPoliciesInput {

    static func urlPathProvider(_ value: ListSecurityPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension ListServersInput {

    static func urlPathProvider(_ value: ListServersInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListUsersInput {

    static func urlPathProvider(_ value: ListUsersInput) -> Swift.String? {
        return "/"
    }
}

extension ListWorkflowsInput {

    static func urlPathProvider(_ value: ListWorkflowsInput) -> Swift.String? {
        return "/"
    }
}

extension SendWorkflowStepStateInput {

    static func urlPathProvider(_ value: SendWorkflowStepStateInput) -> Swift.String? {
        return "/"
    }
}

extension StartDirectoryListingInput {

    static func urlPathProvider(_ value: StartDirectoryListingInput) -> Swift.String? {
        return "/"
    }
}

extension StartFileTransferInput {

    static func urlPathProvider(_ value: StartFileTransferInput) -> Swift.String? {
        return "/"
    }
}

extension StartServerInput {

    static func urlPathProvider(_ value: StartServerInput) -> Swift.String? {
        return "/"
    }
}

extension StopServerInput {

    static func urlPathProvider(_ value: StopServerInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TestConnectionInput {

    static func urlPathProvider(_ value: TestConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension TestIdentityProviderInput {

    static func urlPathProvider(_ value: TestIdentityProviderInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAccessInput {

    static func urlPathProvider(_ value: UpdateAccessInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAgreementInput {

    static func urlPathProvider(_ value: UpdateAgreementInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCertificateInput {

    static func urlPathProvider(_ value: UpdateCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateConnectorInput {

    static func urlPathProvider(_ value: UpdateConnectorInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateHostKeyInput {

    static func urlPathProvider(_ value: UpdateHostKeyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProfileInput {

    static func urlPathProvider(_ value: UpdateProfileInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateServerInput {

    static func urlPathProvider(_ value: UpdateServerInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateUserInput {

    static func urlPathProvider(_ value: UpdateUserInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAccessInput {

    static func write(value: CreateAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExternalId"].write(value.externalId)
        try writer["HomeDirectory"].write(value.homeDirectory)
        try writer["HomeDirectoryMappings"].writeList(value.homeDirectoryMappings, memberWritingClosure: TransferClientTypes.HomeDirectoryMapEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HomeDirectoryType"].write(value.homeDirectoryType)
        try writer["Policy"].write(value.policy)
        try writer["PosixProfile"].write(value.posixProfile, with: TransferClientTypes.PosixProfile.write(value:to:))
        try writer["Role"].write(value.role)
        try writer["ServerId"].write(value.serverId)
    }
}

extension CreateAgreementInput {

    static func write(value: CreateAgreementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessRole"].write(value.accessRole)
        try writer["BaseDirectory"].write(value.baseDirectory)
        try writer["Description"].write(value.description)
        try writer["LocalProfileId"].write(value.localProfileId)
        try writer["PartnerProfileId"].write(value.partnerProfileId)
        try writer["ServerId"].write(value.serverId)
        try writer["Status"].write(value.status)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TransferClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateConnectorInput {

    static func write(value: CreateConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessRole"].write(value.accessRole)
        try writer["As2Config"].write(value.as2Config, with: TransferClientTypes.As2ConnectorConfig.write(value:to:))
        try writer["LoggingRole"].write(value.loggingRole)
        try writer["SecurityPolicyName"].write(value.securityPolicyName)
        try writer["SftpConfig"].write(value.sftpConfig, with: TransferClientTypes.SftpConnectorConfig.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TransferClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Url"].write(value.url)
    }
}

extension CreateProfileInput {

    static func write(value: CreateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["As2Id"].write(value.as2Id)
        try writer["CertificateIds"].writeList(value.certificateIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProfileType"].write(value.profileType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TransferClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateServerInput {

    static func write(value: CreateServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Certificate"].write(value.certificate)
        try writer["Domain"].write(value.domain)
        try writer["EndpointDetails"].write(value.endpointDetails, with: TransferClientTypes.EndpointDetails.write(value:to:))
        try writer["EndpointType"].write(value.endpointType)
        try writer["HostKey"].write(value.hostKey)
        try writer["IdentityProviderDetails"].write(value.identityProviderDetails, with: TransferClientTypes.IdentityProviderDetails.write(value:to:))
        try writer["IdentityProviderType"].write(value.identityProviderType)
        try writer["LoggingRole"].write(value.loggingRole)
        try writer["PostAuthenticationLoginBanner"].write(value.postAuthenticationLoginBanner)
        try writer["PreAuthenticationLoginBanner"].write(value.preAuthenticationLoginBanner)
        try writer["ProtocolDetails"].write(value.protocolDetails, with: TransferClientTypes.ProtocolDetails.write(value:to:))
        try writer["Protocols"].writeList(value.protocols, memberWritingClosure: SmithyReadWrite.WritingClosureBox<TransferClientTypes.ModelProtocol>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["S3StorageOptions"].write(value.s3StorageOptions, with: TransferClientTypes.S3StorageOptions.write(value:to:))
        try writer["SecurityPolicyName"].write(value.securityPolicyName)
        try writer["StructuredLogDestinations"].writeList(value.structuredLogDestinations, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TransferClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkflowDetails"].write(value.workflowDetails, with: TransferClientTypes.WorkflowDetails.write(value:to:))
    }
}

extension CreateUserInput {

    static func write(value: CreateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HomeDirectory"].write(value.homeDirectory)
        try writer["HomeDirectoryMappings"].writeList(value.homeDirectoryMappings, memberWritingClosure: TransferClientTypes.HomeDirectoryMapEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HomeDirectoryType"].write(value.homeDirectoryType)
        try writer["Policy"].write(value.policy)
        try writer["PosixProfile"].write(value.posixProfile, with: TransferClientTypes.PosixProfile.write(value:to:))
        try writer["Role"].write(value.role)
        try writer["ServerId"].write(value.serverId)
        try writer["SshPublicKeyBody"].write(value.sshPublicKeyBody)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TransferClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserName"].write(value.userName)
    }
}

extension CreateWorkflowInput {

    static func write(value: CreateWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["OnExceptionSteps"].writeList(value.onExceptionSteps, memberWritingClosure: TransferClientTypes.WorkflowStep.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Steps"].writeList(value.steps, memberWritingClosure: TransferClientTypes.WorkflowStep.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TransferClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteAccessInput {

    static func write(value: DeleteAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExternalId"].write(value.externalId)
        try writer["ServerId"].write(value.serverId)
    }
}

extension DeleteAgreementInput {

    static func write(value: DeleteAgreementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgreementId"].write(value.agreementId)
        try writer["ServerId"].write(value.serverId)
    }
}

extension DeleteCertificateInput {

    static func write(value: DeleteCertificateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateId"].write(value.certificateId)
    }
}

extension DeleteConnectorInput {

    static func write(value: DeleteConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorId"].write(value.connectorId)
    }
}

extension DeleteHostKeyInput {

    static func write(value: DeleteHostKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HostKeyId"].write(value.hostKeyId)
        try writer["ServerId"].write(value.serverId)
    }
}

extension DeleteProfileInput {

    static func write(value: DeleteProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProfileId"].write(value.profileId)
    }
}

extension DeleteServerInput {

    static func write(value: DeleteServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServerId"].write(value.serverId)
    }
}

extension DeleteSshPublicKeyInput {

    static func write(value: DeleteSshPublicKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServerId"].write(value.serverId)
        try writer["SshPublicKeyId"].write(value.sshPublicKeyId)
        try writer["UserName"].write(value.userName)
    }
}

extension DeleteUserInput {

    static func write(value: DeleteUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServerId"].write(value.serverId)
        try writer["UserName"].write(value.userName)
    }
}

extension DeleteWorkflowInput {

    static func write(value: DeleteWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkflowId"].write(value.workflowId)
    }
}

extension DescribeAccessInput {

    static func write(value: DescribeAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExternalId"].write(value.externalId)
        try writer["ServerId"].write(value.serverId)
    }
}

extension DescribeAgreementInput {

    static func write(value: DescribeAgreementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgreementId"].write(value.agreementId)
        try writer["ServerId"].write(value.serverId)
    }
}

extension DescribeCertificateInput {

    static func write(value: DescribeCertificateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateId"].write(value.certificateId)
    }
}

extension DescribeConnectorInput {

    static func write(value: DescribeConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorId"].write(value.connectorId)
    }
}

extension DescribeExecutionInput {

    static func write(value: DescribeExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExecutionId"].write(value.executionId)
        try writer["WorkflowId"].write(value.workflowId)
    }
}

extension DescribeHostKeyInput {

    static func write(value: DescribeHostKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HostKeyId"].write(value.hostKeyId)
        try writer["ServerId"].write(value.serverId)
    }
}

extension DescribeProfileInput {

    static func write(value: DescribeProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProfileId"].write(value.profileId)
    }
}

extension DescribeSecurityPolicyInput {

    static func write(value: DescribeSecurityPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityPolicyName"].write(value.securityPolicyName)
    }
}

extension DescribeServerInput {

    static func write(value: DescribeServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServerId"].write(value.serverId)
    }
}

extension DescribeUserInput {

    static func write(value: DescribeUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServerId"].write(value.serverId)
        try writer["UserName"].write(value.userName)
    }
}

extension DescribeWorkflowInput {

    static func write(value: DescribeWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkflowId"].write(value.workflowId)
    }
}

extension ImportCertificateInput {

    static func write(value: ImportCertificateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActiveDate"].writeTimestamp(value.activeDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Certificate"].write(value.certificate)
        try writer["CertificateChain"].write(value.certificateChain)
        try writer["Description"].write(value.description)
        try writer["InactiveDate"].writeTimestamp(value.inactiveDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["PrivateKey"].write(value.privateKey)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TransferClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Usage"].write(value.usage)
    }
}

extension ImportHostKeyInput {

    static func write(value: ImportHostKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["HostKeyBody"].write(value.hostKeyBody)
        try writer["ServerId"].write(value.serverId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TransferClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ImportSshPublicKeyInput {

    static func write(value: ImportSshPublicKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServerId"].write(value.serverId)
        try writer["SshPublicKeyBody"].write(value.sshPublicKeyBody)
        try writer["UserName"].write(value.userName)
    }
}

extension ListAccessesInput {

    static func write(value: ListAccessesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServerId"].write(value.serverId)
    }
}

extension ListAgreementsInput {

    static func write(value: ListAgreementsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServerId"].write(value.serverId)
    }
}

extension ListCertificatesInput {

    static func write(value: ListCertificatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListConnectorsInput {

    static func write(value: ListConnectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListExecutionsInput {

    static func write(value: ListExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WorkflowId"].write(value.workflowId)
    }
}

extension ListHostKeysInput {

    static func write(value: ListHostKeysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServerId"].write(value.serverId)
    }
}

extension ListProfilesInput {

    static func write(value: ListProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ProfileType"].write(value.profileType)
    }
}

extension ListSecurityPoliciesInput {

    static func write(value: ListSecurityPoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListServersInput {

    static func write(value: ListServersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListUsersInput {

    static func write(value: ListUsersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServerId"].write(value.serverId)
    }
}

extension ListWorkflowsInput {

    static func write(value: ListWorkflowsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension SendWorkflowStepStateInput {

    static func write(value: SendWorkflowStepStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExecutionId"].write(value.executionId)
        try writer["Status"].write(value.status)
        try writer["Token"].write(value.token)
        try writer["WorkflowId"].write(value.workflowId)
    }
}

extension StartDirectoryListingInput {

    static func write(value: StartDirectoryListingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorId"].write(value.connectorId)
        try writer["MaxItems"].write(value.maxItems)
        try writer["OutputDirectoryPath"].write(value.outputDirectoryPath)
        try writer["RemoteDirectoryPath"].write(value.remoteDirectoryPath)
    }
}

extension StartFileTransferInput {

    static func write(value: StartFileTransferInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorId"].write(value.connectorId)
        try writer["LocalDirectoryPath"].write(value.localDirectoryPath)
        try writer["RemoteDirectoryPath"].write(value.remoteDirectoryPath)
        try writer["RetrieveFilePaths"].writeList(value.retrieveFilePaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SendFilePaths"].writeList(value.sendFilePaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartServerInput {

    static func write(value: StartServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServerId"].write(value.serverId)
    }
}

extension StopServerInput {

    static func write(value: StopServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServerId"].write(value.serverId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TransferClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TestConnectionInput {

    static func write(value: TestConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorId"].write(value.connectorId)
    }
}

extension TestIdentityProviderInput {

    static func write(value: TestIdentityProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServerId"].write(value.serverId)
        try writer["ServerProtocol"].write(value.serverProtocol)
        try writer["SourceIp"].write(value.sourceIp)
        try writer["UserName"].write(value.userName)
        try writer["UserPassword"].write(value.userPassword)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAccessInput {

    static func write(value: UpdateAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExternalId"].write(value.externalId)
        try writer["HomeDirectory"].write(value.homeDirectory)
        try writer["HomeDirectoryMappings"].writeList(value.homeDirectoryMappings, memberWritingClosure: TransferClientTypes.HomeDirectoryMapEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HomeDirectoryType"].write(value.homeDirectoryType)
        try writer["Policy"].write(value.policy)
        try writer["PosixProfile"].write(value.posixProfile, with: TransferClientTypes.PosixProfile.write(value:to:))
        try writer["Role"].write(value.role)
        try writer["ServerId"].write(value.serverId)
    }
}

extension UpdateAgreementInput {

    static func write(value: UpdateAgreementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessRole"].write(value.accessRole)
        try writer["AgreementId"].write(value.agreementId)
        try writer["BaseDirectory"].write(value.baseDirectory)
        try writer["Description"].write(value.description)
        try writer["LocalProfileId"].write(value.localProfileId)
        try writer["PartnerProfileId"].write(value.partnerProfileId)
        try writer["ServerId"].write(value.serverId)
        try writer["Status"].write(value.status)
    }
}

extension UpdateCertificateInput {

    static func write(value: UpdateCertificateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActiveDate"].writeTimestamp(value.activeDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["CertificateId"].write(value.certificateId)
        try writer["Description"].write(value.description)
        try writer["InactiveDate"].writeTimestamp(value.inactiveDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension UpdateConnectorInput {

    static func write(value: UpdateConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessRole"].write(value.accessRole)
        try writer["As2Config"].write(value.as2Config, with: TransferClientTypes.As2ConnectorConfig.write(value:to:))
        try writer["ConnectorId"].write(value.connectorId)
        try writer["LoggingRole"].write(value.loggingRole)
        try writer["SecurityPolicyName"].write(value.securityPolicyName)
        try writer["SftpConfig"].write(value.sftpConfig, with: TransferClientTypes.SftpConnectorConfig.write(value:to:))
        try writer["Url"].write(value.url)
    }
}

extension UpdateHostKeyInput {

    static func write(value: UpdateHostKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["HostKeyId"].write(value.hostKeyId)
        try writer["ServerId"].write(value.serverId)
    }
}

extension UpdateProfileInput {

    static func write(value: UpdateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateIds"].writeList(value.certificateIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProfileId"].write(value.profileId)
    }
}

extension UpdateServerInput {

    static func write(value: UpdateServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Certificate"].write(value.certificate)
        try writer["EndpointDetails"].write(value.endpointDetails, with: TransferClientTypes.EndpointDetails.write(value:to:))
        try writer["EndpointType"].write(value.endpointType)
        try writer["HostKey"].write(value.hostKey)
        try writer["IdentityProviderDetails"].write(value.identityProviderDetails, with: TransferClientTypes.IdentityProviderDetails.write(value:to:))
        try writer["LoggingRole"].write(value.loggingRole)
        try writer["PostAuthenticationLoginBanner"].write(value.postAuthenticationLoginBanner)
        try writer["PreAuthenticationLoginBanner"].write(value.preAuthenticationLoginBanner)
        try writer["ProtocolDetails"].write(value.protocolDetails, with: TransferClientTypes.ProtocolDetails.write(value:to:))
        try writer["Protocols"].writeList(value.protocols, memberWritingClosure: SmithyReadWrite.WritingClosureBox<TransferClientTypes.ModelProtocol>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["S3StorageOptions"].write(value.s3StorageOptions, with: TransferClientTypes.S3StorageOptions.write(value:to:))
        try writer["SecurityPolicyName"].write(value.securityPolicyName)
        try writer["ServerId"].write(value.serverId)
        try writer["StructuredLogDestinations"].writeList(value.structuredLogDestinations, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkflowDetails"].write(value.workflowDetails, with: TransferClientTypes.WorkflowDetails.write(value:to:))
    }
}

extension UpdateUserInput {

    static func write(value: UpdateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HomeDirectory"].write(value.homeDirectory)
        try writer["HomeDirectoryMappings"].writeList(value.homeDirectoryMappings, memberWritingClosure: TransferClientTypes.HomeDirectoryMapEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HomeDirectoryType"].write(value.homeDirectoryType)
        try writer["Policy"].write(value.policy)
        try writer["PosixProfile"].write(value.posixProfile, with: TransferClientTypes.PosixProfile.write(value:to:))
        try writer["Role"].write(value.role)
        try writer["ServerId"].write(value.serverId)
        try writer["UserName"].write(value.userName)
    }
}

extension CreateAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccessOutput()
        value.externalId = try reader["ExternalId"].readIfPresent() ?? ""
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateAgreementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAgreementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAgreementOutput()
        value.agreementId = try reader["AgreementId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectorOutput()
        value.connectorId = try reader["ConnectorId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProfileOutput()
        value.profileId = try reader["ProfileId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServerOutput()
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUserOutput()
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        return value
    }
}

extension CreateWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkflowOutput()
        value.workflowId = try reader["WorkflowId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccessOutput {
        return DeleteAccessOutput()
    }
}

extension DeleteAgreementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAgreementOutput {
        return DeleteAgreementOutput()
    }
}

extension DeleteCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCertificateOutput {
        return DeleteCertificateOutput()
    }
}

extension DeleteConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectorOutput {
        return DeleteConnectorOutput()
    }
}

extension DeleteHostKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteHostKeyOutput {
        return DeleteHostKeyOutput()
    }
}

extension DeleteProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProfileOutput {
        return DeleteProfileOutput()
    }
}

extension DeleteServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServerOutput {
        return DeleteServerOutput()
    }
}

extension DeleteSshPublicKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSshPublicKeyOutput {
        return DeleteSshPublicKeyOutput()
    }
}

extension DeleteUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserOutput {
        return DeleteUserOutput()
    }
}

extension DeleteWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkflowOutput {
        return DeleteWorkflowOutput()
    }
}

extension DescribeAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccessOutput()
        value.access = try reader["Access"].readIfPresent(with: TransferClientTypes.DescribedAccess.read(from:))
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        return value
    }
}

extension DescribeAgreementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAgreementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAgreementOutput()
        value.agreement = try reader["Agreement"].readIfPresent(with: TransferClientTypes.DescribedAgreement.read(from:))
        return value
    }
}

extension DescribeCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCertificateOutput()
        value.certificate = try reader["Certificate"].readIfPresent(with: TransferClientTypes.DescribedCertificate.read(from:))
        return value
    }
}

extension DescribeConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConnectorOutput()
        value.connector = try reader["Connector"].readIfPresent(with: TransferClientTypes.DescribedConnector.read(from:))
        return value
    }
}

extension DescribeExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeExecutionOutput()
        value.execution = try reader["Execution"].readIfPresent(with: TransferClientTypes.DescribedExecution.read(from:))
        value.workflowId = try reader["WorkflowId"].readIfPresent() ?? ""
        return value
    }
}

extension DescribeHostKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeHostKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeHostKeyOutput()
        value.hostKey = try reader["HostKey"].readIfPresent(with: TransferClientTypes.DescribedHostKey.read(from:))
        return value
    }
}

extension DescribeProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProfileOutput()
        value.profile = try reader["Profile"].readIfPresent(with: TransferClientTypes.DescribedProfile.read(from:))
        return value
    }
}

extension DescribeSecurityPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSecurityPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSecurityPolicyOutput()
        value.securityPolicy = try reader["SecurityPolicy"].readIfPresent(with: TransferClientTypes.DescribedSecurityPolicy.read(from:))
        return value
    }
}

extension DescribeServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeServerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeServerOutput()
        value.server = try reader["Server"].readIfPresent(with: TransferClientTypes.DescribedServer.read(from:))
        return value
    }
}

extension DescribeUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUserOutput()
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        value.user = try reader["User"].readIfPresent(with: TransferClientTypes.DescribedUser.read(from:))
        return value
    }
}

extension DescribeWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkflowOutput()
        value.workflow = try reader["Workflow"].readIfPresent(with: TransferClientTypes.DescribedWorkflow.read(from:))
        return value
    }
}

extension ImportCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportCertificateOutput()
        value.certificateId = try reader["CertificateId"].readIfPresent() ?? ""
        return value
    }
}

extension ImportHostKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportHostKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportHostKeyOutput()
        value.hostKeyId = try reader["HostKeyId"].readIfPresent() ?? ""
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        return value
    }
}

extension ImportSshPublicKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportSshPublicKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportSshPublicKeyOutput()
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        value.sshPublicKeyId = try reader["SshPublicKeyId"].readIfPresent() ?? ""
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        return value
    }
}

extension ListAccessesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccessesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccessesOutput()
        value.accesses = try reader["Accesses"].readListIfPresent(memberReadingClosure: TransferClientTypes.ListedAccess.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        return value
    }
}

extension ListAgreementsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAgreementsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgreementsOutput()
        value.agreements = try reader["Agreements"].readListIfPresent(memberReadingClosure: TransferClientTypes.ListedAgreement.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCertificatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCertificatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCertificatesOutput()
        value.certificates = try reader["Certificates"].readListIfPresent(memberReadingClosure: TransferClientTypes.ListedCertificate.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListConnectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConnectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectorsOutput()
        value.connectors = try reader["Connectors"].readListIfPresent(memberReadingClosure: TransferClientTypes.ListedConnector.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExecutionsOutput()
        value.executions = try reader["Executions"].readListIfPresent(memberReadingClosure: TransferClientTypes.ListedExecution.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workflowId = try reader["WorkflowId"].readIfPresent() ?? ""
        return value
    }
}

extension ListHostKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListHostKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListHostKeysOutput()
        value.hostKeys = try reader["HostKeys"].readListIfPresent(memberReadingClosure: TransferClientTypes.ListedHostKey.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        return value
    }
}

extension ListProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfilesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.profiles = try reader["Profiles"].readListIfPresent(memberReadingClosure: TransferClientTypes.ListedProfile.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSecurityPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSecurityPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSecurityPoliciesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.securityPolicyNames = try reader["SecurityPolicyNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListServersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.servers = try reader["Servers"].readListIfPresent(memberReadingClosure: TransferClientTypes.ListedServer.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TransferClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUsersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        value.users = try reader["Users"].readListIfPresent(memberReadingClosure: TransferClientTypes.ListedUser.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListWorkflowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkflowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkflowsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workflows = try reader["Workflows"].readListIfPresent(memberReadingClosure: TransferClientTypes.ListedWorkflow.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SendWorkflowStepStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendWorkflowStepStateOutput {
        return SendWorkflowStepStateOutput()
    }
}

extension StartDirectoryListingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDirectoryListingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDirectoryListingOutput()
        value.listingId = try reader["ListingId"].readIfPresent() ?? ""
        value.outputFileName = try reader["OutputFileName"].readIfPresent() ?? ""
        return value
    }
}

extension StartFileTransferOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartFileTransferOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartFileTransferOutput()
        value.transferId = try reader["TransferId"].readIfPresent() ?? ""
        return value
    }
}

extension StartServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartServerOutput {
        return StartServerOutput()
    }
}

extension StopServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopServerOutput {
        return StopServerOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TestConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestConnectionOutput()
        value.connectorId = try reader["ConnectorId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension TestIdentityProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestIdentityProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestIdentityProviderOutput()
        value.message = try reader["Message"].readIfPresent()
        value.response = try reader["Response"].readIfPresent()
        value.statusCode = try reader["StatusCode"].readIfPresent() ?? 0
        value.url = try reader["Url"].readIfPresent() ?? ""
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAccessOutput()
        value.externalId = try reader["ExternalId"].readIfPresent() ?? ""
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateAgreementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAgreementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAgreementOutput()
        value.agreementId = try reader["AgreementId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCertificateOutput()
        value.certificateId = try reader["CertificateId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConnectorOutput()
        value.connectorId = try reader["ConnectorId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateHostKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateHostKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateHostKeyOutput()
        value.hostKeyId = try reader["HostKeyId"].readIfPresent() ?? ""
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProfileOutput()
        value.profileId = try reader["ProfileId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServerOutput()
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUserOutput()
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        return value
    }
}

enum CreateAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAgreementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAgreementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteHostKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSshPublicKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAgreementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeHostKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSecurityPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportHostKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportSshPublicKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccessesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAgreementsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCertificatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConnectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListHostKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSecurityPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkflowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendWorkflowStepStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDirectoryListingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartFileTransferOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestIdentityProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAgreementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateHostKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceExistsException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resource = try reader["Resource"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resource = try reader["Resource"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceError {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServiceError {
        let reader = baseError.errorBodyReader
        var value = InternalServiceError()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        }
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TransferClientTypes.DescribedAccess {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.DescribedAccess {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.DescribedAccess()
        value.homeDirectory = try reader["HomeDirectory"].readIfPresent()
        value.homeDirectoryMappings = try reader["HomeDirectoryMappings"].readListIfPresent(memberReadingClosure: TransferClientTypes.HomeDirectoryMapEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.homeDirectoryType = try reader["HomeDirectoryType"].readIfPresent()
        value.policy = try reader["Policy"].readIfPresent()
        value.posixProfile = try reader["PosixProfile"].readIfPresent(with: TransferClientTypes.PosixProfile.read(from:))
        value.role = try reader["Role"].readIfPresent()
        value.externalId = try reader["ExternalId"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.PosixProfile {

    static func write(value: TransferClientTypes.PosixProfile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Gid"].write(value.gid)
        try writer["SecondaryGids"].writeList(value.secondaryGids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Uid"].write(value.uid)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.PosixProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.PosixProfile()
        value.uid = try reader["Uid"].readIfPresent() ?? 0
        value.gid = try reader["Gid"].readIfPresent() ?? 0
        value.secondaryGids = try reader["SecondaryGids"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TransferClientTypes.HomeDirectoryMapEntry {

    static func write(value: TransferClientTypes.HomeDirectoryMapEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Entry"].write(value.entry)
        try writer["Target"].write(value.target)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.HomeDirectoryMapEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.HomeDirectoryMapEntry()
        value.entry = try reader["Entry"].readIfPresent() ?? ""
        value.target = try reader["Target"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.DescribedAgreement {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.DescribedAgreement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.DescribedAgreement()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.agreementId = try reader["AgreementId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.serverId = try reader["ServerId"].readIfPresent()
        value.localProfileId = try reader["LocalProfileId"].readIfPresent()
        value.partnerProfileId = try reader["PartnerProfileId"].readIfPresent()
        value.baseDirectory = try reader["BaseDirectory"].readIfPresent()
        value.accessRole = try reader["AccessRole"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TransferClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TransferClientTypes.Tag {

    static func write(value: TransferClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension TransferClientTypes.DescribedCertificate {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.DescribedCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.DescribedCertificate()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.certificateId = try reader["CertificateId"].readIfPresent()
        value.usage = try reader["Usage"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.certificate = try reader["Certificate"].readIfPresent()
        value.certificateChain = try reader["CertificateChain"].readIfPresent()
        value.activeDate = try reader["ActiveDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.inactiveDate = try reader["InactiveDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.serial = try reader["Serial"].readIfPresent()
        value.notBeforeDate = try reader["NotBeforeDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.notAfterDate = try reader["NotAfterDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.type = try reader["Type"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TransferClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TransferClientTypes.DescribedConnector {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.DescribedConnector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.DescribedConnector()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.connectorId = try reader["ConnectorId"].readIfPresent()
        value.url = try reader["Url"].readIfPresent()
        value.as2Config = try reader["As2Config"].readIfPresent(with: TransferClientTypes.As2ConnectorConfig.read(from:))
        value.accessRole = try reader["AccessRole"].readIfPresent()
        value.loggingRole = try reader["LoggingRole"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TransferClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sftpConfig = try reader["SftpConfig"].readIfPresent(with: TransferClientTypes.SftpConnectorConfig.read(from:))
        value.serviceManagedEgressIpAddresses = try reader["ServiceManagedEgressIpAddresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityPolicyName = try reader["SecurityPolicyName"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.SftpConnectorConfig {

    static func write(value: TransferClientTypes.SftpConnectorConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TrustedHostKeys"].writeList(value.trustedHostKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserSecretId"].write(value.userSecretId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.SftpConnectorConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.SftpConnectorConfig()
        value.userSecretId = try reader["UserSecretId"].readIfPresent()
        value.trustedHostKeys = try reader["TrustedHostKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TransferClientTypes.As2ConnectorConfig {

    static func write(value: TransferClientTypes.As2ConnectorConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BasicAuthSecretId"].write(value.basicAuthSecretId)
        try writer["Compression"].write(value.compression)
        try writer["EncryptionAlgorithm"].write(value.encryptionAlgorithm)
        try writer["LocalProfileId"].write(value.localProfileId)
        try writer["MdnResponse"].write(value.mdnResponse)
        try writer["MdnSigningAlgorithm"].write(value.mdnSigningAlgorithm)
        try writer["MessageSubject"].write(value.messageSubject)
        try writer["PartnerProfileId"].write(value.partnerProfileId)
        try writer["SigningAlgorithm"].write(value.signingAlgorithm)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.As2ConnectorConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.As2ConnectorConfig()
        value.localProfileId = try reader["LocalProfileId"].readIfPresent()
        value.partnerProfileId = try reader["PartnerProfileId"].readIfPresent()
        value.messageSubject = try reader["MessageSubject"].readIfPresent()
        value.compression = try reader["Compression"].readIfPresent()
        value.encryptionAlgorithm = try reader["EncryptionAlgorithm"].readIfPresent()
        value.signingAlgorithm = try reader["SigningAlgorithm"].readIfPresent()
        value.mdnSigningAlgorithm = try reader["MdnSigningAlgorithm"].readIfPresent()
        value.mdnResponse = try reader["MdnResponse"].readIfPresent()
        value.basicAuthSecretId = try reader["BasicAuthSecretId"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.DescribedExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.DescribedExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.DescribedExecution()
        value.executionId = try reader["ExecutionId"].readIfPresent()
        value.initialFileLocation = try reader["InitialFileLocation"].readIfPresent(with: TransferClientTypes.FileLocation.read(from:))
        value.serviceMetadata = try reader["ServiceMetadata"].readIfPresent(with: TransferClientTypes.ServiceMetadata.read(from:))
        value.executionRole = try reader["ExecutionRole"].readIfPresent()
        value.loggingConfiguration = try reader["LoggingConfiguration"].readIfPresent(with: TransferClientTypes.LoggingConfiguration.read(from:))
        value.posixProfile = try reader["PosixProfile"].readIfPresent(with: TransferClientTypes.PosixProfile.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.results = try reader["Results"].readIfPresent(with: TransferClientTypes.ExecutionResults.read(from:))
        return value
    }
}

extension TransferClientTypes.ExecutionResults {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ExecutionResults {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ExecutionResults()
        value.steps = try reader["Steps"].readListIfPresent(memberReadingClosure: TransferClientTypes.ExecutionStepResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.onExceptionSteps = try reader["OnExceptionSteps"].readListIfPresent(memberReadingClosure: TransferClientTypes.ExecutionStepResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TransferClientTypes.ExecutionStepResult {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ExecutionStepResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ExecutionStepResult()
        value.stepType = try reader["StepType"].readIfPresent()
        value.outputs = try reader["Outputs"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: TransferClientTypes.ExecutionError.read(from:))
        return value
    }
}

extension TransferClientTypes.ExecutionError {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ExecutionError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ExecutionError()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension TransferClientTypes.LoggingConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.LoggingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.LoggingConfiguration()
        value.loggingRole = try reader["LoggingRole"].readIfPresent()
        value.logGroupName = try reader["LogGroupName"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.ServiceMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ServiceMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ServiceMetadata()
        value.userDetails = try reader["UserDetails"].readIfPresent(with: TransferClientTypes.UserDetails.read(from:))
        return value
    }
}

extension TransferClientTypes.UserDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.UserDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.UserDetails()
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        value.serverId = try reader["ServerId"].readIfPresent() ?? ""
        value.sessionId = try reader["SessionId"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.FileLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.FileLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.FileLocation()
        value.s3FileLocation = try reader["S3FileLocation"].readIfPresent(with: TransferClientTypes.S3FileLocation.read(from:))
        value.efsFileLocation = try reader["EfsFileLocation"].readIfPresent(with: TransferClientTypes.EfsFileLocation.read(from:))
        return value
    }
}

extension TransferClientTypes.EfsFileLocation {

    static func write(value: TransferClientTypes.EfsFileLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileSystemId"].write(value.fileSystemId)
        try writer["Path"].write(value.path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.EfsFileLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.EfsFileLocation()
        value.fileSystemId = try reader["FileSystemId"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.S3FileLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.S3FileLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.S3FileLocation()
        value.bucket = try reader["Bucket"].readIfPresent()
        value.key = try reader["Key"].readIfPresent()
        value.versionId = try reader["VersionId"].readIfPresent()
        value.etag = try reader["Etag"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.DescribedHostKey {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.DescribedHostKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.DescribedHostKey()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.hostKeyId = try reader["HostKeyId"].readIfPresent()
        value.hostKeyFingerprint = try reader["HostKeyFingerprint"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.dateImported = try reader["DateImported"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TransferClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TransferClientTypes.DescribedProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.DescribedProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.DescribedProfile()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.profileId = try reader["ProfileId"].readIfPresent()
        value.profileType = try reader["ProfileType"].readIfPresent()
        value.as2Id = try reader["As2Id"].readIfPresent()
        value.certificateIds = try reader["CertificateIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TransferClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TransferClientTypes.DescribedSecurityPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.DescribedSecurityPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.DescribedSecurityPolicy()
        value.fips = try reader["Fips"].readIfPresent()
        value.securityPolicyName = try reader["SecurityPolicyName"].readIfPresent() ?? ""
        value.sshCiphers = try reader["SshCiphers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sshKexs = try reader["SshKexs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sshMacs = try reader["SshMacs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tlsCiphers = try reader["TlsCiphers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sshHostKeyAlgorithms = try reader["SshHostKeyAlgorithms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        value.protocols = try reader["Protocols"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<TransferClientTypes.SecurityPolicyProtocol>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TransferClientTypes.DescribedServer {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.DescribedServer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.DescribedServer()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.certificate = try reader["Certificate"].readIfPresent()
        value.protocolDetails = try reader["ProtocolDetails"].readIfPresent(with: TransferClientTypes.ProtocolDetails.read(from:))
        value.domain = try reader["Domain"].readIfPresent()
        value.endpointDetails = try reader["EndpointDetails"].readIfPresent(with: TransferClientTypes.EndpointDetails.read(from:))
        value.endpointType = try reader["EndpointType"].readIfPresent()
        value.hostKeyFingerprint = try reader["HostKeyFingerprint"].readIfPresent()
        value.identityProviderDetails = try reader["IdentityProviderDetails"].readIfPresent(with: TransferClientTypes.IdentityProviderDetails.read(from:))
        value.identityProviderType = try reader["IdentityProviderType"].readIfPresent()
        value.loggingRole = try reader["LoggingRole"].readIfPresent()
        value.postAuthenticationLoginBanner = try reader["PostAuthenticationLoginBanner"].readIfPresent()
        value.preAuthenticationLoginBanner = try reader["PreAuthenticationLoginBanner"].readIfPresent()
        value.protocols = try reader["Protocols"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<TransferClientTypes.ModelProtocol>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityPolicyName = try reader["SecurityPolicyName"].readIfPresent()
        value.serverId = try reader["ServerId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TransferClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.userCount = try reader["UserCount"].readIfPresent()
        value.workflowDetails = try reader["WorkflowDetails"].readIfPresent(with: TransferClientTypes.WorkflowDetails.read(from:))
        value.structuredLogDestinations = try reader["StructuredLogDestinations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.s3StorageOptions = try reader["S3StorageOptions"].readIfPresent(with: TransferClientTypes.S3StorageOptions.read(from:))
        value.as2ServiceManagedEgressIpAddresses = try reader["As2ServiceManagedEgressIpAddresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TransferClientTypes.S3StorageOptions {

    static func write(value: TransferClientTypes.S3StorageOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryListingOptimization"].write(value.directoryListingOptimization)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.S3StorageOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.S3StorageOptions()
        value.directoryListingOptimization = try reader["DirectoryListingOptimization"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.WorkflowDetails {

    static func write(value: TransferClientTypes.WorkflowDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OnPartialUpload"].writeList(value.onPartialUpload, memberWritingClosure: TransferClientTypes.WorkflowDetail.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OnUpload"].writeList(value.onUpload, memberWritingClosure: TransferClientTypes.WorkflowDetail.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.WorkflowDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.WorkflowDetails()
        value.onUpload = try reader["OnUpload"].readListIfPresent(memberReadingClosure: TransferClientTypes.WorkflowDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.onPartialUpload = try reader["OnPartialUpload"].readListIfPresent(memberReadingClosure: TransferClientTypes.WorkflowDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TransferClientTypes.WorkflowDetail {

    static func write(value: TransferClientTypes.WorkflowDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExecutionRole"].write(value.executionRole)
        try writer["WorkflowId"].write(value.workflowId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.WorkflowDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.WorkflowDetail()
        value.workflowId = try reader["WorkflowId"].readIfPresent() ?? ""
        value.executionRole = try reader["ExecutionRole"].readIfPresent() ?? ""
        return value
    }
}

extension TransferClientTypes.IdentityProviderDetails {

    static func write(value: TransferClientTypes.IdentityProviderDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryId"].write(value.directoryId)
        try writer["Function"].write(value.function)
        try writer["InvocationRole"].write(value.invocationRole)
        try writer["SftpAuthenticationMethods"].write(value.sftpAuthenticationMethods)
        try writer["Url"].write(value.url)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.IdentityProviderDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.IdentityProviderDetails()
        value.url = try reader["Url"].readIfPresent()
        value.invocationRole = try reader["InvocationRole"].readIfPresent()
        value.directoryId = try reader["DirectoryId"].readIfPresent()
        value.function = try reader["Function"].readIfPresent()
        value.sftpAuthenticationMethods = try reader["SftpAuthenticationMethods"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.EndpointDetails {

    static func write(value: TransferClientTypes.EndpointDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressAllocationIds"].writeList(value.addressAllocationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcEndpointId"].write(value.vpcEndpointId)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.EndpointDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.EndpointDetails()
        value.addressAllocationIds = try reader["AddressAllocationIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcEndpointId = try reader["VpcEndpointId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TransferClientTypes.ProtocolDetails {

    static func write(value: TransferClientTypes.ProtocolDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["As2Transports"].writeList(value.as2Transports, memberWritingClosure: SmithyReadWrite.WritingClosureBox<TransferClientTypes.As2Transport>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PassiveIp"].write(value.passiveIp)
        try writer["SetStatOption"].write(value.setStatOption)
        try writer["TlsSessionResumptionMode"].write(value.tlsSessionResumptionMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ProtocolDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ProtocolDetails()
        value.passiveIp = try reader["PassiveIp"].readIfPresent()
        value.tlsSessionResumptionMode = try reader["TlsSessionResumptionMode"].readIfPresent()
        value.setStatOption = try reader["SetStatOption"].readIfPresent()
        value.as2Transports = try reader["As2Transports"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<TransferClientTypes.As2Transport>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TransferClientTypes.DescribedUser {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.DescribedUser {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.DescribedUser()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.homeDirectory = try reader["HomeDirectory"].readIfPresent()
        value.homeDirectoryMappings = try reader["HomeDirectoryMappings"].readListIfPresent(memberReadingClosure: TransferClientTypes.HomeDirectoryMapEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.homeDirectoryType = try reader["HomeDirectoryType"].readIfPresent()
        value.policy = try reader["Policy"].readIfPresent()
        value.posixProfile = try reader["PosixProfile"].readIfPresent(with: TransferClientTypes.PosixProfile.read(from:))
        value.role = try reader["Role"].readIfPresent()
        value.sshPublicKeys = try reader["SshPublicKeys"].readListIfPresent(memberReadingClosure: TransferClientTypes.SshPublicKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TransferClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.userName = try reader["UserName"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.SshPublicKey {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.SshPublicKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.SshPublicKey()
        value.dateImported = try reader["DateImported"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sshPublicKeyBody = try reader["SshPublicKeyBody"].readIfPresent() ?? ""
        value.sshPublicKeyId = try reader["SshPublicKeyId"].readIfPresent() ?? ""
        return value
    }
}

extension TransferClientTypes.DescribedWorkflow {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.DescribedWorkflow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.DescribedWorkflow()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.steps = try reader["Steps"].readListIfPresent(memberReadingClosure: TransferClientTypes.WorkflowStep.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.onExceptionSteps = try reader["OnExceptionSteps"].readListIfPresent(memberReadingClosure: TransferClientTypes.WorkflowStep.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.workflowId = try reader["WorkflowId"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TransferClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TransferClientTypes.WorkflowStep {

    static func write(value: TransferClientTypes.WorkflowStep?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CopyStepDetails"].write(value.copyStepDetails, with: TransferClientTypes.CopyStepDetails.write(value:to:))
        try writer["CustomStepDetails"].write(value.customStepDetails, with: TransferClientTypes.CustomStepDetails.write(value:to:))
        try writer["DecryptStepDetails"].write(value.decryptStepDetails, with: TransferClientTypes.DecryptStepDetails.write(value:to:))
        try writer["DeleteStepDetails"].write(value.deleteStepDetails, with: TransferClientTypes.DeleteStepDetails.write(value:to:))
        try writer["TagStepDetails"].write(value.tagStepDetails, with: TransferClientTypes.TagStepDetails.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.WorkflowStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.WorkflowStep()
        value.type = try reader["Type"].readIfPresent()
        value.copyStepDetails = try reader["CopyStepDetails"].readIfPresent(with: TransferClientTypes.CopyStepDetails.read(from:))
        value.customStepDetails = try reader["CustomStepDetails"].readIfPresent(with: TransferClientTypes.CustomStepDetails.read(from:))
        value.deleteStepDetails = try reader["DeleteStepDetails"].readIfPresent(with: TransferClientTypes.DeleteStepDetails.read(from:))
        value.tagStepDetails = try reader["TagStepDetails"].readIfPresent(with: TransferClientTypes.TagStepDetails.read(from:))
        value.decryptStepDetails = try reader["DecryptStepDetails"].readIfPresent(with: TransferClientTypes.DecryptStepDetails.read(from:))
        return value
    }
}

extension TransferClientTypes.DecryptStepDetails {

    static func write(value: TransferClientTypes.DecryptStepDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationFileLocation"].write(value.destinationFileLocation, with: TransferClientTypes.InputFileLocation.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["OverwriteExisting"].write(value.overwriteExisting)
        try writer["SourceFileLocation"].write(value.sourceFileLocation)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.DecryptStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.DecryptStepDetails()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.sourceFileLocation = try reader["SourceFileLocation"].readIfPresent()
        value.overwriteExisting = try reader["OverwriteExisting"].readIfPresent()
        value.destinationFileLocation = try reader["DestinationFileLocation"].readIfPresent(with: TransferClientTypes.InputFileLocation.read(from:))
        return value
    }
}

extension TransferClientTypes.InputFileLocation {

    static func write(value: TransferClientTypes.InputFileLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EfsFileLocation"].write(value.efsFileLocation, with: TransferClientTypes.EfsFileLocation.write(value:to:))
        try writer["S3FileLocation"].write(value.s3FileLocation, with: TransferClientTypes.S3InputFileLocation.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.InputFileLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.InputFileLocation()
        value.s3FileLocation = try reader["S3FileLocation"].readIfPresent(with: TransferClientTypes.S3InputFileLocation.read(from:))
        value.efsFileLocation = try reader["EfsFileLocation"].readIfPresent(with: TransferClientTypes.EfsFileLocation.read(from:))
        return value
    }
}

extension TransferClientTypes.S3InputFileLocation {

    static func write(value: TransferClientTypes.S3InputFileLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bucket"].write(value.bucket)
        try writer["Key"].write(value.key)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.S3InputFileLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.S3InputFileLocation()
        value.bucket = try reader["Bucket"].readIfPresent()
        value.key = try reader["Key"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.TagStepDetails {

    static func write(value: TransferClientTypes.TagStepDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["SourceFileLocation"].write(value.sourceFileLocation)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TransferClientTypes.S3Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.TagStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.TagStepDetails()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TransferClientTypes.S3Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceFileLocation = try reader["SourceFileLocation"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.S3Tag {

    static func write(value: TransferClientTypes.S3Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.S3Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.S3Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension TransferClientTypes.DeleteStepDetails {

    static func write(value: TransferClientTypes.DeleteStepDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["SourceFileLocation"].write(value.sourceFileLocation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.DeleteStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.DeleteStepDetails()
        value.name = try reader["Name"].readIfPresent()
        value.sourceFileLocation = try reader["SourceFileLocation"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.CustomStepDetails {

    static func write(value: TransferClientTypes.CustomStepDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["SourceFileLocation"].write(value.sourceFileLocation)
        try writer["Target"].write(value.target)
        try writer["TimeoutSeconds"].write(value.timeoutSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.CustomStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.CustomStepDetails()
        value.name = try reader["Name"].readIfPresent()
        value.target = try reader["Target"].readIfPresent()
        value.timeoutSeconds = try reader["TimeoutSeconds"].readIfPresent()
        value.sourceFileLocation = try reader["SourceFileLocation"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.CopyStepDetails {

    static func write(value: TransferClientTypes.CopyStepDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationFileLocation"].write(value.destinationFileLocation, with: TransferClientTypes.InputFileLocation.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["OverwriteExisting"].write(value.overwriteExisting)
        try writer["SourceFileLocation"].write(value.sourceFileLocation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.CopyStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.CopyStepDetails()
        value.name = try reader["Name"].readIfPresent()
        value.destinationFileLocation = try reader["DestinationFileLocation"].readIfPresent(with: TransferClientTypes.InputFileLocation.read(from:))
        value.overwriteExisting = try reader["OverwriteExisting"].readIfPresent()
        value.sourceFileLocation = try reader["SourceFileLocation"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.ListedAccess {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ListedAccess {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ListedAccess()
        value.homeDirectory = try reader["HomeDirectory"].readIfPresent()
        value.homeDirectoryType = try reader["HomeDirectoryType"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.externalId = try reader["ExternalId"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.ListedAgreement {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ListedAgreement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ListedAgreement()
        value.arn = try reader["Arn"].readIfPresent()
        value.agreementId = try reader["AgreementId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.serverId = try reader["ServerId"].readIfPresent()
        value.localProfileId = try reader["LocalProfileId"].readIfPresent()
        value.partnerProfileId = try reader["PartnerProfileId"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.ListedCertificate {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ListedCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ListedCertificate()
        value.arn = try reader["Arn"].readIfPresent()
        value.certificateId = try reader["CertificateId"].readIfPresent()
        value.usage = try reader["Usage"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.activeDate = try reader["ActiveDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.inactiveDate = try reader["InactiveDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.type = try reader["Type"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.ListedConnector {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ListedConnector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ListedConnector()
        value.arn = try reader["Arn"].readIfPresent()
        value.connectorId = try reader["ConnectorId"].readIfPresent()
        value.url = try reader["Url"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.ListedExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ListedExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ListedExecution()
        value.executionId = try reader["ExecutionId"].readIfPresent()
        value.initialFileLocation = try reader["InitialFileLocation"].readIfPresent(with: TransferClientTypes.FileLocation.read(from:))
        value.serviceMetadata = try reader["ServiceMetadata"].readIfPresent(with: TransferClientTypes.ServiceMetadata.read(from:))
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.ListedHostKey {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ListedHostKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ListedHostKey()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.hostKeyId = try reader["HostKeyId"].readIfPresent()
        value.fingerprint = try reader["Fingerprint"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.dateImported = try reader["DateImported"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension TransferClientTypes.ListedProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ListedProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ListedProfile()
        value.arn = try reader["Arn"].readIfPresent()
        value.profileId = try reader["ProfileId"].readIfPresent()
        value.as2Id = try reader["As2Id"].readIfPresent()
        value.profileType = try reader["ProfileType"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.ListedServer {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ListedServer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ListedServer()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.domain = try reader["Domain"].readIfPresent()
        value.identityProviderType = try reader["IdentityProviderType"].readIfPresent()
        value.endpointType = try reader["EndpointType"].readIfPresent()
        value.loggingRole = try reader["LoggingRole"].readIfPresent()
        value.serverId = try reader["ServerId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.userCount = try reader["UserCount"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.ListedUser {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ListedUser {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ListedUser()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.homeDirectory = try reader["HomeDirectory"].readIfPresent()
        value.homeDirectoryType = try reader["HomeDirectoryType"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.sshPublicKeyCount = try reader["SshPublicKeyCount"].readIfPresent()
        value.userName = try reader["UserName"].readIfPresent()
        return value
    }
}

extension TransferClientTypes.ListedWorkflow {

    static func read(from reader: SmithyJSON.Reader) throws -> TransferClientTypes.ListedWorkflow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TransferClientTypes.ListedWorkflow()
        value.workflowId = try reader["WorkflowId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

public enum TransferClientTypes {}
