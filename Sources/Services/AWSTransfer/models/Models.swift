// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDenied" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransferClientTypes {
    public enum AgreementStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AgreementStatusType] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgreementStatusType(rawValue: rawValue) ?? AgreementStatusType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.As2ConnectorConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basicAuthSecretId = "BasicAuthSecretId"
        case compression = "Compression"
        case encryptionAlgorithm = "EncryptionAlgorithm"
        case localProfileId = "LocalProfileId"
        case mdnResponse = "MdnResponse"
        case mdnSigningAlgorithm = "MdnSigningAlgorithm"
        case messageSubject = "MessageSubject"
        case partnerProfileId = "PartnerProfileId"
        case signingAlgorithm = "SigningAlgorithm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basicAuthSecretId = self.basicAuthSecretId {
            try encodeContainer.encode(basicAuthSecretId, forKey: .basicAuthSecretId)
        }
        if let compression = self.compression {
            try encodeContainer.encode(compression.rawValue, forKey: .compression)
        }
        if let encryptionAlgorithm = self.encryptionAlgorithm {
            try encodeContainer.encode(encryptionAlgorithm.rawValue, forKey: .encryptionAlgorithm)
        }
        if let localProfileId = self.localProfileId {
            try encodeContainer.encode(localProfileId, forKey: .localProfileId)
        }
        if let mdnResponse = self.mdnResponse {
            try encodeContainer.encode(mdnResponse.rawValue, forKey: .mdnResponse)
        }
        if let mdnSigningAlgorithm = self.mdnSigningAlgorithm {
            try encodeContainer.encode(mdnSigningAlgorithm.rawValue, forKey: .mdnSigningAlgorithm)
        }
        if let messageSubject = self.messageSubject {
            try encodeContainer.encode(messageSubject, forKey: .messageSubject)
        }
        if let partnerProfileId = self.partnerProfileId {
            try encodeContainer.encode(partnerProfileId, forKey: .partnerProfileId)
        }
        if let signingAlgorithm = self.signingAlgorithm {
            try encodeContainer.encode(signingAlgorithm.rawValue, forKey: .signingAlgorithm)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localProfileId)
        localProfileId = localProfileIdDecoded
        let partnerProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerProfileId)
        partnerProfileId = partnerProfileIdDecoded
        let messageSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageSubject)
        messageSubject = messageSubjectDecoded
        let compressionDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CompressionEnum.self, forKey: .compression)
        compression = compressionDecoded
        let encryptionAlgorithmDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EncryptionAlg.self, forKey: .encryptionAlgorithm)
        encryptionAlgorithm = encryptionAlgorithmDecoded
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(TransferClientTypes.SigningAlg.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
        let mdnSigningAlgorithmDecoded = try containerValues.decodeIfPresent(TransferClientTypes.MdnSigningAlg.self, forKey: .mdnSigningAlgorithm)
        mdnSigningAlgorithm = mdnSigningAlgorithmDecoded
        let mdnResponseDecoded = try containerValues.decodeIfPresent(TransferClientTypes.MdnResponse.self, forKey: .mdnResponse)
        mdnResponse = mdnResponseDecoded
        let basicAuthSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basicAuthSecretId)
        basicAuthSecretId = basicAuthSecretIdDecoded
    }
}

extension TransferClientTypes {
    /// Contains the details for an AS2 connector object. The connector object is used for AS2 outbound processes, to connect the Transfer Family customer with the trading partner.
    public struct As2ConnectorConfig: Swift.Equatable {
        /// Provides Basic authentication support to the AS2 Connectors API. To use Basic authentication, you must provide the name or Amazon Resource Name (ARN) of a secret in Secrets Manager. The default value for this parameter is null, which indicates that Basic authentication is not enabled for the connector. If the connector should use Basic authentication, the secret needs to be in the following format: { "Username": "user-name", "Password": "user-password" } Replace user-name and user-password with the credentials for the actual user that is being authenticated. Note the following:
        ///
        /// * You are storing these credentials in Secrets Manager, not passing them directly into this API.
        ///
        /// * If you are using the API, SDKs, or CloudFormation to configure your connector, then you must create the secret before you can enable Basic authentication. However, if you are using the Amazon Web Services management console, you can have the system create the secret for you.
        ///
        ///
        /// If you have previously enabled Basic authentication for a connector, you can disable it by using the UpdateConnector API call. For example, if you are using the CLI, you can run the following command to remove Basic authentication: update-connector --connector-id my-connector-id --as2-config 'BasicAuthSecretId=""'
        public var basicAuthSecretId: Swift.String?
        /// Specifies whether the AS2 file is compressed.
        public var compression: TransferClientTypes.CompressionEnum?
        /// The algorithm that is used to encrypt the file. Note the following:
        ///
        /// * Do not use the DES_EDE3_CBC algorithm unless you must support a legacy client that requires it, as it is a weak encryption algorithm.
        ///
        /// * You can only specify NONE if the URL for your connector uses HTTPS. Using HTTPS ensures that no traffic is sent in clear text.
        public var encryptionAlgorithm: TransferClientTypes.EncryptionAlg?
        /// A unique identifier for the AS2 local profile.
        public var localProfileId: Swift.String?
        /// Used for outbound requests (from an Transfer Family server to a partner AS2 server) to determine whether the partner response for transfers is synchronous or asynchronous. Specify either of the following values:
        ///
        /// * SYNC: The system expects a synchronous MDN response, confirming that the file was transferred successfully (or not).
        ///
        /// * NONE: Specifies that no MDN response is required.
        public var mdnResponse: TransferClientTypes.MdnResponse?
        /// The signing algorithm for the MDN response. If set to DEFAULT (or not set at all), the value for SigningAlgorithm is used.
        public var mdnSigningAlgorithm: TransferClientTypes.MdnSigningAlg?
        /// Used as the Subject HTTP header attribute in AS2 messages that are being sent with the connector.
        public var messageSubject: Swift.String?
        /// A unique identifier for the partner profile for the connector.
        public var partnerProfileId: Swift.String?
        /// The algorithm that is used to sign the AS2 messages sent with the connector.
        public var signingAlgorithm: TransferClientTypes.SigningAlg?

        public init(
            basicAuthSecretId: Swift.String? = nil,
            compression: TransferClientTypes.CompressionEnum? = nil,
            encryptionAlgorithm: TransferClientTypes.EncryptionAlg? = nil,
            localProfileId: Swift.String? = nil,
            mdnResponse: TransferClientTypes.MdnResponse? = nil,
            mdnSigningAlgorithm: TransferClientTypes.MdnSigningAlg? = nil,
            messageSubject: Swift.String? = nil,
            partnerProfileId: Swift.String? = nil,
            signingAlgorithm: TransferClientTypes.SigningAlg? = nil
        )
        {
            self.basicAuthSecretId = basicAuthSecretId
            self.compression = compression
            self.encryptionAlgorithm = encryptionAlgorithm
            self.localProfileId = localProfileId
            self.mdnResponse = mdnResponse
            self.mdnSigningAlgorithm = mdnSigningAlgorithm
            self.messageSubject = messageSubject
            self.partnerProfileId = partnerProfileId
            self.signingAlgorithm = signingAlgorithm
        }
    }

}

extension TransferClientTypes {
    public enum As2Transport: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [As2Transport] {
            return [
                .http,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = As2Transport(rawValue: rawValue) ?? As2Transport.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum CertificateStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case pendingRotation
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateStatusType] {
            return [
                .active,
                .inactive,
                .pendingRotation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .pendingRotation: return "PENDING_ROTATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateStatusType(rawValue: rawValue) ?? CertificateStatusType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum CertificateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case certificate
        case certificateWithPrivateKey
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateType] {
            return [
                .certificate,
                .certificateWithPrivateKey,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .certificate: return "CERTIFICATE"
            case .certificateWithPrivateKey: return "CERTIFICATE_WITH_PRIVATE_KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateType(rawValue: rawValue) ?? CertificateType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum CertificateUsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case encryption
        case signing
        case tls
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateUsageType] {
            return [
                .encryption,
                .signing,
                .tls,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .encryption: return "ENCRYPTION"
            case .signing: return "SIGNING"
            case .tls: return "TLS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateUsageType(rawValue: rawValue) ?? CertificateUsageType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum CompressionEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case zlib
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionEnum] {
            return [
                .disabled,
                .zlib,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .zlib: return "ZLIB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CompressionEnum(rawValue: rawValue) ?? CompressionEnum.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the UpdateServer is called for a file transfer protocol-enabled server that has VPC as the endpoint type and the server's VpcEndpointID is not in the available state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransferClientTypes.CopyStepDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationFileLocation = "DestinationFileLocation"
        case name = "Name"
        case overwriteExisting = "OverwriteExisting"
        case sourceFileLocation = "SourceFileLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationFileLocation = self.destinationFileLocation {
            try encodeContainer.encode(destinationFileLocation, forKey: .destinationFileLocation)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overwriteExisting = self.overwriteExisting {
            try encodeContainer.encode(overwriteExisting.rawValue, forKey: .overwriteExisting)
        }
        if let sourceFileLocation = self.sourceFileLocation {
            try encodeContainer.encode(sourceFileLocation, forKey: .sourceFileLocation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.InputFileLocation.self, forKey: .destinationFileLocation)
        destinationFileLocation = destinationFileLocationDecoded
        let overwriteExistingDecoded = try containerValues.decodeIfPresent(TransferClientTypes.OverwriteExisting.self, forKey: .overwriteExisting)
        overwriteExisting = overwriteExistingDecoded
        let sourceFileLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileLocation)
        sourceFileLocation = sourceFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure.
    public struct CopyStepDetails: Swift.Equatable {
        /// Specifies the location for the file being copied. Use ${Transfer:UserName} or ${Transfer:UploadDate} in this field to parametrize the destination prefix by username or uploaded date.
        ///
        /// * Set the value of DestinationFileLocation to ${Transfer:UserName} to copy uploaded files to an Amazon S3 bucket that is prefixed with the name of the Transfer Family user that uploaded the file.
        ///
        /// * Set the value of DestinationFileLocation to ${Transfer:UploadDate} to copy uploaded files to an Amazon S3 bucket that is prefixed with the date of the upload. The system resolves UploadDate to a date format of YYYY-MM-DD, based on the date the file is uploaded in UTC.
        public var destinationFileLocation: TransferClientTypes.InputFileLocation?
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// A flag that indicates whether to overwrite an existing file of the same name. The default is FALSE. If the workflow is processing a file that has the same name as an existing file, the behavior is as follows:
        ///
        /// * If OverwriteExisting is TRUE, the existing file is replaced with the file being processed.
        ///
        /// * If OverwriteExisting is FALSE, nothing happens, and the workflow processing stops.
        public var overwriteExisting: TransferClientTypes.OverwriteExisting?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?

        public init(
            destinationFileLocation: TransferClientTypes.InputFileLocation? = nil,
            name: Swift.String? = nil,
            overwriteExisting: TransferClientTypes.OverwriteExisting? = nil,
            sourceFileLocation: Swift.String? = nil
        )
        {
            self.destinationFileLocation = destinationFileLocation
            self.name = name
            self.overwriteExisting = overwriteExisting
            self.sourceFileLocation = sourceFileLocation
        }
    }

}

extension CreateAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymapentry0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymapentry0)
            }
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = self.posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension CreateAccessInput {

    static func urlPathProvider(_ value: CreateAccessInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateAccessInput: Swift.Equatable {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock down your user to the designated home directory ("chroot"). To do this, you can set Entry to / and set Target to the HomeDirectory parameter value. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use session policies. For session policies, Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Example session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Security Token Service API Reference.
    public var policy: Swift.String?
    /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    /// This member is required.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        externalId: Swift.String? = nil,
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
    }
}

struct CreateAccessInputBody: Swift.Equatable {
    let homeDirectory: Swift.String?
    let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    let policy: Swift.String?
    let posixProfile: TransferClientTypes.PosixProfile?
    let role: Swift.String?
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension CreateAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension CreateAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.externalId = output.externalId
            self.serverId = output.serverId
        } else {
            self.externalId = nil
            self.serverId = nil
        }
    }
}

public struct CreateAccessOutput: Swift.Equatable {
    /// The external identifier of the group whose users have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family.
    /// This member is required.
    public var externalId: Swift.String?
    /// The identifier of the server that the user is attached to.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct CreateAccessOutputBody: Swift.Equatable {
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension CreateAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

enum CreateAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAgreementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case baseDirectory = "BaseDirectory"
        case description = "Description"
        case localProfileId = "LocalProfileId"
        case partnerProfileId = "PartnerProfileId"
        case serverId = "ServerId"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = self.accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let baseDirectory = self.baseDirectory {
            try encodeContainer.encode(baseDirectory, forKey: .baseDirectory)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let localProfileId = self.localProfileId {
            try encodeContainer.encode(localProfileId, forKey: .localProfileId)
        }
        if let partnerProfileId = self.partnerProfileId {
            try encodeContainer.encode(partnerProfileId, forKey: .partnerProfileId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAgreementInput {

    static func urlPathProvider(_ value: CreateAgreementInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateAgreementInput: Swift.Equatable {
    /// Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use. For AS2 connectors With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the fileâ€™s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer. If you are using Basic authentication for your AS2 connector, the access role requires the secretsmanager:GetSecretValue permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the kms:Decrypt permission for that key. For SFTP connectors Make sure that the access role provides read and write access to the parent directory of the file location that's used in the StartFileTransfer request. Additionally, make sure that the role provides secretsmanager:GetSecretValue permission to Secrets Manager.
    /// This member is required.
    public var accessRole: Swift.String?
    /// The landing directory (folder) for files transferred by using the AS2 protocol. A BaseDirectory example is /DOC-EXAMPLE-BUCKET/home/mydirectory.
    /// This member is required.
    public var baseDirectory: Swift.String?
    /// A name or short description to identify the agreement.
    public var description: Swift.String?
    /// A unique identifier for the AS2 local profile.
    /// This member is required.
    public var localProfileId: Swift.String?
    /// A unique identifier for the partner profile used in the agreement.
    /// This member is required.
    public var partnerProfileId: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that the agreement uses.
    /// This member is required.
    public var serverId: Swift.String?
    /// The status of the agreement. The agreement can be either ACTIVE or INACTIVE.
    public var status: TransferClientTypes.AgreementStatusType?
    /// Key-value pairs that can be used to group and search for agreements.
    public var tags: [TransferClientTypes.Tag]?

    public init(
        accessRole: Swift.String? = nil,
        baseDirectory: Swift.String? = nil,
        description: Swift.String? = nil,
        localProfileId: Swift.String? = nil,
        partnerProfileId: Swift.String? = nil,
        serverId: Swift.String? = nil,
        status: TransferClientTypes.AgreementStatusType? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.accessRole = accessRole
        self.baseDirectory = baseDirectory
        self.description = description
        self.localProfileId = localProfileId
        self.partnerProfileId = partnerProfileId
        self.serverId = serverId
        self.status = status
        self.tags = tags
    }
}

struct CreateAgreementInputBody: Swift.Equatable {
    let description: Swift.String?
    let serverId: Swift.String?
    let localProfileId: Swift.String?
    let partnerProfileId: Swift.String?
    let baseDirectory: Swift.String?
    let accessRole: Swift.String?
    let status: TransferClientTypes.AgreementStatusType?
    let tags: [TransferClientTypes.Tag]?
}

extension CreateAgreementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case baseDirectory = "BaseDirectory"
        case description = "Description"
        case localProfileId = "LocalProfileId"
        case partnerProfileId = "PartnerProfileId"
        case serverId = "ServerId"
        case status = "Status"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let localProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localProfileId)
        localProfileId = localProfileIdDecoded
        let partnerProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerProfileId)
        partnerProfileId = partnerProfileIdDecoded
        let baseDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseDirectory)
        baseDirectory = baseDirectoryDecoded
        let accessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.AgreementStatusType.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAgreementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAgreementOutputBody = try responseDecoder.decode(responseBody: data)
            self.agreementId = output.agreementId
        } else {
            self.agreementId = nil
        }
    }
}

public struct CreateAgreementOutput: Swift.Equatable {
    /// The unique identifier for the agreement. Use this ID for deleting, or updating an agreement, as well as in any other API calls that require that you specify the agreement ID.
    /// This member is required.
    public var agreementId: Swift.String?

    public init(
        agreementId: Swift.String? = nil
    )
    {
        self.agreementId = agreementId
    }
}

struct CreateAgreementOutputBody: Swift.Equatable {
    let agreementId: Swift.String?
}

extension CreateAgreementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId = "AgreementId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
    }
}

enum CreateAgreementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case as2Config = "As2Config"
        case loggingRole = "LoggingRole"
        case securityPolicyName = "SecurityPolicyName"
        case sftpConfig = "SftpConfig"
        case tags = "Tags"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = self.accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let as2Config = self.as2Config {
            try encodeContainer.encode(as2Config, forKey: .as2Config)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let securityPolicyName = self.securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let sftpConfig = self.sftpConfig {
            try encodeContainer.encode(sftpConfig, forKey: .sftpConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }
}

extension CreateConnectorInput {

    static func urlPathProvider(_ value: CreateConnectorInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateConnectorInput: Swift.Equatable {
    /// Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use. For AS2 connectors With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the fileâ€™s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer. If you are using Basic authentication for your AS2 connector, the access role requires the secretsmanager:GetSecretValue permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the kms:Decrypt permission for that key. For SFTP connectors Make sure that the access role provides read and write access to the parent directory of the file location that's used in the StartFileTransfer request. Additionally, make sure that the role provides secretsmanager:GetSecretValue permission to Secrets Manager.
    /// This member is required.
    public var accessRole: Swift.String?
    /// A structure that contains the parameters for an AS2 connector object.
    public var as2Config: TransferClientTypes.As2ConnectorConfig?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a connector to turn on CloudWatch logging for Amazon S3 events. When set, you can view connector activity in your CloudWatch logs.
    public var loggingRole: Swift.String?
    /// Specifies the name of the security policy for the connector.
    public var securityPolicyName: Swift.String?
    /// A structure that contains the parameters for an SFTP connector object.
    public var sftpConfig: TransferClientTypes.SftpConnectorConfig?
    /// Key-value pairs that can be used to group and search for connectors. Tags are metadata attached to connectors for any purpose.
    public var tags: [TransferClientTypes.Tag]?
    /// The URL of the partner's AS2 or SFTP endpoint.
    /// This member is required.
    public var url: Swift.String?

    public init(
        accessRole: Swift.String? = nil,
        as2Config: TransferClientTypes.As2ConnectorConfig? = nil,
        loggingRole: Swift.String? = nil,
        securityPolicyName: Swift.String? = nil,
        sftpConfig: TransferClientTypes.SftpConnectorConfig? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        url: Swift.String? = nil
    )
    {
        self.accessRole = accessRole
        self.as2Config = as2Config
        self.loggingRole = loggingRole
        self.securityPolicyName = securityPolicyName
        self.sftpConfig = sftpConfig
        self.tags = tags
        self.url = url
    }
}

struct CreateConnectorInputBody: Swift.Equatable {
    let url: Swift.String?
    let as2Config: TransferClientTypes.As2ConnectorConfig?
    let accessRole: Swift.String?
    let loggingRole: Swift.String?
    let tags: [TransferClientTypes.Tag]?
    let sftpConfig: TransferClientTypes.SftpConnectorConfig?
    let securityPolicyName: Swift.String?
}

extension CreateConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case as2Config = "As2Config"
        case loggingRole = "LoggingRole"
        case securityPolicyName = "SecurityPolicyName"
        case sftpConfig = "SftpConfig"
        case tags = "Tags"
        case url = "Url"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let as2ConfigDecoded = try containerValues.decodeIfPresent(TransferClientTypes.As2ConnectorConfig.self, forKey: .as2Config)
        as2Config = as2ConfigDecoded
        let accessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let sftpConfigDecoded = try containerValues.decodeIfPresent(TransferClientTypes.SftpConnectorConfig.self, forKey: .sftpConfig)
        sftpConfig = sftpConfigDecoded
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
    }
}

extension CreateConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectorId = output.connectorId
        } else {
            self.connectorId = nil
        }
    }
}

public struct CreateConnectorOutput: Swift.Equatable {
    /// The unique identifier for the connector, returned after the API call succeeds.
    /// This member is required.
    public var connectorId: Swift.String?

    public init(
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

struct CreateConnectorOutputBody: Swift.Equatable {
    let connectorId: Swift.String?
}

extension CreateConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
    }
}

enum CreateConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case as2Id = "As2Id"
        case certificateIds = "CertificateIds"
        case profileType = "ProfileType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let as2Id = self.as2Id {
            try encodeContainer.encode(as2Id, forKey: .as2Id)
        }
        if let certificateIds = certificateIds {
            var certificateIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateIds)
            for certificateid0 in certificateIds {
                try certificateIdsContainer.encode(certificateid0)
            }
        }
        if let profileType = self.profileType {
            try encodeContainer.encode(profileType.rawValue, forKey: .profileType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateProfileInput {

    static func urlPathProvider(_ value: CreateProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateProfileInput: Swift.Equatable {
    /// The As2Id is the AS2-name, as defined in the [RFC 4130](https://datatracker.ietf.org/doc/html/rfc4130). For inbound transfers, this is the AS2-From header for the AS2 messages sent from the partner. For outbound connectors, this is the AS2-To header for the AS2 messages sent to the partner using the StartFileTransfer API operation. This ID cannot include spaces.
    /// This member is required.
    public var as2Id: Swift.String?
    /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
    public var certificateIds: [Swift.String]?
    /// Determines the type of profile to create:
    ///
    /// * Specify LOCAL to create a local profile. A local profile represents the AS2-enabled Transfer Family server organization or party.
    ///
    /// * Specify PARTNER to create a partner profile. A partner profile represents a remote organization, external to Transfer Family.
    /// This member is required.
    public var profileType: TransferClientTypes.ProfileType?
    /// Key-value pairs that can be used to group and search for AS2 profiles.
    public var tags: [TransferClientTypes.Tag]?

    public init(
        as2Id: Swift.String? = nil,
        certificateIds: [Swift.String]? = nil,
        profileType: TransferClientTypes.ProfileType? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.as2Id = as2Id
        self.certificateIds = certificateIds
        self.profileType = profileType
        self.tags = tags
    }
}

struct CreateProfileInputBody: Swift.Equatable {
    let as2Id: Swift.String?
    let profileType: TransferClientTypes.ProfileType?
    let certificateIds: [Swift.String]?
    let tags: [TransferClientTypes.Tag]?
}

extension CreateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case as2Id = "As2Id"
        case certificateIds = "CertificateIds"
        case profileType = "ProfileType"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let as2IdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .as2Id)
        as2Id = as2IdDecoded
        let profileTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProfileType.self, forKey: .profileType)
        profileType = profileTypeDecoded
        let certificateIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .certificateIds)
        var certificateIdsDecoded0:[Swift.String]? = nil
        if let certificateIdsContainer = certificateIdsContainer {
            certificateIdsDecoded0 = [Swift.String]()
            for string0 in certificateIdsContainer {
                if let string0 = string0 {
                    certificateIdsDecoded0?.append(string0)
                }
            }
        }
        certificateIds = certificateIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profileId = output.profileId
        } else {
            self.profileId = nil
        }
    }
}

public struct CreateProfileOutput: Swift.Equatable {
    /// The unique identifier for the AS2 profile, returned after the API call succeeds.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct CreateProfileOutputBody: Swift.Equatable {
    let profileId: Swift.String?
}

extension CreateProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

enum CreateProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServerInput(certificate: \(Swift.String(describing: certificate)), domain: \(Swift.String(describing: domain)), endpointDetails: \(Swift.String(describing: endpointDetails)), endpointType: \(Swift.String(describing: endpointType)), identityProviderDetails: \(Swift.String(describing: identityProviderDetails)), identityProviderType: \(Swift.String(describing: identityProviderType)), loggingRole: \(Swift.String(describing: loggingRole)), postAuthenticationLoginBanner: \(Swift.String(describing: postAuthenticationLoginBanner)), preAuthenticationLoginBanner: \(Swift.String(describing: preAuthenticationLoginBanner)), protocolDetails: \(Swift.String(describing: protocolDetails)), protocols: \(Swift.String(describing: protocols)), s3StorageOptions: \(Swift.String(describing: s3StorageOptions)), securityPolicyName: \(Swift.String(describing: securityPolicyName)), structuredLogDestinations: \(Swift.String(describing: structuredLogDestinations)), tags: \(Swift.String(describing: tags)), workflowDetails: \(Swift.String(describing: workflowDetails)), hostKey: \"CONTENT_REDACTED\")"}
}

extension CreateServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case postAuthenticationLoginBanner = "PostAuthenticationLoginBanner"
        case preAuthenticationLoginBanner = "PreAuthenticationLoginBanner"
        case protocolDetails = "ProtocolDetails"
        case protocols = "Protocols"
        case s3StorageOptions = "S3StorageOptions"
        case securityPolicyName = "SecurityPolicyName"
        case structuredLogDestinations = "StructuredLogDestinations"
        case tags = "Tags"
        case workflowDetails = "WorkflowDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointDetails = self.endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKey = self.hostKey {
            try encodeContainer.encode(hostKey, forKey: .hostKey)
        }
        if let identityProviderDetails = self.identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let postAuthenticationLoginBanner = self.postAuthenticationLoginBanner {
            try encodeContainer.encode(postAuthenticationLoginBanner, forKey: .postAuthenticationLoginBanner)
        }
        if let preAuthenticationLoginBanner = self.preAuthenticationLoginBanner {
            try encodeContainer.encode(preAuthenticationLoginBanner, forKey: .preAuthenticationLoginBanner)
        }
        if let protocolDetails = self.protocolDetails {
            try encodeContainer.encode(protocolDetails, forKey: .protocolDetails)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocol0 in protocols {
                try protocolsContainer.encode(protocol0.rawValue)
            }
        }
        if let s3StorageOptions = self.s3StorageOptions {
            try encodeContainer.encode(s3StorageOptions, forKey: .s3StorageOptions)
        }
        if let securityPolicyName = self.securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let structuredLogDestinations = structuredLogDestinations {
            var structuredLogDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .structuredLogDestinations)
            for arn0 in structuredLogDestinations {
                try structuredLogDestinationsContainer.encode(arn0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let workflowDetails = self.workflowDetails {
            try encodeContainer.encode(workflowDetails, forKey: .workflowDetails)
        }
    }
}

extension CreateServerInput {

    static func urlPathProvider(_ value: CreateServerInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateServerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Certificate Manager (ACM) certificate. Required when Protocols is set to FTPS. To request a new public certificate, see [Request a public certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html) in the Certificate Manager User Guide. To import an existing certificate into ACM, see [Importing certificates into ACM](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the Certificate Manager User Guide. To request a private certificate to use FTPS through private IP addresses, see [Request a private certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html) in the Certificate Manager User Guide. Certificates with the following cryptographic algorithms and key sizes are supported:
    ///
    /// * 2048-bit RSA (RSA_2048)
    ///
    /// * 4096-bit RSA (RSA_4096)
    ///
    /// * Elliptic Prime Curve 256 bit (EC_prime256v1)
    ///
    /// * Elliptic Prime Curve 384 bit (EC_secp384r1)
    ///
    /// * Elliptic Prime Curve 521 bit (EC_secp521r1)
    ///
    ///
    /// The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP address specified and information about the issuer.
    public var certificate: Swift.String?
    /// The domain of the storage system that is used for file transfers. There are two domains available: Amazon Simple Storage Service (Amazon S3) and Amazon Elastic File System (Amazon EFS). The default value is S3. After the server is created, the domain cannot be changed.
    public var domain: TransferClientTypes.Domain?
    /// The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make your endpoint accessible only to resources within your VPC, or you can attach Elastic IP addresses and make your endpoint accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.
    public var endpointDetails: TransferClientTypes.EndpointDetails?
    /// The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC) or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it. After May 19, 2021, you won't be able to create a server using EndpointType=VPC_ENDPOINT in your Amazon Web Services account if your account hasn't already done so before May 19, 2021. If you have already created servers with EndpointType=VPC_ENDPOINT in your Amazon Web Services account on or before May 19, 2021, you will not be affected. After this date, use EndpointType=VPC. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint. It is recommended that you use VPC as the EndpointType. With this endpoint type, you have the option to directly associate up to three Elastic IPv4 addresses (BYO IP included) with your server's endpoint and use VPC security groups to restrict traffic by the client's public IP address. This is not possible with EndpointType set to VPC_ENDPOINT.
    public var endpointType: TransferClientTypes.EndpointType?
    /// The RSA, ECDSA, or ED25519 private key to use for your SFTP-enabled server. You can add multiple host keys, in case you want to rotate keys, or have a set of active keys that use different algorithms. Use the following command to generate an RSA 2048 bit key with no passphrase: ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key. Use a minimum value of 2048 for the -b option. You can create a stronger key by using 3072 or 4096. Use the following command to generate an ECDSA 256 bit key with no passphrase: ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key. Valid values for the -b option for ECDSA are 256, 384, and 521. Use the following command to generate an ED25519 key with no passphrase: ssh-keygen -t ed25519 -N "" -f my-new-server-key. For all of these commands, you can replace my-new-server-key with a string of your choice. If you aren't planning to migrate existing users from an existing SFTP-enabled server to a new server, don't update the host key. Accidentally changing a server's host key can be disruptive. For more information, see [Manage host keys for your SFTP-enabled server](https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key) in the Transfer Family User Guide.
    public var hostKey: Swift.String?
    /// Required when IdentityProviderType is set to AWS_DIRECTORY_SERVICE, Amazon Web Services_LAMBDA or API_GATEWAY. Accepts an array containing all of the information required to use a directory in AWS_DIRECTORY_SERVICE or invoke a customer-supplied authentication API, including the API Gateway URL. Not required when IdentityProviderType is set to SERVICE_MANAGED.
    public var identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    /// The mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Transfer Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the IdentityProviderDetails parameter. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the IdentityProviderDetails parameter. Use the AWS_LAMBDA value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the Function parameter for the IdentityProviderDetails data type.
    public var identityProviderType: TransferClientTypes.IdentityProviderType?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
    public var loggingRole: Swift.String?
    /// Specifies a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
    public var postAuthenticationLoginBanner: Swift.String?
    /// Specifies a string to display when users connect to a server. This string is displayed before the user authenticates. For example, the following banner displays details about using the system: This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel.
    public var preAuthenticationLoginBanner: Swift.String?
    /// The protocol settings that are configured for your server.
    ///
    /// * To indicate passive mode (for FTP and FTPS protocols), use the PassiveIp parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
    ///
    /// * To ignore the error that is generated when the client attempts to use the SETSTAT command on a file that you are uploading to an Amazon S3 bucket, use the SetStatOption parameter. To have the Transfer Family server ignore the SETSTAT command and upload files without needing to make any changes to your SFTP client, set the value to ENABLE_NO_OP. If you set the SetStatOption parameter to ENABLE_NO_OP, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a SETSTAT call.
    ///
    /// * To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the TlsSessionResumptionMode parameter.
    ///
    /// * As2Transports indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
    public var protocolDetails: TransferClientTypes.ProtocolDetails?
    /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:
    ///
    /// * SFTP (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH
    ///
    /// * FTPS (File Transfer Protocol Secure): File transfer with TLS encryption
    ///
    /// * FTP (File Transfer Protocol): Unencrypted file transfer
    ///
    /// * AS2 (Applicability Statement 2): used for transporting structured business-to-business data
    ///
    ///
    ///
    ///
    /// * If you select FTPS, you must choose a certificate stored in Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS.
    ///
    /// * If Protocol includes either FTP or FTPS, then the EndpointType must be VPC and the IdentityProviderType must be either AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
    ///
    /// * If Protocol includes FTP, then AddressAllocationIds cannot be associated.
    ///
    /// * If Protocol is set only to SFTP, the EndpointType can be set to PUBLIC and the IdentityProviderType can be set any of the supported identity types: SERVICE_MANAGED, AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
    ///
    /// * If Protocol includes AS2, then the EndpointType must be VPC, and domain must be Amazon S3.
    public var protocols: [TransferClientTypes.ModelProtocol]?
    /// Specifies whether or not performance for your Amazon S3 directories is optimized. This is disabled by default. By default, home directory mappings have a TYPE of DIRECTORY. If you enable this option, you would then need to explicitly set the HomeDirectoryMapEntryType to FILE if you want a mapping to have a file target.
    public var s3StorageOptions: TransferClientTypes.S3StorageOptions?
    /// Specifies the name of the security policy for the server.
    public var securityPolicyName: Swift.String?
    /// Specifies the log groups to which your server logs are sent. To specify a log group, you must provide the ARN for an existing log group. In this case, the format of the log group is as follows: arn:aws:logs:region-name:amazon-account-id:log-group:log-group-name:* For example, arn:aws:logs:us-east-1:111122223333:log-group:mytestgroup:* If you have previously specified a log group for a server, you can clear it, and in effect turn off structured logging, by providing an empty value for this parameter in an update-server call. For example: update-server --server-id s-1234567890abcdef0 --structured-log-destinations
    public var structuredLogDestinations: [Swift.String]?
    /// Key-value pairs that can be used to group and search for servers.
    public var tags: [TransferClientTypes.Tag]?
    /// Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow. In addition to a workflow to execute when a file is uploaded completely, WorkflowDetails can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when the server session disconnects while the file is still being uploaded.
    public var workflowDetails: TransferClientTypes.WorkflowDetails?

    public init(
        certificate: Swift.String? = nil,
        domain: TransferClientTypes.Domain? = nil,
        endpointDetails: TransferClientTypes.EndpointDetails? = nil,
        endpointType: TransferClientTypes.EndpointType? = nil,
        hostKey: Swift.String? = nil,
        identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
        identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
        loggingRole: Swift.String? = nil,
        postAuthenticationLoginBanner: Swift.String? = nil,
        preAuthenticationLoginBanner: Swift.String? = nil,
        protocolDetails: TransferClientTypes.ProtocolDetails? = nil,
        protocols: [TransferClientTypes.ModelProtocol]? = nil,
        s3StorageOptions: TransferClientTypes.S3StorageOptions? = nil,
        securityPolicyName: Swift.String? = nil,
        structuredLogDestinations: [Swift.String]? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        workflowDetails: TransferClientTypes.WorkflowDetails? = nil
    )
    {
        self.certificate = certificate
        self.domain = domain
        self.endpointDetails = endpointDetails
        self.endpointType = endpointType
        self.hostKey = hostKey
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderType = identityProviderType
        self.loggingRole = loggingRole
        self.postAuthenticationLoginBanner = postAuthenticationLoginBanner
        self.preAuthenticationLoginBanner = preAuthenticationLoginBanner
        self.protocolDetails = protocolDetails
        self.protocols = protocols
        self.s3StorageOptions = s3StorageOptions
        self.securityPolicyName = securityPolicyName
        self.structuredLogDestinations = structuredLogDestinations
        self.tags = tags
        self.workflowDetails = workflowDetails
    }
}

struct CreateServerInputBody: Swift.Equatable {
    let certificate: Swift.String?
    let domain: TransferClientTypes.Domain?
    let endpointDetails: TransferClientTypes.EndpointDetails?
    let endpointType: TransferClientTypes.EndpointType?
    let hostKey: Swift.String?
    let identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    let identityProviderType: TransferClientTypes.IdentityProviderType?
    let loggingRole: Swift.String?
    let postAuthenticationLoginBanner: Swift.String?
    let preAuthenticationLoginBanner: Swift.String?
    let protocols: [TransferClientTypes.ModelProtocol]?
    let protocolDetails: TransferClientTypes.ProtocolDetails?
    let securityPolicyName: Swift.String?
    let tags: [TransferClientTypes.Tag]?
    let workflowDetails: TransferClientTypes.WorkflowDetails?
    let structuredLogDestinations: [Swift.String]?
    let s3StorageOptions: TransferClientTypes.S3StorageOptions?
}

extension CreateServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case postAuthenticationLoginBanner = "PostAuthenticationLoginBanner"
        case preAuthenticationLoginBanner = "PreAuthenticationLoginBanner"
        case protocolDetails = "ProtocolDetails"
        case protocols = "Protocols"
        case s3StorageOptions = "S3StorageOptions"
        case securityPolicyName = "SecurityPolicyName"
        case structuredLogDestinations = "StructuredLogDestinations"
        case tags = "Tags"
        case workflowDetails = "WorkflowDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let domainDecoded = try containerValues.decodeIfPresent(TransferClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKey)
        hostKey = hostKeyDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let postAuthenticationLoginBannerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postAuthenticationLoginBanner)
        postAuthenticationLoginBanner = postAuthenticationLoginBannerDecoded
        let preAuthenticationLoginBannerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preAuthenticationLoginBanner)
        preAuthenticationLoginBanner = preAuthenticationLoginBannerDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[TransferClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [TransferClientTypes.ModelProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
        let protocolDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProtocolDetails.self, forKey: .protocolDetails)
        protocolDetails = protocolDetailsDecoded
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let workflowDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowDetails.self, forKey: .workflowDetails)
        workflowDetails = workflowDetailsDecoded
        let structuredLogDestinationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .structuredLogDestinations)
        var structuredLogDestinationsDecoded0:[Swift.String]? = nil
        if let structuredLogDestinationsContainer = structuredLogDestinationsContainer {
            structuredLogDestinationsDecoded0 = [Swift.String]()
            for string0 in structuredLogDestinationsContainer {
                if let string0 = string0 {
                    structuredLogDestinationsDecoded0?.append(string0)
                }
            }
        }
        structuredLogDestinations = structuredLogDestinationsDecoded0
        let s3StorageOptionsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.S3StorageOptions.self, forKey: .s3StorageOptions)
        s3StorageOptions = s3StorageOptionsDecoded
    }
}

extension CreateServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServerOutputBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
        } else {
            self.serverId = nil
        }
    }
}

public struct CreateServerOutput: Swift.Equatable {
    /// The service-assigned identifier of the server that is created.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct CreateServerOutputBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension CreateServerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

enum CreateServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymapentry0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymapentry0)
            }
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = self.posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyBody = self.sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension CreateUserInput {

    static func urlPathProvider(_ value: CreateUserInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock your user down to the designated home directory ("chroot"). To do this, you can set Entry to / and set Target to the value the user should see for their home directory when they log in. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use session policies. For session policies, Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Example session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Amazon Web Services Security Token Service API Reference.
    public var policy: Swift.String?
    /// Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in Amazon EFS determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    /// This member is required.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.
    /// This member is required.
    public var serverId: Swift.String?
    /// The public portion of the Secure Shell (SSH) key used to authenticate the user to the server. The three standard SSH public key format elements are <key type>, <body base64>, and an optional <comment>, with spaces between each element. Transfer Family accepts RSA, ECDSA, and ED25519 keys.
    ///
    /// * For RSA keys, the key type is ssh-rsa.
    ///
    /// * For ED25519 keys, the key type is ssh-ed25519.
    ///
    /// * For ECDSA keys, the key type is either ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, or ecdsa-sha2-nistp521, depending on the size of the key you generated.
    public var sshPublicKeyBody: Swift.String?
    /// Key-value pairs that can be used to group and search for users. Tags are metadata attached to users for any purpose.
    public var tags: [TransferClientTypes.Tag]?
    /// A unique string that identifies a user and is associated with a ServerId. This user name must be a minimum of 3 and a maximum of 100 characters long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen '-', period '.', and at sign '@'. The user name can't start with a hyphen, period, or at sign.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil,
        sshPublicKeyBody: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
        self.sshPublicKeyBody = sshPublicKeyBody
        self.tags = tags
        self.userName = userName
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let homeDirectory: Swift.String?
    let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    let policy: Swift.String?
    let posixProfile: TransferClientTypes.PosixProfile?
    let role: Swift.String?
    let serverId: Swift.String?
    let sshPublicKeyBody: Swift.String?
    let tags: [TransferClientTypes.Tag]?
    let userName: Swift.String?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case tags = "Tags"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension CreateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.userName = nil
        }
    }
}

public struct CreateUserOutput: Swift.Equatable {
    /// The identifier of the server that the user is attached to.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique string that identifies a Transfer Family user.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct CreateUserOutputBody: Swift.Equatable {
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension CreateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

enum CreateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case onExceptionSteps = "OnExceptionSteps"
        case steps = "Steps"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let onExceptionSteps = onExceptionSteps {
            var onExceptionStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .onExceptionSteps)
            for workflowstep0 in onExceptionSteps {
                try onExceptionStepsContainer.encode(workflowstep0)
            }
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for workflowstep0 in steps {
                try stepsContainer.encode(workflowstep0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateWorkflowInput {

    static func urlPathProvider(_ value: CreateWorkflowInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateWorkflowInput: Swift.Equatable {
    /// A textual description for the workflow.
    public var description: Swift.String?
    /// Specifies the steps (actions) to take if errors are encountered during execution of the workflow. For custom steps, the Lambda function needs to send FAILURE to the call back API to kick off the exception steps. Additionally, if the Lambda does not send SUCCESS before it times out, the exception steps are executed.
    public var onExceptionSteps: [TransferClientTypes.WorkflowStep]?
    /// Specifies the details for the steps that are in the specified workflow. The TYPE specifies which of the following actions is being taken for this step.
    ///
    /// * COPY - Copy the file to another location.
    ///
    /// * CUSTOM - Perform a custom step with an Lambda function target.
    ///
    /// * DECRYPT - Decrypt a file that was encrypted before it was uploaded.
    ///
    /// * DELETE - Delete the file.
    ///
    /// * TAG - Add a tag to the file.
    ///
    ///
    /// Currently, copying and tagging are supported only on S3. For file location, you specify either the Amazon S3 bucket and key, or the Amazon EFS file system ID and path.
    /// This member is required.
    public var steps: [TransferClientTypes.WorkflowStep]?
    /// Key-value pairs that can be used to group and search for workflows. Tags are metadata attached to workflows for any purpose.
    public var tags: [TransferClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        onExceptionSteps: [TransferClientTypes.WorkflowStep]? = nil,
        steps: [TransferClientTypes.WorkflowStep]? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.onExceptionSteps = onExceptionSteps
        self.steps = steps
        self.tags = tags
    }
}

struct CreateWorkflowInputBody: Swift.Equatable {
    let description: Swift.String?
    let steps: [TransferClientTypes.WorkflowStep]?
    let onExceptionSteps: [TransferClientTypes.WorkflowStep]?
    let tags: [TransferClientTypes.Tag]?
}

extension CreateWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case onExceptionSteps = "OnExceptionSteps"
        case steps = "Steps"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowStep?].self, forKey: .steps)
        var stepsDecoded0:[TransferClientTypes.WorkflowStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [TransferClientTypes.WorkflowStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let onExceptionStepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowStep?].self, forKey: .onExceptionSteps)
        var onExceptionStepsDecoded0:[TransferClientTypes.WorkflowStep]? = nil
        if let onExceptionStepsContainer = onExceptionStepsContainer {
            onExceptionStepsDecoded0 = [TransferClientTypes.WorkflowStep]()
            for structure0 in onExceptionStepsContainer {
                if let structure0 = structure0 {
                    onExceptionStepsDecoded0?.append(structure0)
                }
            }
        }
        onExceptionSteps = onExceptionStepsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.workflowId = output.workflowId
        } else {
            self.workflowId = nil
        }
    }
}

public struct CreateWorkflowOutput: Swift.Equatable {
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        workflowId: Swift.String? = nil
    )
    {
        self.workflowId = workflowId
    }
}

struct CreateWorkflowOutputBody: Swift.Equatable {
    let workflowId: Swift.String?
}

extension CreateWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

enum CreateWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TransferClientTypes.CustomStepDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sourceFileLocation = "SourceFileLocation"
        case target = "Target"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceFileLocation = self.sourceFileLocation {
            try encodeContainer.encode(sourceFileLocation, forKey: .sourceFileLocation)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let timeoutSeconds = self.timeoutSeconds {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let sourceFileLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileLocation)
        sourceFileLocation = sourceFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure.
    public struct CustomStepDetails: Swift.Equatable {
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?
        /// The ARN for the Lambda function that is being called.
        public var target: Swift.String?
        /// Timeout, in seconds, for the step.
        public var timeoutSeconds: Swift.Int?

        public init(
            name: Swift.String? = nil,
            sourceFileLocation: Swift.String? = nil,
            target: Swift.String? = nil,
            timeoutSeconds: Swift.Int? = nil
        )
        {
            self.name = name
            self.sourceFileLocation = sourceFileLocation
            self.target = target
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension TransferClientTypes {
    public enum CustomStepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failure
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomStepStatus] {
            return [
                .failure,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failure: return "FAILURE"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomStepStatus(rawValue: rawValue) ?? CustomStepStatus.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.DecryptStepDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationFileLocation = "DestinationFileLocation"
        case name = "Name"
        case overwriteExisting = "OverwriteExisting"
        case sourceFileLocation = "SourceFileLocation"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationFileLocation = self.destinationFileLocation {
            try encodeContainer.encode(destinationFileLocation, forKey: .destinationFileLocation)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overwriteExisting = self.overwriteExisting {
            try encodeContainer.encode(overwriteExisting.rawValue, forKey: .overwriteExisting)
        }
        if let sourceFileLocation = self.sourceFileLocation {
            try encodeContainer.encode(sourceFileLocation, forKey: .sourceFileLocation)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EncryptionType.self, forKey: .type)
        type = typeDecoded
        let sourceFileLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileLocation)
        sourceFileLocation = sourceFileLocationDecoded
        let overwriteExistingDecoded = try containerValues.decodeIfPresent(TransferClientTypes.OverwriteExisting.self, forKey: .overwriteExisting)
        overwriteExisting = overwriteExistingDecoded
        let destinationFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.InputFileLocation.self, forKey: .destinationFileLocation)
        destinationFileLocation = destinationFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure.
    public struct DecryptStepDetails: Swift.Equatable {
        /// Specifies the location for the file being decrypted. Use ${Transfer:UserName} or ${Transfer:UploadDate} in this field to parametrize the destination prefix by username or uploaded date.
        ///
        /// * Set the value of DestinationFileLocation to ${Transfer:UserName} to decrypt uploaded files to an Amazon S3 bucket that is prefixed with the name of the Transfer Family user that uploaded the file.
        ///
        /// * Set the value of DestinationFileLocation to ${Transfer:UploadDate} to decrypt uploaded files to an Amazon S3 bucket that is prefixed with the date of the upload. The system resolves UploadDate to a date format of YYYY-MM-DD, based on the date the file is uploaded in UTC.
        /// This member is required.
        public var destinationFileLocation: TransferClientTypes.InputFileLocation?
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// A flag that indicates whether to overwrite an existing file of the same name. The default is FALSE. If the workflow is processing a file that has the same name as an existing file, the behavior is as follows:
        ///
        /// * If OverwriteExisting is TRUE, the existing file is replaced with the file being processed.
        ///
        /// * If OverwriteExisting is FALSE, nothing happens, and the workflow processing stops.
        public var overwriteExisting: TransferClientTypes.OverwriteExisting?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?
        /// The type of encryption used. Currently, this value must be PGP.
        /// This member is required.
        public var type: TransferClientTypes.EncryptionType?

        public init(
            destinationFileLocation: TransferClientTypes.InputFileLocation? = nil,
            name: Swift.String? = nil,
            overwriteExisting: TransferClientTypes.OverwriteExisting? = nil,
            sourceFileLocation: Swift.String? = nil,
            type: TransferClientTypes.EncryptionType? = nil
        )
        {
            self.destinationFileLocation = destinationFileLocation
            self.name = name
            self.overwriteExisting = overwriteExisting
            self.sourceFileLocation = sourceFileLocation
            self.type = type
        }
    }

}

extension DeleteAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DeleteAccessInput {

    static func urlPathProvider(_ value: DeleteAccessInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteAccessInput: Swift.Equatable {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// A system-assigned unique identifier for a server that has this user assigned.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct DeleteAccessInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension DeleteAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension DeleteAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAgreementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId = "AgreementId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agreementId = self.agreementId {
            try encodeContainer.encode(agreementId, forKey: .agreementId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DeleteAgreementInput {

    static func urlPathProvider(_ value: DeleteAgreementInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteAgreementInput: Swift.Equatable {
    /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
    /// This member is required.
    public var agreementId: Swift.String?
    /// The server identifier associated with the agreement that you are deleting.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        agreementId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.agreementId = agreementId
        self.serverId = serverId
    }
}

struct DeleteAgreementInputBody: Swift.Equatable {
    let agreementId: Swift.String?
    let serverId: Swift.String?
}

extension DeleteAgreementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId = "AgreementId"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension DeleteAgreementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAgreementOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAgreementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
    }
}

extension DeleteCertificateInput {

    static func urlPathProvider(_ value: DeleteCertificateInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteCertificateInput: Swift.Equatable {
    /// The identifier of the certificate object that you are deleting.
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct DeleteCertificateInputBody: Swift.Equatable {
    let certificateId: Swift.String?
}

extension DeleteCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

extension DeleteCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCertificateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
    }
}

extension DeleteConnectorInput {

    static func urlPathProvider(_ value: DeleteConnectorInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteConnectorInput: Swift.Equatable {
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?

    public init(
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

struct DeleteConnectorInputBody: Swift.Equatable {
    let connectorId: Swift.String?
}

extension DeleteConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
    }
}

extension DeleteConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConnectorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteHostKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostKeyId = self.hostKeyId {
            try encodeContainer.encode(hostKeyId, forKey: .hostKeyId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DeleteHostKeyInput {

    static func urlPathProvider(_ value: DeleteHostKeyInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteHostKeyInput: Swift.Equatable {
    /// The identifier of the host key that you are deleting.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// The identifier of the server that contains the host key that you are deleting.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

struct DeleteHostKeyInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let hostKeyId: Swift.String?
}

extension DeleteHostKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let hostKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyId)
        hostKeyId = hostKeyIdDecoded
    }
}

extension DeleteHostKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteHostKeyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteHostKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
    }
}

extension DeleteProfileInput {

    static func urlPathProvider(_ value: DeleteProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteProfileInput: Swift.Equatable {
    /// The identifier of the profile that you are deleting.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct DeleteProfileInputBody: Swift.Equatable {
    let profileId: Swift.String?
}

extension DeleteProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

extension DeleteProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DeleteServerInput {

    static func urlPathProvider(_ value: DeleteServerInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteServerInput: Swift.Equatable {
    /// A unique system-assigned identifier for a server instance.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct DeleteServerInputBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension DeleteServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension DeleteServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteServerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSshPublicKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyId = self.sshPublicKeyId {
            try encodeContainer.encode(sshPublicKeyId, forKey: .sshPublicKeyId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DeleteSshPublicKeyInput {

    static func urlPathProvider(_ value: DeleteSshPublicKeyInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteSshPublicKeyInput: Swift.Equatable {
    /// A system-assigned unique identifier for a file transfer protocol-enabled server instance that has the user assigned to it.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique identifier used to reference your user's specific SSH key.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// A unique string that identifies a user whose public key is being deleted.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

struct DeleteSshPublicKeyInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let sshPublicKeyId: Swift.String?
    let userName: Swift.String?
}

extension DeleteSshPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteSshPublicKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSshPublicKeyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSshPublicKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TransferClientTypes.DeleteStepDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sourceFileLocation = "SourceFileLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceFileLocation = self.sourceFileLocation {
            try encodeContainer.encode(sourceFileLocation, forKey: .sourceFileLocation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceFileLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileLocation)
        sourceFileLocation = sourceFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// The name of the step, used to identify the delete step.
    public struct DeleteStepDetails: Swift.Equatable {
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?

        public init(
            name: Swift.String? = nil,
            sourceFileLocation: Swift.String? = nil
        )
        {
            self.name = name
            self.sourceFileLocation = sourceFileLocation
        }
    }

}

extension DeleteUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DeleteUserInput {

    static func urlPathProvider(_ value: DeleteUserInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server instance that has the user assigned to it.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique string that identifies a user that is being deleted from a server.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension DeleteWorkflowInput {

    static func urlPathProvider(_ value: DeleteWorkflowInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteWorkflowInput: Swift.Equatable {
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        workflowId: Swift.String? = nil
    )
    {
        self.workflowId = workflowId
    }
}

struct DeleteWorkflowInputBody: Swift.Equatable {
    let workflowId: Swift.String?
}

extension DeleteWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

extension DeleteWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorkflowOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DescribeAccessInput {

    static func urlPathProvider(_ value: DescribeAccessInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeAccessInput: Swift.Equatable {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// A system-assigned unique identifier for a server that has this access assigned.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct DescribeAccessInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension DescribeAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension DescribeAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.access = output.access
            self.serverId = output.serverId
        } else {
            self.access = nil
            self.serverId = nil
        }
    }
}

public struct DescribeAccessOutput: Swift.Equatable {
    /// The external identifier of the server that the access is attached to.
    /// This member is required.
    public var access: TransferClientTypes.DescribedAccess?
    /// A system-assigned unique identifier for a server that has this access assigned.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        access: TransferClientTypes.DescribedAccess? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.access = access
        self.serverId = serverId
    }
}

struct DescribeAccessOutputBody: Swift.Equatable {
    let serverId: Swift.String?
    let access: TransferClientTypes.DescribedAccess?
}

extension DescribeAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case access = "Access"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let accessDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedAccess.self, forKey: .access)
        access = accessDecoded
    }
}

enum DescribeAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAgreementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId = "AgreementId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agreementId = self.agreementId {
            try encodeContainer.encode(agreementId, forKey: .agreementId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DescribeAgreementInput {

    static func urlPathProvider(_ value: DescribeAgreementInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeAgreementInput: Swift.Equatable {
    /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
    /// This member is required.
    public var agreementId: Swift.String?
    /// The server identifier that's associated with the agreement.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        agreementId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.agreementId = agreementId
        self.serverId = serverId
    }
}

struct DescribeAgreementInputBody: Swift.Equatable {
    let agreementId: Swift.String?
    let serverId: Swift.String?
}

extension DescribeAgreementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId = "AgreementId"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension DescribeAgreementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAgreementOutputBody = try responseDecoder.decode(responseBody: data)
            self.agreement = output.agreement
        } else {
            self.agreement = nil
        }
    }
}

public struct DescribeAgreementOutput: Swift.Equatable {
    /// The details for the specified agreement, returned as a DescribedAgreement object.
    /// This member is required.
    public var agreement: TransferClientTypes.DescribedAgreement?

    public init(
        agreement: TransferClientTypes.DescribedAgreement? = nil
    )
    {
        self.agreement = agreement
    }
}

struct DescribeAgreementOutputBody: Swift.Equatable {
    let agreement: TransferClientTypes.DescribedAgreement?
}

extension DescribeAgreementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreement = "Agreement"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedAgreement.self, forKey: .agreement)
        agreement = agreementDecoded
    }
}

enum DescribeAgreementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
    }
}

extension DescribeCertificateInput {

    static func urlPathProvider(_ value: DescribeCertificateInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeCertificateInput: Swift.Equatable {
    /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct DescribeCertificateInputBody: Swift.Equatable {
    let certificateId: Swift.String?
}

extension DescribeCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

extension DescribeCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct DescribeCertificateOutput: Swift.Equatable {
    /// The details for the specified certificate, returned as an object.
    /// This member is required.
    public var certificate: TransferClientTypes.DescribedCertificate?

    public init(
        certificate: TransferClientTypes.DescribedCertificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct DescribeCertificateOutputBody: Swift.Equatable {
    let certificate: TransferClientTypes.DescribedCertificate?
}

extension DescribeCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedCertificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

enum DescribeCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
    }
}

extension DescribeConnectorInput {

    static func urlPathProvider(_ value: DescribeConnectorInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeConnectorInput: Swift.Equatable {
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?

    public init(
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

struct DescribeConnectorInputBody: Swift.Equatable {
    let connectorId: Swift.String?
}

extension DescribeConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
    }
}

extension DescribeConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.connector = output.connector
        } else {
            self.connector = nil
        }
    }
}

public struct DescribeConnectorOutput: Swift.Equatable {
    /// The structure that contains the details of the connector.
    /// This member is required.
    public var connector: TransferClientTypes.DescribedConnector?

    public init(
        connector: TransferClientTypes.DescribedConnector? = nil
    )
    {
        self.connector = connector
    }
}

struct DescribeConnectorOutputBody: Swift.Equatable {
    let connector: TransferClientTypes.DescribedConnector?
}

extension DescribeConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connector = "Connector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedConnector.self, forKey: .connector)
        connector = connectorDecoded
    }
}

enum DescribeConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension DescribeExecutionInput {

    static func urlPathProvider(_ value: DescribeExecutionInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeExecutionInput: Swift.Equatable {
    /// A unique identifier for the execution of a workflow.
    /// This member is required.
    public var executionId: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        executionId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.executionId = executionId
        self.workflowId = workflowId
    }
}

struct DescribeExecutionInputBody: Swift.Equatable {
    let executionId: Swift.String?
    let workflowId: Swift.String?
}

extension DescribeExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case workflowId = "WorkflowId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

extension DescribeExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.execution = output.execution
            self.workflowId = output.workflowId
        } else {
            self.execution = nil
            self.workflowId = nil
        }
    }
}

public struct DescribeExecutionOutput: Swift.Equatable {
    /// The structure that contains the details of the workflow' execution.
    /// This member is required.
    public var execution: TransferClientTypes.DescribedExecution?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        execution: TransferClientTypes.DescribedExecution? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.execution = execution
        self.workflowId = workflowId
    }
}

struct DescribeExecutionOutputBody: Swift.Equatable {
    let workflowId: Swift.String?
    let execution: TransferClientTypes.DescribedExecution?
}

extension DescribeExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case execution = "Execution"
        case workflowId = "WorkflowId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let executionDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedExecution.self, forKey: .execution)
        execution = executionDecoded
    }
}

enum DescribeExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeHostKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostKeyId = self.hostKeyId {
            try encodeContainer.encode(hostKeyId, forKey: .hostKeyId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DescribeHostKeyInput {

    static func urlPathProvider(_ value: DescribeHostKeyInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeHostKeyInput: Swift.Equatable {
    /// The identifier of the host key that you want described.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// The identifier of the server that contains the host key that you want described.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

struct DescribeHostKeyInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let hostKeyId: Swift.String?
}

extension DescribeHostKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let hostKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyId)
        hostKeyId = hostKeyIdDecoded
    }
}

extension DescribeHostKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeHostKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.hostKey = output.hostKey
        } else {
            self.hostKey = nil
        }
    }
}

public struct DescribeHostKeyOutput: Swift.Equatable {
    /// Returns the details for the specified host key.
    /// This member is required.
    public var hostKey: TransferClientTypes.DescribedHostKey?

    public init(
        hostKey: TransferClientTypes.DescribedHostKey? = nil
    )
    {
        self.hostKey = hostKey
    }
}

struct DescribeHostKeyOutputBody: Swift.Equatable {
    let hostKey: TransferClientTypes.DescribedHostKey?
}

extension DescribeHostKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKey = "HostKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostKeyDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedHostKey.self, forKey: .hostKey)
        hostKey = hostKeyDecoded
    }
}

enum DescribeHostKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
    }
}

extension DescribeProfileInput {

    static func urlPathProvider(_ value: DescribeProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeProfileInput: Swift.Equatable {
    /// The identifier of the profile that you want described.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct DescribeProfileInputBody: Swift.Equatable {
    let profileId: Swift.String?
}

extension DescribeProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

extension DescribeProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct DescribeProfileOutput: Swift.Equatable {
    /// The details of the specified profile, returned as an object.
    /// This member is required.
    public var profile: TransferClientTypes.DescribedProfile?

    public init(
        profile: TransferClientTypes.DescribedProfile? = nil
    )
    {
        self.profile = profile
    }
}

struct DescribeProfileOutputBody: Swift.Equatable {
    let profile: TransferClientTypes.DescribedProfile?
}

extension DescribeProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile = "Profile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedProfile.self, forKey: .profile)
        profile = profileDecoded
    }
}

enum DescribeProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSecurityPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicyName = "SecurityPolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityPolicyName = self.securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
    }
}

extension DescribeSecurityPolicyInput {

    static func urlPathProvider(_ value: DescribeSecurityPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeSecurityPolicyInput: Swift.Equatable {
    /// Specify the text name of the security policy for which you want the details.
    /// This member is required.
    public var securityPolicyName: Swift.String?

    public init(
        securityPolicyName: Swift.String? = nil
    )
    {
        self.securityPolicyName = securityPolicyName
    }
}

struct DescribeSecurityPolicyInputBody: Swift.Equatable {
    let securityPolicyName: Swift.String?
}

extension DescribeSecurityPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicyName = "SecurityPolicyName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
    }
}

extension DescribeSecurityPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSecurityPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.securityPolicy = output.securityPolicy
        } else {
            self.securityPolicy = nil
        }
    }
}

public struct DescribeSecurityPolicyOutput: Swift.Equatable {
    /// An array containing the properties of the security policy.
    /// This member is required.
    public var securityPolicy: TransferClientTypes.DescribedSecurityPolicy?

    public init(
        securityPolicy: TransferClientTypes.DescribedSecurityPolicy? = nil
    )
    {
        self.securityPolicy = securityPolicy
    }
}

struct DescribeSecurityPolicyOutputBody: Swift.Equatable {
    let securityPolicy: TransferClientTypes.DescribedSecurityPolicy?
}

extension DescribeSecurityPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicy = "SecurityPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedSecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
    }
}

enum DescribeSecurityPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DescribeServerInput {

    static func urlPathProvider(_ value: DescribeServerInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeServerInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct DescribeServerInputBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension DescribeServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension DescribeServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeServerOutputBody = try responseDecoder.decode(responseBody: data)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct DescribeServerOutput: Swift.Equatable {
    /// An array containing the properties of a server with the ServerID you specified.
    /// This member is required.
    public var server: TransferClientTypes.DescribedServer?

    public init(
        server: TransferClientTypes.DescribedServer? = nil
    )
    {
        self.server = server
    }
}

struct DescribeServerOutputBody: Swift.Equatable {
    let server: TransferClientTypes.DescribedServer?
}

extension DescribeServerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server = "Server"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedServer.self, forKey: .server)
        server = serverDecoded
    }
}

enum DescribeServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DescribeUserInput {

    static func urlPathProvider(_ value: DescribeUserInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeUserInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server that has this user assigned.
    /// This member is required.
    public var serverId: Swift.String?
    /// The name of the user assigned to one or more servers. User names are part of the sign-in credentials to use the Transfer Family service and perform file transfer tasks.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct DescribeUserInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension DescribeUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DescribeUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.user = output.user
        } else {
            self.serverId = nil
            self.user = nil
        }
    }
}

public struct DescribeUserOutput: Swift.Equatable {
    /// A system-assigned unique identifier for a server that has this user assigned.
    /// This member is required.
    public var serverId: Swift.String?
    /// An array containing the properties of the Transfer Family user for the ServerID value that you specified.
    /// This member is required.
    public var user: TransferClientTypes.DescribedUser?

    public init(
        serverId: Swift.String? = nil,
        user: TransferClientTypes.DescribedUser? = nil
    )
    {
        self.serverId = serverId
        self.user = user
    }
}

struct DescribeUserOutputBody: Swift.Equatable {
    let serverId: Swift.String?
    let user: TransferClientTypes.DescribedUser?
}

extension DescribeUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedUser.self, forKey: .user)
        user = userDecoded
    }
}

enum DescribeUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension DescribeWorkflowInput {

    static func urlPathProvider(_ value: DescribeWorkflowInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeWorkflowInput: Swift.Equatable {
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        workflowId: Swift.String? = nil
    )
    {
        self.workflowId = workflowId
    }
}

struct DescribeWorkflowInputBody: Swift.Equatable {
    let workflowId: Swift.String?
}

extension DescribeWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

extension DescribeWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.workflow = output.workflow
        } else {
            self.workflow = nil
        }
    }
}

public struct DescribeWorkflowOutput: Swift.Equatable {
    /// The structure that contains the details of the workflow.
    /// This member is required.
    public var workflow: TransferClientTypes.DescribedWorkflow?

    public init(
        workflow: TransferClientTypes.DescribedWorkflow? = nil
    )
    {
        self.workflow = workflow
    }
}

struct DescribeWorkflowOutputBody: Swift.Equatable {
    let workflow: TransferClientTypes.DescribedWorkflow?
}

extension DescribeWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflow = "Workflow"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedWorkflow.self, forKey: .workflow)
        workflow = workflowDecoded
    }
}

enum DescribeWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TransferClientTypes.DescribedAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymapentry0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymapentry0)
            }
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = self.posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension TransferClientTypes {
    /// Describes the properties of the access that was specified.
    public struct DescribedAccess: Swift.Equatable {
        /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
        public var externalId: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
        public var homeDirectory: Swift.String?
        /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. In most cases, you can use this value instead of the session policy to lock down the associated access to the designated home directory ("chroot"). To do this, you can set Entry to '/' and set Target to the HomeDirectory parameter value.
        public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
        /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}.
        public var policy: Swift.String?
        /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
        public var posixProfile: TransferClientTypes.PosixProfile?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
        public var role: Swift.String?

        public init(
            externalId: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            policy: Swift.String? = nil,
            posixProfile: TransferClientTypes.PosixProfile? = nil,
            role: Swift.String? = nil
        )
        {
            self.externalId = externalId
            self.homeDirectory = homeDirectory
            self.homeDirectoryMappings = homeDirectoryMappings
            self.homeDirectoryType = homeDirectoryType
            self.policy = policy
            self.posixProfile = posixProfile
            self.role = role
        }
    }

}

extension TransferClientTypes.DescribedAgreement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case agreementId = "AgreementId"
        case arn = "Arn"
        case baseDirectory = "BaseDirectory"
        case description = "Description"
        case localProfileId = "LocalProfileId"
        case partnerProfileId = "PartnerProfileId"
        case serverId = "ServerId"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = self.accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let agreementId = self.agreementId {
            try encodeContainer.encode(agreementId, forKey: .agreementId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let baseDirectory = self.baseDirectory {
            try encodeContainer.encode(baseDirectory, forKey: .baseDirectory)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let localProfileId = self.localProfileId {
            try encodeContainer.encode(localProfileId, forKey: .localProfileId)
        }
        if let partnerProfileId = self.partnerProfileId {
            try encodeContainer.encode(partnerProfileId, forKey: .partnerProfileId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.AgreementStatusType.self, forKey: .status)
        status = statusDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let localProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localProfileId)
        localProfileId = localProfileIdDecoded
        let partnerProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerProfileId)
        partnerProfileId = partnerProfileIdDecoded
        let baseDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseDirectory)
        baseDirectory = baseDirectoryDecoded
        let accessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TransferClientTypes {
    /// Describes the properties of an agreement.
    public struct DescribedAgreement: Swift.Equatable {
        /// Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use. For AS2 connectors With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the fileâ€™s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer. If you are using Basic authentication for your AS2 connector, the access role requires the secretsmanager:GetSecretValue permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the kms:Decrypt permission for that key. For SFTP connectors Make sure that the access role provides read and write access to the parent directory of the file location that's used in the StartFileTransfer request. Additionally, make sure that the role provides secretsmanager:GetSecretValue permission to Secrets Manager.
        public var accessRole: Swift.String?
        /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
        public var agreementId: Swift.String?
        /// The unique Amazon Resource Name (ARN) for the agreement.
        /// This member is required.
        public var arn: Swift.String?
        /// The landing directory (folder) for files that are transferred by using the AS2 protocol.
        public var baseDirectory: Swift.String?
        /// The name or short description that's used to identify the agreement.
        public var description: Swift.String?
        /// A unique identifier for the AS2 local profile.
        public var localProfileId: Swift.String?
        /// A unique identifier for the partner profile used in the agreement.
        public var partnerProfileId: Swift.String?
        /// A system-assigned unique identifier for a server instance. This identifier indicates the specific server that the agreement uses.
        public var serverId: Swift.String?
        /// The current status of the agreement, either ACTIVE or INACTIVE.
        public var status: TransferClientTypes.AgreementStatusType?
        /// Key-value pairs that can be used to group and search for agreements.
        public var tags: [TransferClientTypes.Tag]?

        public init(
            accessRole: Swift.String? = nil,
            agreementId: Swift.String? = nil,
            arn: Swift.String? = nil,
            baseDirectory: Swift.String? = nil,
            description: Swift.String? = nil,
            localProfileId: Swift.String? = nil,
            partnerProfileId: Swift.String? = nil,
            serverId: Swift.String? = nil,
            status: TransferClientTypes.AgreementStatusType? = nil,
            tags: [TransferClientTypes.Tag]? = nil
        )
        {
            self.accessRole = accessRole
            self.agreementId = agreementId
            self.arn = arn
            self.baseDirectory = baseDirectory
            self.description = description
            self.localProfileId = localProfileId
            self.partnerProfileId = partnerProfileId
            self.serverId = serverId
            self.status = status
            self.tags = tags
        }
    }

}

extension TransferClientTypes.DescribedCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDate = "ActiveDate"
        case arn = "Arn"
        case certificate = "Certificate"
        case certificateChain = "CertificateChain"
        case certificateId = "CertificateId"
        case description = "Description"
        case inactiveDate = "InactiveDate"
        case notAfterDate = "NotAfterDate"
        case notBeforeDate = "NotBeforeDate"
        case serial = "Serial"
        case status = "Status"
        case tags = "Tags"
        case type = "Type"
        case usage = "Usage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDate = self.activeDate {
            try encodeContainer.encodeTimestamp(activeDate, format: .epochSeconds, forKey: .activeDate)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let certificateChain = self.certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inactiveDate = self.inactiveDate {
            try encodeContainer.encodeTimestamp(inactiveDate, format: .epochSeconds, forKey: .inactiveDate)
        }
        if let notAfterDate = self.notAfterDate {
            try encodeContainer.encodeTimestamp(notAfterDate, format: .epochSeconds, forKey: .notAfterDate)
        }
        if let notBeforeDate = self.notBeforeDate {
            try encodeContainer.encodeTimestamp(notBeforeDate, format: .epochSeconds, forKey: .notBeforeDate)
        }
        if let serial = self.serial {
            try encodeContainer.encode(serial, forKey: .serial)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let usage = self.usage {
            try encodeContainer.encode(usage.rawValue, forKey: .usage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let usageDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CertificateUsageType.self, forKey: .usage)
        usage = usageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CertificateStatusType.self, forKey: .status)
        status = statusDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        let activeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .activeDate)
        activeDate = activeDateDecoded
        let inactiveDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .inactiveDate)
        inactiveDate = inactiveDateDecoded
        let serialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serial)
        serial = serialDecoded
        let notBeforeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notBeforeDate)
        notBeforeDate = notBeforeDateDecoded
        let notAfterDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notAfterDate)
        notAfterDate = notAfterDateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CertificateType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TransferClientTypes.DescribedCertificate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribedCertificate(activeDate: \(Swift.String(describing: activeDate)), arn: \(Swift.String(describing: arn)), certificateId: \(Swift.String(describing: certificateId)), description: \(Swift.String(describing: description)), inactiveDate: \(Swift.String(describing: inactiveDate)), notAfterDate: \(Swift.String(describing: notAfterDate)), notBeforeDate: \(Swift.String(describing: notBeforeDate)), serial: \(Swift.String(describing: serial)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), usage: \(Swift.String(describing: usage)), certificate: \"CONTENT_REDACTED\", certificateChain: \"CONTENT_REDACTED\")"}
}

extension TransferClientTypes {
    /// Describes the properties of a certificate.
    public struct DescribedCertificate: Swift.Equatable {
        /// An optional date that specifies when the certificate becomes active.
        public var activeDate: ClientRuntime.Date?
        /// The unique Amazon Resource Name (ARN) for the certificate.
        /// This member is required.
        public var arn: Swift.String?
        /// The file name for the certificate.
        public var certificate: Swift.String?
        /// The list of certificates that make up the chain for the certificate.
        public var certificateChain: Swift.String?
        /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
        public var certificateId: Swift.String?
        /// The name or description that's used to identity the certificate.
        public var description: Swift.String?
        /// An optional date that specifies when the certificate becomes inactive.
        public var inactiveDate: ClientRuntime.Date?
        /// The final date that the certificate is valid.
        public var notAfterDate: ClientRuntime.Date?
        /// The earliest date that the certificate is valid.
        public var notBeforeDate: ClientRuntime.Date?
        /// The serial number for the certificate.
        public var serial: Swift.String?
        /// The certificate can be either ACTIVE, PENDING_ROTATION, or INACTIVE. PENDING_ROTATION means that this certificate will replace the current certificate when it expires.
        public var status: TransferClientTypes.CertificateStatusType?
        /// Key-value pairs that can be used to group and search for certificates.
        public var tags: [TransferClientTypes.Tag]?
        /// If a private key has been specified for the certificate, its type is CERTIFICATE_WITH_PRIVATE_KEY. If there is no private key, the type is CERTIFICATE.
        public var type: TransferClientTypes.CertificateType?
        /// Specifies whether this certificate is used for signing or encryption.
        public var usage: TransferClientTypes.CertificateUsageType?

        public init(
            activeDate: ClientRuntime.Date? = nil,
            arn: Swift.String? = nil,
            certificate: Swift.String? = nil,
            certificateChain: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            description: Swift.String? = nil,
            inactiveDate: ClientRuntime.Date? = nil,
            notAfterDate: ClientRuntime.Date? = nil,
            notBeforeDate: ClientRuntime.Date? = nil,
            serial: Swift.String? = nil,
            status: TransferClientTypes.CertificateStatusType? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            type: TransferClientTypes.CertificateType? = nil,
            usage: TransferClientTypes.CertificateUsageType? = nil
        )
        {
            self.activeDate = activeDate
            self.arn = arn
            self.certificate = certificate
            self.certificateChain = certificateChain
            self.certificateId = certificateId
            self.description = description
            self.inactiveDate = inactiveDate
            self.notAfterDate = notAfterDate
            self.notBeforeDate = notBeforeDate
            self.serial = serial
            self.status = status
            self.tags = tags
            self.type = type
            self.usage = usage
        }
    }

}

extension TransferClientTypes.DescribedConnector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case arn = "Arn"
        case as2Config = "As2Config"
        case connectorId = "ConnectorId"
        case loggingRole = "LoggingRole"
        case securityPolicyName = "SecurityPolicyName"
        case serviceManagedEgressIpAddresses = "ServiceManagedEgressIpAddresses"
        case sftpConfig = "SftpConfig"
        case tags = "Tags"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = self.accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let as2Config = self.as2Config {
            try encodeContainer.encode(as2Config, forKey: .as2Config)
        }
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let securityPolicyName = self.securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let serviceManagedEgressIpAddresses = serviceManagedEgressIpAddresses {
            var serviceManagedEgressIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceManagedEgressIpAddresses)
            for servicemanagedegressipaddress0 in serviceManagedEgressIpAddresses {
                try serviceManagedEgressIpAddressesContainer.encode(servicemanagedegressipaddress0)
            }
        }
        if let sftpConfig = self.sftpConfig {
            try encodeContainer.encode(sftpConfig, forKey: .sftpConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let as2ConfigDecoded = try containerValues.decodeIfPresent(TransferClientTypes.As2ConnectorConfig.self, forKey: .as2Config)
        as2Config = as2ConfigDecoded
        let accessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let sftpConfigDecoded = try containerValues.decodeIfPresent(TransferClientTypes.SftpConnectorConfig.self, forKey: .sftpConfig)
        sftpConfig = sftpConfigDecoded
        let serviceManagedEgressIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .serviceManagedEgressIpAddresses)
        var serviceManagedEgressIpAddressesDecoded0:[Swift.String]? = nil
        if let serviceManagedEgressIpAddressesContainer = serviceManagedEgressIpAddressesContainer {
            serviceManagedEgressIpAddressesDecoded0 = [Swift.String]()
            for string0 in serviceManagedEgressIpAddressesContainer {
                if let string0 = string0 {
                    serviceManagedEgressIpAddressesDecoded0?.append(string0)
                }
            }
        }
        serviceManagedEgressIpAddresses = serviceManagedEgressIpAddressesDecoded0
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
    }
}

extension TransferClientTypes {
    /// Describes the parameters for the connector, as identified by the ConnectorId.
    public struct DescribedConnector: Swift.Equatable {
        /// Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use. For AS2 connectors With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the fileâ€™s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer. If you are using Basic authentication for your AS2 connector, the access role requires the secretsmanager:GetSecretValue permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the kms:Decrypt permission for that key. For SFTP connectors Make sure that the access role provides read and write access to the parent directory of the file location that's used in the StartFileTransfer request. Additionally, make sure that the role provides secretsmanager:GetSecretValue permission to Secrets Manager.
        public var accessRole: Swift.String?
        /// The unique Amazon Resource Name (ARN) for the connector.
        /// This member is required.
        public var arn: Swift.String?
        /// A structure that contains the parameters for an AS2 connector object.
        public var as2Config: TransferClientTypes.As2ConnectorConfig?
        /// The unique identifier for the connector.
        public var connectorId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a connector to turn on CloudWatch logging for Amazon S3 events. When set, you can view connector activity in your CloudWatch logs.
        public var loggingRole: Swift.String?
        /// The text name of the security policy for the specified connector.
        public var securityPolicyName: Swift.String?
        /// The list of egress IP addresses of this connector. These IP addresses are assigned automatically when you create the connector.
        public var serviceManagedEgressIpAddresses: [Swift.String]?
        /// A structure that contains the parameters for an SFTP connector object.
        public var sftpConfig: TransferClientTypes.SftpConnectorConfig?
        /// Key-value pairs that can be used to group and search for connectors.
        public var tags: [TransferClientTypes.Tag]?
        /// The URL of the partner's AS2 or SFTP endpoint.
        public var url: Swift.String?

        public init(
            accessRole: Swift.String? = nil,
            arn: Swift.String? = nil,
            as2Config: TransferClientTypes.As2ConnectorConfig? = nil,
            connectorId: Swift.String? = nil,
            loggingRole: Swift.String? = nil,
            securityPolicyName: Swift.String? = nil,
            serviceManagedEgressIpAddresses: [Swift.String]? = nil,
            sftpConfig: TransferClientTypes.SftpConnectorConfig? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            url: Swift.String? = nil
        )
        {
            self.accessRole = accessRole
            self.arn = arn
            self.as2Config = as2Config
            self.connectorId = connectorId
            self.loggingRole = loggingRole
            self.securityPolicyName = securityPolicyName
            self.serviceManagedEgressIpAddresses = serviceManagedEgressIpAddresses
            self.sftpConfig = sftpConfig
            self.tags = tags
            self.url = url
        }
    }

}

extension TransferClientTypes.DescribedExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case executionRole = "ExecutionRole"
        case initialFileLocation = "InitialFileLocation"
        case loggingConfiguration = "LoggingConfiguration"
        case posixProfile = "PosixProfile"
        case results = "Results"
        case serviceMetadata = "ServiceMetadata"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let initialFileLocation = self.initialFileLocation {
            try encodeContainer.encode(initialFileLocation, forKey: .initialFileLocation)
        }
        if let loggingConfiguration = self.loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
        if let posixProfile = self.posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let results = self.results {
            try encodeContainer.encode(results, forKey: .results)
        }
        if let serviceMetadata = self.serviceMetadata {
            try encodeContainer.encode(serviceMetadata, forKey: .serviceMetadata)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let initialFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.FileLocation.self, forKey: .initialFileLocation)
        initialFileLocation = initialFileLocationDecoded
        let serviceMetadataDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ServiceMetadata.self, forKey: .serviceMetadata)
        serviceMetadata = serviceMetadataDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionResults.self, forKey: .results)
        results = resultsDecoded
    }
}

extension TransferClientTypes {
    /// The details for an execution object.
    public struct DescribedExecution: Swift.Equatable {
        /// A unique identifier for the execution of a workflow.
        public var executionId: Swift.String?
        /// The IAM role associated with the execution.
        public var executionRole: Swift.String?
        /// A structure that describes the Amazon S3 or EFS file location. This is the file location when the execution begins: if the file is being copied, this is the initial (as opposed to destination) file location.
        public var initialFileLocation: TransferClientTypes.FileLocation?
        /// The IAM logging role associated with the execution.
        public var loggingConfiguration: TransferClientTypes.LoggingConfiguration?
        /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
        public var posixProfile: TransferClientTypes.PosixProfile?
        /// A structure that describes the execution results. This includes a list of the steps along with the details of each step, error type and message (if any), and the OnExceptionSteps structure.
        public var results: TransferClientTypes.ExecutionResults?
        /// A container object for the session details that are associated with a workflow.
        public var serviceMetadata: TransferClientTypes.ServiceMetadata?
        /// The status is one of the execution. Can be in progress, completed, exception encountered, or handling the exception.
        public var status: TransferClientTypes.ExecutionStatus?

        public init(
            executionId: Swift.String? = nil,
            executionRole: Swift.String? = nil,
            initialFileLocation: TransferClientTypes.FileLocation? = nil,
            loggingConfiguration: TransferClientTypes.LoggingConfiguration? = nil,
            posixProfile: TransferClientTypes.PosixProfile? = nil,
            results: TransferClientTypes.ExecutionResults? = nil,
            serviceMetadata: TransferClientTypes.ServiceMetadata? = nil,
            status: TransferClientTypes.ExecutionStatus? = nil
        )
        {
            self.executionId = executionId
            self.executionRole = executionRole
            self.initialFileLocation = initialFileLocation
            self.loggingConfiguration = loggingConfiguration
            self.posixProfile = posixProfile
            self.results = results
            self.serviceMetadata = serviceMetadata
            self.status = status
        }
    }

}

extension TransferClientTypes.DescribedHostKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dateImported = "DateImported"
        case description = "Description"
        case hostKeyFingerprint = "HostKeyFingerprint"
        case hostKeyId = "HostKeyId"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateImported = self.dateImported {
            try encodeContainer.encodeTimestamp(dateImported, format: .epochSeconds, forKey: .dateImported)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hostKeyFingerprint = self.hostKeyFingerprint {
            try encodeContainer.encode(hostKeyFingerprint, forKey: .hostKeyFingerprint)
        }
        if let hostKeyId = self.hostKeyId {
            try encodeContainer.encode(hostKeyId, forKey: .hostKeyId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let hostKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyId)
        hostKeyId = hostKeyIdDecoded
        let hostKeyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyFingerprint)
        hostKeyFingerprint = hostKeyFingerprintDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let dateImportedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateImported)
        dateImported = dateImportedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TransferClientTypes {
    /// The details for a server host key.
    public struct DescribedHostKey: Swift.Equatable {
        /// The unique Amazon Resource Name (ARN) for the host key.
        /// This member is required.
        public var arn: Swift.String?
        /// The date on which the host key was added to the server.
        public var dateImported: ClientRuntime.Date?
        /// The text description for this host key.
        public var description: Swift.String?
        /// The public key fingerprint, which is a short sequence of bytes used to identify the longer public key.
        public var hostKeyFingerprint: Swift.String?
        /// A unique identifier for the host key.
        public var hostKeyId: Swift.String?
        /// Key-value pairs that can be used to group and search for host keys.
        public var tags: [TransferClientTypes.Tag]?
        /// The encryption algorithm that is used for the host key. The Type parameter is specified by using one of the following values:
        ///
        /// * ssh-rsa
        ///
        /// * ssh-ed25519
        ///
        /// * ecdsa-sha2-nistp256
        ///
        /// * ecdsa-sha2-nistp384
        ///
        /// * ecdsa-sha2-nistp521
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            dateImported: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            hostKeyFingerprint: Swift.String? = nil,
            hostKeyId: Swift.String? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.dateImported = dateImported
            self.description = description
            self.hostKeyFingerprint = hostKeyFingerprint
            self.hostKeyId = hostKeyId
            self.tags = tags
            self.type = type
        }
    }

}

extension TransferClientTypes.DescribedProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case as2Id = "As2Id"
        case certificateIds = "CertificateIds"
        case profileId = "ProfileId"
        case profileType = "ProfileType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let as2Id = self.as2Id {
            try encodeContainer.encode(as2Id, forKey: .as2Id)
        }
        if let certificateIds = certificateIds {
            var certificateIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateIds)
            for certificateid0 in certificateIds {
                try certificateIdsContainer.encode(certificateid0)
            }
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let profileType = self.profileType {
            try encodeContainer.encode(profileType.rawValue, forKey: .profileType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let profileTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProfileType.self, forKey: .profileType)
        profileType = profileTypeDecoded
        let as2IdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .as2Id)
        as2Id = as2IdDecoded
        let certificateIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .certificateIds)
        var certificateIdsDecoded0:[Swift.String]? = nil
        if let certificateIdsContainer = certificateIdsContainer {
            certificateIdsDecoded0 = [Swift.String]()
            for string0 in certificateIdsContainer {
                if let string0 = string0 {
                    certificateIdsDecoded0?.append(string0)
                }
            }
        }
        certificateIds = certificateIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TransferClientTypes {
    /// The details for a local or partner AS2 profile.
    public struct DescribedProfile: Swift.Equatable {
        /// The unique Amazon Resource Name (ARN) for the profile.
        /// This member is required.
        public var arn: Swift.String?
        /// The As2Id is the AS2-name, as defined in the [RFC 4130](https://datatracker.ietf.org/doc/html/rfc4130). For inbound transfers, this is the AS2-From header for the AS2 messages sent from the partner. For outbound connectors, this is the AS2-To header for the AS2 messages sent to the partner using the StartFileTransfer API operation. This ID cannot include spaces.
        public var as2Id: Swift.String?
        /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
        public var certificateIds: [Swift.String]?
        /// A unique identifier for the local or partner AS2 profile.
        public var profileId: Swift.String?
        /// Indicates whether to list only LOCAL type profiles or only PARTNER type profiles. If not supplied in the request, the command lists all types of profiles.
        public var profileType: TransferClientTypes.ProfileType?
        /// Key-value pairs that can be used to group and search for profiles.
        public var tags: [TransferClientTypes.Tag]?

        public init(
            arn: Swift.String? = nil,
            as2Id: Swift.String? = nil,
            certificateIds: [Swift.String]? = nil,
            profileId: Swift.String? = nil,
            profileType: TransferClientTypes.ProfileType? = nil,
            tags: [TransferClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.as2Id = as2Id
            self.certificateIds = certificateIds
            self.profileId = profileId
            self.profileType = profileType
            self.tags = tags
        }
    }

}

extension TransferClientTypes.DescribedSecurityPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fips = "Fips"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case sshCiphers = "SshCiphers"
        case sshHostKeyAlgorithms = "SshHostKeyAlgorithms"
        case sshKexs = "SshKexs"
        case sshMacs = "SshMacs"
        case tlsCiphers = "TlsCiphers"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fips = self.fips {
            try encodeContainer.encode(fips, forKey: .fips)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for securitypolicyprotocol0 in protocols {
                try protocolsContainer.encode(securitypolicyprotocol0.rawValue)
            }
        }
        if let securityPolicyName = self.securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let sshCiphers = sshCiphers {
            var sshCiphersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshCiphers)
            for securitypolicyoption0 in sshCiphers {
                try sshCiphersContainer.encode(securitypolicyoption0)
            }
        }
        if let sshHostKeyAlgorithms = sshHostKeyAlgorithms {
            var sshHostKeyAlgorithmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshHostKeyAlgorithms)
            for securitypolicyoption0 in sshHostKeyAlgorithms {
                try sshHostKeyAlgorithmsContainer.encode(securitypolicyoption0)
            }
        }
        if let sshKexs = sshKexs {
            var sshKexsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshKexs)
            for securitypolicyoption0 in sshKexs {
                try sshKexsContainer.encode(securitypolicyoption0)
            }
        }
        if let sshMacs = sshMacs {
            var sshMacsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshMacs)
            for securitypolicyoption0 in sshMacs {
                try sshMacsContainer.encode(securitypolicyoption0)
            }
        }
        if let tlsCiphers = tlsCiphers {
            var tlsCiphersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tlsCiphers)
            for securitypolicyoption0 in tlsCiphers {
                try tlsCiphersContainer.encode(securitypolicyoption0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fipsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fips)
        fips = fipsDecoded
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let sshCiphersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sshCiphers)
        var sshCiphersDecoded0:[Swift.String]? = nil
        if let sshCiphersContainer = sshCiphersContainer {
            sshCiphersDecoded0 = [Swift.String]()
            for string0 in sshCiphersContainer {
                if let string0 = string0 {
                    sshCiphersDecoded0?.append(string0)
                }
            }
        }
        sshCiphers = sshCiphersDecoded0
        let sshKexsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sshKexs)
        var sshKexsDecoded0:[Swift.String]? = nil
        if let sshKexsContainer = sshKexsContainer {
            sshKexsDecoded0 = [Swift.String]()
            for string0 in sshKexsContainer {
                if let string0 = string0 {
                    sshKexsDecoded0?.append(string0)
                }
            }
        }
        sshKexs = sshKexsDecoded0
        let sshMacsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sshMacs)
        var sshMacsDecoded0:[Swift.String]? = nil
        if let sshMacsContainer = sshMacsContainer {
            sshMacsDecoded0 = [Swift.String]()
            for string0 in sshMacsContainer {
                if let string0 = string0 {
                    sshMacsDecoded0?.append(string0)
                }
            }
        }
        sshMacs = sshMacsDecoded0
        let tlsCiphersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tlsCiphers)
        var tlsCiphersDecoded0:[Swift.String]? = nil
        if let tlsCiphersContainer = tlsCiphersContainer {
            tlsCiphersDecoded0 = [Swift.String]()
            for string0 in tlsCiphersContainer {
                if let string0 = string0 {
                    tlsCiphersDecoded0?.append(string0)
                }
            }
        }
        tlsCiphers = tlsCiphersDecoded0
        let sshHostKeyAlgorithmsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sshHostKeyAlgorithms)
        var sshHostKeyAlgorithmsDecoded0:[Swift.String]? = nil
        if let sshHostKeyAlgorithmsContainer = sshHostKeyAlgorithmsContainer {
            sshHostKeyAlgorithmsDecoded0 = [Swift.String]()
            for string0 in sshHostKeyAlgorithmsContainer {
                if let string0 = string0 {
                    sshHostKeyAlgorithmsDecoded0?.append(string0)
                }
            }
        }
        sshHostKeyAlgorithms = sshHostKeyAlgorithmsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.SecurityPolicyResourceType.self, forKey: .type)
        type = typeDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([TransferClientTypes.SecurityPolicyProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[TransferClientTypes.SecurityPolicyProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [TransferClientTypes.SecurityPolicyProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
    }
}

extension TransferClientTypes {
    /// Describes the properties of a security policy that you specify. For more information about security policies, see [Working with security policies for servers](https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html) or [Working with security policies for SFTP connectors](https://docs.aws.amazon.com/transfer/latest/userguide/security-policies-connectors.html).
    public struct DescribedSecurityPolicy: Swift.Equatable {
        /// Specifies whether this policy enables Federal Information Processing Standards (FIPS). This parameter applies to both server and connector security policies.
        public var fips: Swift.Bool?
        /// Lists the file transfer protocols that the security policy applies to.
        public var protocols: [TransferClientTypes.SecurityPolicyProtocol]?
        /// The text name of the specified security policy.
        /// This member is required.
        public var securityPolicyName: Swift.String?
        /// Lists the enabled Secure Shell (SSH) cipher encryption algorithms in the security policy that is attached to the server or connector. This parameter applies to both server and connector security policies.
        public var sshCiphers: [Swift.String]?
        /// Lists the host key algorithms for the security policy. This parameter only applies to security policies for connectors.
        public var sshHostKeyAlgorithms: [Swift.String]?
        /// Lists the enabled SSH key exchange (KEX) encryption algorithms in the security policy that is attached to the server or connector. This parameter applies to both server and connector security policies.
        public var sshKexs: [Swift.String]?
        /// Lists the enabled SSH message authentication code (MAC) encryption algorithms in the security policy that is attached to the server or connector. This parameter applies to both server and connector security policies.
        public var sshMacs: [Swift.String]?
        /// Lists the enabled Transport Layer Security (TLS) cipher encryption algorithms in the security policy that is attached to the server. This parameter only applies to security policies for servers.
        public var tlsCiphers: [Swift.String]?
        /// The resource type to which the security policy applies, either server or connector.
        public var type: TransferClientTypes.SecurityPolicyResourceType?

        public init(
            fips: Swift.Bool? = nil,
            protocols: [TransferClientTypes.SecurityPolicyProtocol]? = nil,
            securityPolicyName: Swift.String? = nil,
            sshCiphers: [Swift.String]? = nil,
            sshHostKeyAlgorithms: [Swift.String]? = nil,
            sshKexs: [Swift.String]? = nil,
            sshMacs: [Swift.String]? = nil,
            tlsCiphers: [Swift.String]? = nil,
            type: TransferClientTypes.SecurityPolicyResourceType? = nil
        )
        {
            self.fips = fips
            self.protocols = protocols
            self.securityPolicyName = securityPolicyName
            self.sshCiphers = sshCiphers
            self.sshHostKeyAlgorithms = sshHostKeyAlgorithms
            self.sshKexs = sshKexs
            self.sshMacs = sshMacs
            self.tlsCiphers = tlsCiphers
            self.type = type
        }
    }

}

extension TransferClientTypes.DescribedServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case as2ServiceManagedEgressIpAddresses = "As2ServiceManagedEgressIpAddresses"
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKeyFingerprint = "HostKeyFingerprint"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case postAuthenticationLoginBanner = "PostAuthenticationLoginBanner"
        case preAuthenticationLoginBanner = "PreAuthenticationLoginBanner"
        case protocolDetails = "ProtocolDetails"
        case protocols = "Protocols"
        case s3StorageOptions = "S3StorageOptions"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
        case state = "State"
        case structuredLogDestinations = "StructuredLogDestinations"
        case tags = "Tags"
        case userCount = "UserCount"
        case workflowDetails = "WorkflowDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let as2ServiceManagedEgressIpAddresses = as2ServiceManagedEgressIpAddresses {
            var as2ServiceManagedEgressIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .as2ServiceManagedEgressIpAddresses)
            for servicemanagedegressipaddress0 in as2ServiceManagedEgressIpAddresses {
                try as2ServiceManagedEgressIpAddressesContainer.encode(servicemanagedegressipaddress0)
            }
        }
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointDetails = self.endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKeyFingerprint = self.hostKeyFingerprint {
            try encodeContainer.encode(hostKeyFingerprint, forKey: .hostKeyFingerprint)
        }
        if let identityProviderDetails = self.identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let postAuthenticationLoginBanner = self.postAuthenticationLoginBanner {
            try encodeContainer.encode(postAuthenticationLoginBanner, forKey: .postAuthenticationLoginBanner)
        }
        if let preAuthenticationLoginBanner = self.preAuthenticationLoginBanner {
            try encodeContainer.encode(preAuthenticationLoginBanner, forKey: .preAuthenticationLoginBanner)
        }
        if let protocolDetails = self.protocolDetails {
            try encodeContainer.encode(protocolDetails, forKey: .protocolDetails)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocol0 in protocols {
                try protocolsContainer.encode(protocol0.rawValue)
            }
        }
        if let s3StorageOptions = self.s3StorageOptions {
            try encodeContainer.encode(s3StorageOptions, forKey: .s3StorageOptions)
        }
        if let securityPolicyName = self.securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let structuredLogDestinations = structuredLogDestinations {
            var structuredLogDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .structuredLogDestinations)
            for arn0 in structuredLogDestinations {
                try structuredLogDestinationsContainer.encode(arn0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userCount = self.userCount {
            try encodeContainer.encode(userCount, forKey: .userCount)
        }
        if let workflowDetails = self.workflowDetails {
            try encodeContainer.encode(workflowDetails, forKey: .workflowDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let protocolDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProtocolDetails.self, forKey: .protocolDetails)
        protocolDetails = protocolDetailsDecoded
        let domainDecoded = try containerValues.decodeIfPresent(TransferClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyFingerprint)
        hostKeyFingerprint = hostKeyFingerprintDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let postAuthenticationLoginBannerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postAuthenticationLoginBanner)
        postAuthenticationLoginBanner = postAuthenticationLoginBannerDecoded
        let preAuthenticationLoginBannerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preAuthenticationLoginBanner)
        preAuthenticationLoginBanner = preAuthenticationLoginBannerDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[TransferClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [TransferClientTypes.ModelProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TransferClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userCount)
        userCount = userCountDecoded
        let workflowDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowDetails.self, forKey: .workflowDetails)
        workflowDetails = workflowDetailsDecoded
        let structuredLogDestinationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .structuredLogDestinations)
        var structuredLogDestinationsDecoded0:[Swift.String]? = nil
        if let structuredLogDestinationsContainer = structuredLogDestinationsContainer {
            structuredLogDestinationsDecoded0 = [Swift.String]()
            for string0 in structuredLogDestinationsContainer {
                if let string0 = string0 {
                    structuredLogDestinationsDecoded0?.append(string0)
                }
            }
        }
        structuredLogDestinations = structuredLogDestinationsDecoded0
        let s3StorageOptionsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.S3StorageOptions.self, forKey: .s3StorageOptions)
        s3StorageOptions = s3StorageOptionsDecoded
        let as2ServiceManagedEgressIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .as2ServiceManagedEgressIpAddresses)
        var as2ServiceManagedEgressIpAddressesDecoded0:[Swift.String]? = nil
        if let as2ServiceManagedEgressIpAddressesContainer = as2ServiceManagedEgressIpAddressesContainer {
            as2ServiceManagedEgressIpAddressesDecoded0 = [Swift.String]()
            for string0 in as2ServiceManagedEgressIpAddressesContainer {
                if let string0 = string0 {
                    as2ServiceManagedEgressIpAddressesDecoded0?.append(string0)
                }
            }
        }
        as2ServiceManagedEgressIpAddresses = as2ServiceManagedEgressIpAddressesDecoded0
    }
}

extension TransferClientTypes {
    /// Describes the properties of a file transfer protocol-enabled server that was specified.
    public struct DescribedServer: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) of the server.
        /// This member is required.
        public var arn: Swift.String?
        /// The list of egress IP addresses of this server. These IP addresses are only relevant for servers that use the AS2 protocol. They are used for sending asynchronous MDNs. These IP addresses are assigned automatically when you create an AS2 server. Additionally, if you update an existing server and add the AS2 protocol, static IP addresses are assigned as well.
        public var as2ServiceManagedEgressIpAddresses: [Swift.String]?
        /// Specifies the ARN of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when Protocols is set to FTPS.
        public var certificate: Swift.String?
        /// Specifies the domain of the storage system that is used for file transfers.
        public var domain: TransferClientTypes.Domain?
        /// The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make your endpoint accessible only to resources within your VPC, or you can attach Elastic IP addresses and make your endpoint accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.
        public var endpointDetails: TransferClientTypes.EndpointDetails?
        /// Defines the type of endpoint that your server is connected to. If your server is connected to a VPC endpoint, your server isn't accessible over the public internet.
        public var endpointType: TransferClientTypes.EndpointType?
        /// Specifies the Base64-encoded SHA256 fingerprint of the server's host key. This value is equivalent to the output of the ssh-keygen -l -f my-new-server-key command.
        public var hostKeyFingerprint: Swift.String?
        /// Specifies information to call a customer-supplied authentication API. This field is not populated when the IdentityProviderType of a server is AWS_DIRECTORY_SERVICE or SERVICE_MANAGED.
        public var identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
        /// The mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Transfer Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the IdentityProviderDetails parameter. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the IdentityProviderDetails parameter. Use the AWS_LAMBDA value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the Function parameter for the IdentityProviderDetails data type.
        public var identityProviderType: TransferClientTypes.IdentityProviderType?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
        public var loggingRole: Swift.String?
        /// Specifies a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
        public var postAuthenticationLoginBanner: Swift.String?
        /// Specifies a string to display when users connect to a server. This string is displayed before the user authenticates. For example, the following banner displays details about using the system: This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel.
        public var preAuthenticationLoginBanner: Swift.String?
        /// The protocol settings that are configured for your server.
        ///
        /// * To indicate passive mode (for FTP and FTPS protocols), use the PassiveIp parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
        ///
        /// * To ignore the error that is generated when the client attempts to use the SETSTAT command on a file that you are uploading to an Amazon S3 bucket, use the SetStatOption parameter. To have the Transfer Family server ignore the SETSTAT command and upload files without needing to make any changes to your SFTP client, set the value to ENABLE_NO_OP. If you set the SetStatOption parameter to ENABLE_NO_OP, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a SETSTAT call.
        ///
        /// * To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the TlsSessionResumptionMode parameter.
        ///
        /// * As2Transports indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
        public var protocolDetails: TransferClientTypes.ProtocolDetails?
        /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:
        ///
        /// * SFTP (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH
        ///
        /// * FTPS (File Transfer Protocol Secure): File transfer with TLS encryption
        ///
        /// * FTP (File Transfer Protocol): Unencrypted file transfer
        ///
        /// * AS2 (Applicability Statement 2): used for transporting structured business-to-business data
        ///
        ///
        ///
        ///
        /// * If you select FTPS, you must choose a certificate stored in Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS.
        ///
        /// * If Protocol includes either FTP or FTPS, then the EndpointType must be VPC and the IdentityProviderType must be either AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
        ///
        /// * If Protocol includes FTP, then AddressAllocationIds cannot be associated.
        ///
        /// * If Protocol is set only to SFTP, the EndpointType can be set to PUBLIC and the IdentityProviderType can be set any of the supported identity types: SERVICE_MANAGED, AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
        ///
        /// * If Protocol includes AS2, then the EndpointType must be VPC, and domain must be Amazon S3.
        public var protocols: [TransferClientTypes.ModelProtocol]?
        /// Specifies whether or not performance for your Amazon S3 directories is optimized. This is disabled by default. By default, home directory mappings have a TYPE of DIRECTORY. If you enable this option, you would then need to explicitly set the HomeDirectoryMapEntryType to FILE if you want a mapping to have a file target.
        public var s3StorageOptions: TransferClientTypes.S3StorageOptions?
        /// Specifies the name of the security policy for the server.
        public var securityPolicyName: Swift.String?
        /// Specifies the unique system-assigned identifier for a server that you instantiate.
        public var serverId: Swift.String?
        /// The condition of the server that was described. A value of ONLINE indicates that the server can accept jobs and transfer files. A State value of OFFLINE means that the server cannot perform file transfer operations. The states of STARTING and STOPPING indicate that the server is in an intermediate state, either not fully able to respond, or not fully offline. The values of START_FAILED or STOP_FAILED can indicate an error condition.
        public var state: TransferClientTypes.State?
        /// Specifies the log groups to which your server logs are sent. To specify a log group, you must provide the ARN for an existing log group. In this case, the format of the log group is as follows: arn:aws:logs:region-name:amazon-account-id:log-group:log-group-name:* For example, arn:aws:logs:us-east-1:111122223333:log-group:mytestgroup:* If you have previously specified a log group for a server, you can clear it, and in effect turn off structured logging, by providing an empty value for this parameter in an update-server call. For example: update-server --server-id s-1234567890abcdef0 --structured-log-destinations
        public var structuredLogDestinations: [Swift.String]?
        /// Specifies the key-value pairs that you can use to search for and group servers that were assigned to the server that was described.
        public var tags: [TransferClientTypes.Tag]?
        /// Specifies the number of users that are assigned to a server you specified with the ServerId.
        public var userCount: Swift.Int?
        /// Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow. In addition to a workflow to execute when a file is uploaded completely, WorkflowDetails can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when the server session disconnects while the file is still being uploaded.
        public var workflowDetails: TransferClientTypes.WorkflowDetails?

        public init(
            arn: Swift.String? = nil,
            as2ServiceManagedEgressIpAddresses: [Swift.String]? = nil,
            certificate: Swift.String? = nil,
            domain: TransferClientTypes.Domain? = nil,
            endpointDetails: TransferClientTypes.EndpointDetails? = nil,
            endpointType: TransferClientTypes.EndpointType? = nil,
            hostKeyFingerprint: Swift.String? = nil,
            identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
            identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
            loggingRole: Swift.String? = nil,
            postAuthenticationLoginBanner: Swift.String? = nil,
            preAuthenticationLoginBanner: Swift.String? = nil,
            protocolDetails: TransferClientTypes.ProtocolDetails? = nil,
            protocols: [TransferClientTypes.ModelProtocol]? = nil,
            s3StorageOptions: TransferClientTypes.S3StorageOptions? = nil,
            securityPolicyName: Swift.String? = nil,
            serverId: Swift.String? = nil,
            state: TransferClientTypes.State? = nil,
            structuredLogDestinations: [Swift.String]? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            userCount: Swift.Int? = nil,
            workflowDetails: TransferClientTypes.WorkflowDetails? = nil
        )
        {
            self.arn = arn
            self.as2ServiceManagedEgressIpAddresses = as2ServiceManagedEgressIpAddresses
            self.certificate = certificate
            self.domain = domain
            self.endpointDetails = endpointDetails
            self.endpointType = endpointType
            self.hostKeyFingerprint = hostKeyFingerprint
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderType = identityProviderType
            self.loggingRole = loggingRole
            self.postAuthenticationLoginBanner = postAuthenticationLoginBanner
            self.preAuthenticationLoginBanner = preAuthenticationLoginBanner
            self.protocolDetails = protocolDetails
            self.protocols = protocols
            self.s3StorageOptions = s3StorageOptions
            self.securityPolicyName = securityPolicyName
            self.serverId = serverId
            self.state = state
            self.structuredLogDestinations = structuredLogDestinations
            self.tags = tags
            self.userCount = userCount
            self.workflowDetails = workflowDetails
        }
    }

}

extension TransferClientTypes.DescribedUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case sshPublicKeys = "SshPublicKeys"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymapentry0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymapentry0)
            }
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = self.posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let sshPublicKeys = sshPublicKeys {
            var sshPublicKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshPublicKeys)
            for sshpublickey0 in sshPublicKeys {
                try sshPublicKeysContainer.encode(sshpublickey0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let sshPublicKeysContainer = try containerValues.decodeIfPresent([TransferClientTypes.SshPublicKey?].self, forKey: .sshPublicKeys)
        var sshPublicKeysDecoded0:[TransferClientTypes.SshPublicKey]? = nil
        if let sshPublicKeysContainer = sshPublicKeysContainer {
            sshPublicKeysDecoded0 = [TransferClientTypes.SshPublicKey]()
            for structure0 in sshPublicKeysContainer {
                if let structure0 = structure0 {
                    sshPublicKeysDecoded0?.append(structure0)
                }
            }
        }
        sshPublicKeys = sshPublicKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension TransferClientTypes {
    /// Describes the properties of a user that was specified.
    public struct DescribedUser: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) for the user that was requested to be described.
        /// This member is required.
        public var arn: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
        public var homeDirectory: Swift.String?
        /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. In most cases, you can use this value instead of the session policy to lock your user down to the designated home directory ("chroot"). To do this, you can set Entry to '/' and set Target to the HomeDirectory parameter value.
        public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
        /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}.
        public var policy: Swift.String?
        /// Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon Elastic File System (Amazon EFS) file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
        public var posixProfile: TransferClientTypes.PosixProfile?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
        public var role: Swift.String?
        /// Specifies the public key portion of the Secure Shell (SSH) keys stored for the described user.
        public var sshPublicKeys: [TransferClientTypes.SshPublicKey]?
        /// Specifies the key-value pairs for the user requested. Tag can be used to search for and group users for a variety of purposes.
        public var tags: [TransferClientTypes.Tag]?
        /// Specifies the name of the user that was requested to be described. User names are used for authentication purposes. This is the string that will be used by your user when they log in to your server.
        public var userName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            policy: Swift.String? = nil,
            posixProfile: TransferClientTypes.PosixProfile? = nil,
            role: Swift.String? = nil,
            sshPublicKeys: [TransferClientTypes.SshPublicKey]? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.homeDirectory = homeDirectory
            self.homeDirectoryMappings = homeDirectoryMappings
            self.homeDirectoryType = homeDirectoryType
            self.policy = policy
            self.posixProfile = posixProfile
            self.role = role
            self.sshPublicKeys = sshPublicKeys
            self.tags = tags
            self.userName = userName
        }
    }

}

extension TransferClientTypes.DescribedWorkflow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case onExceptionSteps = "OnExceptionSteps"
        case steps = "Steps"
        case tags = "Tags"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let onExceptionSteps = onExceptionSteps {
            var onExceptionStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .onExceptionSteps)
            for workflowstep0 in onExceptionSteps {
                try onExceptionStepsContainer.encode(workflowstep0)
            }
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for workflowstep0 in steps {
                try stepsContainer.encode(workflowstep0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowStep?].self, forKey: .steps)
        var stepsDecoded0:[TransferClientTypes.WorkflowStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [TransferClientTypes.WorkflowStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let onExceptionStepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowStep?].self, forKey: .onExceptionSteps)
        var onExceptionStepsDecoded0:[TransferClientTypes.WorkflowStep]? = nil
        if let onExceptionStepsContainer = onExceptionStepsContainer {
            onExceptionStepsDecoded0 = [TransferClientTypes.WorkflowStep]()
            for structure0 in onExceptionStepsContainer {
                if let structure0 = structure0 {
                    onExceptionStepsDecoded0?.append(structure0)
                }
            }
        }
        onExceptionSteps = onExceptionStepsDecoded0
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TransferClientTypes {
    /// Describes the properties of the specified workflow
    public struct DescribedWorkflow: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) for the workflow.
        /// This member is required.
        public var arn: Swift.String?
        /// Specifies the text description for the workflow.
        public var description: Swift.String?
        /// Specifies the steps (actions) to take if errors are encountered during execution of the workflow.
        public var onExceptionSteps: [TransferClientTypes.WorkflowStep]?
        /// Specifies the details for the steps that are in the specified workflow.
        public var steps: [TransferClientTypes.WorkflowStep]?
        /// Key-value pairs that can be used to group and search for workflows. Tags are metadata attached to workflows for any purpose.
        public var tags: [TransferClientTypes.Tag]?
        /// A unique identifier for the workflow.
        public var workflowId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            onExceptionSteps: [TransferClientTypes.WorkflowStep]? = nil,
            steps: [TransferClientTypes.WorkflowStep]? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.onExceptionSteps = onExceptionSteps
            self.steps = steps
            self.tags = tags
            self.workflowId = workflowId
        }
    }

}

extension TransferClientTypes {
    /// Indicates whether optimization to directory listing on S3 servers is used. Disabled by default for compatibility.
    public enum DirectoryListingOptimization: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectoryListingOptimization] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectoryListingOptimization(rawValue: rawValue) ?? DirectoryListingOptimization.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum Domain: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case efs
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [Domain] {
            return [
                .efs,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .efs: return "EFS"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Domain(rawValue: rawValue) ?? Domain.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.EfsFileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "FileSystemId"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemId = self.fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the details for the file location for the file that's being used in the workflow. Only applicable if you are using Amazon Elastic File Systems (Amazon EFS) for storage.
    public struct EfsFileLocation: Swift.Equatable {
        /// The identifier of the file system, assigned by Amazon EFS.
        public var fileSystemId: Swift.String?
        /// The pathname for the folder being used by a workflow.
        public var path: Swift.String?

        public init(
            fileSystemId: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.fileSystemId = fileSystemId
            self.path = path
        }
    }

}

extension TransferClientTypes {
    public enum EncryptionAlg: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes128Cbc
        case aes192Cbc
        case aes256Cbc
        case desEde3Cbc
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionAlg] {
            return [
                .aes128Cbc,
                .aes192Cbc,
                .aes256Cbc,
                .desEde3Cbc,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes128Cbc: return "AES128_CBC"
            case .aes192Cbc: return "AES192_CBC"
            case .aes256Cbc: return "AES256_CBC"
            case .desEde3Cbc: return "DES_EDE3_CBC"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionAlg(rawValue: rawValue) ?? EncryptionAlg.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pgp
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .pgp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pgp: return "PGP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.EndpointDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressAllocationIds = "AddressAllocationIds"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcEndpointId = "VpcEndpointId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressAllocationIds = addressAllocationIds {
            var addressAllocationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addressAllocationIds)
            for addressallocationid0 in addressAllocationIds {
                try addressAllocationIdsContainer.encode(addressallocationid0)
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcEndpointId = self.vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressAllocationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .addressAllocationIds)
        var addressAllocationIdsDecoded0:[Swift.String]? = nil
        if let addressAllocationIdsContainer = addressAllocationIdsContainer {
            addressAllocationIdsDecoded0 = [Swift.String]()
            for string0 in addressAllocationIdsContainer {
                if let string0 = string0 {
                    addressAllocationIdsDecoded0?.append(string0)
                }
            }
        }
        addressAllocationIds = addressAllocationIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension TransferClientTypes {
    /// The virtual private cloud (VPC) endpoint settings that are configured for your file transfer protocol-enabled server. With a VPC endpoint, you can restrict access to your server and resources only within your VPC. To control incoming internet traffic, invoke the UpdateServer API and attach an Elastic IP address to your server's endpoint. After May 19, 2021, you won't be able to create a server using EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount if your account hasn't already done so before May 19, 2021. If you have already created servers with EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount on or before May 19, 2021, you will not be affected. After this date, use EndpointType=VPC. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.
    public struct EndpointDetails: Swift.Equatable {
        /// A list of address allocation IDs that are required to attach an Elastic IP address to your server's endpoint. An address allocation ID corresponds to the allocation ID of an Elastic IP address. This value can be retrieved from the allocationId field from the Amazon EC2 [Address](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Address.html) data type. One way to retrieve this value is by calling the EC2 [DescribeAddresses](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAddresses.html) API. This parameter is optional. Set this parameter if you want to make your VPC endpoint public-facing. For details, see [Create an internet-facing endpoint for your server](https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#create-internet-facing-endpoint). This property can only be set as follows:
        ///
        /// * EndpointType must be set to VPC
        ///
        /// * The Transfer Family server must be offline.
        ///
        /// * You cannot set this parameter for Transfer Family servers that use the FTP protocol.
        ///
        /// * The server must already have SubnetIds populated (SubnetIds and AddressAllocationIds cannot be updated simultaneously).
        ///
        /// * AddressAllocationIds can't contain duplicates, and must be equal in length to SubnetIds. For example, if you have three subnet IDs, you must also specify three address allocation IDs.
        ///
        /// * Call the UpdateServer API to set or change this parameter.
        public var addressAllocationIds: [Swift.String]?
        /// A list of security groups IDs that are available to attach to your server's endpoint. This property can only be set when EndpointType is set to VPC. You can edit the SecurityGroupIds property in the [UpdateServer](https://docs.aws.amazon.com/transfer/latest/userguide/API_UpdateServer.html) API only if you are changing the EndpointType from PUBLIC or VPC_ENDPOINT to VPC. To change security groups associated with your server's VPC endpoint after creation, use the Amazon EC2 [ModifyVpcEndpoint](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyVpcEndpoint.html) API.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs that are required to host your server endpoint in your VPC. This property can only be set when EndpointType is set to VPC.
        public var subnetIds: [Swift.String]?
        /// The identifier of the VPC endpoint. This property can only be set when EndpointType is set to VPC_ENDPOINT. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.
        public var vpcEndpointId: Swift.String?
        /// The VPC identifier of the VPC in which a server's endpoint will be hosted. This property can only be set when EndpointType is set to VPC.
        public var vpcId: Swift.String?

        public init(
            addressAllocationIds: [Swift.String]? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.addressAllocationIds = addressAllocationIds
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }

}

extension TransferClientTypes {
    public enum EndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `public`
        case vpc
        case vpcEndpoint
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .public,
                .vpc,
                .vpcEndpoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .public: return "PUBLIC"
            case .vpc: return "VPC"
            case .vpcEndpoint: return "VPC_ENDPOINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointType(rawValue: rawValue) ?? EndpointType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.ExecutionError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the error message and type, for an error that occurs during the execution of the workflow.
    public struct ExecutionError: Swift.Equatable {
        /// Specifies the descriptive message that corresponds to the ErrorType.
        /// This member is required.
        public var message: Swift.String?
        /// Specifies the error type.
        ///
        /// * ALREADY_EXISTS: occurs for a copy step, if the overwrite option is not selected and a file with the same name already exists in the target location.
        ///
        /// * BAD_REQUEST: a general bad request: for example, a step that attempts to tag an EFS file returns BAD_REQUEST, as only S3 files can be tagged.
        ///
        /// * CUSTOM_STEP_FAILED: occurs when the custom step provided a callback that indicates failure.
        ///
        /// * INTERNAL_SERVER_ERROR: a catch-all error that can occur for a variety of reasons.
        ///
        /// * NOT_FOUND: occurs when a requested entity, for example a source file for a copy step, does not exist.
        ///
        /// * PERMISSION_DENIED: occurs if your policy does not contain the correct permissions to complete one or more of the steps in the workflow.
        ///
        /// * TIMEOUT: occurs when the execution times out. You can set the TimeoutSeconds for a custom step, anywhere from 1 second to 1800 seconds (30 minutes).
        ///
        /// * THROTTLED: occurs if you exceed the new execution refill rate of one workflow per second.
        /// This member is required.
        public var type: TransferClientTypes.ExecutionErrorType?

        public init(
            message: Swift.String? = nil,
            type: TransferClientTypes.ExecutionErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension TransferClientTypes {
    public enum ExecutionErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alreadyExists
        case badRequest
        case customStepFailed
        case internalServerError
        case notFound
        case permissionDenied
        case throttled
        case timeout
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionErrorType] {
            return [
                .alreadyExists,
                .badRequest,
                .customStepFailed,
                .internalServerError,
                .notFound,
                .permissionDenied,
                .throttled,
                .timeout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alreadyExists: return "ALREADY_EXISTS"
            case .badRequest: return "BAD_REQUEST"
            case .customStepFailed: return "CUSTOM_STEP_FAILED"
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case .notFound: return "NOT_FOUND"
            case .permissionDenied: return "PERMISSION_DENIED"
            case .throttled: return "THROTTLED"
            case .timeout: return "TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionErrorType(rawValue: rawValue) ?? ExecutionErrorType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.ExecutionResults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case onExceptionSteps = "OnExceptionSteps"
        case steps = "Steps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onExceptionSteps = onExceptionSteps {
            var onExceptionStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .onExceptionSteps)
            for executionstepresult0 in onExceptionSteps {
                try onExceptionStepsContainer.encode(executionstepresult0)
            }
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for executionstepresult0 in steps {
                try stepsContainer.encode(executionstepresult0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ExecutionStepResult?].self, forKey: .steps)
        var stepsDecoded0:[TransferClientTypes.ExecutionStepResult]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [TransferClientTypes.ExecutionStepResult]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let onExceptionStepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ExecutionStepResult?].self, forKey: .onExceptionSteps)
        var onExceptionStepsDecoded0:[TransferClientTypes.ExecutionStepResult]? = nil
        if let onExceptionStepsContainer = onExceptionStepsContainer {
            onExceptionStepsDecoded0 = [TransferClientTypes.ExecutionStepResult]()
            for structure0 in onExceptionStepsContainer {
                if let structure0 = structure0 {
                    onExceptionStepsDecoded0?.append(structure0)
                }
            }
        }
        onExceptionSteps = onExceptionStepsDecoded0
    }
}

extension TransferClientTypes {
    /// Specifies the steps in the workflow, as well as the steps to execute in case of any errors during workflow execution.
    public struct ExecutionResults: Swift.Equatable {
        /// Specifies the steps (actions) to take if errors are encountered during execution of the workflow.
        public var onExceptionSteps: [TransferClientTypes.ExecutionStepResult]?
        /// Specifies the details for the steps that are in the specified workflow.
        public var steps: [TransferClientTypes.ExecutionStepResult]?

        public init(
            onExceptionSteps: [TransferClientTypes.ExecutionStepResult]? = nil,
            steps: [TransferClientTypes.ExecutionStepResult]? = nil
        )
        {
            self.onExceptionSteps = onExceptionSteps
            self.steps = steps
        }
    }

}

extension TransferClientTypes {
    public enum ExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case exception
        case handlingException
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .completed,
                .exception,
                .handlingException,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .exception: return "EXCEPTION"
            case .handlingException: return "HANDLING_EXCEPTION"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionStatus(rawValue: rawValue) ?? ExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.ExecutionStepResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case outputs = "Outputs"
        case stepType = "StepType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let outputs = self.outputs {
            try encodeContainer.encode(outputs, forKey: .outputs)
        }
        if let stepType = self.stepType {
            try encodeContainer.encode(stepType.rawValue, forKey: .stepType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowStepType.self, forKey: .stepType)
        stepType = stepTypeDecoded
        let outputsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputs)
        outputs = outputsDecoded
        let errorDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionError.self, forKey: .error)
        error = errorDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the following details for the step: error (if any), outputs (if any), and the step type.
    public struct ExecutionStepResult: Swift.Equatable {
        /// Specifies the details for an error, if it occurred during execution of the specified workflow step.
        public var error: TransferClientTypes.ExecutionError?
        /// The values for the key/value pair applied as a tag to the file. Only applicable if the step type is TAG.
        public var outputs: Swift.String?
        /// One of the available step types.
        ///
        /// * COPY - Copy the file to another location.
        ///
        /// * CUSTOM - Perform a custom step with an Lambda function target.
        ///
        /// * DECRYPT - Decrypt a file that was encrypted before it was uploaded.
        ///
        /// * DELETE - Delete the file.
        ///
        /// * TAG - Add a tag to the file.
        public var stepType: TransferClientTypes.WorkflowStepType?

        public init(
            error: TransferClientTypes.ExecutionError? = nil,
            outputs: Swift.String? = nil,
            stepType: TransferClientTypes.WorkflowStepType? = nil
        )
        {
            self.error = error
            self.outputs = outputs
            self.stepType = stepType
        }
    }

}

extension TransferClientTypes.FileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case efsFileLocation = "EfsFileLocation"
        case s3FileLocation = "S3FileLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let efsFileLocation = self.efsFileLocation {
            try encodeContainer.encode(efsFileLocation, forKey: .efsFileLocation)
        }
        if let s3FileLocation = self.s3FileLocation {
            try encodeContainer.encode(s3FileLocation, forKey: .s3FileLocation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3FileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.S3FileLocation.self, forKey: .s3FileLocation)
        s3FileLocation = s3FileLocationDecoded
        let efsFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EfsFileLocation.self, forKey: .efsFileLocation)
        efsFileLocation = efsFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the Amazon S3 or EFS file details to be used in the step.
    public struct FileLocation: Swift.Equatable {
        /// Specifies the Amazon EFS identifier and the path for the file being used.
        public var efsFileLocation: TransferClientTypes.EfsFileLocation?
        /// Specifies the S3 details for the file being used, such as bucket, ETag, and so forth.
        public var s3FileLocation: TransferClientTypes.S3FileLocation?

        public init(
            efsFileLocation: TransferClientTypes.EfsFileLocation? = nil,
            s3FileLocation: TransferClientTypes.S3FileLocation? = nil
        )
        {
            self.efsFileLocation = efsFileLocation
            self.s3FileLocation = s3FileLocation
        }
    }

}

extension TransferClientTypes.HomeDirectoryMapEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entry = "Entry"
        case target = "Target"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entry = self.entry {
            try encodeContainer.encode(entry, forKey: .entry)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entry)
        entry = entryDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.MapType.self, forKey: .type)
        type = typeDecoded
    }
}

extension TransferClientTypes {
    /// Represents an object that contains entries and targets for HomeDirectoryMappings. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public struct HomeDirectoryMapEntry: Swift.Equatable {
        /// Represents an entry for HomeDirectoryMappings.
        /// This member is required.
        public var entry: Swift.String?
        /// Represents the map target that is used in a HomeDirectoryMapEntry.
        /// This member is required.
        public var target: Swift.String?
        /// Specifies the type of mapping. Set the type to FILE if you want the mapping to point to a file, or DIRECTORY for the directory to point to a directory. By default, home directory mappings have a Type of DIRECTORY when you create a Transfer Family server. You would need to explicitly set Type to FILE if you want a mapping to have a file target.
        public var type: TransferClientTypes.MapType?

        public init(
            entry: Swift.String? = nil,
            target: Swift.String? = nil,
            type: TransferClientTypes.MapType? = nil
        )
        {
            self.entry = entry
            self.target = target
            self.type = type
        }
    }

}

extension TransferClientTypes {
    public enum HomeDirectoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case logical
        case path
        case sdkUnknown(Swift.String)

        public static var allCases: [HomeDirectoryType] {
            return [
                .logical,
                .path,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .logical: return "LOGICAL"
            case .path: return "PATH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HomeDirectoryType(rawValue: rawValue) ?? HomeDirectoryType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.IdentityProviderDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case function = "Function"
        case invocationRole = "InvocationRole"
        case sftpAuthenticationMethods = "SftpAuthenticationMethods"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let function = self.function {
            try encodeContainer.encode(function, forKey: .function)
        }
        if let invocationRole = self.invocationRole {
            try encodeContainer.encode(invocationRole, forKey: .invocationRole)
        }
        if let sftpAuthenticationMethods = self.sftpAuthenticationMethods {
            try encodeContainer.encode(sftpAuthenticationMethods.rawValue, forKey: .sftpAuthenticationMethods)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let invocationRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationRole)
        invocationRole = invocationRoleDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let functionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .function)
        function = functionDecoded
        let sftpAuthenticationMethodsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.SftpAuthenticationMethods.self, forKey: .sftpAuthenticationMethods)
        sftpAuthenticationMethods = sftpAuthenticationMethodsDecoded
    }
}

extension TransferClientTypes {
    /// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. A server can have only one method of authentication.
    public struct IdentityProviderDetails: Swift.Equatable {
        /// The identifier of the Directory Service directory that you want to use as your identity provider.
        public var directoryId: Swift.String?
        /// The ARN for a Lambda function to use for the Identity provider.
        public var function: Swift.String?
        /// This parameter is only applicable if your IdentityProviderType is API_GATEWAY. Provides the type of InvocationRole used to authenticate the user account.
        public var invocationRole: Swift.String?
        /// For SFTP-enabled servers, and for custom identity providers only, you can specify whether to authenticate using a password, SSH key pair, or both.
        ///
        /// * PASSWORD - users must provide their password to connect.
        ///
        /// * PUBLIC_KEY - users must provide their private key to connect.
        ///
        /// * PUBLIC_KEY_OR_PASSWORD - users can authenticate with either their password or their key. This is the default value.
        ///
        /// * PUBLIC_KEY_AND_PASSWORD - users must provide both their private key and their password to connect. The server checks the key first, and then if the key is valid, the system prompts for a password. If the private key provided does not match the public key that is stored, authentication fails.
        public var sftpAuthenticationMethods: TransferClientTypes.SftpAuthenticationMethods?
        /// Provides the location of the service endpoint used to authenticate users.
        public var url: Swift.String?

        public init(
            directoryId: Swift.String? = nil,
            function: Swift.String? = nil,
            invocationRole: Swift.String? = nil,
            sftpAuthenticationMethods: TransferClientTypes.SftpAuthenticationMethods? = nil,
            url: Swift.String? = nil
        )
        {
            self.directoryId = directoryId
            self.function = function
            self.invocationRole = invocationRole
            self.sftpAuthenticationMethods = sftpAuthenticationMethods
            self.url = url
        }
    }

}

extension TransferClientTypes {
    /// The mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Transfer Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the IdentityProviderDetails parameter. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the IdentityProviderDetails parameter. Use the AWS_LAMBDA value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the Function parameter for the IdentityProviderDetails data type.
    public enum IdentityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiGateway
        case awsDirectoryService
        case awsLambda
        case serviceManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityProviderType] {
            return [
                .apiGateway,
                .awsDirectoryService,
                .awsLambda,
                .serviceManaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiGateway: return "API_GATEWAY"
            case .awsDirectoryService: return "AWS_DIRECTORY_SERVICE"
            case .awsLambda: return "AWS_LAMBDA"
            case .serviceManaged: return "SERVICE_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityProviderType(rawValue: rawValue) ?? IdentityProviderType.sdkUnknown(rawValue)
        }
    }
}

extension ImportCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportCertificateInput(activeDate: \(Swift.String(describing: activeDate)), description: \(Swift.String(describing: description)), inactiveDate: \(Swift.String(describing: inactiveDate)), tags: \(Swift.String(describing: tags)), usage: \(Swift.String(describing: usage)), certificate: \"CONTENT_REDACTED\", certificateChain: \"CONTENT_REDACTED\", privateKey: \"CONTENT_REDACTED\")"}
}

extension ImportCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDate = "ActiveDate"
        case certificate = "Certificate"
        case certificateChain = "CertificateChain"
        case description = "Description"
        case inactiveDate = "InactiveDate"
        case privateKey = "PrivateKey"
        case tags = "Tags"
        case usage = "Usage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDate = self.activeDate {
            try encodeContainer.encodeTimestamp(activeDate, format: .epochSeconds, forKey: .activeDate)
        }
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let certificateChain = self.certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inactiveDate = self.inactiveDate {
            try encodeContainer.encodeTimestamp(inactiveDate, format: .epochSeconds, forKey: .inactiveDate)
        }
        if let privateKey = self.privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let usage = self.usage {
            try encodeContainer.encode(usage.rawValue, forKey: .usage)
        }
    }
}

extension ImportCertificateInput {

    static func urlPathProvider(_ value: ImportCertificateInput) -> Swift.String? {
        return "/"
    }
}

public struct ImportCertificateInput: Swift.Equatable {
    /// An optional date that specifies when the certificate becomes active.
    public var activeDate: ClientRuntime.Date?
    /// * For the CLI, provide a file path for a certificate in URI format. For example, --certificate file://encryption-cert.pem. Alternatively, you can provide the raw content.
    ///
    /// * For the SDK, specify the raw content of a certificate file. For example, --certificate "`cat encryption-cert.pem`".
    /// This member is required.
    public var certificate: Swift.String?
    /// An optional list of certificates that make up the chain for the certificate that's being imported.
    public var certificateChain: Swift.String?
    /// A short description that helps identify the certificate.
    public var description: Swift.String?
    /// An optional date that specifies when the certificate becomes inactive.
    public var inactiveDate: ClientRuntime.Date?
    /// * For the CLI, provide a file path for a private key in URI format.For example, --private-key file://encryption-key.pem. Alternatively, you can provide the raw content of the private key file.
    ///
    /// * For the SDK, specify the raw content of a private key file. For example, --private-key "`cat encryption-key.pem`"
    public var privateKey: Swift.String?
    /// Key-value pairs that can be used to group and search for certificates.
    public var tags: [TransferClientTypes.Tag]?
    /// Specifies whether this certificate is used for signing or encryption.
    /// This member is required.
    public var usage: TransferClientTypes.CertificateUsageType?

    public init(
        activeDate: ClientRuntime.Date? = nil,
        certificate: Swift.String? = nil,
        certificateChain: Swift.String? = nil,
        description: Swift.String? = nil,
        inactiveDate: ClientRuntime.Date? = nil,
        privateKey: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        usage: TransferClientTypes.CertificateUsageType? = nil
    )
    {
        self.activeDate = activeDate
        self.certificate = certificate
        self.certificateChain = certificateChain
        self.description = description
        self.inactiveDate = inactiveDate
        self.privateKey = privateKey
        self.tags = tags
        self.usage = usage
    }
}

struct ImportCertificateInputBody: Swift.Equatable {
    let usage: TransferClientTypes.CertificateUsageType?
    let certificate: Swift.String?
    let certificateChain: Swift.String?
    let privateKey: Swift.String?
    let activeDate: ClientRuntime.Date?
    let inactiveDate: ClientRuntime.Date?
    let description: Swift.String?
    let tags: [TransferClientTypes.Tag]?
}

extension ImportCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDate = "ActiveDate"
        case certificate = "Certificate"
        case certificateChain = "CertificateChain"
        case description = "Description"
        case inactiveDate = "InactiveDate"
        case privateKey = "PrivateKey"
        case tags = "Tags"
        case usage = "Usage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CertificateUsageType.self, forKey: .usage)
        usage = usageDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
        let activeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .activeDate)
        activeDate = activeDateDecoded
        let inactiveDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .inactiveDate)
        inactiveDate = inactiveDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateId = output.certificateId
        } else {
            self.certificateId = nil
        }
    }
}

public struct ImportCertificateOutput: Swift.Equatable {
    /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct ImportCertificateOutputBody: Swift.Equatable {
    let certificateId: Swift.String?
}

extension ImportCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

enum ImportCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportHostKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportHostKeyInput(description: \(Swift.String(describing: description)), serverId: \(Swift.String(describing: serverId)), tags: \(Swift.String(describing: tags)), hostKeyBody: \"CONTENT_REDACTED\")"}
}

extension ImportHostKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hostKeyBody = "HostKeyBody"
        case serverId = "ServerId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hostKeyBody = self.hostKeyBody {
            try encodeContainer.encode(hostKeyBody, forKey: .hostKeyBody)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension ImportHostKeyInput {

    static func urlPathProvider(_ value: ImportHostKeyInput) -> Swift.String? {
        return "/"
    }
}

public struct ImportHostKeyInput: Swift.Equatable {
    /// The text description that identifies this host key.
    public var description: Swift.String?
    /// The private key portion of an SSH key pair. Transfer Family accepts RSA, ECDSA, and ED25519 keys.
    /// This member is required.
    public var hostKeyBody: Swift.String?
    /// The identifier of the server that contains the host key that you are importing.
    /// This member is required.
    public var serverId: Swift.String?
    /// Key-value pairs that can be used to group and search for host keys.
    public var tags: [TransferClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        hostKeyBody: Swift.String? = nil,
        serverId: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.hostKeyBody = hostKeyBody
        self.serverId = serverId
        self.tags = tags
    }
}

struct ImportHostKeyInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let hostKeyBody: Swift.String?
    let description: Swift.String?
    let tags: [TransferClientTypes.Tag]?
}

extension ImportHostKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hostKeyBody = "HostKeyBody"
        case serverId = "ServerId"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let hostKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyBody)
        hostKeyBody = hostKeyBodyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportHostKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportHostKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.hostKeyId = output.hostKeyId
            self.serverId = output.serverId
        } else {
            self.hostKeyId = nil
            self.serverId = nil
        }
    }
}

public struct ImportHostKeyOutput: Swift.Equatable {
    /// Returns the host key identifier for the imported key.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// Returns the server identifier that contains the imported key.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

struct ImportHostKeyOutputBody: Swift.Equatable {
    let serverId: Swift.String?
    let hostKeyId: Swift.String?
}

extension ImportHostKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let hostKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyId)
        hostKeyId = hostKeyIdDecoded
    }
}

enum ImportHostKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportSshPublicKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyBody = self.sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension ImportSshPublicKeyInput {

    static func urlPathProvider(_ value: ImportSshPublicKeyInput) -> Swift.String? {
        return "/"
    }
}

public struct ImportSshPublicKeyInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server.
    /// This member is required.
    public var serverId: Swift.String?
    /// The public key portion of an SSH key pair. Transfer Family accepts RSA, ECDSA, and ED25519 keys.
    /// This member is required.
    public var sshPublicKeyBody: Swift.String?
    /// The name of the Transfer Family user that is assigned to one or more servers.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        sshPublicKeyBody: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyBody = sshPublicKeyBody
        self.userName = userName
    }
}

struct ImportSshPublicKeyInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let sshPublicKeyBody: Swift.String?
    let userName: Swift.String?
}

extension ImportSshPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension ImportSshPublicKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportSshPublicKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.sshPublicKeyId = output.sshPublicKeyId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.sshPublicKeyId = nil
            self.userName = nil
        }
    }
}

/// Identifies the user, the server they belong to, and the identifier of the SSH public key associated with that user. A user can have more than one key on each server that they are associated with.
public struct ImportSshPublicKeyOutput: Swift.Equatable {
    /// A system-assigned unique identifier for a server.
    /// This member is required.
    public var serverId: Swift.String?
    /// The name given to a public key by the system that was imported.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// A user name assigned to the ServerID value that you specified.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

struct ImportSshPublicKeyOutputBody: Swift.Equatable {
    let serverId: Swift.String?
    let sshPublicKeyId: Swift.String?
    let userName: Swift.String?
}

extension ImportSshPublicKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

enum ImportSshPublicKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TransferClientTypes.InputFileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case efsFileLocation = "EfsFileLocation"
        case s3FileLocation = "S3FileLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let efsFileLocation = self.efsFileLocation {
            try encodeContainer.encode(efsFileLocation, forKey: .efsFileLocation)
        }
        if let s3FileLocation = self.s3FileLocation {
            try encodeContainer.encode(s3FileLocation, forKey: .s3FileLocation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3FileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.S3InputFileLocation.self, forKey: .s3FileLocation)
        s3FileLocation = s3FileLocationDecoded
        let efsFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EfsFileLocation.self, forKey: .efsFileLocation)
        efsFileLocation = efsFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the location for the file that's being processed.
    public struct InputFileLocation: Swift.Equatable {
        /// Specifies the details for the Amazon Elastic File System (Amazon EFS) file that's being decrypted.
        public var efsFileLocation: TransferClientTypes.EfsFileLocation?
        /// Specifies the details for the Amazon S3 file that's being copied or decrypted.
        public var s3FileLocation: TransferClientTypes.S3InputFileLocation?

        public init(
            efsFileLocation: TransferClientTypes.EfsFileLocation? = nil,
            s3FileLocation: TransferClientTypes.S3InputFileLocation? = nil
        )
        {
            self.efsFileLocation = efsFileLocation
            self.s3FileLocation = s3FileLocation
        }
    }

}

extension InternalServiceError {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when an error occurs in the Transfer Family service.
public struct InternalServiceError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The NextToken parameter that was passed is invalid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the client submits a malformed request.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccessesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension ListAccessesInput {

    static func urlPathProvider(_ value: ListAccessesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListAccessesInput: Swift.Equatable {
    /// Specifies the maximum number of access SIDs to return.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListAccesses call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional accesses.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that has users assigned to it.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListAccessesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let serverId: Swift.String?
}

extension ListAccessesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension ListAccessesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccessesOutputBody = try responseDecoder.decode(responseBody: data)
            self.accesses = output.accesses
            self.nextToken = output.nextToken
            self.serverId = output.serverId
        } else {
            self.accesses = nil
            self.nextToken = nil
            self.serverId = nil
        }
    }
}

public struct ListAccessesOutput: Swift.Equatable {
    /// Returns the accesses and their properties for the ServerId value that you specify.
    /// This member is required.
    public var accesses: [TransferClientTypes.ListedAccess]?
    /// When you can get additional results from the ListAccesses call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional accesses.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that has users assigned to it.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        accesses: [TransferClientTypes.ListedAccess]? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.accesses = accesses
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListAccessesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serverId: Swift.String?
    let accesses: [TransferClientTypes.ListedAccess]?
}

extension ListAccessesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accesses = "Accesses"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let accessesContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedAccess?].self, forKey: .accesses)
        var accessesDecoded0:[TransferClientTypes.ListedAccess]? = nil
        if let accessesContainer = accessesContainer {
            accessesDecoded0 = [TransferClientTypes.ListedAccess]()
            for structure0 in accessesContainer {
                if let structure0 = structure0 {
                    accessesDecoded0?.append(structure0)
                }
            }
        }
        accesses = accessesDecoded0
    }
}

enum ListAccessesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAgreementsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension ListAgreementsInput {

    static func urlPathProvider(_ value: ListAgreementsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListAgreementsInput: Swift.Equatable {
    /// The maximum number of agreements to return.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListAgreements call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional agreements.
    public var nextToken: Swift.String?
    /// The identifier of the server for which you want a list of agreements.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListAgreementsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let serverId: Swift.String?
}

extension ListAgreementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension ListAgreementsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAgreementsOutputBody = try responseDecoder.decode(responseBody: data)
            self.agreements = output.agreements
            self.nextToken = output.nextToken
        } else {
            self.agreements = nil
            self.nextToken = nil
        }
    }
}

public struct ListAgreementsOutput: Swift.Equatable {
    /// Returns an array, where each item contains the details of an agreement.
    /// This member is required.
    public var agreements: [TransferClientTypes.ListedAgreement]?
    /// Returns a token that you can use to call ListAgreements again and receive additional results, if there are any.
    public var nextToken: Swift.String?

    public init(
        agreements: [TransferClientTypes.ListedAgreement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agreements = agreements
        self.nextToken = nextToken
    }
}

struct ListAgreementsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let agreements: [TransferClientTypes.ListedAgreement]?
}

extension ListAgreementsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreements = "Agreements"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let agreementsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedAgreement?].self, forKey: .agreements)
        var agreementsDecoded0:[TransferClientTypes.ListedAgreement]? = nil
        if let agreementsContainer = agreementsContainer {
            agreementsDecoded0 = [TransferClientTypes.ListedAgreement]()
            for structure0 in agreementsContainer {
                if let structure0 = structure0 {
                    agreementsDecoded0?.append(structure0)
                }
            }
        }
        agreements = agreementsDecoded0
    }
}

enum ListAgreementsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCertificatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCertificatesInput {

    static func urlPathProvider(_ value: ListCertificatesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListCertificatesInput: Swift.Equatable {
    /// The maximum number of certificates to return.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListCertificates call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional certificates.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCertificatesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCertificatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCertificatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCertificatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificates = output.certificates
            self.nextToken = output.nextToken
        } else {
            self.certificates = nil
            self.nextToken = nil
        }
    }
}

public struct ListCertificatesOutput: Swift.Equatable {
    /// Returns an array of the certificates that are specified in the ListCertificates call.
    /// This member is required.
    public var certificates: [TransferClientTypes.ListedCertificate]?
    /// Returns the next token, which you can use to list the next certificate.
    public var nextToken: Swift.String?

    public init(
        certificates: [TransferClientTypes.ListedCertificate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.nextToken = nextToken
    }
}

struct ListCertificatesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let certificates: [TransferClientTypes.ListedCertificate]?
}

extension ListCertificatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificates = "Certificates"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let certificatesContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedCertificate?].self, forKey: .certificates)
        var certificatesDecoded0:[TransferClientTypes.ListedCertificate]? = nil
        if let certificatesContainer = certificatesContainer {
            certificatesDecoded0 = [TransferClientTypes.ListedCertificate]()
            for structure0 in certificatesContainer {
                if let structure0 = structure0 {
                    certificatesDecoded0?.append(structure0)
                }
            }
        }
        certificates = certificatesDecoded0
    }
}

enum ListCertificatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConnectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListConnectorsInput {

    static func urlPathProvider(_ value: ListConnectorsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListConnectorsInput: Swift.Equatable {
    /// The maximum number of connectors to return.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListConnectors call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional connectors.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectorsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListConnectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConnectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectors = output.connectors
            self.nextToken = output.nextToken
        } else {
            self.connectors = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectorsOutput: Swift.Equatable {
    /// Returns an array, where each item contains the details of a connector.
    /// This member is required.
    public var connectors: [TransferClientTypes.ListedConnector]?
    /// Returns a token that you can use to call ListConnectors again and receive additional results, if there are any.
    public var nextToken: Swift.String?

    public init(
        connectors: [TransferClientTypes.ListedConnector]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectors = connectors
        self.nextToken = nextToken
    }
}

struct ListConnectorsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let connectors: [TransferClientTypes.ListedConnector]?
}

extension ListConnectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectors = "Connectors"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let connectorsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedConnector?].self, forKey: .connectors)
        var connectorsDecoded0:[TransferClientTypes.ListedConnector]? = nil
        if let connectorsContainer = connectorsContainer {
            connectorsDecoded0 = [TransferClientTypes.ListedConnector]()
            for structure0 in connectorsContainer {
                if let structure0 = structure0 {
                    connectorsDecoded0?.append(structure0)
                }
            }
        }
        connectors = connectorsDecoded0
    }
}

enum ListConnectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension ListExecutionsInput {

    static func urlPathProvider(_ value: ListExecutionsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListExecutionsInput: Swift.Equatable {
    /// Specifies the maximum number of executions to return.
    public var maxResults: Swift.Int?
    /// ListExecutions returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional executions. This is useful for pagination, for instance. If you have 100 executions for a workflow, you might only want to list first 10. If so, call the API by specifying the max-results: aws transfer list-executions --max-results 10 This returns details for the first 10 executions, as well as the pointer (NextToken) to the eleventh execution. You can now call the API again, supplying the NextToken value you received: aws transfer list-executions --max-results 10 --next-token $somePointerReturnedFromPreviousListResult This call returns the next 10 executions, the 11th through the 20th. You can then repeat the call until the details for all 100 executions have been returned.
    public var nextToken: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowId = workflowId
    }
}

struct ListExecutionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let workflowId: Swift.String?
}

extension ListExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workflowId = "WorkflowId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

extension ListExecutionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExecutionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.executions = output.executions
            self.nextToken = output.nextToken
            self.workflowId = output.workflowId
        } else {
            self.executions = nil
            self.nextToken = nil
            self.workflowId = nil
        }
    }
}

public struct ListExecutionsOutput: Swift.Equatable {
    /// Returns the details for each execution, in a ListedExecution array.
    /// This member is required.
    public var executions: [TransferClientTypes.ListedExecution]?
    /// ListExecutions returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional executions.
    public var nextToken: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        executions: [TransferClientTypes.ListedExecution]? = nil,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.executions = executions
        self.nextToken = nextToken
        self.workflowId = workflowId
    }
}

struct ListExecutionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workflowId: Swift.String?
    let executions: [TransferClientTypes.ListedExecution]?
}

extension ListExecutionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executions = "Executions"
        case nextToken = "NextToken"
        case workflowId = "WorkflowId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let executionsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedExecution?].self, forKey: .executions)
        var executionsDecoded0:[TransferClientTypes.ListedExecution]? = nil
        if let executionsContainer = executionsContainer {
            executionsDecoded0 = [TransferClientTypes.ListedExecution]()
            for structure0 in executionsContainer {
                if let structure0 = structure0 {
                    executionsDecoded0?.append(structure0)
                }
            }
        }
        executions = executionsDecoded0
    }
}

enum ListExecutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListHostKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension ListHostKeysInput {

    static func urlPathProvider(_ value: ListHostKeysInput) -> Swift.String? {
        return "/"
    }
}

public struct ListHostKeysInput: Swift.Equatable {
    /// The maximum number of host keys to return.
    public var maxResults: Swift.Int?
    /// When there are additional results that were not returned, a NextToken parameter is returned. You can use that value for a subsequent call to ListHostKeys to continue listing results.
    public var nextToken: Swift.String?
    /// The identifier of the server that contains the host keys that you want to view.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListHostKeysInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let serverId: Swift.String?
}

extension ListHostKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension ListHostKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListHostKeysOutputBody = try responseDecoder.decode(responseBody: data)
            self.hostKeys = output.hostKeys
            self.nextToken = output.nextToken
            self.serverId = output.serverId
        } else {
            self.hostKeys = nil
            self.nextToken = nil
            self.serverId = nil
        }
    }
}

public struct ListHostKeysOutput: Swift.Equatable {
    /// Returns an array, where each item contains the details of a host key.
    /// This member is required.
    public var hostKeys: [TransferClientTypes.ListedHostKey]?
    /// Returns a token that you can use to call ListHostKeys again and receive additional results, if there are any.
    public var nextToken: Swift.String?
    /// Returns the server identifier that contains the listed host keys.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        hostKeys: [TransferClientTypes.ListedHostKey]? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeys = hostKeys
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListHostKeysOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serverId: Swift.String?
    let hostKeys: [TransferClientTypes.ListedHostKey]?
}

extension ListHostKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKeys = "HostKeys"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let hostKeysContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedHostKey?].self, forKey: .hostKeys)
        var hostKeysDecoded0:[TransferClientTypes.ListedHostKey]? = nil
        if let hostKeysContainer = hostKeysContainer {
            hostKeysDecoded0 = [TransferClientTypes.ListedHostKey]()
            for structure0 in hostKeysContainer {
                if let structure0 = structure0 {
                    hostKeysDecoded0?.append(structure0)
                }
            }
        }
        hostKeys = hostKeysDecoded0
    }
}

enum ListHostKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case profileType = "ProfileType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let profileType = self.profileType {
            try encodeContainer.encode(profileType.rawValue, forKey: .profileType)
        }
    }
}

extension ListProfilesInput {

    static func urlPathProvider(_ value: ListProfilesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListProfilesInput: Swift.Equatable {
    /// The maximum number of profiles to return.
    public var maxResults: Swift.Int?
    /// When there are additional results that were not returned, a NextToken parameter is returned. You can use that value for a subsequent call to ListProfiles to continue listing results.
    public var nextToken: Swift.String?
    /// Indicates whether to list only LOCAL type profiles or only PARTNER type profiles. If not supplied in the request, the command lists all types of profiles.
    public var profileType: TransferClientTypes.ProfileType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileType: TransferClientTypes.ProfileType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileType = profileType
    }
}

struct ListProfilesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let profileType: TransferClientTypes.ProfileType?
}

extension ListProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case profileType = "ProfileType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let profileTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProfileType.self, forKey: .profileType)
        profileType = profileTypeDecoded
    }
}

extension ListProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profiles = output.profiles
        } else {
            self.nextToken = nil
            self.profiles = nil
        }
    }
}

public struct ListProfilesOutput: Swift.Equatable {
    /// Returns a token that you can use to call ListProfiles again and receive additional results, if there are any.
    public var nextToken: Swift.String?
    /// Returns an array, where each item contains the details of a profile.
    /// This member is required.
    public var profiles: [TransferClientTypes.ListedProfile]?

    public init(
        nextToken: Swift.String? = nil,
        profiles: [TransferClientTypes.ListedProfile]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

struct ListProfilesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let profiles: [TransferClientTypes.ListedProfile]?
}

extension ListProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case profiles = "Profiles"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let profilesContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedProfile?].self, forKey: .profiles)
        var profilesDecoded0:[TransferClientTypes.ListedProfile]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [TransferClientTypes.ListedProfile]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
    }
}

enum ListProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSecurityPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSecurityPoliciesInput {

    static func urlPathProvider(_ value: ListSecurityPoliciesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListSecurityPoliciesInput: Swift.Equatable {
    /// Specifies the number of security policies to return as a response to the ListSecurityPolicies query.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the ListSecurityPolicies command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional security policies.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSecurityPoliciesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSecurityPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSecurityPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSecurityPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityPolicyNames = output.securityPolicyNames
        } else {
            self.nextToken = nil
            self.securityPolicyNames = nil
        }
    }
}

public struct ListSecurityPoliciesOutput: Swift.Equatable {
    /// When you can get additional results from the ListSecurityPolicies operation, a NextToken parameter is returned in the output. In a following command, you can pass in the NextToken parameter to continue listing security policies.
    public var nextToken: Swift.String?
    /// An array of security policies that were listed.
    /// This member is required.
    public var securityPolicyNames: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        securityPolicyNames: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityPolicyNames = securityPolicyNames
    }
}

struct ListSecurityPoliciesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let securityPolicyNames: [Swift.String]?
}

extension ListSecurityPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case securityPolicyNames = "SecurityPolicyNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let securityPolicyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityPolicyNames)
        var securityPolicyNamesDecoded0:[Swift.String]? = nil
        if let securityPolicyNamesContainer = securityPolicyNamesContainer {
            securityPolicyNamesDecoded0 = [Swift.String]()
            for string0 in securityPolicyNamesContainer {
                if let string0 = string0 {
                    securityPolicyNamesDecoded0?.append(string0)
                }
            }
        }
        securityPolicyNames = securityPolicyNamesDecoded0
    }
}

enum ListSecurityPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListServersInput {

    static func urlPathProvider(_ value: ListServersInput) -> Swift.String? {
        return "/"
    }
}

public struct ListServersInput: Swift.Equatable {
    /// Specifies the number of servers to return as a response to the ListServers query.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the ListServers command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional servers.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.servers = output.servers
        } else {
            self.nextToken = nil
            self.servers = nil
        }
    }
}

public struct ListServersOutput: Swift.Equatable {
    /// When you can get additional results from the ListServers operation, a NextToken parameter is returned in the output. In a following command, you can pass in the NextToken parameter to continue listing additional servers.
    public var nextToken: Swift.String?
    /// An array of servers that were listed.
    /// This member is required.
    public var servers: [TransferClientTypes.ListedServer]?

    public init(
        nextToken: Swift.String? = nil,
        servers: [TransferClientTypes.ListedServer]? = nil
    )
    {
        self.nextToken = nextToken
        self.servers = servers
    }
}

struct ListServersOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let servers: [TransferClientTypes.ListedServer]?
}

extension ListServersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case servers = "Servers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serversContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedServer?].self, forKey: .servers)
        var serversDecoded0:[TransferClientTypes.ListedServer]? = nil
        if let serversContainer = serversContainer {
            serversDecoded0 = [TransferClientTypes.ListedServer]()
            for structure0 in serversContainer {
                if let structure0 = structure0 {
                    serversDecoded0?.append(structure0)
                }
            }
        }
        servers = serversDecoded0
    }
}

enum ListServersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an identifier for a specific Amazon Web Services resource, such as a server, user, or role.
    /// This member is required.
    public var arn: Swift.String?
    /// Specifies the number of tags to return as a response to the ListTagsForResource request.
    public var maxResults: Swift.Int?
    /// When you request additional results from the ListTagsForResource operation, a NextToken parameter is returned in the input. You can then pass in a subsequent command to the NextToken parameter to continue listing additional tags.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.arn = nil
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The ARN you specified to list the tags of.
    public var arn: Swift.String?
    /// When you can get additional results from the ListTagsForResource call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional tags.
    public var nextToken: Swift.String?
    /// Key-value pairs that are assigned to a resource, usually for the purpose of grouping and searching for items. Tags are metadata that you define.
    public var tags: [TransferClientTypes.Tag]?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let nextToken: Swift.String?
    let tags: [TransferClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension ListUsersInput {

    static func urlPathProvider(_ value: ListUsersInput) -> Swift.String? {
        return "/"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// Specifies the number of users to return as a response to the ListUsers request.
    public var maxResults: Swift.Int?
    /// If there are additional results from the ListUsers call, a NextToken parameter is returned in the output. You can then pass the NextToken to a subsequent ListUsers command, to continue listing additional users.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that has users assigned to it.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListUsersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let serverId: Swift.String?
}

extension ListUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension ListUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serverId = output.serverId
            self.users = output.users
        } else {
            self.nextToken = nil
            self.serverId = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutput: Swift.Equatable {
    /// When you can get additional results from the ListUsers call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional users.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that the users are assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// Returns the Transfer Family users and their properties for the ServerId value that you specify.
    /// This member is required.
    public var users: [TransferClientTypes.ListedUser]?

    public init(
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil,
        users: [TransferClientTypes.ListedUser]? = nil
    )
    {
        self.nextToken = nextToken
        self.serverId = serverId
        self.users = users
    }
}

struct ListUsersOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serverId: Swift.String?
    let users: [TransferClientTypes.ListedUser]?
}

extension ListUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serverId = "ServerId"
        case users = "Users"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let usersContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedUser?].self, forKey: .users)
        var usersDecoded0:[TransferClientTypes.ListedUser]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [TransferClientTypes.ListedUser]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

enum ListUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkflowsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorkflowsInput {

    static func urlPathProvider(_ value: ListWorkflowsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListWorkflowsInput: Swift.Equatable {
    /// Specifies the maximum number of workflows to return.
    public var maxResults: Swift.Int?
    /// ListWorkflows returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional workflows.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkflowsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListWorkflowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkflowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkflowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workflows = output.workflows
        } else {
            self.nextToken = nil
            self.workflows = nil
        }
    }
}

public struct ListWorkflowsOutput: Swift.Equatable {
    /// ListWorkflows returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional workflows.
    public var nextToken: Swift.String?
    /// Returns the Arn, WorkflowId, and Description for each workflow.
    /// This member is required.
    public var workflows: [TransferClientTypes.ListedWorkflow]?

    public init(
        nextToken: Swift.String? = nil,
        workflows: [TransferClientTypes.ListedWorkflow]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflows = workflows
    }
}

struct ListWorkflowsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workflows: [TransferClientTypes.ListedWorkflow]?
}

extension ListWorkflowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workflows = "Workflows"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workflowsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedWorkflow?].self, forKey: .workflows)
        var workflowsDecoded0:[TransferClientTypes.ListedWorkflow]? = nil
        if let workflowsContainer = workflowsContainer {
            workflowsDecoded0 = [TransferClientTypes.ListedWorkflow]()
            for structure0 in workflowsContainer {
                if let structure0 = structure0 {
                    workflowsDecoded0?.append(structure0)
                }
            }
        }
        workflows = workflowsDecoded0
    }
}

enum ListWorkflowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TransferClientTypes.ListedAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryType = "HomeDirectoryType"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension TransferClientTypes {
    /// Lists the properties for one or more specified associated accesses.
    public struct ListedAccess: Swift.Equatable {
        /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
        public var externalId: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
        public var homeDirectory: Swift.String?
        /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
        public var role: Swift.String?

        public init(
            externalId: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            role: Swift.String? = nil
        )
        {
            self.externalId = externalId
            self.homeDirectory = homeDirectory
            self.homeDirectoryType = homeDirectoryType
            self.role = role
        }
    }

}

extension TransferClientTypes.ListedAgreement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId = "AgreementId"
        case arn = "Arn"
        case description = "Description"
        case localProfileId = "LocalProfileId"
        case partnerProfileId = "PartnerProfileId"
        case serverId = "ServerId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agreementId = self.agreementId {
            try encodeContainer.encode(agreementId, forKey: .agreementId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let localProfileId = self.localProfileId {
            try encodeContainer.encode(localProfileId, forKey: .localProfileId)
        }
        if let partnerProfileId = self.partnerProfileId {
            try encodeContainer.encode(partnerProfileId, forKey: .partnerProfileId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.AgreementStatusType.self, forKey: .status)
        status = statusDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let localProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localProfileId)
        localProfileId = localProfileIdDecoded
        let partnerProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerProfileId)
        partnerProfileId = partnerProfileIdDecoded
    }
}

extension TransferClientTypes {
    /// Describes the properties of an agreement.
    public struct ListedAgreement: Swift.Equatable {
        /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
        public var agreementId: Swift.String?
        /// The Amazon Resource Name (ARN) of the specified agreement.
        public var arn: Swift.String?
        /// The current description for the agreement. You can change it by calling the UpdateAgreement operation and providing a new description.
        public var description: Swift.String?
        /// A unique identifier for the AS2 local profile.
        public var localProfileId: Swift.String?
        /// A unique identifier for the partner profile.
        public var partnerProfileId: Swift.String?
        /// The unique identifier for the agreement.
        public var serverId: Swift.String?
        /// The agreement can be either ACTIVE or INACTIVE.
        public var status: TransferClientTypes.AgreementStatusType?

        public init(
            agreementId: Swift.String? = nil,
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            localProfileId: Swift.String? = nil,
            partnerProfileId: Swift.String? = nil,
            serverId: Swift.String? = nil,
            status: TransferClientTypes.AgreementStatusType? = nil
        )
        {
            self.agreementId = agreementId
            self.arn = arn
            self.description = description
            self.localProfileId = localProfileId
            self.partnerProfileId = partnerProfileId
            self.serverId = serverId
            self.status = status
        }
    }

}

extension TransferClientTypes.ListedCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDate = "ActiveDate"
        case arn = "Arn"
        case certificateId = "CertificateId"
        case description = "Description"
        case inactiveDate = "InactiveDate"
        case status = "Status"
        case type = "Type"
        case usage = "Usage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDate = self.activeDate {
            try encodeContainer.encodeTimestamp(activeDate, format: .epochSeconds, forKey: .activeDate)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inactiveDate = self.inactiveDate {
            try encodeContainer.encodeTimestamp(inactiveDate, format: .epochSeconds, forKey: .inactiveDate)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let usage = self.usage {
            try encodeContainer.encode(usage.rawValue, forKey: .usage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let usageDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CertificateUsageType.self, forKey: .usage)
        usage = usageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CertificateStatusType.self, forKey: .status)
        status = statusDecoded
        let activeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .activeDate)
        activeDate = activeDateDecoded
        let inactiveDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .inactiveDate)
        inactiveDate = inactiveDateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CertificateType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension TransferClientTypes {
    /// Describes the properties of a certificate.
    public struct ListedCertificate: Swift.Equatable {
        /// An optional date that specifies when the certificate becomes active.
        public var activeDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the specified certificate.
        public var arn: Swift.String?
        /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
        public var certificateId: Swift.String?
        /// The name or short description that's used to identify the certificate.
        public var description: Swift.String?
        /// An optional date that specifies when the certificate becomes inactive.
        public var inactiveDate: ClientRuntime.Date?
        /// The certificate can be either ACTIVE, PENDING_ROTATION, or INACTIVE. PENDING_ROTATION means that this certificate will replace the current certificate when it expires.
        public var status: TransferClientTypes.CertificateStatusType?
        /// The type for the certificate. If a private key has been specified for the certificate, its type is CERTIFICATE_WITH_PRIVATE_KEY. If there is no private key, the type is CERTIFICATE.
        public var type: TransferClientTypes.CertificateType?
        /// Specifies whether this certificate is used for signing or encryption.
        public var usage: TransferClientTypes.CertificateUsageType?

        public init(
            activeDate: ClientRuntime.Date? = nil,
            arn: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            description: Swift.String? = nil,
            inactiveDate: ClientRuntime.Date? = nil,
            status: TransferClientTypes.CertificateStatusType? = nil,
            type: TransferClientTypes.CertificateType? = nil,
            usage: TransferClientTypes.CertificateUsageType? = nil
        )
        {
            self.activeDate = activeDate
            self.arn = arn
            self.certificateId = certificateId
            self.description = description
            self.inactiveDate = inactiveDate
            self.status = status
            self.type = type
            self.usage = usage
        }
    }

}

extension TransferClientTypes.ListedConnector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case connectorId = "ConnectorId"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension TransferClientTypes {
    /// Returns details of the connector that is specified.
    public struct ListedConnector: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the specified connector.
        public var arn: Swift.String?
        /// The unique identifier for the connector.
        public var connectorId: Swift.String?
        /// The URL of the partner's AS2 or SFTP endpoint.
        public var url: Swift.String?

        public init(
            arn: Swift.String? = nil,
            connectorId: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.arn = arn
            self.connectorId = connectorId
            self.url = url
        }
    }

}

extension TransferClientTypes.ListedExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case initialFileLocation = "InitialFileLocation"
        case serviceMetadata = "ServiceMetadata"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let initialFileLocation = self.initialFileLocation {
            try encodeContainer.encode(initialFileLocation, forKey: .initialFileLocation)
        }
        if let serviceMetadata = self.serviceMetadata {
            try encodeContainer.encode(serviceMetadata, forKey: .serviceMetadata)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let initialFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.FileLocation.self, forKey: .initialFileLocation)
        initialFileLocation = initialFileLocationDecoded
        let serviceMetadataDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ServiceMetadata.self, forKey: .serviceMetadata)
        serviceMetadata = serviceMetadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension TransferClientTypes {
    /// Returns properties of the execution that is specified.
    public struct ListedExecution: Swift.Equatable {
        /// A unique identifier for the execution of a workflow.
        public var executionId: Swift.String?
        /// A structure that describes the Amazon S3 or EFS file location. This is the file location when the execution begins: if the file is being copied, this is the initial (as opposed to destination) file location.
        public var initialFileLocation: TransferClientTypes.FileLocation?
        /// A container object for the session details that are associated with a workflow.
        public var serviceMetadata: TransferClientTypes.ServiceMetadata?
        /// The status is one of the execution. Can be in progress, completed, exception encountered, or handling the exception.
        public var status: TransferClientTypes.ExecutionStatus?

        public init(
            executionId: Swift.String? = nil,
            initialFileLocation: TransferClientTypes.FileLocation? = nil,
            serviceMetadata: TransferClientTypes.ServiceMetadata? = nil,
            status: TransferClientTypes.ExecutionStatus? = nil
        )
        {
            self.executionId = executionId
            self.initialFileLocation = initialFileLocation
            self.serviceMetadata = serviceMetadata
            self.status = status
        }
    }

}

extension TransferClientTypes.ListedHostKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dateImported = "DateImported"
        case description = "Description"
        case fingerprint = "Fingerprint"
        case hostKeyId = "HostKeyId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateImported = self.dateImported {
            try encodeContainer.encodeTimestamp(dateImported, format: .epochSeconds, forKey: .dateImported)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fingerprint = self.fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
        if let hostKeyId = self.hostKeyId {
            try encodeContainer.encode(hostKeyId, forKey: .hostKeyId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let hostKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyId)
        hostKeyId = hostKeyIdDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let dateImportedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateImported)
        dateImported = dateImportedDecoded
    }
}

extension TransferClientTypes {
    /// Returns properties of the host key that's specified.
    public struct ListedHostKey: Swift.Equatable {
        /// The unique Amazon Resource Name (ARN) of the host key.
        /// This member is required.
        public var arn: Swift.String?
        /// The date on which the host key was added to the server.
        public var dateImported: ClientRuntime.Date?
        /// The current description for the host key. You can change it by calling the UpdateHostKey operation and providing a new description.
        public var description: Swift.String?
        /// The public key fingerprint, which is a short sequence of bytes used to identify the longer public key.
        public var fingerprint: Swift.String?
        /// A unique identifier for the host key.
        public var hostKeyId: Swift.String?
        /// The encryption algorithm that is used for the host key. The Type parameter is specified by using one of the following values:
        ///
        /// * ssh-rsa
        ///
        /// * ssh-ed25519
        ///
        /// * ecdsa-sha2-nistp256
        ///
        /// * ecdsa-sha2-nistp384
        ///
        /// * ecdsa-sha2-nistp521
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            dateImported: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            fingerprint: Swift.String? = nil,
            hostKeyId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.dateImported = dateImported
            self.description = description
            self.fingerprint = fingerprint
            self.hostKeyId = hostKeyId
            self.type = type
        }
    }

}

extension TransferClientTypes.ListedProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case as2Id = "As2Id"
        case profileId = "ProfileId"
        case profileType = "ProfileType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let as2Id = self.as2Id {
            try encodeContainer.encode(as2Id, forKey: .as2Id)
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let profileType = self.profileType {
            try encodeContainer.encode(profileType.rawValue, forKey: .profileType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let as2IdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .as2Id)
        as2Id = as2IdDecoded
        let profileTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProfileType.self, forKey: .profileType)
        profileType = profileTypeDecoded
    }
}

extension TransferClientTypes {
    /// Returns the properties of the profile that was specified.
    public struct ListedProfile: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the specified profile.
        public var arn: Swift.String?
        /// The As2Id is the AS2-name, as defined in the [RFC 4130](https://datatracker.ietf.org/doc/html/rfc4130). For inbound transfers, this is the AS2-From header for the AS2 messages sent from the partner. For outbound connectors, this is the AS2-To header for the AS2 messages sent to the partner using the StartFileTransfer API operation. This ID cannot include spaces.
        public var as2Id: Swift.String?
        /// A unique identifier for the local or partner AS2 profile.
        public var profileId: Swift.String?
        /// Indicates whether to list only LOCAL type profiles or only PARTNER type profiles. If not supplied in the request, the command lists all types of profiles.
        public var profileType: TransferClientTypes.ProfileType?

        public init(
            arn: Swift.String? = nil,
            as2Id: Swift.String? = nil,
            profileId: Swift.String? = nil,
            profileType: TransferClientTypes.ProfileType? = nil
        )
        {
            self.arn = arn
            self.as2Id = as2Id
            self.profileId = profileId
            self.profileType = profileType
        }
    }

}

extension TransferClientTypes.ListedServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case domain = "Domain"
        case endpointType = "EndpointType"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case serverId = "ServerId"
        case state = "State"
        case userCount = "UserCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userCount = self.userCount {
            try encodeContainer.encode(userCount, forKey: .userCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let domainDecoded = try containerValues.decodeIfPresent(TransferClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TransferClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let userCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userCount)
        userCount = userCountDecoded
    }
}

extension TransferClientTypes {
    /// Returns properties of a file transfer protocol-enabled server that was specified.
    public struct ListedServer: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) for a server to be listed.
        /// This member is required.
        public var arn: Swift.String?
        /// Specifies the domain of the storage system that is used for file transfers.
        public var domain: TransferClientTypes.Domain?
        /// Specifies the type of VPC endpoint that your server is connected to. If your server is connected to a VPC endpoint, your server isn't accessible over the public internet.
        public var endpointType: TransferClientTypes.EndpointType?
        /// The mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Transfer Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the IdentityProviderDetails parameter. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the IdentityProviderDetails parameter. Use the AWS_LAMBDA value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the Function parameter for the IdentityProviderDetails data type.
        public var identityProviderType: TransferClientTypes.IdentityProviderType?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
        public var loggingRole: Swift.String?
        /// Specifies the unique system assigned identifier for the servers that were listed.
        public var serverId: Swift.String?
        /// The condition of the server that was described. A value of ONLINE indicates that the server can accept jobs and transfer files. A State value of OFFLINE means that the server cannot perform file transfer operations. The states of STARTING and STOPPING indicate that the server is in an intermediate state, either not fully able to respond, or not fully offline. The values of START_FAILED or STOP_FAILED can indicate an error condition.
        public var state: TransferClientTypes.State?
        /// Specifies the number of users that are assigned to a server you specified with the ServerId.
        public var userCount: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            domain: TransferClientTypes.Domain? = nil,
            endpointType: TransferClientTypes.EndpointType? = nil,
            identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
            loggingRole: Swift.String? = nil,
            serverId: Swift.String? = nil,
            state: TransferClientTypes.State? = nil,
            userCount: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.domain = domain
            self.endpointType = endpointType
            self.identityProviderType = identityProviderType
            self.loggingRole = loggingRole
            self.serverId = serverId
            self.state = state
            self.userCount = userCount
        }
    }

}

extension TransferClientTypes.ListedUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryType = "HomeDirectoryType"
        case role = "Role"
        case sshPublicKeyCount = "SshPublicKeyCount"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let sshPublicKeyCount = self.sshPublicKeyCount {
            try encodeContainer.encode(sshPublicKeyCount, forKey: .sshPublicKeyCount)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let sshPublicKeyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sshPublicKeyCount)
        sshPublicKeyCount = sshPublicKeyCountDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension TransferClientTypes {
    /// Returns properties of the user that you specify.
    public struct ListedUser: Swift.Equatable {
        /// Provides the unique Amazon Resource Name (ARN) for the user that you want to learn about.
        /// This member is required.
        public var arn: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
        public var homeDirectory: Swift.String?
        /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests. The IAM role that controls your users' access to your Amazon S3 bucket for servers with Domain=S3, or your EFS file system for servers with Domain=EFS. The policies attached to this role determine the level of access you want to provide your users when transferring files into and out of your S3 buckets or EFS file systems.
        public var role: Swift.String?
        /// Specifies the number of SSH public keys stored for the user you specified.
        public var sshPublicKeyCount: Swift.Int?
        /// Specifies the name of the user whose ARN was specified. User names are used for authentication purposes.
        public var userName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            role: Swift.String? = nil,
            sshPublicKeyCount: Swift.Int? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.homeDirectory = homeDirectory
            self.homeDirectoryType = homeDirectoryType
            self.role = role
            self.sshPublicKeyCount = sshPublicKeyCount
            self.userName = userName
        }
    }

}

extension TransferClientTypes.ListedWorkflow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension TransferClientTypes {
    /// Contains the identifier, text description, and Amazon Resource Name (ARN) for the workflow.
    public struct ListedWorkflow: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) for the workflow.
        public var arn: Swift.String?
        /// Specifies the text description for the workflow.
        public var description: Swift.String?
        /// A unique identifier for the workflow.
        public var workflowId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.workflowId = workflowId
        }
    }

}

extension TransferClientTypes.LoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName = "LogGroupName"
        case loggingRole = "LoggingRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension TransferClientTypes {
    /// Consists of the logging role and the log group name.
    public struct LoggingConfiguration: Swift.Equatable {
        /// The name of the CloudWatch logging group for the Transfer Family server to which this workflow belongs.
        public var logGroupName: Swift.String?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
        public var loggingRole: Swift.String?

        public init(
            logGroupName: Swift.String? = nil,
            loggingRole: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
            self.loggingRole = loggingRole
        }
    }

}

extension TransferClientTypes {
    public enum MapType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case directory
        case file
        case sdkUnknown(Swift.String)

        public static var allCases: [MapType] {
            return [
                .directory,
                .file,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .directory: return "DIRECTORY"
            case .file: return "FILE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MapType(rawValue: rawValue) ?? MapType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum MdnResponse: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case sync
        case sdkUnknown(Swift.String)

        public static var allCases: [MdnResponse] {
            return [
                .none,
                .sync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .sync: return "SYNC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MdnResponse(rawValue: rawValue) ?? MdnResponse.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum MdnSigningAlg: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case `none`
        case sha1
        case sha256
        case sha384
        case sha512
        case sdkUnknown(Swift.String)

        public static var allCases: [MdnSigningAlg] {
            return [
                .default,
                .none,
                .sha1,
                .sha256,
                .sha384,
                .sha512,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .none: return "NONE"
            case .sha1: return "SHA1"
            case .sha256: return "SHA256"
            case .sha384: return "SHA384"
            case .sha512: return "SHA512"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MdnSigningAlg(rawValue: rawValue) ?? MdnSigningAlg.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum OverwriteExisting: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [OverwriteExisting] {
            return [
                .false,
                .true,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OverwriteExisting(rawValue: rawValue) ?? OverwriteExisting.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.PosixProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gid = "Gid"
        case secondaryGids = "SecondaryGids"
        case uid = "Uid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gid = self.gid {
            try encodeContainer.encode(gid, forKey: .gid)
        }
        if let secondaryGids = secondaryGids {
            var secondaryGidsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryGids)
            for posixid0 in secondaryGids {
                try secondaryGidsContainer.encode(posixid0)
            }
        }
        if let uid = self.uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uid)
        uid = uidDecoded
        let gidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gid)
        gid = gidDecoded
        let secondaryGidsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .secondaryGids)
        var secondaryGidsDecoded0:[Swift.Int]? = nil
        if let secondaryGidsContainer = secondaryGidsContainer {
            secondaryGidsDecoded0 = [Swift.Int]()
            for long0 in secondaryGidsContainer {
                if let long0 = long0 {
                    secondaryGidsDecoded0?.append(long0)
                }
            }
        }
        secondaryGids = secondaryGidsDecoded0
    }
}

extension TransferClientTypes {
    /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public struct PosixProfile: Swift.Equatable {
        /// The POSIX group ID used for all EFS operations by this user.
        /// This member is required.
        public var gid: Swift.Int?
        /// The secondary POSIX group IDs used for all EFS operations by this user.
        public var secondaryGids: [Swift.Int]?
        /// The POSIX user ID used for all EFS operations by this user.
        /// This member is required.
        public var uid: Swift.Int?

        public init(
            gid: Swift.Int? = nil,
            secondaryGids: [Swift.Int]? = nil,
            uid: Swift.Int? = nil
        )
        {
            self.gid = gid
            self.secondaryGids = secondaryGids
            self.uid = uid
        }
    }

}

extension TransferClientTypes {
    public enum ProfileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case local
        case partner
        case sdkUnknown(Swift.String)

        public static var allCases: [ProfileType] {
            return [
                .local,
                .partner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .local: return "LOCAL"
            case .partner: return "PARTNER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProfileType(rawValue: rawValue) ?? ProfileType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case as2
        case ftp
        case ftps
        case sftp
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .as2,
                .ftp,
                .ftps,
                .sftp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .as2: return "AS2"
            case .ftp: return "FTP"
            case .ftps: return "FTPS"
            case .sftp: return "SFTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.ProtocolDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case as2Transports = "As2Transports"
        case passiveIp = "PassiveIp"
        case setStatOption = "SetStatOption"
        case tlsSessionResumptionMode = "TlsSessionResumptionMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let as2Transports = as2Transports {
            var as2TransportsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .as2Transports)
            for as2transport0 in as2Transports {
                try as2TransportsContainer.encode(as2transport0.rawValue)
            }
        }
        if let passiveIp = self.passiveIp {
            try encodeContainer.encode(passiveIp, forKey: .passiveIp)
        }
        if let setStatOption = self.setStatOption {
            try encodeContainer.encode(setStatOption.rawValue, forKey: .setStatOption)
        }
        if let tlsSessionResumptionMode = self.tlsSessionResumptionMode {
            try encodeContainer.encode(tlsSessionResumptionMode.rawValue, forKey: .tlsSessionResumptionMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let passiveIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .passiveIp)
        passiveIp = passiveIpDecoded
        let tlsSessionResumptionModeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.TlsSessionResumptionMode.self, forKey: .tlsSessionResumptionMode)
        tlsSessionResumptionMode = tlsSessionResumptionModeDecoded
        let setStatOptionDecoded = try containerValues.decodeIfPresent(TransferClientTypes.SetStatOption.self, forKey: .setStatOption)
        setStatOption = setStatOptionDecoded
        let as2TransportsContainer = try containerValues.decodeIfPresent([TransferClientTypes.As2Transport?].self, forKey: .as2Transports)
        var as2TransportsDecoded0:[TransferClientTypes.As2Transport]? = nil
        if let as2TransportsContainer = as2TransportsContainer {
            as2TransportsDecoded0 = [TransferClientTypes.As2Transport]()
            for enum0 in as2TransportsContainer {
                if let enum0 = enum0 {
                    as2TransportsDecoded0?.append(enum0)
                }
            }
        }
        as2Transports = as2TransportsDecoded0
    }
}

extension TransferClientTypes {
    /// The protocol settings that are configured for your server.
    public struct ProtocolDetails: Swift.Equatable {
        /// Indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
        public var as2Transports: [TransferClientTypes.As2Transport]?
        /// Indicates passive mode, for FTP and FTPS protocols. Enter a single IPv4 address, such as the public IP address of a firewall, router, or load balancer. For example: aws transfer update-server --protocol-details PassiveIp=0.0.0.0 Replace 0.0.0.0 in the example above with the actual IP address you want to use. If you change the PassiveIp value, you must stop and then restart your Transfer Family server for the change to take effect. For details on using passive mode (PASV) in a NAT environment, see [Configuring your FTPS server behind a firewall or NAT with Transfer Family](http://aws.amazon.com/blogs/storage/configuring-your-ftps-server-behind-a-firewall-or-nat-with-aws-transfer-family/). Special values The AUTO and 0.0.0.0 are special values for the PassiveIp parameter. The value PassiveIp=AUTO is assigned by default to FTP and FTPS type servers. In this case, the server automatically responds with one of the endpoint IPs within the PASV response. PassiveIp=0.0.0.0 has a more unique application for its usage. For example, if you have a High Availability (HA) Network Load Balancer (NLB) environment, where you have 3 subnets, you can only specify a single IP address using the PassiveIp parameter. This reduces the effectiveness of having High Availability. In this case, you can specify PassiveIp=0.0.0.0. This tells the client to use the same IP address as the Control connection and utilize all AZs for their connections. Note, however, that not all FTP clients support the PassiveIp=0.0.0.0 response. FileZilla and WinSCP do support it. If you are using other clients, check to see if your client supports the PassiveIp=0.0.0.0 response.
        public var passiveIp: Swift.String?
        /// Use the SetStatOption to ignore the error that is generated when the client attempts to use SETSTAT on a file you are uploading to an S3 bucket. Some SFTP file transfer clients can attempt to change the attributes of remote files, including timestamp and permissions, using commands, such as SETSTAT when uploading the file. However, these commands are not compatible with object storage systems, such as Amazon S3. Due to this incompatibility, file uploads from these clients can result in errors even when the file is otherwise successfully uploaded. Set the value to ENABLE_NO_OP to have the Transfer Family server ignore the SETSTAT command, and upload files without needing to make any changes to your SFTP client. While the SetStatOptionENABLE_NO_OP setting ignores the error, it does generate a log entry in Amazon CloudWatch Logs, so you can determine when the client is making a SETSTAT call. If you want to preserve the original timestamp for your file, and modify other file attributes using SETSTAT, you can use Amazon EFS as backend storage with Transfer Family.
        public var setStatOption: TransferClientTypes.SetStatOption?
        /// A property used with Transfer Family servers that use the FTPS protocol. TLS Session Resumption provides a mechanism to resume or share a negotiated secret key between the control and data connection for an FTPS session. TlsSessionResumptionMode determines whether or not the server resumes recent, negotiated sessions through a unique session ID. This property is available during CreateServer and UpdateServer calls. If a TlsSessionResumptionMode value is not specified during CreateServer, it is set to ENFORCED by default.
        ///
        /// * DISABLED: the server does not process TLS session resumption client requests and creates a new TLS session for each request.
        ///
        /// * ENABLED: the server processes and accepts clients that are performing TLS session resumption. The server doesn't reject client data connections that do not perform the TLS session resumption client processing.
        ///
        /// * ENFORCED: the server processes and accepts clients that are performing TLS session resumption. The server rejects client data connections that do not perform the TLS session resumption client processing. Before you set the value to ENFORCED, test your clients. Not all FTPS clients perform TLS session resumption. So, if you choose to enforce TLS session resumption, you prevent any connections from FTPS clients that don't perform the protocol negotiation. To determine whether or not you can use the ENFORCED value, you need to test your clients.
        public var tlsSessionResumptionMode: TransferClientTypes.TlsSessionResumptionMode?

        public init(
            as2Transports: [TransferClientTypes.As2Transport]? = nil,
            passiveIp: Swift.String? = nil,
            setStatOption: TransferClientTypes.SetStatOption? = nil,
            tlsSessionResumptionMode: TransferClientTypes.TlsSessionResumptionMode? = nil
        )
        {
            self.as2Transports = as2Transports
            self.passiveIp = passiveIp
            self.setStatOption = setStatOption
            self.tlsSessionResumptionMode = tlsSessionResumptionMode
        }
    }

}

extension ResourceExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resource = output.resource
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resource = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource does not exist, or exists in a region other than the one specified for the command.
public struct ResourceExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// This member is required.
        public internal(set) var resource: Swift.String? = nil
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resource = resource
        self.properties.resourceType = resourceType
    }
}

struct ResourceExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resource: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resource = "Resource"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resource = output.resource
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resource = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when a resource is not found by the Amazon Web ServicesTransfer Family service.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// This member is required.
        public internal(set) var resource: Swift.String? = nil
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resource = resource
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resource: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resource = "Resource"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension TransferClientTypes.S3FileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case etag = "Etag"
        case key = "Key"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let etag = self.etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let etagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etag)
        etag = etagDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the details for the file location for the file that's being used in the workflow. Only applicable if you are using S3 storage.
    public struct S3FileLocation: Swift.Equatable {
        /// Specifies the S3 bucket that contains the file being used.
        public var bucket: Swift.String?
        /// The entity tag is a hash of the object. The ETag reflects changes only to the contents of an object, not its metadata.
        public var etag: Swift.String?
        /// The name assigned to the file when it was created in Amazon S3. You use the object key to retrieve the object.
        public var key: Swift.String?
        /// Specifies the file version.
        public var versionId: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            etag: Swift.String? = nil,
            key: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.etag = etag
            self.key = key
            self.versionId = versionId
        }
    }

}

extension TransferClientTypes.S3InputFileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the customer input Amazon S3 file location. If it is used inside copyStepDetails.DestinationFileLocation, it should be the S3 copy destination. You need to provide the bucket and key. The key can represent either a path or a file. This is determined by whether or not you end the key value with the forward slash (/) character. If the final character is "/", then your file is copied to the folder, and its name does not change. If, rather, the final character is alphanumeric, your uploaded file is renamed to the path value. In this case, if a file with that name already exists, it is overwritten. For example, if your path is shared-files/bob/, your uploaded files are copied to the shared-files/bob/, folder. If your path is shared-files/today, each uploaded file is copied to the shared-files folder and named today: each upload overwrites the previous version of the bob file.
    public struct S3InputFileLocation: Swift.Equatable {
        /// Specifies the S3 bucket for the customer input file.
        public var bucket: Swift.String?
        /// The name assigned to the file when it was created in Amazon S3. You use the object key to retrieve the object.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension TransferClientTypes.S3StorageOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryListingOptimization = "DirectoryListingOptimization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryListingOptimization = self.directoryListingOptimization {
            try encodeContainer.encode(directoryListingOptimization.rawValue, forKey: .directoryListingOptimization)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryListingOptimizationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DirectoryListingOptimization.self, forKey: .directoryListingOptimization)
        directoryListingOptimization = directoryListingOptimizationDecoded
    }
}

extension TransferClientTypes {
    /// The Amazon S3 storage options that are configured for your server.
    public struct S3StorageOptions: Swift.Equatable {
        /// Specifies whether or not performance for your Amazon S3 directories is optimized. This is disabled by default. By default, home directory mappings have a TYPE of DIRECTORY. If you enable this option, you would then need to explicitly set the HomeDirectoryMapEntryType to FILE if you want a mapping to have a file target.
        public var directoryListingOptimization: TransferClientTypes.DirectoryListingOptimization?

        public init(
            directoryListingOptimization: TransferClientTypes.DirectoryListingOptimization? = nil
        )
        {
            self.directoryListingOptimization = directoryListingOptimization
        }
    }

}

extension TransferClientTypes.S3Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the key-value pair that are assigned to a file during the execution of a Tagging step.
    public struct S3Tag: Swift.Equatable {
        /// The name assigned to the tag that you create.
        /// This member is required.
        public var key: Swift.String?
        /// The value that corresponds to the key.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TransferClientTypes {
    public enum SecurityPolicyProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ftps
        case sftp
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityPolicyProtocol] {
            return [
                .ftps,
                .sftp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ftps: return "FTPS"
            case .sftp: return "SFTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SecurityPolicyProtocol(rawValue: rawValue) ?? SecurityPolicyProtocol.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum SecurityPolicyResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connector
        case server
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityPolicyResourceType] {
            return [
                .connector,
                .server,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connector: return "CONNECTOR"
            case .server: return "SERVER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SecurityPolicyResourceType(rawValue: rawValue) ?? SecurityPolicyResourceType.sdkUnknown(rawValue)
        }
    }
}

extension SendWorkflowStepStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case status = "Status"
        case token = "Token"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension SendWorkflowStepStateInput {

    static func urlPathProvider(_ value: SendWorkflowStepStateInput) -> Swift.String? {
        return "/"
    }
}

public struct SendWorkflowStepStateInput: Swift.Equatable {
    /// A unique identifier for the execution of a workflow.
    /// This member is required.
    public var executionId: Swift.String?
    /// Indicates whether the specified step succeeded or failed.
    /// This member is required.
    public var status: TransferClientTypes.CustomStepStatus?
    /// Used to distinguish between multiple callbacks for multiple Lambda steps within the same execution.
    /// This member is required.
    public var token: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        executionId: Swift.String? = nil,
        status: TransferClientTypes.CustomStepStatus? = nil,
        token: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.executionId = executionId
        self.status = status
        self.token = token
        self.workflowId = workflowId
    }
}

struct SendWorkflowStepStateInputBody: Swift.Equatable {
    let workflowId: Swift.String?
    let executionId: Swift.String?
    let token: Swift.String?
    let status: TransferClientTypes.CustomStepStatus?
}

extension SendWorkflowStepStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case status = "Status"
        case token = "Token"
        case workflowId = "WorkflowId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CustomStepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SendWorkflowStepStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SendWorkflowStepStateOutput: Swift.Equatable {

    public init() { }
}

enum SendWorkflowStepStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TransferClientTypes.ServiceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userDetails = "UserDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userDetails = self.userDetails {
            try encodeContainer.encode(userDetails, forKey: .userDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.UserDetails.self, forKey: .userDetails)
        userDetails = userDetailsDecoded
    }
}

extension TransferClientTypes {
    /// A container object for the session details that are associated with a workflow.
    public struct ServiceMetadata: Swift.Equatable {
        /// The Server ID (ServerId), Session ID (SessionId) and user (UserName) make up the UserDetails.
        /// This member is required.
        public var userDetails: TransferClientTypes.UserDetails?

        public init(
            userDetails: TransferClientTypes.UserDetails? = nil
        )
        {
            self.userDetails = userDetails
        }
    }

}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has failed because the Amazon Web ServicesTransfer Family service is not available.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailable" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransferClientTypes {
    public enum SetStatOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case enableNoOp
        case sdkUnknown(Swift.String)

        public static var allCases: [SetStatOption] {
            return [
                .default,
                .enableNoOp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .enableNoOp: return "ENABLE_NO_OP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SetStatOption(rawValue: rawValue) ?? SetStatOption.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum SftpAuthenticationMethods: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case password
        case publicKey
        case publicKeyAndPassword
        case publicKeyOrPassword
        case sdkUnknown(Swift.String)

        public static var allCases: [SftpAuthenticationMethods] {
            return [
                .password,
                .publicKey,
                .publicKeyAndPassword,
                .publicKeyOrPassword,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .password: return "PASSWORD"
            case .publicKey: return "PUBLIC_KEY"
            case .publicKeyAndPassword: return "PUBLIC_KEY_AND_PASSWORD"
            case .publicKeyOrPassword: return "PUBLIC_KEY_OR_PASSWORD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SftpAuthenticationMethods(rawValue: rawValue) ?? SftpAuthenticationMethods.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.SftpConnectorConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustedHostKeys = "TrustedHostKeys"
        case userSecretId = "UserSecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trustedHostKeys = trustedHostKeys {
            var trustedHostKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trustedHostKeys)
            for sftpconnectortrustedhostkey0 in trustedHostKeys {
                try trustedHostKeysContainer.encode(sftpconnectortrustedhostkey0)
            }
        }
        if let userSecretId = self.userSecretId {
            try encodeContainer.encode(userSecretId, forKey: .userSecretId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSecretId)
        userSecretId = userSecretIdDecoded
        let trustedHostKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .trustedHostKeys)
        var trustedHostKeysDecoded0:[Swift.String]? = nil
        if let trustedHostKeysContainer = trustedHostKeysContainer {
            trustedHostKeysDecoded0 = [Swift.String]()
            for string0 in trustedHostKeysContainer {
                if let string0 = string0 {
                    trustedHostKeysDecoded0?.append(string0)
                }
            }
        }
        trustedHostKeys = trustedHostKeysDecoded0
    }
}

extension TransferClientTypes {
    /// Contains the details for an SFTP connector object. The connector object is used for transferring files to and from a partner's SFTP server. Because the SftpConnectorConfig data type is used for both creating and updating SFTP connectors, its parameters, TrustedHostKeys and UserSecretId are marked as not required. This is a bit misleading, as they are not required when you are updating an existing SFTP connector, but are required when you are creating a new SFTP connector.
    public struct SftpConnectorConfig: Swift.Equatable {
        /// The public portion of the host key, or keys, that are used to identify the external server to which you are connecting. You can use the ssh-keyscan command against the SFTP server to retrieve the necessary key. The three standard SSH public key format elements are <key type>, <body base64>, and an optional <comment>, with spaces between each element. Specify only the <key type> and <body base64>: do not enter the <comment> portion of the key. For the trusted host key, Transfer Family accepts RSA and ECDSA keys.
        ///
        /// * For RSA keys, the <key type> string is ssh-rsa.
        ///
        /// * For ECDSA keys, the <key type> string is either ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, or ecdsa-sha2-nistp521, depending on the size of the key you generated.
        ///
        ///
        /// Run this command to retrieve the SFTP server host key, where your SFTP server name is ftp.host.com. ssh-keyscan ftp.host.com This prints the public host key to standard output. ftp.host.com ssh-rsa AAAAB3Nza...<long-string-for-public-key Copy and paste this string into the TrustedHostKeys field for the create-connector command or into the Trusted host keys field in the console.
        public var trustedHostKeys: [Swift.String]?
        /// The identifier for the secret (in Amazon Web Services Secrets Manager) that contains the SFTP user's private key, password, or both. The identifier must be the Amazon Resource Name (ARN) of the secret.
        public var userSecretId: Swift.String?

        public init(
            trustedHostKeys: [Swift.String]? = nil,
            userSecretId: Swift.String? = nil
        )
        {
            self.trustedHostKeys = trustedHostKeys
            self.userSecretId = userSecretId
        }
    }

}

extension TransferClientTypes {
    public enum SigningAlg: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case sha1
        case sha256
        case sha384
        case sha512
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningAlg] {
            return [
                .none,
                .sha1,
                .sha256,
                .sha384,
                .sha512,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .sha1: return "SHA1"
            case .sha256: return "SHA256"
            case .sha384: return "SHA384"
            case .sha512: return "SHA512"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SigningAlg(rawValue: rawValue) ?? SigningAlg.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.SshPublicKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateImported = "DateImported"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case sshPublicKeyId = "SshPublicKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateImported = self.dateImported {
            try encodeContainer.encodeTimestamp(dateImported, format: .epochSeconds, forKey: .dateImported)
        }
        if let sshPublicKeyBody = self.sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let sshPublicKeyId = self.sshPublicKeyId {
            try encodeContainer.encode(sshPublicKeyId, forKey: .sshPublicKeyId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateImportedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateImported)
        dateImported = dateImportedDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
    }
}

extension TransferClientTypes {
    /// Provides information about the public Secure Shell (SSH) key that is associated with a Transfer Family user for the specific file transfer protocol-enabled server (as identified by ServerId). The information returned includes the date the key was imported, the public key contents, and the public key ID. A user can store more than one SSH public key associated with their user name on a specific server.
    public struct SshPublicKey: Swift.Equatable {
        /// Specifies the date that the public key was added to the Transfer Family user.
        /// This member is required.
        public var dateImported: ClientRuntime.Date?
        /// Specifies the content of the SSH public key as specified by the PublicKeyId. Transfer Family accepts RSA, ECDSA, and ED25519 keys.
        /// This member is required.
        public var sshPublicKeyBody: Swift.String?
        /// Specifies the SshPublicKeyId parameter contains the identifier of the public key.
        /// This member is required.
        public var sshPublicKeyId: Swift.String?

        public init(
            dateImported: ClientRuntime.Date? = nil,
            sshPublicKeyBody: Swift.String? = nil,
            sshPublicKeyId: Swift.String? = nil
        )
        {
            self.dateImported = dateImported
            self.sshPublicKeyBody = sshPublicKeyBody
            self.sshPublicKeyId = sshPublicKeyId
        }
    }

}

extension StartDirectoryListingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
        case maxItems = "MaxItems"
        case outputDirectoryPath = "OutputDirectoryPath"
        case remoteDirectoryPath = "RemoteDirectoryPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
        if let maxItems = self.maxItems {
            try encodeContainer.encode(maxItems, forKey: .maxItems)
        }
        if let outputDirectoryPath = self.outputDirectoryPath {
            try encodeContainer.encode(outputDirectoryPath, forKey: .outputDirectoryPath)
        }
        if let remoteDirectoryPath = self.remoteDirectoryPath {
            try encodeContainer.encode(remoteDirectoryPath, forKey: .remoteDirectoryPath)
        }
    }
}

extension StartDirectoryListingInput {

    static func urlPathProvider(_ value: StartDirectoryListingInput) -> Swift.String? {
        return "/"
    }
}

public struct StartDirectoryListingInput: Swift.Equatable {
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?
    /// An optional parameter where you can specify the maximum number of file/directory names to retrieve. The default value is 1,000.
    public var maxItems: Swift.Int?
    /// Specifies the path (bucket and prefix) in Amazon S3 storage to store the results of the directory listing.
    /// This member is required.
    public var outputDirectoryPath: Swift.String?
    /// Specifies the directory on the remote SFTP server for which you want to list its contents.
    /// This member is required.
    public var remoteDirectoryPath: Swift.String?

    public init(
        connectorId: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        outputDirectoryPath: Swift.String? = nil,
        remoteDirectoryPath: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
        self.maxItems = maxItems
        self.outputDirectoryPath = outputDirectoryPath
        self.remoteDirectoryPath = remoteDirectoryPath
    }
}

struct StartDirectoryListingInputBody: Swift.Equatable {
    let connectorId: Swift.String?
    let remoteDirectoryPath: Swift.String?
    let maxItems: Swift.Int?
    let outputDirectoryPath: Swift.String?
}

extension StartDirectoryListingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
        case maxItems = "MaxItems"
        case outputDirectoryPath = "OutputDirectoryPath"
        case remoteDirectoryPath = "RemoteDirectoryPath"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let remoteDirectoryPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteDirectoryPath)
        remoteDirectoryPath = remoteDirectoryPathDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let outputDirectoryPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputDirectoryPath)
        outputDirectoryPath = outputDirectoryPathDecoded
    }
}

extension StartDirectoryListingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartDirectoryListingOutputBody = try responseDecoder.decode(responseBody: data)
            self.listingId = output.listingId
            self.outputFileName = output.outputFileName
        } else {
            self.listingId = nil
            self.outputFileName = nil
        }
    }
}

public struct StartDirectoryListingOutput: Swift.Equatable {
    /// Returns a unique identifier for the directory listing call.
    /// This member is required.
    public var listingId: Swift.String?
    /// Returns the file name where the results are stored. This is a combination of the connector ID and the listing ID: <connector-id>-<listing-id>.json.
    /// This member is required.
    public var outputFileName: Swift.String?

    public init(
        listingId: Swift.String? = nil,
        outputFileName: Swift.String? = nil
    )
    {
        self.listingId = listingId
        self.outputFileName = outputFileName
    }
}

struct StartDirectoryListingOutputBody: Swift.Equatable {
    let listingId: Swift.String?
    let outputFileName: Swift.String?
}

extension StartDirectoryListingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listingId = "ListingId"
        case outputFileName = "OutputFileName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listingId)
        listingId = listingIdDecoded
        let outputFileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputFileName)
        outputFileName = outputFileNameDecoded
    }
}

enum StartDirectoryListingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartFileTransferInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
        case localDirectoryPath = "LocalDirectoryPath"
        case remoteDirectoryPath = "RemoteDirectoryPath"
        case retrieveFilePaths = "RetrieveFilePaths"
        case sendFilePaths = "SendFilePaths"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
        if let localDirectoryPath = self.localDirectoryPath {
            try encodeContainer.encode(localDirectoryPath, forKey: .localDirectoryPath)
        }
        if let remoteDirectoryPath = self.remoteDirectoryPath {
            try encodeContainer.encode(remoteDirectoryPath, forKey: .remoteDirectoryPath)
        }
        if let retrieveFilePaths = retrieveFilePaths {
            var retrieveFilePathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .retrieveFilePaths)
            for filepath0 in retrieveFilePaths {
                try retrieveFilePathsContainer.encode(filepath0)
            }
        }
        if let sendFilePaths = sendFilePaths {
            var sendFilePathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sendFilePaths)
            for filepath0 in sendFilePaths {
                try sendFilePathsContainer.encode(filepath0)
            }
        }
    }
}

extension StartFileTransferInput {

    static func urlPathProvider(_ value: StartFileTransferInput) -> Swift.String? {
        return "/"
    }
}

public struct StartFileTransferInput: Swift.Equatable {
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?
    /// For an inbound transfer, the LocaDirectoryPath specifies the destination for one or more files that are transferred from the partner's SFTP server.
    public var localDirectoryPath: Swift.String?
    /// For an outbound transfer, the RemoteDirectoryPath specifies the destination for one or more files that are transferred to the partner's SFTP server. If you don't specify a RemoteDirectoryPath, the destination for transferred files is the SFTP user's home directory.
    public var remoteDirectoryPath: Swift.String?
    /// One or more source paths for the partner's SFTP server. Each string represents a source file path for one inbound file transfer.
    public var retrieveFilePaths: [Swift.String]?
    /// One or more source paths for the Amazon S3 storage. Each string represents a source file path for one outbound file transfer. For example,  DOC-EXAMPLE-BUCKET/myfile.txt . Replace  DOC-EXAMPLE-BUCKET  with one of your actual buckets.
    public var sendFilePaths: [Swift.String]?

    public init(
        connectorId: Swift.String? = nil,
        localDirectoryPath: Swift.String? = nil,
        remoteDirectoryPath: Swift.String? = nil,
        retrieveFilePaths: [Swift.String]? = nil,
        sendFilePaths: [Swift.String]? = nil
    )
    {
        self.connectorId = connectorId
        self.localDirectoryPath = localDirectoryPath
        self.remoteDirectoryPath = remoteDirectoryPath
        self.retrieveFilePaths = retrieveFilePaths
        self.sendFilePaths = sendFilePaths
    }
}

struct StartFileTransferInputBody: Swift.Equatable {
    let connectorId: Swift.String?
    let sendFilePaths: [Swift.String]?
    let retrieveFilePaths: [Swift.String]?
    let localDirectoryPath: Swift.String?
    let remoteDirectoryPath: Swift.String?
}

extension StartFileTransferInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
        case localDirectoryPath = "LocalDirectoryPath"
        case remoteDirectoryPath = "RemoteDirectoryPath"
        case retrieveFilePaths = "RetrieveFilePaths"
        case sendFilePaths = "SendFilePaths"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let sendFilePathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sendFilePaths)
        var sendFilePathsDecoded0:[Swift.String]? = nil
        if let sendFilePathsContainer = sendFilePathsContainer {
            sendFilePathsDecoded0 = [Swift.String]()
            for string0 in sendFilePathsContainer {
                if let string0 = string0 {
                    sendFilePathsDecoded0?.append(string0)
                }
            }
        }
        sendFilePaths = sendFilePathsDecoded0
        let retrieveFilePathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .retrieveFilePaths)
        var retrieveFilePathsDecoded0:[Swift.String]? = nil
        if let retrieveFilePathsContainer = retrieveFilePathsContainer {
            retrieveFilePathsDecoded0 = [Swift.String]()
            for string0 in retrieveFilePathsContainer {
                if let string0 = string0 {
                    retrieveFilePathsDecoded0?.append(string0)
                }
            }
        }
        retrieveFilePaths = retrieveFilePathsDecoded0
        let localDirectoryPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localDirectoryPath)
        localDirectoryPath = localDirectoryPathDecoded
        let remoteDirectoryPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteDirectoryPath)
        remoteDirectoryPath = remoteDirectoryPathDecoded
    }
}

extension StartFileTransferOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartFileTransferOutputBody = try responseDecoder.decode(responseBody: data)
            self.transferId = output.transferId
        } else {
            self.transferId = nil
        }
    }
}

public struct StartFileTransferOutput: Swift.Equatable {
    /// Returns the unique identifier for the file transfer.
    /// This member is required.
    public var transferId: Swift.String?

    public init(
        transferId: Swift.String? = nil
    )
    {
        self.transferId = transferId
    }
}

struct StartFileTransferOutputBody: Swift.Equatable {
    let transferId: Swift.String?
}

extension StartFileTransferOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transferId = "TransferId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transferIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transferId)
        transferId = transferIdDecoded
    }
}

enum StartFileTransferOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension StartServerInput {

    static func urlPathProvider(_ value: StartServerInput) -> Swift.String? {
        return "/"
    }
}

public struct StartServerInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server that you start.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct StartServerInputBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension StartServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension StartServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartServerOutput: Swift.Equatable {

    public init() { }
}

enum StartServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TransferClientTypes {
    /// Describes the condition of a file transfer protocol-enabled server with respect to its ability to perform file operations. There are six possible states: OFFLINE, ONLINE, STARTING, STOPPING, START_FAILED, and STOP_FAILED. OFFLINE indicates that the server exists, but that it is not available for file operations. ONLINE indicates that the server is available to perform file operations. STARTING indicates that the server's was instantiated, but the server is not yet available to perform file operations. Under normal conditions, it can take a couple of minutes for the server to be completely operational. Both START_FAILED and STOP_FAILED are error conditions.
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case offline
        case online
        case starting
        case startFailed
        case stopping
        case stopFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .offline,
                .online,
                .starting,
                .startFailed,
                .stopping,
                .stopFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .starting: return "STARTING"
            case .startFailed: return "START_FAILED"
            case .stopping: return "STOPPING"
            case .stopFailed: return "STOP_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension StopServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension StopServerInput {

    static func urlPathProvider(_ value: StopServerInput) -> Swift.String? {
        return "/"
    }
}

public struct StopServerInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server that you stopped.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct StopServerInputBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension StopServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension StopServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopServerOutput: Swift.Equatable {

    public init() { }
}

enum StopServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TransferClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TransferClientTypes {
    /// Creates a key-value pair for a specific resource. Tags are metadata that you can use to search for and group a resource for various purposes. You can apply tags to servers, users, and roles. A tag key can take more than one value. For example, to group servers for accounting purposes, you might create a tag called Group and assign the values Research and Accounting to that group.
    public struct Tag: Swift.Equatable {
        /// The name assigned to the tag that you create.
        /// This member is required.
        public var key: Swift.String?
        /// Contains one or more values that you assigned to the key name you create.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a server, user, or role.
    /// This member is required.
    public var arn: Swift.String?
    /// Key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (servers, users, workflows, and so on) for any purpose.
    /// This member is required.
    public var tags: [TransferClientTypes.Tag]?

    public init(
        arn: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let tags: [TransferClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TransferClientTypes.TagStepDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sourceFileLocation = "SourceFileLocation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceFileLocation = self.sourceFileLocation {
            try encodeContainer.encode(sourceFileLocation, forKey: .sourceFileLocation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for s3tag0 in tags {
                try tagsContainer.encode(s3tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.S3Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.S3Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.S3Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let sourceFileLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileLocation)
        sourceFileLocation = sourceFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure. The key/value pairs used to tag a file during the execution of a workflow step.
    public struct TagStepDetails: Swift.Equatable {
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?
        /// Array that contains from 1 to 10 key/value pairs.
        public var tags: [TransferClientTypes.S3Tag]?

        public init(
            name: Swift.String? = nil,
            sourceFileLocation: Swift.String? = nil,
            tags: [TransferClientTypes.S3Tag]? = nil
        )
        {
            self.name = name
            self.sourceFileLocation = sourceFileLocation
            self.tags = tags
        }
    }

}

extension TestConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
    }
}

extension TestConnectionInput {

    static func urlPathProvider(_ value: TestConnectionInput) -> Swift.String? {
        return "/"
    }
}

public struct TestConnectionInput: Swift.Equatable {
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?

    public init(
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

struct TestConnectionInputBody: Swift.Equatable {
    let connectorId: Swift.String?
}

extension TestConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
    }
}

extension TestConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectorId = output.connectorId
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.connectorId = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct TestConnectionOutput: Swift.Equatable {
    /// Returns the identifier of the connector object that you are testing.
    public var connectorId: Swift.String?
    /// Returns OK for successful test, or ERROR if the test fails.
    public var status: Swift.String?
    /// Returns Connection succeeded if the test is successful. Or, returns a descriptive error message if the test fails. The following list provides troubleshooting details, depending on the error message that you receive.
    ///
    /// * Verify that your secret name aligns with the one in Transfer Role permissions.
    ///
    /// * Verify the server URL in the connector configuration , and verify that the login credentials work successfully outside of the connector.
    ///
    /// * Verify that the secret exists and is formatted correctly.
    ///
    /// * Verify that the trusted host key in the connector configuration matches the ssh-keyscan output.
    public var statusMessage: Swift.String?

    public init(
        connectorId: Swift.String? = nil,
        status: Swift.String? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct TestConnectionOutputBody: Swift.Equatable {
    let connectorId: Swift.String?
    let status: Swift.String?
    let statusMessage: Swift.String?
}

extension TestConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

enum TestConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TestIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestIdentityProviderInput(serverId: \(Swift.String(describing: serverId)), serverProtocol: \(Swift.String(describing: serverProtocol)), sourceIp: \(Swift.String(describing: sourceIp)), userName: \(Swift.String(describing: userName)), userPassword: \"CONTENT_REDACTED\")"}
}

extension TestIdentityProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case serverProtocol = "ServerProtocol"
        case sourceIp = "SourceIp"
        case userName = "UserName"
        case userPassword = "UserPassword"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let serverProtocol = self.serverProtocol {
            try encodeContainer.encode(serverProtocol.rawValue, forKey: .serverProtocol)
        }
        if let sourceIp = self.sourceIp {
            try encodeContainer.encode(sourceIp, forKey: .sourceIp)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userPassword = self.userPassword {
            try encodeContainer.encode(userPassword, forKey: .userPassword)
        }
    }
}

extension TestIdentityProviderInput {

    static func urlPathProvider(_ value: TestIdentityProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct TestIdentityProviderInput: Swift.Equatable {
    /// A system-assigned identifier for a specific server. That server's user authentication method is tested with a user name and password.
    /// This member is required.
    public var serverId: Swift.String?
    /// The type of file transfer protocol to be tested. The available protocols are:
    ///
    /// * Secure Shell (SSH) File Transfer Protocol (SFTP)
    ///
    /// * File Transfer Protocol Secure (FTPS)
    ///
    /// * File Transfer Protocol (FTP)
    ///
    /// * Applicability Statement 2 (AS2)
    public var serverProtocol: TransferClientTypes.ModelProtocol?
    /// The source IP address of the account to be tested.
    public var sourceIp: Swift.String?
    /// The name of the account to be tested.
    /// This member is required.
    public var userName: Swift.String?
    /// The password of the account to be tested.
    public var userPassword: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        serverProtocol: TransferClientTypes.ModelProtocol? = nil,
        sourceIp: Swift.String? = nil,
        userName: Swift.String? = nil,
        userPassword: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.serverProtocol = serverProtocol
        self.sourceIp = sourceIp
        self.userName = userName
        self.userPassword = userPassword
    }
}

struct TestIdentityProviderInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let serverProtocol: TransferClientTypes.ModelProtocol?
    let sourceIp: Swift.String?
    let userName: Swift.String?
    let userPassword: Swift.String?
}

extension TestIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case serverProtocol = "ServerProtocol"
        case sourceIp = "SourceIp"
        case userName = "UserName"
        case userPassword = "UserPassword"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let serverProtocolDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ModelProtocol.self, forKey: .serverProtocol)
        serverProtocol = serverProtocolDecoded
        let sourceIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIp)
        sourceIp = sourceIpDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPassword)
        userPassword = userPasswordDecoded
    }
}

extension TestIdentityProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestIdentityProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.response = output.response
            self.statusCode = output.statusCode
            self.url = output.url
        } else {
            self.message = nil
            self.response = nil
            self.statusCode = 0
            self.url = nil
        }
    }
}

public struct TestIdentityProviderOutput: Swift.Equatable {
    /// A message that indicates whether the test was successful or not. If an empty string is returned, the most likely cause is that the authentication failed due to an incorrect username or password.
    public var message: Swift.String?
    /// The response that is returned from your API Gateway or your Lambda function.
    public var response: Swift.String?
    /// The HTTP status code that is the response from your API Gateway or your Lambda function.
    /// This member is required.
    public var statusCode: Swift.Int
    /// The endpoint of the service used to authenticate a user.
    /// This member is required.
    public var url: Swift.String?

    public init(
        message: Swift.String? = nil,
        response: Swift.String? = nil,
        statusCode: Swift.Int = 0,
        url: Swift.String? = nil
    )
    {
        self.message = message
        self.response = response
        self.statusCode = statusCode
        self.url = url
    }
}

struct TestIdentityProviderOutputBody: Swift.Equatable {
    let response: Swift.String?
    let statusCode: Swift.Int
    let message: Swift.String?
    let url: Swift.String?
}

extension TestIdentityProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case response = "Response"
        case statusCode = "StatusCode"
        case url = "Url"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .response)
        response = responseDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode) ?? 0
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

enum TestIdentityProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.properties.retryAfterSeconds = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var retryAfterSeconds: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

extension TransferClientTypes {
    public enum TlsSessionResumptionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case enforced
        case sdkUnknown(Swift.String)

        public static var allCases: [TlsSessionResumptionMode] {
            return [
                .disabled,
                .enabled,
                .enforced,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .enforced: return "ENFORCED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TlsSessionResumptionMode(rawValue: rawValue) ?? TlsSessionResumptionMode.sdkUnknown(rawValue)
        }
    }
}

public enum TransferClientTypes {}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The value of the resource that will have the tag removed. An Amazon Resource Name (ARN) is an identifier for a specific Amazon Web Services resource, such as a server, user, or role.
    /// This member is required.
    public var arn: Swift.String?
    /// TagKeys are key-value pairs assigned to ARNs that can be used to group and search for resources by type. This metadata can be attached to resources for any purpose.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymapentry0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymapentry0)
            }
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = self.posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension UpdateAccessInput {

    static func urlPathProvider(_ value: UpdateAccessInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateAccessInput: Swift.Equatable {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock down your user to the designated home directory ("chroot"). To do this, you can set Entry to / and set Target to the HomeDirectory parameter value. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use session policies. For session policies, Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Example session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Amazon Web ServicesSecurity Token Service API Reference.
    public var policy: Swift.String?
    /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        externalId: Swift.String? = nil,
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
    }
}

struct UpdateAccessInputBody: Swift.Equatable {
    let homeDirectory: Swift.String?
    let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    let policy: Swift.String?
    let posixProfile: TransferClientTypes.PosixProfile?
    let role: Swift.String?
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension UpdateAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension UpdateAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.externalId = output.externalId
            self.serverId = output.serverId
        } else {
            self.externalId = nil
            self.serverId = nil
        }
    }
}

public struct UpdateAccessOutput: Swift.Equatable {
    /// The external identifier of the group whose users have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Amazon Web ServicesTransfer Family.
    /// This member is required.
    public var externalId: Swift.String?
    /// The identifier of the server that the user is attached to.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct UpdateAccessOutputBody: Swift.Equatable {
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension UpdateAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

enum UpdateAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAgreementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case agreementId = "AgreementId"
        case baseDirectory = "BaseDirectory"
        case description = "Description"
        case localProfileId = "LocalProfileId"
        case partnerProfileId = "PartnerProfileId"
        case serverId = "ServerId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = self.accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let agreementId = self.agreementId {
            try encodeContainer.encode(agreementId, forKey: .agreementId)
        }
        if let baseDirectory = self.baseDirectory {
            try encodeContainer.encode(baseDirectory, forKey: .baseDirectory)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let localProfileId = self.localProfileId {
            try encodeContainer.encode(localProfileId, forKey: .localProfileId)
        }
        if let partnerProfileId = self.partnerProfileId {
            try encodeContainer.encode(partnerProfileId, forKey: .partnerProfileId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateAgreementInput {

    static func urlPathProvider(_ value: UpdateAgreementInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateAgreementInput: Swift.Equatable {
    /// Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use. For AS2 connectors With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the fileâ€™s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer. If you are using Basic authentication for your AS2 connector, the access role requires the secretsmanager:GetSecretValue permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the kms:Decrypt permission for that key. For SFTP connectors Make sure that the access role provides read and write access to the parent directory of the file location that's used in the StartFileTransfer request. Additionally, make sure that the role provides secretsmanager:GetSecretValue permission to Secrets Manager.
    public var accessRole: Swift.String?
    /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
    /// This member is required.
    public var agreementId: Swift.String?
    /// To change the landing directory (folder) for files that are transferred, provide the bucket folder that you want to use; for example, /DOC-EXAMPLE-BUCKET/home/mydirectory .
    public var baseDirectory: Swift.String?
    /// To replace the existing description, provide a short description for the agreement.
    public var description: Swift.String?
    /// A unique identifier for the AS2 local profile. To change the local profile identifier, provide a new value here.
    public var localProfileId: Swift.String?
    /// A unique identifier for the partner profile. To change the partner profile identifier, provide a new value here.
    public var partnerProfileId: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that the agreement uses.
    /// This member is required.
    public var serverId: Swift.String?
    /// You can update the status for the agreement, either activating an inactive agreement or the reverse.
    public var status: TransferClientTypes.AgreementStatusType?

    public init(
        accessRole: Swift.String? = nil,
        agreementId: Swift.String? = nil,
        baseDirectory: Swift.String? = nil,
        description: Swift.String? = nil,
        localProfileId: Swift.String? = nil,
        partnerProfileId: Swift.String? = nil,
        serverId: Swift.String? = nil,
        status: TransferClientTypes.AgreementStatusType? = nil
    )
    {
        self.accessRole = accessRole
        self.agreementId = agreementId
        self.baseDirectory = baseDirectory
        self.description = description
        self.localProfileId = localProfileId
        self.partnerProfileId = partnerProfileId
        self.serverId = serverId
        self.status = status
    }
}

struct UpdateAgreementInputBody: Swift.Equatable {
    let agreementId: Swift.String?
    let serverId: Swift.String?
    let description: Swift.String?
    let status: TransferClientTypes.AgreementStatusType?
    let localProfileId: Swift.String?
    let partnerProfileId: Swift.String?
    let baseDirectory: Swift.String?
    let accessRole: Swift.String?
}

extension UpdateAgreementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case agreementId = "AgreementId"
        case baseDirectory = "BaseDirectory"
        case description = "Description"
        case localProfileId = "LocalProfileId"
        case partnerProfileId = "PartnerProfileId"
        case serverId = "ServerId"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.AgreementStatusType.self, forKey: .status)
        status = statusDecoded
        let localProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localProfileId)
        localProfileId = localProfileIdDecoded
        let partnerProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerProfileId)
        partnerProfileId = partnerProfileIdDecoded
        let baseDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseDirectory)
        baseDirectory = baseDirectoryDecoded
        let accessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
    }
}

extension UpdateAgreementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAgreementOutputBody = try responseDecoder.decode(responseBody: data)
            self.agreementId = output.agreementId
        } else {
            self.agreementId = nil
        }
    }
}

public struct UpdateAgreementOutput: Swift.Equatable {
    /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
    /// This member is required.
    public var agreementId: Swift.String?

    public init(
        agreementId: Swift.String? = nil
    )
    {
        self.agreementId = agreementId
    }
}

struct UpdateAgreementOutputBody: Swift.Equatable {
    let agreementId: Swift.String?
}

extension UpdateAgreementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId = "AgreementId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
    }
}

enum UpdateAgreementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDate = "ActiveDate"
        case certificateId = "CertificateId"
        case description = "Description"
        case inactiveDate = "InactiveDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDate = self.activeDate {
            try encodeContainer.encodeTimestamp(activeDate, format: .epochSeconds, forKey: .activeDate)
        }
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inactiveDate = self.inactiveDate {
            try encodeContainer.encodeTimestamp(inactiveDate, format: .epochSeconds, forKey: .inactiveDate)
        }
    }
}

extension UpdateCertificateInput {

    static func urlPathProvider(_ value: UpdateCertificateInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateCertificateInput: Swift.Equatable {
    /// An optional date that specifies when the certificate becomes active.
    public var activeDate: ClientRuntime.Date?
    /// The identifier of the certificate object that you are updating.
    /// This member is required.
    public var certificateId: Swift.String?
    /// A short description to help identify the certificate.
    public var description: Swift.String?
    /// An optional date that specifies when the certificate becomes inactive.
    public var inactiveDate: ClientRuntime.Date?

    public init(
        activeDate: ClientRuntime.Date? = nil,
        certificateId: Swift.String? = nil,
        description: Swift.String? = nil,
        inactiveDate: ClientRuntime.Date? = nil
    )
    {
        self.activeDate = activeDate
        self.certificateId = certificateId
        self.description = description
        self.inactiveDate = inactiveDate
    }
}

struct UpdateCertificateInputBody: Swift.Equatable {
    let certificateId: Swift.String?
    let activeDate: ClientRuntime.Date?
    let inactiveDate: ClientRuntime.Date?
    let description: Swift.String?
}

extension UpdateCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDate = "ActiveDate"
        case certificateId = "CertificateId"
        case description = "Description"
        case inactiveDate = "InactiveDate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let activeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .activeDate)
        activeDate = activeDateDecoded
        let inactiveDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .inactiveDate)
        inactiveDate = inactiveDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateId = output.certificateId
        } else {
            self.certificateId = nil
        }
    }
}

public struct UpdateCertificateOutput: Swift.Equatable {
    /// Returns the identifier of the certificate object that you are updating.
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct UpdateCertificateOutputBody: Swift.Equatable {
    let certificateId: Swift.String?
}

extension UpdateCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

enum UpdateCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case as2Config = "As2Config"
        case connectorId = "ConnectorId"
        case loggingRole = "LoggingRole"
        case securityPolicyName = "SecurityPolicyName"
        case sftpConfig = "SftpConfig"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = self.accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let as2Config = self.as2Config {
            try encodeContainer.encode(as2Config, forKey: .as2Config)
        }
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let securityPolicyName = self.securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let sftpConfig = self.sftpConfig {
            try encodeContainer.encode(sftpConfig, forKey: .sftpConfig)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }
}

extension UpdateConnectorInput {

    static func urlPathProvider(_ value: UpdateConnectorInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateConnectorInput: Swift.Equatable {
    /// Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use. For AS2 connectors With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the fileâ€™s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer. If you are using Basic authentication for your AS2 connector, the access role requires the secretsmanager:GetSecretValue permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the kms:Decrypt permission for that key. For SFTP connectors Make sure that the access role provides read and write access to the parent directory of the file location that's used in the StartFileTransfer request. Additionally, make sure that the role provides secretsmanager:GetSecretValue permission to Secrets Manager.
    public var accessRole: Swift.String?
    /// A structure that contains the parameters for an AS2 connector object.
    public var as2Config: TransferClientTypes.As2ConnectorConfig?
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a connector to turn on CloudWatch logging for Amazon S3 events. When set, you can view connector activity in your CloudWatch logs.
    public var loggingRole: Swift.String?
    /// Specifies the name of the security policy for the connector.
    public var securityPolicyName: Swift.String?
    /// A structure that contains the parameters for an SFTP connector object.
    public var sftpConfig: TransferClientTypes.SftpConnectorConfig?
    /// The URL of the partner's AS2 or SFTP endpoint.
    public var url: Swift.String?

    public init(
        accessRole: Swift.String? = nil,
        as2Config: TransferClientTypes.As2ConnectorConfig? = nil,
        connectorId: Swift.String? = nil,
        loggingRole: Swift.String? = nil,
        securityPolicyName: Swift.String? = nil,
        sftpConfig: TransferClientTypes.SftpConnectorConfig? = nil,
        url: Swift.String? = nil
    )
    {
        self.accessRole = accessRole
        self.as2Config = as2Config
        self.connectorId = connectorId
        self.loggingRole = loggingRole
        self.securityPolicyName = securityPolicyName
        self.sftpConfig = sftpConfig
        self.url = url
    }
}

struct UpdateConnectorInputBody: Swift.Equatable {
    let connectorId: Swift.String?
    let url: Swift.String?
    let as2Config: TransferClientTypes.As2ConnectorConfig?
    let accessRole: Swift.String?
    let loggingRole: Swift.String?
    let sftpConfig: TransferClientTypes.SftpConnectorConfig?
    let securityPolicyName: Swift.String?
}

extension UpdateConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case as2Config = "As2Config"
        case connectorId = "ConnectorId"
        case loggingRole = "LoggingRole"
        case securityPolicyName = "SecurityPolicyName"
        case sftpConfig = "SftpConfig"
        case url = "Url"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let as2ConfigDecoded = try containerValues.decodeIfPresent(TransferClientTypes.As2ConnectorConfig.self, forKey: .as2Config)
        as2Config = as2ConfigDecoded
        let accessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let sftpConfigDecoded = try containerValues.decodeIfPresent(TransferClientTypes.SftpConnectorConfig.self, forKey: .sftpConfig)
        sftpConfig = sftpConfigDecoded
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
    }
}

extension UpdateConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectorId = output.connectorId
        } else {
            self.connectorId = nil
        }
    }
}

public struct UpdateConnectorOutput: Swift.Equatable {
    /// Returns the identifier of the connector object that you are updating.
    /// This member is required.
    public var connectorId: Swift.String?

    public init(
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

struct UpdateConnectorOutputBody: Swift.Equatable {
    let connectorId: Swift.String?
}

extension UpdateConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
    }
}

enum UpdateConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateHostKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hostKeyId = self.hostKeyId {
            try encodeContainer.encode(hostKeyId, forKey: .hostKeyId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension UpdateHostKeyInput {

    static func urlPathProvider(_ value: UpdateHostKeyInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateHostKeyInput: Swift.Equatable {
    /// An updated description for the host key.
    /// This member is required.
    public var description: Swift.String?
    /// The identifier of the host key that you are updating.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// The identifier of the server that contains the host key that you are updating.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        description: Swift.String? = nil,
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.description = description
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

struct UpdateHostKeyInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let hostKeyId: Swift.String?
    let description: Swift.String?
}

extension UpdateHostKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let hostKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyId)
        hostKeyId = hostKeyIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateHostKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateHostKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.hostKeyId = output.hostKeyId
            self.serverId = output.serverId
        } else {
            self.hostKeyId = nil
            self.serverId = nil
        }
    }
}

public struct UpdateHostKeyOutput: Swift.Equatable {
    /// Returns the host key identifier for the updated host key.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// Returns the server identifier for the server that contains the updated host key.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

struct UpdateHostKeyOutputBody: Swift.Equatable {
    let serverId: Swift.String?
    let hostKeyId: Swift.String?
}

extension UpdateHostKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let hostKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyId)
        hostKeyId = hostKeyIdDecoded
    }
}

enum UpdateHostKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateIds = "CertificateIds"
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateIds = certificateIds {
            var certificateIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateIds)
            for certificateid0 in certificateIds {
                try certificateIdsContainer.encode(certificateid0)
            }
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
    }
}

extension UpdateProfileInput {

    static func urlPathProvider(_ value: UpdateProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateProfileInput: Swift.Equatable {
    /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
    public var certificateIds: [Swift.String]?
    /// The identifier of the profile object that you are updating.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        certificateIds: [Swift.String]? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.certificateIds = certificateIds
        self.profileId = profileId
    }
}

struct UpdateProfileInputBody: Swift.Equatable {
    let profileId: Swift.String?
    let certificateIds: [Swift.String]?
}

extension UpdateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateIds = "CertificateIds"
        case profileId = "ProfileId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let certificateIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .certificateIds)
        var certificateIdsDecoded0:[Swift.String]? = nil
        if let certificateIdsContainer = certificateIdsContainer {
            certificateIdsDecoded0 = [Swift.String]()
            for string0 in certificateIdsContainer {
                if let string0 = string0 {
                    certificateIdsDecoded0?.append(string0)
                }
            }
        }
        certificateIds = certificateIdsDecoded0
    }
}

extension UpdateProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profileId = output.profileId
        } else {
            self.profileId = nil
        }
    }
}

public struct UpdateProfileOutput: Swift.Equatable {
    /// Returns the identifier for the profile that's being updated.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct UpdateProfileOutputBody: Swift.Equatable {
    let profileId: Swift.String?
}

extension UpdateProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

enum UpdateProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServerInput(certificate: \(Swift.String(describing: certificate)), endpointDetails: \(Swift.String(describing: endpointDetails)), endpointType: \(Swift.String(describing: endpointType)), identityProviderDetails: \(Swift.String(describing: identityProviderDetails)), loggingRole: \(Swift.String(describing: loggingRole)), postAuthenticationLoginBanner: \(Swift.String(describing: postAuthenticationLoginBanner)), preAuthenticationLoginBanner: \(Swift.String(describing: preAuthenticationLoginBanner)), protocolDetails: \(Swift.String(describing: protocolDetails)), protocols: \(Swift.String(describing: protocols)), s3StorageOptions: \(Swift.String(describing: s3StorageOptions)), securityPolicyName: \(Swift.String(describing: securityPolicyName)), serverId: \(Swift.String(describing: serverId)), structuredLogDestinations: \(Swift.String(describing: structuredLogDestinations)), workflowDetails: \(Swift.String(describing: workflowDetails)), hostKey: \"CONTENT_REDACTED\")"}
}

extension UpdateServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case loggingRole = "LoggingRole"
        case postAuthenticationLoginBanner = "PostAuthenticationLoginBanner"
        case preAuthenticationLoginBanner = "PreAuthenticationLoginBanner"
        case protocolDetails = "ProtocolDetails"
        case protocols = "Protocols"
        case s3StorageOptions = "S3StorageOptions"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
        case structuredLogDestinations = "StructuredLogDestinations"
        case workflowDetails = "WorkflowDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let endpointDetails = self.endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKey = self.hostKey {
            try encodeContainer.encode(hostKey, forKey: .hostKey)
        }
        if let identityProviderDetails = self.identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let postAuthenticationLoginBanner = self.postAuthenticationLoginBanner {
            try encodeContainer.encode(postAuthenticationLoginBanner, forKey: .postAuthenticationLoginBanner)
        }
        if let preAuthenticationLoginBanner = self.preAuthenticationLoginBanner {
            try encodeContainer.encode(preAuthenticationLoginBanner, forKey: .preAuthenticationLoginBanner)
        }
        if let protocolDetails = self.protocolDetails {
            try encodeContainer.encode(protocolDetails, forKey: .protocolDetails)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocol0 in protocols {
                try protocolsContainer.encode(protocol0.rawValue)
            }
        }
        if let s3StorageOptions = self.s3StorageOptions {
            try encodeContainer.encode(s3StorageOptions, forKey: .s3StorageOptions)
        }
        if let securityPolicyName = self.securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let structuredLogDestinations = structuredLogDestinations {
            var structuredLogDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .structuredLogDestinations)
            for arn0 in structuredLogDestinations {
                try structuredLogDestinationsContainer.encode(arn0)
            }
        }
        if let workflowDetails = self.workflowDetails {
            try encodeContainer.encode(workflowDetails, forKey: .workflowDetails)
        }
    }
}

extension UpdateServerInput {

    static func urlPathProvider(_ value: UpdateServerInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateServerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when Protocols is set to FTPS. To request a new public certificate, see [Request a public certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html) in the Amazon Web ServicesCertificate Manager User Guide. To import an existing certificate into ACM, see [Importing certificates into ACM](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the Amazon Web ServicesCertificate Manager User Guide. To request a private certificate to use FTPS through private IP addresses, see [Request a private certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html) in the Amazon Web ServicesCertificate Manager User Guide. Certificates with the following cryptographic algorithms and key sizes are supported:
    ///
    /// * 2048-bit RSA (RSA_2048)
    ///
    /// * 4096-bit RSA (RSA_4096)
    ///
    /// * Elliptic Prime Curve 256 bit (EC_prime256v1)
    ///
    /// * Elliptic Prime Curve 384 bit (EC_secp384r1)
    ///
    /// * Elliptic Prime Curve 521 bit (EC_secp521r1)
    ///
    ///
    /// The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP address specified and information about the issuer.
    public var certificate: Swift.String?
    /// The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make your endpoint accessible only to resources within your VPC, or you can attach Elastic IP addresses and make your endpoint accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.
    public var endpointDetails: TransferClientTypes.EndpointDetails?
    /// The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC) or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it. After May 19, 2021, you won't be able to create a server using EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount if your account hasn't already done so before May 19, 2021. If you have already created servers with EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount on or before May 19, 2021, you will not be affected. After this date, use EndpointType=VPC. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint. It is recommended that you use VPC as the EndpointType. With this endpoint type, you have the option to directly associate up to three Elastic IPv4 addresses (BYO IP included) with your server's endpoint and use VPC security groups to restrict traffic by the client's public IP address. This is not possible with EndpointType set to VPC_ENDPOINT.
    public var endpointType: TransferClientTypes.EndpointType?
    /// The RSA, ECDSA, or ED25519 private key to use for your SFTP-enabled server. You can add multiple host keys, in case you want to rotate keys, or have a set of active keys that use different algorithms. Use the following command to generate an RSA 2048 bit key with no passphrase: ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key. Use a minimum value of 2048 for the -b option. You can create a stronger key by using 3072 or 4096. Use the following command to generate an ECDSA 256 bit key with no passphrase: ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key. Valid values for the -b option for ECDSA are 256, 384, and 521. Use the following command to generate an ED25519 key with no passphrase: ssh-keygen -t ed25519 -N "" -f my-new-server-key. For all of these commands, you can replace my-new-server-key with a string of your choice. If you aren't planning to migrate existing users from an existing SFTP-enabled server to a new server, don't update the host key. Accidentally changing a server's host key can be disruptive. For more information, see [Manage host keys for your SFTP-enabled server](https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key) in the Transfer Family User Guide.
    public var hostKey: Swift.String?
    /// An array containing all of the information required to call a customer's authentication API method.
    public var identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
    public var loggingRole: Swift.String?
    /// Specifies a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
    public var postAuthenticationLoginBanner: Swift.String?
    /// Specifies a string to display when users connect to a server. This string is displayed before the user authenticates. For example, the following banner displays details about using the system: This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel.
    public var preAuthenticationLoginBanner: Swift.String?
    /// The protocol settings that are configured for your server.
    ///
    /// * To indicate passive mode (for FTP and FTPS protocols), use the PassiveIp parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
    ///
    /// * To ignore the error that is generated when the client attempts to use the SETSTAT command on a file that you are uploading to an Amazon S3 bucket, use the SetStatOption parameter. To have the Transfer Family server ignore the SETSTAT command and upload files without needing to make any changes to your SFTP client, set the value to ENABLE_NO_OP. If you set the SetStatOption parameter to ENABLE_NO_OP, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a SETSTAT call.
    ///
    /// * To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the TlsSessionResumptionMode parameter.
    ///
    /// * As2Transports indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
    public var protocolDetails: TransferClientTypes.ProtocolDetails?
    /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:
    ///
    /// * SFTP (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH
    ///
    /// * FTPS (File Transfer Protocol Secure): File transfer with TLS encryption
    ///
    /// * FTP (File Transfer Protocol): Unencrypted file transfer
    ///
    /// * AS2 (Applicability Statement 2): used for transporting structured business-to-business data
    ///
    ///
    ///
    ///
    /// * If you select FTPS, you must choose a certificate stored in Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS.
    ///
    /// * If Protocol includes either FTP or FTPS, then the EndpointType must be VPC and the IdentityProviderType must be either AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
    ///
    /// * If Protocol includes FTP, then AddressAllocationIds cannot be associated.
    ///
    /// * If Protocol is set only to SFTP, the EndpointType can be set to PUBLIC and the IdentityProviderType can be set any of the supported identity types: SERVICE_MANAGED, AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
    ///
    /// * If Protocol includes AS2, then the EndpointType must be VPC, and domain must be Amazon S3.
    public var protocols: [TransferClientTypes.ModelProtocol]?
    /// Specifies whether or not performance for your Amazon S3 directories is optimized. This is disabled by default. By default, home directory mappings have a TYPE of DIRECTORY. If you enable this option, you would then need to explicitly set the HomeDirectoryMapEntryType to FILE if you want a mapping to have a file target.
    public var s3StorageOptions: TransferClientTypes.S3StorageOptions?
    /// Specifies the name of the security policy for the server.
    public var securityPolicyName: Swift.String?
    /// A system-assigned unique identifier for a server instance that the Transfer Family user is assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// Specifies the log groups to which your server logs are sent. To specify a log group, you must provide the ARN for an existing log group. In this case, the format of the log group is as follows: arn:aws:logs:region-name:amazon-account-id:log-group:log-group-name:* For example, arn:aws:logs:us-east-1:111122223333:log-group:mytestgroup:* If you have previously specified a log group for a server, you can clear it, and in effect turn off structured logging, by providing an empty value for this parameter in an update-server call. For example: update-server --server-id s-1234567890abcdef0 --structured-log-destinations
    public var structuredLogDestinations: [Swift.String]?
    /// Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow. In addition to a workflow to execute when a file is uploaded completely, WorkflowDetails can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when the server session disconnects while the file is still being uploaded. To remove an associated workflow from a server, you can provide an empty OnUpload object, as in the following example. aws transfer update-server --server-id s-01234567890abcdef --workflow-details '{"OnUpload":[]}'
    public var workflowDetails: TransferClientTypes.WorkflowDetails?

    public init(
        certificate: Swift.String? = nil,
        endpointDetails: TransferClientTypes.EndpointDetails? = nil,
        endpointType: TransferClientTypes.EndpointType? = nil,
        hostKey: Swift.String? = nil,
        identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
        loggingRole: Swift.String? = nil,
        postAuthenticationLoginBanner: Swift.String? = nil,
        preAuthenticationLoginBanner: Swift.String? = nil,
        protocolDetails: TransferClientTypes.ProtocolDetails? = nil,
        protocols: [TransferClientTypes.ModelProtocol]? = nil,
        s3StorageOptions: TransferClientTypes.S3StorageOptions? = nil,
        securityPolicyName: Swift.String? = nil,
        serverId: Swift.String? = nil,
        structuredLogDestinations: [Swift.String]? = nil,
        workflowDetails: TransferClientTypes.WorkflowDetails? = nil
    )
    {
        self.certificate = certificate
        self.endpointDetails = endpointDetails
        self.endpointType = endpointType
        self.hostKey = hostKey
        self.identityProviderDetails = identityProviderDetails
        self.loggingRole = loggingRole
        self.postAuthenticationLoginBanner = postAuthenticationLoginBanner
        self.preAuthenticationLoginBanner = preAuthenticationLoginBanner
        self.protocolDetails = protocolDetails
        self.protocols = protocols
        self.s3StorageOptions = s3StorageOptions
        self.securityPolicyName = securityPolicyName
        self.serverId = serverId
        self.structuredLogDestinations = structuredLogDestinations
        self.workflowDetails = workflowDetails
    }
}

struct UpdateServerInputBody: Swift.Equatable {
    let certificate: Swift.String?
    let protocolDetails: TransferClientTypes.ProtocolDetails?
    let endpointDetails: TransferClientTypes.EndpointDetails?
    let endpointType: TransferClientTypes.EndpointType?
    let hostKey: Swift.String?
    let identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    let loggingRole: Swift.String?
    let postAuthenticationLoginBanner: Swift.String?
    let preAuthenticationLoginBanner: Swift.String?
    let protocols: [TransferClientTypes.ModelProtocol]?
    let securityPolicyName: Swift.String?
    let serverId: Swift.String?
    let workflowDetails: TransferClientTypes.WorkflowDetails?
    let structuredLogDestinations: [Swift.String]?
    let s3StorageOptions: TransferClientTypes.S3StorageOptions?
}

extension UpdateServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case loggingRole = "LoggingRole"
        case postAuthenticationLoginBanner = "PostAuthenticationLoginBanner"
        case preAuthenticationLoginBanner = "PreAuthenticationLoginBanner"
        case protocolDetails = "ProtocolDetails"
        case protocols = "Protocols"
        case s3StorageOptions = "S3StorageOptions"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
        case structuredLogDestinations = "StructuredLogDestinations"
        case workflowDetails = "WorkflowDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let protocolDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProtocolDetails.self, forKey: .protocolDetails)
        protocolDetails = protocolDetailsDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKey)
        hostKey = hostKeyDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let postAuthenticationLoginBannerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postAuthenticationLoginBanner)
        postAuthenticationLoginBanner = postAuthenticationLoginBannerDecoded
        let preAuthenticationLoginBannerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preAuthenticationLoginBanner)
        preAuthenticationLoginBanner = preAuthenticationLoginBannerDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[TransferClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [TransferClientTypes.ModelProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let workflowDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowDetails.self, forKey: .workflowDetails)
        workflowDetails = workflowDetailsDecoded
        let structuredLogDestinationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .structuredLogDestinations)
        var structuredLogDestinationsDecoded0:[Swift.String]? = nil
        if let structuredLogDestinationsContainer = structuredLogDestinationsContainer {
            structuredLogDestinationsDecoded0 = [Swift.String]()
            for string0 in structuredLogDestinationsContainer {
                if let string0 = string0 {
                    structuredLogDestinationsDecoded0?.append(string0)
                }
            }
        }
        structuredLogDestinations = structuredLogDestinationsDecoded0
        let s3StorageOptionsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.S3StorageOptions.self, forKey: .s3StorageOptions)
        s3StorageOptions = s3StorageOptionsDecoded
    }
}

extension UpdateServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServerOutputBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
        } else {
            self.serverId = nil
        }
    }
}

public struct UpdateServerOutput: Swift.Equatable {
    /// A system-assigned unique identifier for a server that the Transfer Family user is assigned to.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct UpdateServerOutputBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension UpdateServerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

enum UpdateServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymapentry0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymapentry0)
            }
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = self.posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension UpdateUserInput {

    static func urlPathProvider(_ value: UpdateUserInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory. The HomeDirectory parameter is only used if HomeDirectoryType is set to PATH.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock down your user to the designated home directory ("chroot"). To do this, you can set Entry to '/' and set Target to the HomeDirectory parameter value. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or Amazon EFS path as is in their file transfer protocol clients. If you set it to LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users. If HomeDirectoryType is LOGICAL, you must provide mappings, using the HomeDirectoryMappings parameter. If, on the other hand, HomeDirectoryType is PATH, you provide an absolute path using the HomeDirectory parameter. You cannot have both HomeDirectory and HomeDirectoryMappings in your template.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use session policies. For session policies, Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Creating a session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Amazon Web Services Security Token Service API Reference.
    public var policy: Swift.String?
    /// Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon Elastic File Systems (Amazon EFS). The POSIX permissions that are set on files and directories in your file system determines the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a Transfer Family server instance that the user is assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique string that identifies a user and is associated with a server as specified by the ServerId. This user name must be a minimum of 3 and a maximum of 100 characters long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen '-', period '.', and at sign '@'. The user name can't start with a hyphen, period, or at sign.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
        self.userName = userName
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let homeDirectory: Swift.String?
    let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    let policy: Swift.String?
    let posixProfile: TransferClientTypes.PosixProfile?
    let role: Swift.String?
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension UpdateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.userName = nil
        }
    }
}

/// UpdateUserResponse returns the user name and identifier for the request to update a user's properties.
public struct UpdateUserOutput: Swift.Equatable {
    /// A system-assigned unique identifier for a Transfer Family server instance that the account is assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// The unique identifier for a user that is assigned to a server instance that was specified in the request.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct UpdateUserOutputBody: Swift.Equatable {
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension UpdateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

enum UpdateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TransferClientTypes.UserDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sessionId = "SessionId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the user name, server ID, and session ID for a workflow.
    public struct UserDetails: Swift.Equatable {
        /// The system-assigned unique identifier for a Transfer server instance.
        /// This member is required.
        public var serverId: Swift.String?
        /// The system-assigned unique identifier for a session that corresponds to the workflow.
        public var sessionId: Swift.String?
        /// A unique string that identifies a Transfer Family user associated with a server.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            serverId: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.serverId = serverId
            self.sessionId = sessionId
            self.userName = userName
        }
    }

}

extension TransferClientTypes.WorkflowDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionRole = "ExecutionRole"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow. In addition to a workflow to execute when a file is uploaded completely, WorkflowDetails can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when the server session disconnects while the file is still being uploaded.
    public struct WorkflowDetail: Swift.Equatable {
        /// Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources
        /// This member is required.
        public var executionRole: Swift.String?
        /// A unique identifier for the workflow.
        /// This member is required.
        public var workflowId: Swift.String?

        public init(
            executionRole: Swift.String? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.executionRole = executionRole
            self.workflowId = workflowId
        }
    }

}

extension TransferClientTypes.WorkflowDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case onPartialUpload = "OnPartialUpload"
        case onUpload = "OnUpload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onPartialUpload = onPartialUpload {
            var onPartialUploadContainer = encodeContainer.nestedUnkeyedContainer(forKey: .onPartialUpload)
            for workflowdetail0 in onPartialUpload {
                try onPartialUploadContainer.encode(workflowdetail0)
            }
        }
        if let onUpload = onUpload {
            var onUploadContainer = encodeContainer.nestedUnkeyedContainer(forKey: .onUpload)
            for workflowdetail0 in onUpload {
                try onUploadContainer.encode(workflowdetail0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onUploadContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowDetail?].self, forKey: .onUpload)
        var onUploadDecoded0:[TransferClientTypes.WorkflowDetail]? = nil
        if let onUploadContainer = onUploadContainer {
            onUploadDecoded0 = [TransferClientTypes.WorkflowDetail]()
            for structure0 in onUploadContainer {
                if let structure0 = structure0 {
                    onUploadDecoded0?.append(structure0)
                }
            }
        }
        onUpload = onUploadDecoded0
        let onPartialUploadContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowDetail?].self, forKey: .onPartialUpload)
        var onPartialUploadDecoded0:[TransferClientTypes.WorkflowDetail]? = nil
        if let onPartialUploadContainer = onPartialUploadContainer {
            onPartialUploadDecoded0 = [TransferClientTypes.WorkflowDetail]()
            for structure0 in onPartialUploadContainer {
                if let structure0 = structure0 {
                    onPartialUploadDecoded0?.append(structure0)
                }
            }
        }
        onPartialUpload = onPartialUploadDecoded0
    }
}

extension TransferClientTypes {
    /// Container for the WorkflowDetail data type. It is used by actions that trigger a workflow to begin execution.
    public struct WorkflowDetails: Swift.Equatable {
        /// A trigger that starts a workflow if a file is only partially uploaded. You can attach a workflow to a server that executes whenever there is a partial upload. A partial upload occurs when a file is open when the session disconnects.
        public var onPartialUpload: [TransferClientTypes.WorkflowDetail]?
        /// A trigger that starts a workflow: the workflow begins to execute after a file is uploaded. To remove an associated workflow from a server, you can provide an empty OnUpload object, as in the following example. aws transfer update-server --server-id s-01234567890abcdef --workflow-details '{"OnUpload":[]}'
        public var onUpload: [TransferClientTypes.WorkflowDetail]?

        public init(
            onPartialUpload: [TransferClientTypes.WorkflowDetail]? = nil,
            onUpload: [TransferClientTypes.WorkflowDetail]? = nil
        )
        {
            self.onPartialUpload = onPartialUpload
            self.onUpload = onUpload
        }
    }

}

extension TransferClientTypes.WorkflowStep: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyStepDetails = "CopyStepDetails"
        case customStepDetails = "CustomStepDetails"
        case decryptStepDetails = "DecryptStepDetails"
        case deleteStepDetails = "DeleteStepDetails"
        case tagStepDetails = "TagStepDetails"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copyStepDetails = self.copyStepDetails {
            try encodeContainer.encode(copyStepDetails, forKey: .copyStepDetails)
        }
        if let customStepDetails = self.customStepDetails {
            try encodeContainer.encode(customStepDetails, forKey: .customStepDetails)
        }
        if let decryptStepDetails = self.decryptStepDetails {
            try encodeContainer.encode(decryptStepDetails, forKey: .decryptStepDetails)
        }
        if let deleteStepDetails = self.deleteStepDetails {
            try encodeContainer.encode(deleteStepDetails, forKey: .deleteStepDetails)
        }
        if let tagStepDetails = self.tagStepDetails {
            try encodeContainer.encode(tagStepDetails, forKey: .tagStepDetails)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowStepType.self, forKey: .type)
        type = typeDecoded
        let copyStepDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CopyStepDetails.self, forKey: .copyStepDetails)
        copyStepDetails = copyStepDetailsDecoded
        let customStepDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CustomStepDetails.self, forKey: .customStepDetails)
        customStepDetails = customStepDetailsDecoded
        let deleteStepDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DeleteStepDetails.self, forKey: .deleteStepDetails)
        deleteStepDetails = deleteStepDetailsDecoded
        let tagStepDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.TagStepDetails.self, forKey: .tagStepDetails)
        tagStepDetails = tagStepDetailsDecoded
        let decryptStepDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DecryptStepDetails.self, forKey: .decryptStepDetails)
        decryptStepDetails = decryptStepDetailsDecoded
    }
}

extension TransferClientTypes {
    /// The basic building block of a workflow.
    public struct WorkflowStep: Swift.Equatable {
        /// Details for a step that performs a file copy. Consists of the following values:
        ///
        /// * A description
        ///
        /// * An Amazon S3 location for the destination of the file copy.
        ///
        /// * A flag that indicates whether to overwrite an existing file of the same name. The default is FALSE.
        public var copyStepDetails: TransferClientTypes.CopyStepDetails?
        /// Details for a step that invokes an Lambda function. Consists of the Lambda function's name, target, and timeout (in seconds).
        public var customStepDetails: TransferClientTypes.CustomStepDetails?
        /// Details for a step that decrypts an encrypted file. Consists of the following values:
        ///
        /// * A descriptive name
        ///
        /// * An Amazon S3 or Amazon Elastic File System (Amazon EFS) location for the source file to decrypt.
        ///
        /// * An S3 or Amazon EFS location for the destination of the file decryption.
        ///
        /// * A flag that indicates whether to overwrite an existing file of the same name. The default is FALSE.
        ///
        /// * The type of encryption that's used. Currently, only PGP encryption is supported.
        public var decryptStepDetails: TransferClientTypes.DecryptStepDetails?
        /// Details for a step that deletes the file.
        public var deleteStepDetails: TransferClientTypes.DeleteStepDetails?
        /// Details for a step that creates one or more tags. You specify one or more tags. Each tag contains a key-value pair.
        public var tagStepDetails: TransferClientTypes.TagStepDetails?
        /// Currently, the following step types are supported.
        ///
        /// * COPY - Copy the file to another location.
        ///
        /// * CUSTOM - Perform a custom step with an Lambda function target.
        ///
        /// * DECRYPT - Decrypt a file that was encrypted before it was uploaded.
        ///
        /// * DELETE - Delete the file.
        ///
        /// * TAG - Add a tag to the file.
        public var type: TransferClientTypes.WorkflowStepType?

        public init(
            copyStepDetails: TransferClientTypes.CopyStepDetails? = nil,
            customStepDetails: TransferClientTypes.CustomStepDetails? = nil,
            decryptStepDetails: TransferClientTypes.DecryptStepDetails? = nil,
            deleteStepDetails: TransferClientTypes.DeleteStepDetails? = nil,
            tagStepDetails: TransferClientTypes.TagStepDetails? = nil,
            type: TransferClientTypes.WorkflowStepType? = nil
        )
        {
            self.copyStepDetails = copyStepDetails
            self.customStepDetails = customStepDetails
            self.decryptStepDetails = decryptStepDetails
            self.deleteStepDetails = deleteStepDetails
            self.tagStepDetails = tagStepDetails
            self.type = type
        }
    }

}

extension TransferClientTypes {
    public enum WorkflowStepType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case copy
        case custom
        case decrypt
        case delete
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStepType] {
            return [
                .copy,
                .custom,
                .decrypt,
                .delete,
                .tag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .copy: return "COPY"
            case .custom: return "CUSTOM"
            case .decrypt: return "DECRYPT"
            case .delete: return "DELETE"
            case .tag: return "TAG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowStepType(rawValue: rawValue) ?? WorkflowStepType.sdkUnknown(rawValue)
        }
    }
}
