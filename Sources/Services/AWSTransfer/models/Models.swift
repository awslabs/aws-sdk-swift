// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransferClientTypes {
    public enum AgreementStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AgreementStatusType] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgreementStatusType(rawValue: rawValue) ?? AgreementStatusType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.As2ConnectorConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compression = "Compression"
        case encryptionAlgorithm = "EncryptionAlgorithm"
        case localProfileId = "LocalProfileId"
        case mdnResponse = "MdnResponse"
        case mdnSigningAlgorithm = "MdnSigningAlgorithm"
        case messageSubject = "MessageSubject"
        case partnerProfileId = "PartnerProfileId"
        case signingAlgorithm = "SigningAlgorithm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compression = self.compression {
            try encodeContainer.encode(compression.rawValue, forKey: .compression)
        }
        if let encryptionAlgorithm = self.encryptionAlgorithm {
            try encodeContainer.encode(encryptionAlgorithm.rawValue, forKey: .encryptionAlgorithm)
        }
        if let localProfileId = self.localProfileId {
            try encodeContainer.encode(localProfileId, forKey: .localProfileId)
        }
        if let mdnResponse = self.mdnResponse {
            try encodeContainer.encode(mdnResponse.rawValue, forKey: .mdnResponse)
        }
        if let mdnSigningAlgorithm = self.mdnSigningAlgorithm {
            try encodeContainer.encode(mdnSigningAlgorithm.rawValue, forKey: .mdnSigningAlgorithm)
        }
        if let messageSubject = self.messageSubject {
            try encodeContainer.encode(messageSubject, forKey: .messageSubject)
        }
        if let partnerProfileId = self.partnerProfileId {
            try encodeContainer.encode(partnerProfileId, forKey: .partnerProfileId)
        }
        if let signingAlgorithm = self.signingAlgorithm {
            try encodeContainer.encode(signingAlgorithm.rawValue, forKey: .signingAlgorithm)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localProfileId)
        localProfileId = localProfileIdDecoded
        let partnerProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerProfileId)
        partnerProfileId = partnerProfileIdDecoded
        let messageSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageSubject)
        messageSubject = messageSubjectDecoded
        let compressionDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CompressionEnum.self, forKey: .compression)
        compression = compressionDecoded
        let encryptionAlgorithmDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EncryptionAlg.self, forKey: .encryptionAlgorithm)
        encryptionAlgorithm = encryptionAlgorithmDecoded
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(TransferClientTypes.SigningAlg.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
        let mdnSigningAlgorithmDecoded = try containerValues.decodeIfPresent(TransferClientTypes.MdnSigningAlg.self, forKey: .mdnSigningAlgorithm)
        mdnSigningAlgorithm = mdnSigningAlgorithmDecoded
        let mdnResponseDecoded = try containerValues.decodeIfPresent(TransferClientTypes.MdnResponse.self, forKey: .mdnResponse)
        mdnResponse = mdnResponseDecoded
    }
}

extension TransferClientTypes {
    /// Contains the details for a connector object. The connector object is used for AS2 outbound processes, to connect the Transfer Family customer with the trading partner.
    public struct As2ConnectorConfig: Swift.Equatable {
        /// Specifies whether the AS2 file is compressed.
        public var compression: TransferClientTypes.CompressionEnum?
        /// The algorithm that is used to encrypt the file. You can only specify NONE if the URL for your connector uses HTTPS. This ensures that no traffic is sent in clear text.
        public var encryptionAlgorithm: TransferClientTypes.EncryptionAlg?
        /// A unique identifier for the AS2 local profile.
        public var localProfileId: Swift.String?
        /// Used for outbound requests (from an Transfer Family server to a partner AS2 server) to determine whether the partner response for transfers is synchronous or asynchronous. Specify either of the following values:
        ///
        /// * SYNC: The system expects a synchronous MDN response, confirming that the file was transferred successfully (or not).
        ///
        /// * NONE: Specifies that no MDN response is required.
        public var mdnResponse: TransferClientTypes.MdnResponse?
        /// The signing algorithm for the MDN response. If set to DEFAULT (or not set at all), the value for SigningAlgorithm is used.
        public var mdnSigningAlgorithm: TransferClientTypes.MdnSigningAlg?
        /// Used as the Subject HTTP header attribute in AS2 messages that are being sent with the connector.
        public var messageSubject: Swift.String?
        /// A unique identifier for the partner profile for the connector.
        public var partnerProfileId: Swift.String?
        /// The algorithm that is used to sign the AS2 messages sent with the connector.
        public var signingAlgorithm: TransferClientTypes.SigningAlg?

        public init (
            compression: TransferClientTypes.CompressionEnum? = nil,
            encryptionAlgorithm: TransferClientTypes.EncryptionAlg? = nil,
            localProfileId: Swift.String? = nil,
            mdnResponse: TransferClientTypes.MdnResponse? = nil,
            mdnSigningAlgorithm: TransferClientTypes.MdnSigningAlg? = nil,
            messageSubject: Swift.String? = nil,
            partnerProfileId: Swift.String? = nil,
            signingAlgorithm: TransferClientTypes.SigningAlg? = nil
        )
        {
            self.compression = compression
            self.encryptionAlgorithm = encryptionAlgorithm
            self.localProfileId = localProfileId
            self.mdnResponse = mdnResponse
            self.mdnSigningAlgorithm = mdnSigningAlgorithm
            self.messageSubject = messageSubject
            self.partnerProfileId = partnerProfileId
            self.signingAlgorithm = signingAlgorithm
        }
    }

}

extension TransferClientTypes {
    public enum As2Transport: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [As2Transport] {
            return [
                .http,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = As2Transport(rawValue: rawValue) ?? As2Transport.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum CertificateStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case pendingRotation
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateStatusType] {
            return [
                .active,
                .inactive,
                .pendingRotation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .pendingRotation: return "PENDING_ROTATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateStatusType(rawValue: rawValue) ?? CertificateStatusType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum CertificateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case certificate
        case certificateWithPrivateKey
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateType] {
            return [
                .certificate,
                .certificateWithPrivateKey,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .certificate: return "CERTIFICATE"
            case .certificateWithPrivateKey: return "CERTIFICATE_WITH_PRIVATE_KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateType(rawValue: rawValue) ?? CertificateType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum CertificateUsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case encryption
        case signing
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateUsageType] {
            return [
                .encryption,
                .signing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .encryption: return "ENCRYPTION"
            case .signing: return "SIGNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateUsageType(rawValue: rawValue) ?? CertificateUsageType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum CompressionEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case zlib
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionEnum] {
            return [
                .disabled,
                .zlib,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .zlib: return "ZLIB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CompressionEnum(rawValue: rawValue) ?? CompressionEnum.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the UpdateServer is called for a file transfer protocol-enabled server that has VPC as the endpoint type and the server's VpcEndpointID is not in the available state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransferClientTypes.CopyStepDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationFileLocation = "DestinationFileLocation"
        case name = "Name"
        case overwriteExisting = "OverwriteExisting"
        case sourceFileLocation = "SourceFileLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationFileLocation = self.destinationFileLocation {
            try encodeContainer.encode(destinationFileLocation, forKey: .destinationFileLocation)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overwriteExisting = self.overwriteExisting {
            try encodeContainer.encode(overwriteExisting.rawValue, forKey: .overwriteExisting)
        }
        if let sourceFileLocation = self.sourceFileLocation {
            try encodeContainer.encode(sourceFileLocation, forKey: .sourceFileLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.InputFileLocation.self, forKey: .destinationFileLocation)
        destinationFileLocation = destinationFileLocationDecoded
        let overwriteExistingDecoded = try containerValues.decodeIfPresent(TransferClientTypes.OverwriteExisting.self, forKey: .overwriteExisting)
        overwriteExisting = overwriteExistingDecoded
        let sourceFileLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileLocation)
        sourceFileLocation = sourceFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure.
    public struct CopyStepDetails: Swift.Equatable {
        /// Specifies the location for the file being copied. Use ${Transfer:username} or ${Transfer:UploadDate} in this field to parametrize the destination prefix by username or uploaded date.
        ///
        /// * Set the value of DestinationFileLocation to ${Transfer:username} to copy uploaded files to an Amazon S3 bucket that is prefixed with the name of the Transfer Family user that uploaded the file.
        ///
        /// * Set the value of DestinationFileLocation to ${Transfer:UploadDate} to copy uploaded files to an Amazon S3 bucket that is prefixed with the date of the upload. The system resolves UploadDate to a date format of YYYY-MM-DD, based on the date the file is uploaded.
        public var destinationFileLocation: TransferClientTypes.InputFileLocation?
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// A flag that indicates whether to overwrite an existing file of the same name. The default is FALSE.
        public var overwriteExisting: TransferClientTypes.OverwriteExisting?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?

        public init (
            destinationFileLocation: TransferClientTypes.InputFileLocation? = nil,
            name: Swift.String? = nil,
            overwriteExisting: TransferClientTypes.OverwriteExisting? = nil,
            sourceFileLocation: Swift.String? = nil
        )
        {
            self.destinationFileLocation = destinationFileLocation
            self.name = name
            self.overwriteExisting = overwriteExisting
            self.sourceFileLocation = sourceFileLocation
        }
    }

}

extension CreateAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymapentry0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymapentry0)
            }
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = self.posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension CreateAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAccessInput: Swift.Equatable {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock down your user to the designated home directory ("chroot"). To do this, you can set Entry to / and set Target to the HomeDirectory parameter value. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use session policies. For session policies, Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Example session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Security Token Service API Reference.
    public var policy: Swift.String?
    /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    /// This member is required.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
    }
}

struct CreateAccessInputBody: Swift.Equatable {
    let homeDirectory: Swift.String?
    let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    let policy: Swift.String?
    let posixProfile: TransferClientTypes.PosixProfile?
    let role: Swift.String?
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension CreateAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension CreateAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.externalId = output.externalId
            self.serverId = output.serverId
        } else {
            self.externalId = nil
            self.serverId = nil
        }
    }
}

public struct CreateAccessOutputResponse: Swift.Equatable {
    /// The external identifier of the group whose users have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family.
    /// This member is required.
    public var externalId: Swift.String?
    /// The identifier of the server that the user is attached to.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct CreateAccessOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension CreateAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension CreateAgreementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case baseDirectory = "BaseDirectory"
        case description = "Description"
        case localProfileId = "LocalProfileId"
        case partnerProfileId = "PartnerProfileId"
        case serverId = "ServerId"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = self.accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let baseDirectory = self.baseDirectory {
            try encodeContainer.encode(baseDirectory, forKey: .baseDirectory)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let localProfileId = self.localProfileId {
            try encodeContainer.encode(localProfileId, forKey: .localProfileId)
        }
        if let partnerProfileId = self.partnerProfileId {
            try encodeContainer.encode(partnerProfileId, forKey: .partnerProfileId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAgreementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAgreementInput: Swift.Equatable {
    /// With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the file’s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer.
    /// This member is required.
    public var accessRole: Swift.String?
    /// The landing directory (folder) for files transferred by using the AS2 protocol. A BaseDirectory example is /DOC-EXAMPLE-BUCKET/home/mydirectory.
    /// This member is required.
    public var baseDirectory: Swift.String?
    /// A name or short description to identify the agreement.
    public var description: Swift.String?
    /// A unique identifier for the AS2 local profile.
    /// This member is required.
    public var localProfileId: Swift.String?
    /// A unique identifier for the partner profile used in the agreement.
    /// This member is required.
    public var partnerProfileId: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that the agreement uses.
    /// This member is required.
    public var serverId: Swift.String?
    /// The status of the agreement. The agreement can be either ACTIVE or INACTIVE.
    public var status: TransferClientTypes.AgreementStatusType?
    /// Key-value pairs that can be used to group and search for agreements.
    public var tags: [TransferClientTypes.Tag]?

    public init (
        accessRole: Swift.String? = nil,
        baseDirectory: Swift.String? = nil,
        description: Swift.String? = nil,
        localProfileId: Swift.String? = nil,
        partnerProfileId: Swift.String? = nil,
        serverId: Swift.String? = nil,
        status: TransferClientTypes.AgreementStatusType? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.accessRole = accessRole
        self.baseDirectory = baseDirectory
        self.description = description
        self.localProfileId = localProfileId
        self.partnerProfileId = partnerProfileId
        self.serverId = serverId
        self.status = status
        self.tags = tags
    }
}

struct CreateAgreementInputBody: Swift.Equatable {
    let description: Swift.String?
    let serverId: Swift.String?
    let localProfileId: Swift.String?
    let partnerProfileId: Swift.String?
    let baseDirectory: Swift.String?
    let accessRole: Swift.String?
    let status: TransferClientTypes.AgreementStatusType?
    let tags: [TransferClientTypes.Tag]?
}

extension CreateAgreementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case baseDirectory = "BaseDirectory"
        case description = "Description"
        case localProfileId = "LocalProfileId"
        case partnerProfileId = "PartnerProfileId"
        case serverId = "ServerId"
        case status = "Status"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let localProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localProfileId)
        localProfileId = localProfileIdDecoded
        let partnerProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerProfileId)
        partnerProfileId = partnerProfileIdDecoded
        let baseDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseDirectory)
        baseDirectory = baseDirectoryDecoded
        let accessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.AgreementStatusType.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAgreementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAgreementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAgreementOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAgreementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAgreementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agreementId = output.agreementId
        } else {
            self.agreementId = nil
        }
    }
}

public struct CreateAgreementOutputResponse: Swift.Equatable {
    /// The unique identifier for the agreement. Use this ID for deleting, or updating an agreement, as well as in any other API calls that require that you specify the agreement ID.
    /// This member is required.
    public var agreementId: Swift.String?

    public init (
        agreementId: Swift.String? = nil
    )
    {
        self.agreementId = agreementId
    }
}

struct CreateAgreementOutputResponseBody: Swift.Equatable {
    let agreementId: Swift.String?
}

extension CreateAgreementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId = "AgreementId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
    }
}

extension CreateConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case as2Config = "As2Config"
        case loggingRole = "LoggingRole"
        case tags = "Tags"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = self.accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let as2Config = self.as2Config {
            try encodeContainer.encode(as2Config, forKey: .as2Config)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }
}

extension CreateConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateConnectorInput: Swift.Equatable {
    /// With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the file’s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer.
    /// This member is required.
    public var accessRole: Swift.String?
    /// A structure that contains the parameters for a connector object.
    /// This member is required.
    public var as2Config: TransferClientTypes.As2ConnectorConfig?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a connector to turn on CloudWatch logging for Amazon S3 events. When set, you can view connector activity in your CloudWatch logs.
    public var loggingRole: Swift.String?
    /// Key-value pairs that can be used to group and search for connectors. Tags are metadata attached to connectors for any purpose.
    public var tags: [TransferClientTypes.Tag]?
    /// The URL of the partner's AS2 endpoint.
    /// This member is required.
    public var url: Swift.String?

    public init (
        accessRole: Swift.String? = nil,
        as2Config: TransferClientTypes.As2ConnectorConfig? = nil,
        loggingRole: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        url: Swift.String? = nil
    )
    {
        self.accessRole = accessRole
        self.as2Config = as2Config
        self.loggingRole = loggingRole
        self.tags = tags
        self.url = url
    }
}

struct CreateConnectorInputBody: Swift.Equatable {
    let url: Swift.String?
    let as2Config: TransferClientTypes.As2ConnectorConfig?
    let accessRole: Swift.String?
    let loggingRole: Swift.String?
    let tags: [TransferClientTypes.Tag]?
}

extension CreateConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case as2Config = "As2Config"
        case loggingRole = "LoggingRole"
        case tags = "Tags"
        case url = "Url"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let as2ConfigDecoded = try containerValues.decodeIfPresent(TransferClientTypes.As2ConnectorConfig.self, forKey: .as2Config)
        as2Config = as2ConfigDecoded
        let accessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateConnectorOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorId = output.connectorId
        } else {
            self.connectorId = nil
        }
    }
}

public struct CreateConnectorOutputResponse: Swift.Equatable {
    /// The unique identifier for the connector, returned after the API call succeeds.
    /// This member is required.
    public var connectorId: Swift.String?

    public init (
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

struct CreateConnectorOutputResponseBody: Swift.Equatable {
    let connectorId: Swift.String?
}

extension CreateConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
    }
}

extension CreateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case as2Id = "As2Id"
        case certificateIds = "CertificateIds"
        case profileType = "ProfileType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let as2Id = self.as2Id {
            try encodeContainer.encode(as2Id, forKey: .as2Id)
        }
        if let certificateIds = certificateIds {
            var certificateIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateIds)
            for certificateid0 in certificateIds {
                try certificateIdsContainer.encode(certificateid0)
            }
        }
        if let profileType = self.profileType {
            try encodeContainer.encode(profileType.rawValue, forKey: .profileType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProfileInput: Swift.Equatable {
    /// The As2Id is the AS2-name, as defined in the [RFC 4130](https://datatracker.ietf.org/doc/html/rfc4130). For inbound transfers, this is the AS2-From header for the AS2 messages sent from the partner. For outbound connectors, this is the AS2-To header for the AS2 messages sent to the partner using the StartFileTransfer API operation. This ID cannot include spaces.
    /// This member is required.
    public var as2Id: Swift.String?
    /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
    public var certificateIds: [Swift.String]?
    /// Determines the type of profile to create:
    ///
    /// * Specify LOCAL to create a local profile. A local profile represents the AS2-enabled Transfer Family server organization or party.
    ///
    /// * Specify PARTNER to create a partner profile. A partner profile represents a remote organization, external to Transfer Family.
    /// This member is required.
    public var profileType: TransferClientTypes.ProfileType?
    /// Key-value pairs that can be used to group and search for AS2 profiles.
    public var tags: [TransferClientTypes.Tag]?

    public init (
        as2Id: Swift.String? = nil,
        certificateIds: [Swift.String]? = nil,
        profileType: TransferClientTypes.ProfileType? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.as2Id = as2Id
        self.certificateIds = certificateIds
        self.profileType = profileType
        self.tags = tags
    }
}

struct CreateProfileInputBody: Swift.Equatable {
    let as2Id: Swift.String?
    let profileType: TransferClientTypes.ProfileType?
    let certificateIds: [Swift.String]?
    let tags: [TransferClientTypes.Tag]?
}

extension CreateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case as2Id = "As2Id"
        case certificateIds = "CertificateIds"
        case profileType = "ProfileType"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let as2IdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .as2Id)
        as2Id = as2IdDecoded
        let profileTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProfileType.self, forKey: .profileType)
        profileType = profileTypeDecoded
        let certificateIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .certificateIds)
        var certificateIdsDecoded0:[Swift.String]? = nil
        if let certificateIdsContainer = certificateIdsContainer {
            certificateIdsDecoded0 = [Swift.String]()
            for string0 in certificateIdsContainer {
                if let string0 = string0 {
                    certificateIdsDecoded0?.append(string0)
                }
            }
        }
        certificateIds = certificateIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateProfileOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.profileId = output.profileId
        } else {
            self.profileId = nil
        }
    }
}

public struct CreateProfileOutputResponse: Swift.Equatable {
    /// The unique identifier for the AS2 profile, returned after the API call succeeds.
    /// This member is required.
    public var profileId: Swift.String?

    public init (
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct CreateProfileOutputResponseBody: Swift.Equatable {
    let profileId: Swift.String?
}

extension CreateProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

extension CreateServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServerInput(certificate: \(Swift.String(describing: certificate)), domain: \(Swift.String(describing: domain)), endpointDetails: \(Swift.String(describing: endpointDetails)), endpointType: \(Swift.String(describing: endpointType)), identityProviderDetails: \(Swift.String(describing: identityProviderDetails)), identityProviderType: \(Swift.String(describing: identityProviderType)), loggingRole: \(Swift.String(describing: loggingRole)), postAuthenticationLoginBanner: \(Swift.String(describing: postAuthenticationLoginBanner)), preAuthenticationLoginBanner: \(Swift.String(describing: preAuthenticationLoginBanner)), protocolDetails: \(Swift.String(describing: protocolDetails)), protocols: \(Swift.String(describing: protocols)), securityPolicyName: \(Swift.String(describing: securityPolicyName)), tags: \(Swift.String(describing: tags)), workflowDetails: \(Swift.String(describing: workflowDetails)), hostKey: \"CONTENT_REDACTED\")"}
}

extension CreateServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case postAuthenticationLoginBanner = "PostAuthenticationLoginBanner"
        case preAuthenticationLoginBanner = "PreAuthenticationLoginBanner"
        case protocolDetails = "ProtocolDetails"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case tags = "Tags"
        case workflowDetails = "WorkflowDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointDetails = self.endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKey = self.hostKey {
            try encodeContainer.encode(hostKey, forKey: .hostKey)
        }
        if let identityProviderDetails = self.identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let postAuthenticationLoginBanner = self.postAuthenticationLoginBanner {
            try encodeContainer.encode(postAuthenticationLoginBanner, forKey: .postAuthenticationLoginBanner)
        }
        if let preAuthenticationLoginBanner = self.preAuthenticationLoginBanner {
            try encodeContainer.encode(preAuthenticationLoginBanner, forKey: .preAuthenticationLoginBanner)
        }
        if let protocolDetails = self.protocolDetails {
            try encodeContainer.encode(protocolDetails, forKey: .protocolDetails)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocol0 in protocols {
                try protocolsContainer.encode(protocol0.rawValue)
            }
        }
        if let securityPolicyName = self.securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let workflowDetails = self.workflowDetails {
            try encodeContainer.encode(workflowDetails, forKey: .workflowDetails)
        }
    }
}

extension CreateServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Certificate Manager (ACM) certificate. Required when Protocols is set to FTPS. To request a new public certificate, see [Request a public certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html) in the Certificate Manager User Guide. To import an existing certificate into ACM, see [Importing certificates into ACM](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the Certificate Manager User Guide. To request a private certificate to use FTPS through private IP addresses, see [Request a private certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html) in the Certificate Manager User Guide. Certificates with the following cryptographic algorithms and key sizes are supported:
    ///
    /// * 2048-bit RSA (RSA_2048)
    ///
    /// * 4096-bit RSA (RSA_4096)
    ///
    /// * Elliptic Prime Curve 256 bit (EC_prime256v1)
    ///
    /// * Elliptic Prime Curve 384 bit (EC_secp384r1)
    ///
    /// * Elliptic Prime Curve 521 bit (EC_secp521r1)
    ///
    ///
    /// The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP address specified and information about the issuer.
    public var certificate: Swift.String?
    /// The domain of the storage system that is used for file transfers. There are two domains available: Amazon Simple Storage Service (Amazon S3) and Amazon Elastic File System (Amazon EFS). The default value is S3. After the server is created, the domain cannot be changed.
    public var domain: TransferClientTypes.Domain?
    /// The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make your endpoint accessible only to resources within your VPC, or you can attach Elastic IP addresses and make your endpoint accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.
    public var endpointDetails: TransferClientTypes.EndpointDetails?
    /// The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC) or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it. After May 19, 2021, you won't be able to create a server using EndpointType=VPC_ENDPOINT in your Amazon Web Services account if your account hasn't already done so before May 19, 2021. If you have already created servers with EndpointType=VPC_ENDPOINT in your Amazon Web Services account on or before May 19, 2021, you will not be affected. After this date, use EndpointType=VPC. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint. It is recommended that you use VPC as the EndpointType. With this endpoint type, you have the option to directly associate up to three Elastic IPv4 addresses (BYO IP included) with your server's endpoint and use VPC security groups to restrict traffic by the client's public IP address. This is not possible with EndpointType set to VPC_ENDPOINT.
    public var endpointType: TransferClientTypes.EndpointType?
    /// The RSA, ECDSA, or ED25519 private key to use for your SFTP-enabled server. You can add multiple host keys, in case you want to rotate keys, or have a set of active keys that use different algorithms. Use the following command to generate an RSA 2048 bit key with no passphrase: ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key. Use a minimum value of 2048 for the -b option. You can create a stronger key by using 3072 or 4096. Use the following command to generate an ECDSA 256 bit key with no passphrase: ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key. Valid values for the -b option for ECDSA are 256, 384, and 521. Use the following command to generate an ED25519 key with no passphrase: ssh-keygen -t ed25519 -N "" -f my-new-server-key. For all of these commands, you can replace my-new-server-key with a string of your choice. If you aren't planning to migrate existing users from an existing SFTP-enabled server to a new server, don't update the host key. Accidentally changing a server's host key can be disruptive. For more information, see [Manage host keys for your SFTP-enabled server](https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key) in the Transfer Family User Guide.
    public var hostKey: Swift.String?
    /// Required when IdentityProviderType is set to AWS_DIRECTORY_SERVICE or API_GATEWAY. Accepts an array containing all of the information required to use a directory in AWS_DIRECTORY_SERVICE or invoke a customer-supplied authentication API, including the API Gateway URL. Not required when IdentityProviderType is set to SERVICE_MANAGED.
    public var identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    /// The mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Transfer Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the IdentityProviderDetails parameter. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the IdentityProviderDetails parameter. Use the AWS_LAMBDA value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the Function parameter or the IdentityProviderDetails data type.
    public var identityProviderType: TransferClientTypes.IdentityProviderType?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
    public var loggingRole: Swift.String?
    /// Specifies a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
    public var postAuthenticationLoginBanner: Swift.String?
    /// Specifies a string to display when users connect to a server. This string is displayed before the user authenticates. For example, the following banner displays details about using the system: This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel.
    public var preAuthenticationLoginBanner: Swift.String?
    /// The protocol settings that are configured for your server.
    ///
    /// * To indicate passive mode (for FTP and FTPS protocols), use the PassiveIp parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
    ///
    /// * To ignore the error that is generated when the client attempts to use the SETSTAT command on a file that you are uploading to an Amazon S3 bucket, use the SetStatOption parameter. To have the Transfer Family server ignore the SETSTAT command and upload files without needing to make any changes to your SFTP client, set the value to ENABLE_NO_OP. If you set the SetStatOption parameter to ENABLE_NO_OP, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a SETSTAT call.
    ///
    /// * To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the TlsSessionResumptionMode parameter.
    ///
    /// * As2Transports indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
    public var protocolDetails: TransferClientTypes.ProtocolDetails?
    /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:
    ///
    /// * SFTP (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH
    ///
    /// * FTPS (File Transfer Protocol Secure): File transfer with TLS encryption
    ///
    /// * FTP (File Transfer Protocol): Unencrypted file transfer
    ///
    /// * AS2 (Applicability Statement 2): used for transporting structured business-to-business data
    ///
    ///
    ///
    ///
    /// * If you select FTPS, you must choose a certificate stored in Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS.
    ///
    /// * If Protocol includes either FTP or FTPS, then the EndpointType must be VPC and the IdentityProviderType must be either AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
    ///
    /// * If Protocol includes FTP, then AddressAllocationIds cannot be associated.
    ///
    /// * If Protocol is set only to SFTP, the EndpointType can be set to PUBLIC and the IdentityProviderType can be set any of the supported identity types: SERVICE_MANAGED, AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
    ///
    /// * If Protocol includes AS2, then the EndpointType must be VPC, and domain must be Amazon S3.
    public var protocols: [TransferClientTypes.ModelProtocol]?
    /// Specifies the name of the security policy that is attached to the server.
    public var securityPolicyName: Swift.String?
    /// Key-value pairs that can be used to group and search for servers.
    public var tags: [TransferClientTypes.Tag]?
    /// Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow. In addition to a workflow to execute when a file is uploaded completely, WorkflowDetails can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when a file is open when the session disconnects.
    public var workflowDetails: TransferClientTypes.WorkflowDetails?

    public init (
        certificate: Swift.String? = nil,
        domain: TransferClientTypes.Domain? = nil,
        endpointDetails: TransferClientTypes.EndpointDetails? = nil,
        endpointType: TransferClientTypes.EndpointType? = nil,
        hostKey: Swift.String? = nil,
        identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
        identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
        loggingRole: Swift.String? = nil,
        postAuthenticationLoginBanner: Swift.String? = nil,
        preAuthenticationLoginBanner: Swift.String? = nil,
        protocolDetails: TransferClientTypes.ProtocolDetails? = nil,
        protocols: [TransferClientTypes.ModelProtocol]? = nil,
        securityPolicyName: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        workflowDetails: TransferClientTypes.WorkflowDetails? = nil
    )
    {
        self.certificate = certificate
        self.domain = domain
        self.endpointDetails = endpointDetails
        self.endpointType = endpointType
        self.hostKey = hostKey
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderType = identityProviderType
        self.loggingRole = loggingRole
        self.postAuthenticationLoginBanner = postAuthenticationLoginBanner
        self.preAuthenticationLoginBanner = preAuthenticationLoginBanner
        self.protocolDetails = protocolDetails
        self.protocols = protocols
        self.securityPolicyName = securityPolicyName
        self.tags = tags
        self.workflowDetails = workflowDetails
    }
}

struct CreateServerInputBody: Swift.Equatable {
    let certificate: Swift.String?
    let domain: TransferClientTypes.Domain?
    let endpointDetails: TransferClientTypes.EndpointDetails?
    let endpointType: TransferClientTypes.EndpointType?
    let hostKey: Swift.String?
    let identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    let identityProviderType: TransferClientTypes.IdentityProviderType?
    let loggingRole: Swift.String?
    let postAuthenticationLoginBanner: Swift.String?
    let preAuthenticationLoginBanner: Swift.String?
    let protocols: [TransferClientTypes.ModelProtocol]?
    let protocolDetails: TransferClientTypes.ProtocolDetails?
    let securityPolicyName: Swift.String?
    let tags: [TransferClientTypes.Tag]?
    let workflowDetails: TransferClientTypes.WorkflowDetails?
}

extension CreateServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case postAuthenticationLoginBanner = "PostAuthenticationLoginBanner"
        case preAuthenticationLoginBanner = "PreAuthenticationLoginBanner"
        case protocolDetails = "ProtocolDetails"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case tags = "Tags"
        case workflowDetails = "WorkflowDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let domainDecoded = try containerValues.decodeIfPresent(TransferClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKey)
        hostKey = hostKeyDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let postAuthenticationLoginBannerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postAuthenticationLoginBanner)
        postAuthenticationLoginBanner = postAuthenticationLoginBannerDecoded
        let preAuthenticationLoginBannerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preAuthenticationLoginBanner)
        preAuthenticationLoginBanner = preAuthenticationLoginBannerDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[TransferClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [TransferClientTypes.ModelProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
        let protocolDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProtocolDetails.self, forKey: .protocolDetails)
        protocolDetails = protocolDetailsDecoded
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let workflowDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowDetails.self, forKey: .workflowDetails)
        workflowDetails = workflowDetailsDecoded
    }
}

extension CreateServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateServerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
        } else {
            self.serverId = nil
        }
    }
}

public struct CreateServerOutputResponse: Swift.Equatable {
    /// The service-assigned identifier of the server that is created.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct CreateServerOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension CreateServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymapentry0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymapentry0)
            }
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = self.posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyBody = self.sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock your user down to the designated home directory ("chroot"). To do this, you can set Entry to / and set Target to the HomeDirectory parameter value. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use session policies. For session policies, Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Example session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Amazon Web Services Security Token Service API Reference.
    public var policy: Swift.String?
    /// Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in Amazon EFS determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    /// This member is required.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.
    /// This member is required.
    public var serverId: Swift.String?
    /// The public portion of the Secure Shell (SSH) key used to authenticate the user to the server. The three standard SSH public key format elements are , , and an optional , with spaces between each element. Transfer Family accepts RSA, ECDSA, and ED25519 keys.
    ///
    /// * For RSA keys, the key type is ssh-rsa.
    ///
    /// * For ED25519 keys, the key type is ssh-ed25519.
    ///
    /// * For ECDSA keys, the key type is either ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, or ecdsa-sha2-nistp521, depending on the size of the key you generated.
    public var sshPublicKeyBody: Swift.String?
    /// Key-value pairs that can be used to group and search for users. Tags are metadata attached to users for any purpose.
    public var tags: [TransferClientTypes.Tag]?
    /// A unique string that identifies a user and is associated with a ServerId. This user name must be a minimum of 3 and a maximum of 100 characters long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen '-', period '.', and at sign '@'. The user name can't start with a hyphen, period, or at sign.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil,
        sshPublicKeyBody: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
        self.sshPublicKeyBody = sshPublicKeyBody
        self.tags = tags
        self.userName = userName
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let homeDirectory: Swift.String?
    let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    let policy: Swift.String?
    let posixProfile: TransferClientTypes.PosixProfile?
    let role: Swift.String?
    let serverId: Swift.String?
    let sshPublicKeyBody: Swift.String?
    let tags: [TransferClientTypes.Tag]?
    let userName: Swift.String?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case tags = "Tags"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.userName = nil
        }
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {
    /// The identifier of the server that the user is attached to.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique string that identifies a user account associated with a server.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct CreateUserOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension CreateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension CreateWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case onExceptionSteps = "OnExceptionSteps"
        case steps = "Steps"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let onExceptionSteps = onExceptionSteps {
            var onExceptionStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .onExceptionSteps)
            for workflowstep0 in onExceptionSteps {
                try onExceptionStepsContainer.encode(workflowstep0)
            }
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for workflowstep0 in steps {
                try stepsContainer.encode(workflowstep0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkflowInput: Swift.Equatable {
    /// A textual description for the workflow.
    public var description: Swift.String?
    /// Specifies the steps (actions) to take if errors are encountered during execution of the workflow. For custom steps, the lambda function needs to send FAILURE to the call back API to kick off the exception steps. Additionally, if the lambda does not send SUCCESS before it times out, the exception steps are executed.
    public var onExceptionSteps: [TransferClientTypes.WorkflowStep]?
    /// Specifies the details for the steps that are in the specified workflow. The TYPE specifies which of the following actions is being taken for this step.
    ///
    /// * COPY - Copy the file to another location.
    ///
    /// * CUSTOM - Perform a custom step with an Lambda function target.
    ///
    /// * DECRYPT - Decrypt a file that was encrypted before it was uploaded.
    ///
    /// * DELETE - Delete the file.
    ///
    /// * TAG - Add a tag to the file.
    ///
    ///
    /// Currently, copying and tagging are supported only on S3. For file location, you specify either the Amazon S3 bucket and key, or the Amazon EFS file system ID and path.
    /// This member is required.
    public var steps: [TransferClientTypes.WorkflowStep]?
    /// Key-value pairs that can be used to group and search for workflows. Tags are metadata attached to workflows for any purpose.
    public var tags: [TransferClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        onExceptionSteps: [TransferClientTypes.WorkflowStep]? = nil,
        steps: [TransferClientTypes.WorkflowStep]? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.onExceptionSteps = onExceptionSteps
        self.steps = steps
        self.tags = tags
    }
}

struct CreateWorkflowInputBody: Swift.Equatable {
    let description: Swift.String?
    let steps: [TransferClientTypes.WorkflowStep]?
    let onExceptionSteps: [TransferClientTypes.WorkflowStep]?
    let tags: [TransferClientTypes.Tag]?
}

extension CreateWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case onExceptionSteps = "OnExceptionSteps"
        case steps = "Steps"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowStep?].self, forKey: .steps)
        var stepsDecoded0:[TransferClientTypes.WorkflowStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [TransferClientTypes.WorkflowStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let onExceptionStepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowStep?].self, forKey: .onExceptionSteps)
        var onExceptionStepsDecoded0:[TransferClientTypes.WorkflowStep]? = nil
        if let onExceptionStepsContainer = onExceptionStepsContainer {
            onExceptionStepsDecoded0 = [TransferClientTypes.WorkflowStep]()
            for structure0 in onExceptionStepsContainer {
                if let structure0 = structure0 {
                    onExceptionStepsDecoded0?.append(structure0)
                }
            }
        }
        onExceptionSteps = onExceptionStepsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorkflowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workflowId = output.workflowId
        } else {
            self.workflowId = nil
        }
    }
}

public struct CreateWorkflowOutputResponse: Swift.Equatable {
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        workflowId: Swift.String? = nil
    )
    {
        self.workflowId = workflowId
    }
}

struct CreateWorkflowOutputResponseBody: Swift.Equatable {
    let workflowId: Swift.String?
}

extension CreateWorkflowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

extension TransferClientTypes.CustomStepDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sourceFileLocation = "SourceFileLocation"
        case target = "Target"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceFileLocation = self.sourceFileLocation {
            try encodeContainer.encode(sourceFileLocation, forKey: .sourceFileLocation)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let timeoutSeconds = self.timeoutSeconds {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let sourceFileLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileLocation)
        sourceFileLocation = sourceFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure.
    public struct CustomStepDetails: Swift.Equatable {
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?
        /// The ARN for the lambda function that is being called.
        public var target: Swift.String?
        /// Timeout, in seconds, for the step.
        public var timeoutSeconds: Swift.Int?

        public init (
            name: Swift.String? = nil,
            sourceFileLocation: Swift.String? = nil,
            target: Swift.String? = nil,
            timeoutSeconds: Swift.Int? = nil
        )
        {
            self.name = name
            self.sourceFileLocation = sourceFileLocation
            self.target = target
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension TransferClientTypes {
    public enum CustomStepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failure
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomStepStatus] {
            return [
                .failure,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failure: return "FAILURE"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomStepStatus(rawValue: rawValue) ?? CustomStepStatus.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.DecryptStepDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationFileLocation = "DestinationFileLocation"
        case name = "Name"
        case overwriteExisting = "OverwriteExisting"
        case sourceFileLocation = "SourceFileLocation"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationFileLocation = self.destinationFileLocation {
            try encodeContainer.encode(destinationFileLocation, forKey: .destinationFileLocation)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overwriteExisting = self.overwriteExisting {
            try encodeContainer.encode(overwriteExisting.rawValue, forKey: .overwriteExisting)
        }
        if let sourceFileLocation = self.sourceFileLocation {
            try encodeContainer.encode(sourceFileLocation, forKey: .sourceFileLocation)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EncryptionType.self, forKey: .type)
        type = typeDecoded
        let sourceFileLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileLocation)
        sourceFileLocation = sourceFileLocationDecoded
        let overwriteExistingDecoded = try containerValues.decodeIfPresent(TransferClientTypes.OverwriteExisting.self, forKey: .overwriteExisting)
        overwriteExisting = overwriteExistingDecoded
        let destinationFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.InputFileLocation.self, forKey: .destinationFileLocation)
        destinationFileLocation = destinationFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure.
    public struct DecryptStepDetails: Swift.Equatable {
        /// Specifies the location for the file that's being processed.
        /// This member is required.
        public var destinationFileLocation: TransferClientTypes.InputFileLocation?
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// A flag that indicates whether to overwrite an existing file of the same name. The default is FALSE.
        public var overwriteExisting: TransferClientTypes.OverwriteExisting?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?
        /// The type of encryption used. Currently, this value must be PGP.
        /// This member is required.
        public var type: TransferClientTypes.EncryptionType?

        public init (
            destinationFileLocation: TransferClientTypes.InputFileLocation? = nil,
            name: Swift.String? = nil,
            overwriteExisting: TransferClientTypes.OverwriteExisting? = nil,
            sourceFileLocation: Swift.String? = nil,
            type: TransferClientTypes.EncryptionType? = nil
        )
        {
            self.destinationFileLocation = destinationFileLocation
            self.name = name
            self.overwriteExisting = overwriteExisting
            self.sourceFileLocation = sourceFileLocation
            self.type = type
        }
    }

}

extension DeleteAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DeleteAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAccessInput: Swift.Equatable {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// A system-assigned unique identifier for a server that has this user assigned.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct DeleteAccessInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension DeleteAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension DeleteAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAgreementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId = "AgreementId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agreementId = self.agreementId {
            try encodeContainer.encode(agreementId, forKey: .agreementId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DeleteAgreementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAgreementInput: Swift.Equatable {
    /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
    /// This member is required.
    public var agreementId: Swift.String?
    /// The server identifier associated with the agreement that you are deleting.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        agreementId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.agreementId = agreementId
        self.serverId = serverId
    }
}

struct DeleteAgreementInputBody: Swift.Equatable {
    let agreementId: Swift.String?
    let serverId: Swift.String?
}

extension DeleteAgreementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId = "AgreementId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension DeleteAgreementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAgreementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAgreementOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAgreementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAgreementOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
    }
}

extension DeleteCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCertificateInput: Swift.Equatable {
    /// The identifier of the certificate object that you are deleting.
    /// This member is required.
    public var certificateId: Swift.String?

    public init (
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct DeleteCertificateInputBody: Swift.Equatable {
    let certificateId: Swift.String?
}

extension DeleteCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

extension DeleteCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCertificateOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCertificateOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
    }
}

extension DeleteConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConnectorInput: Swift.Equatable {
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?

    public init (
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

struct DeleteConnectorInputBody: Swift.Equatable {
    let connectorId: Swift.String?
}

extension DeleteConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
    }
}

extension DeleteConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConnectorOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConnectorOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteHostKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostKeyId = self.hostKeyId {
            try encodeContainer.encode(hostKeyId, forKey: .hostKeyId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DeleteHostKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteHostKeyInput: Swift.Equatable {
    /// The identifier of the host key that you are deleting.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// The identifier of the server that contains the host key that you are deleting.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

struct DeleteHostKeyInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let hostKeyId: Swift.String?
}

extension DeleteHostKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let hostKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyId)
        hostKeyId = hostKeyIdDecoded
    }
}

extension DeleteHostKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHostKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteHostKeyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHostKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHostKeyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
    }
}

extension DeleteProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProfileInput: Swift.Equatable {
    /// The identifier of the profile that you are deleting.
    /// This member is required.
    public var profileId: Swift.String?

    public init (
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct DeleteProfileInputBody: Swift.Equatable {
    let profileId: Swift.String?
}

extension DeleteProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

extension DeleteProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteProfileOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProfileOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DeleteServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServerInput: Swift.Equatable {
    /// A unique system-assigned identifier for a server instance.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct DeleteServerInputBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension DeleteServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension DeleteServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteServerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServerOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSshPublicKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyId = self.sshPublicKeyId {
            try encodeContainer.encode(sshPublicKeyId, forKey: .sshPublicKeyId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DeleteSshPublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSshPublicKeyInput: Swift.Equatable {
    /// A system-assigned unique identifier for a file transfer protocol-enabled server instance that has the user assigned to it.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique identifier used to reference your user's specific SSH key.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// A unique string that identifies a user whose public key is being deleted.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

struct DeleteSshPublicKeyInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let sshPublicKeyId: Swift.String?
    let userName: Swift.String?
}

extension DeleteSshPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteSshPublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSshPublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSshPublicKeyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSshPublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSshPublicKeyOutputResponse: Swift.Equatable {

    public init () { }
}

extension TransferClientTypes.DeleteStepDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sourceFileLocation = "SourceFileLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceFileLocation = self.sourceFileLocation {
            try encodeContainer.encode(sourceFileLocation, forKey: .sourceFileLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceFileLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileLocation)
        sourceFileLocation = sourceFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// The name of the step, used to identify the delete step.
    public struct DeleteStepDetails: Swift.Equatable {
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?

        public init (
            name: Swift.String? = nil,
            sourceFileLocation: Swift.String? = nil
        )
        {
            self.name = name
            self.sourceFileLocation = sourceFileLocation
        }
    }

}

extension DeleteUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server instance that has the user assigned to it.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique string that identifies a user that is being deleted from a server.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension DeleteWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWorkflowInput: Swift.Equatable {
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        workflowId: Swift.String? = nil
    )
    {
        self.workflowId = workflowId
    }
}

struct DeleteWorkflowInputBody: Swift.Equatable {
    let workflowId: Swift.String?
}

extension DeleteWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

extension DeleteWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWorkflowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkflowOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DescribeAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccessInput: Swift.Equatable {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// A system-assigned unique identifier for a server that has this access assigned.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct DescribeAccessInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension DescribeAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension DescribeAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.access = output.access
            self.serverId = output.serverId
        } else {
            self.access = nil
            self.serverId = nil
        }
    }
}

public struct DescribeAccessOutputResponse: Swift.Equatable {
    /// The external identifier of the server that the access is attached to.
    /// This member is required.
    public var access: TransferClientTypes.DescribedAccess?
    /// A system-assigned unique identifier for a server that has this access assigned.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        access: TransferClientTypes.DescribedAccess? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.access = access
        self.serverId = serverId
    }
}

struct DescribeAccessOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let access: TransferClientTypes.DescribedAccess?
}

extension DescribeAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case access = "Access"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let accessDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedAccess.self, forKey: .access)
        access = accessDecoded
    }
}

extension DescribeAgreementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId = "AgreementId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agreementId = self.agreementId {
            try encodeContainer.encode(agreementId, forKey: .agreementId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DescribeAgreementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAgreementInput: Swift.Equatable {
    /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
    /// This member is required.
    public var agreementId: Swift.String?
    /// The server identifier that's associated with the agreement.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        agreementId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.agreementId = agreementId
        self.serverId = serverId
    }
}

struct DescribeAgreementInputBody: Swift.Equatable {
    let agreementId: Swift.String?
    let serverId: Swift.String?
}

extension DescribeAgreementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId = "AgreementId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension DescribeAgreementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAgreementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAgreementOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAgreementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAgreementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agreement = output.agreement
        } else {
            self.agreement = nil
        }
    }
}

public struct DescribeAgreementOutputResponse: Swift.Equatable {
    /// The details for the specified agreement, returned as a DescribedAgreement object.
    /// This member is required.
    public var agreement: TransferClientTypes.DescribedAgreement?

    public init (
        agreement: TransferClientTypes.DescribedAgreement? = nil
    )
    {
        self.agreement = agreement
    }
}

struct DescribeAgreementOutputResponseBody: Swift.Equatable {
    let agreement: TransferClientTypes.DescribedAgreement?
}

extension DescribeAgreementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreement = "Agreement"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedAgreement.self, forKey: .agreement)
        agreement = agreementDecoded
    }
}

extension DescribeCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
    }
}

extension DescribeCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCertificateInput: Swift.Equatable {
    /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
    /// This member is required.
    public var certificateId: Swift.String?

    public init (
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct DescribeCertificateInputBody: Swift.Equatable {
    let certificateId: Swift.String?
}

extension DescribeCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

extension DescribeCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeCertificateOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct DescribeCertificateOutputResponse: Swift.Equatable {
    /// The details for the specified certificate, returned as an object.
    /// This member is required.
    public var certificate: TransferClientTypes.DescribedCertificate?

    public init (
        certificate: TransferClientTypes.DescribedCertificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct DescribeCertificateOutputResponseBody: Swift.Equatable {
    let certificate: TransferClientTypes.DescribedCertificate?
}

extension DescribeCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedCertificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension DescribeConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
    }
}

extension DescribeConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConnectorInput: Swift.Equatable {
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?

    public init (
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

struct DescribeConnectorInputBody: Swift.Equatable {
    let connectorId: Swift.String?
}

extension DescribeConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
    }
}

extension DescribeConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConnectorOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connector = output.connector
        } else {
            self.connector = nil
        }
    }
}

public struct DescribeConnectorOutputResponse: Swift.Equatable {
    /// The structure that contains the details of the connector.
    /// This member is required.
    public var connector: TransferClientTypes.DescribedConnector?

    public init (
        connector: TransferClientTypes.DescribedConnector? = nil
    )
    {
        self.connector = connector
    }
}

struct DescribeConnectorOutputResponseBody: Swift.Equatable {
    let connector: TransferClientTypes.DescribedConnector?
}

extension DescribeConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connector = "Connector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedConnector.self, forKey: .connector)
        connector = connectorDecoded
    }
}

extension DescribeExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension DescribeExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExecutionInput: Swift.Equatable {
    /// A unique identifier for the execution of a workflow.
    /// This member is required.
    public var executionId: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        executionId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.executionId = executionId
        self.workflowId = workflowId
    }
}

struct DescribeExecutionInputBody: Swift.Equatable {
    let executionId: Swift.String?
    let workflowId: Swift.String?
}

extension DescribeExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

extension DescribeExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeExecutionOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.execution = output.execution
            self.workflowId = output.workflowId
        } else {
            self.execution = nil
            self.workflowId = nil
        }
    }
}

public struct DescribeExecutionOutputResponse: Swift.Equatable {
    /// The structure that contains the details of the workflow' execution.
    /// This member is required.
    public var execution: TransferClientTypes.DescribedExecution?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        execution: TransferClientTypes.DescribedExecution? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.execution = execution
        self.workflowId = workflowId
    }
}

struct DescribeExecutionOutputResponseBody: Swift.Equatable {
    let workflowId: Swift.String?
    let execution: TransferClientTypes.DescribedExecution?
}

extension DescribeExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case execution = "Execution"
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let executionDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedExecution.self, forKey: .execution)
        execution = executionDecoded
    }
}

extension DescribeHostKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostKeyId = self.hostKeyId {
            try encodeContainer.encode(hostKeyId, forKey: .hostKeyId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DescribeHostKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeHostKeyInput: Swift.Equatable {
    /// The identifier of the host key that you want described.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// The identifier of the server that contains the host key that you want described.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

struct DescribeHostKeyInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let hostKeyId: Swift.String?
}

extension DescribeHostKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let hostKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyId)
        hostKeyId = hostKeyIdDecoded
    }
}

extension DescribeHostKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHostKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeHostKeyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHostKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeHostKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hostKey = output.hostKey
        } else {
            self.hostKey = nil
        }
    }
}

public struct DescribeHostKeyOutputResponse: Swift.Equatable {
    /// Returns the details for the specified host key.
    /// This member is required.
    public var hostKey: TransferClientTypes.DescribedHostKey?

    public init (
        hostKey: TransferClientTypes.DescribedHostKey? = nil
    )
    {
        self.hostKey = hostKey
    }
}

struct DescribeHostKeyOutputResponseBody: Swift.Equatable {
    let hostKey: TransferClientTypes.DescribedHostKey?
}

extension DescribeHostKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKey = "HostKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostKeyDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedHostKey.self, forKey: .hostKey)
        hostKey = hostKeyDecoded
    }
}

extension DescribeProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
    }
}

extension DescribeProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProfileInput: Swift.Equatable {
    /// The identifier of the profile that you want described.
    /// This member is required.
    public var profileId: Swift.String?

    public init (
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct DescribeProfileInputBody: Swift.Equatable {
    let profileId: Swift.String?
}

extension DescribeProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

extension DescribeProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeProfileOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct DescribeProfileOutputResponse: Swift.Equatable {
    /// The details of the specified profile, returned as an object.
    /// This member is required.
    public var profile: TransferClientTypes.DescribedProfile?

    public init (
        profile: TransferClientTypes.DescribedProfile? = nil
    )
    {
        self.profile = profile
    }
}

struct DescribeProfileOutputResponseBody: Swift.Equatable {
    let profile: TransferClientTypes.DescribedProfile?
}

extension DescribeProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile = "Profile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedProfile.self, forKey: .profile)
        profile = profileDecoded
    }
}

extension DescribeSecurityPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicyName = "SecurityPolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityPolicyName = self.securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
    }
}

extension DescribeSecurityPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSecurityPolicyInput: Swift.Equatable {
    /// Specifies the name of the security policy that is attached to the server.
    /// This member is required.
    public var securityPolicyName: Swift.String?

    public init (
        securityPolicyName: Swift.String? = nil
    )
    {
        self.securityPolicyName = securityPolicyName
    }
}

struct DescribeSecurityPolicyInputBody: Swift.Equatable {
    let securityPolicyName: Swift.String?
}

extension DescribeSecurityPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicyName = "SecurityPolicyName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
    }
}

extension DescribeSecurityPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSecurityPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSecurityPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSecurityPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSecurityPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityPolicy = output.securityPolicy
        } else {
            self.securityPolicy = nil
        }
    }
}

public struct DescribeSecurityPolicyOutputResponse: Swift.Equatable {
    /// An array containing the properties of the security policy.
    /// This member is required.
    public var securityPolicy: TransferClientTypes.DescribedSecurityPolicy?

    public init (
        securityPolicy: TransferClientTypes.DescribedSecurityPolicy? = nil
    )
    {
        self.securityPolicy = securityPolicy
    }
}

struct DescribeSecurityPolicyOutputResponseBody: Swift.Equatable {
    let securityPolicy: TransferClientTypes.DescribedSecurityPolicy?
}

extension DescribeSecurityPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicy = "SecurityPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedSecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
    }
}

extension DescribeServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DescribeServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeServerInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct DescribeServerInputBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension DescribeServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension DescribeServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeServerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct DescribeServerOutputResponse: Swift.Equatable {
    /// An array containing the properties of a server with the ServerID you specified.
    /// This member is required.
    public var server: TransferClientTypes.DescribedServer?

    public init (
        server: TransferClientTypes.DescribedServer? = nil
    )
    {
        self.server = server
    }
}

struct DescribeServerOutputResponseBody: Swift.Equatable {
    let server: TransferClientTypes.DescribedServer?
}

extension DescribeServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server = "Server"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedServer.self, forKey: .server)
        server = serverDecoded
    }
}

extension DescribeUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DescribeUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUserInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server that has this user assigned.
    /// This member is required.
    public var serverId: Swift.String?
    /// The name of the user assigned to one or more servers. User names are part of the sign-in credentials to use the Transfer Family service and perform file transfer tasks.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct DescribeUserInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension DescribeUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DescribeUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeUserOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.user = output.user
        } else {
            self.serverId = nil
            self.user = nil
        }
    }
}

public struct DescribeUserOutputResponse: Swift.Equatable {
    /// A system-assigned unique identifier for a server that has this user assigned.
    /// This member is required.
    public var serverId: Swift.String?
    /// An array containing the properties of the user account for the ServerID value that you specified.
    /// This member is required.
    public var user: TransferClientTypes.DescribedUser?

    public init (
        serverId: Swift.String? = nil,
        user: TransferClientTypes.DescribedUser? = nil
    )
    {
        self.serverId = serverId
        self.user = user
    }
}

struct DescribeUserOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let user: TransferClientTypes.DescribedUser?
}

extension DescribeUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedUser.self, forKey: .user)
        user = userDecoded
    }
}

extension DescribeWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension DescribeWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkflowInput: Swift.Equatable {
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        workflowId: Swift.String? = nil
    )
    {
        self.workflowId = workflowId
    }
}

struct DescribeWorkflowInputBody: Swift.Equatable {
    let workflowId: Swift.String?
}

extension DescribeWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

extension DescribeWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWorkflowOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workflow = output.workflow
        } else {
            self.workflow = nil
        }
    }
}

public struct DescribeWorkflowOutputResponse: Swift.Equatable {
    /// The structure that contains the details of the workflow.
    /// This member is required.
    public var workflow: TransferClientTypes.DescribedWorkflow?

    public init (
        workflow: TransferClientTypes.DescribedWorkflow? = nil
    )
    {
        self.workflow = workflow
    }
}

struct DescribeWorkflowOutputResponseBody: Swift.Equatable {
    let workflow: TransferClientTypes.DescribedWorkflow?
}

extension DescribeWorkflowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflow = "Workflow"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedWorkflow.self, forKey: .workflow)
        workflow = workflowDecoded
    }
}

extension TransferClientTypes.DescribedAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymapentry0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymapentry0)
            }
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = self.posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension TransferClientTypes {
    /// Describes the properties of the access that was specified.
    public struct DescribedAccess: Swift.Equatable {
        /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
        public var externalId: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
        public var homeDirectory: Swift.String?
        /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. In most cases, you can use this value instead of the session policy to lock down the associated access to the designated home directory ("chroot"). To do this, you can set Entry to '/' and set Target to the HomeDirectory parameter value.
        public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
        /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}.
        public var policy: Swift.String?
        /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
        public var posixProfile: TransferClientTypes.PosixProfile?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
        public var role: Swift.String?

        public init (
            externalId: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            policy: Swift.String? = nil,
            posixProfile: TransferClientTypes.PosixProfile? = nil,
            role: Swift.String? = nil
        )
        {
            self.externalId = externalId
            self.homeDirectory = homeDirectory
            self.homeDirectoryMappings = homeDirectoryMappings
            self.homeDirectoryType = homeDirectoryType
            self.policy = policy
            self.posixProfile = posixProfile
            self.role = role
        }
    }

}

extension TransferClientTypes.DescribedAgreement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case agreementId = "AgreementId"
        case arn = "Arn"
        case baseDirectory = "BaseDirectory"
        case description = "Description"
        case localProfileId = "LocalProfileId"
        case partnerProfileId = "PartnerProfileId"
        case serverId = "ServerId"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = self.accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let agreementId = self.agreementId {
            try encodeContainer.encode(agreementId, forKey: .agreementId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let baseDirectory = self.baseDirectory {
            try encodeContainer.encode(baseDirectory, forKey: .baseDirectory)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let localProfileId = self.localProfileId {
            try encodeContainer.encode(localProfileId, forKey: .localProfileId)
        }
        if let partnerProfileId = self.partnerProfileId {
            try encodeContainer.encode(partnerProfileId, forKey: .partnerProfileId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.AgreementStatusType.self, forKey: .status)
        status = statusDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let localProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localProfileId)
        localProfileId = localProfileIdDecoded
        let partnerProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerProfileId)
        partnerProfileId = partnerProfileIdDecoded
        let baseDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseDirectory)
        baseDirectory = baseDirectoryDecoded
        let accessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TransferClientTypes {
    /// Describes the properties of an agreement.
    public struct DescribedAgreement: Swift.Equatable {
        /// With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the file’s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer.
        public var accessRole: Swift.String?
        /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
        public var agreementId: Swift.String?
        /// The unique Amazon Resource Name (ARN) for the agreement.
        /// This member is required.
        public var arn: Swift.String?
        /// The landing directory (folder) for files that are transferred by using the AS2 protocol.
        public var baseDirectory: Swift.String?
        /// The name or short description that's used to identify the agreement.
        public var description: Swift.String?
        /// A unique identifier for the AS2 local profile.
        public var localProfileId: Swift.String?
        /// A unique identifier for the partner profile used in the agreement.
        public var partnerProfileId: Swift.String?
        /// A system-assigned unique identifier for a server instance. This identifier indicates the specific server that the agreement uses.
        public var serverId: Swift.String?
        /// The current status of the agreement, either ACTIVE or INACTIVE.
        public var status: TransferClientTypes.AgreementStatusType?
        /// Key-value pairs that can be used to group and search for agreements.
        public var tags: [TransferClientTypes.Tag]?

        public init (
            accessRole: Swift.String? = nil,
            agreementId: Swift.String? = nil,
            arn: Swift.String? = nil,
            baseDirectory: Swift.String? = nil,
            description: Swift.String? = nil,
            localProfileId: Swift.String? = nil,
            partnerProfileId: Swift.String? = nil,
            serverId: Swift.String? = nil,
            status: TransferClientTypes.AgreementStatusType? = nil,
            tags: [TransferClientTypes.Tag]? = nil
        )
        {
            self.accessRole = accessRole
            self.agreementId = agreementId
            self.arn = arn
            self.baseDirectory = baseDirectory
            self.description = description
            self.localProfileId = localProfileId
            self.partnerProfileId = partnerProfileId
            self.serverId = serverId
            self.status = status
            self.tags = tags
        }
    }

}

extension TransferClientTypes.DescribedCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDate = "ActiveDate"
        case arn = "Arn"
        case certificate = "Certificate"
        case certificateChain = "CertificateChain"
        case certificateId = "CertificateId"
        case description = "Description"
        case inactiveDate = "InactiveDate"
        case notAfterDate = "NotAfterDate"
        case notBeforeDate = "NotBeforeDate"
        case serial = "Serial"
        case status = "Status"
        case tags = "Tags"
        case type = "Type"
        case usage = "Usage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDate = self.activeDate {
            try encodeContainer.encodeTimestamp(activeDate, format: .epochSeconds, forKey: .activeDate)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let certificateChain = self.certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inactiveDate = self.inactiveDate {
            try encodeContainer.encodeTimestamp(inactiveDate, format: .epochSeconds, forKey: .inactiveDate)
        }
        if let notAfterDate = self.notAfterDate {
            try encodeContainer.encodeTimestamp(notAfterDate, format: .epochSeconds, forKey: .notAfterDate)
        }
        if let notBeforeDate = self.notBeforeDate {
            try encodeContainer.encodeTimestamp(notBeforeDate, format: .epochSeconds, forKey: .notBeforeDate)
        }
        if let serial = self.serial {
            try encodeContainer.encode(serial, forKey: .serial)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let usage = self.usage {
            try encodeContainer.encode(usage.rawValue, forKey: .usage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let usageDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CertificateUsageType.self, forKey: .usage)
        usage = usageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CertificateStatusType.self, forKey: .status)
        status = statusDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        let activeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .activeDate)
        activeDate = activeDateDecoded
        let inactiveDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .inactiveDate)
        inactiveDate = inactiveDateDecoded
        let serialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serial)
        serial = serialDecoded
        let notBeforeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notBeforeDate)
        notBeforeDate = notBeforeDateDecoded
        let notAfterDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notAfterDate)
        notAfterDate = notAfterDateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CertificateType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TransferClientTypes.DescribedCertificate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribedCertificate(activeDate: \(Swift.String(describing: activeDate)), arn: \(Swift.String(describing: arn)), certificateId: \(Swift.String(describing: certificateId)), description: \(Swift.String(describing: description)), inactiveDate: \(Swift.String(describing: inactiveDate)), notAfterDate: \(Swift.String(describing: notAfterDate)), notBeforeDate: \(Swift.String(describing: notBeforeDate)), serial: \(Swift.String(describing: serial)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), usage: \(Swift.String(describing: usage)), certificate: \"CONTENT_REDACTED\", certificateChain: \"CONTENT_REDACTED\")"}
}

extension TransferClientTypes {
    /// Describes the properties of a certificate.
    public struct DescribedCertificate: Swift.Equatable {
        /// An optional date that specifies when the certificate becomes active.
        public var activeDate: ClientRuntime.Date?
        /// The unique Amazon Resource Name (ARN) for the certificate.
        /// This member is required.
        public var arn: Swift.String?
        /// The file name for the certificate.
        public var certificate: Swift.String?
        /// The list of certificates that make up the chain for the certificate.
        public var certificateChain: Swift.String?
        /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
        public var certificateId: Swift.String?
        /// The name or description that's used to identity the certificate.
        public var description: Swift.String?
        /// An optional date that specifies when the certificate becomes inactive.
        public var inactiveDate: ClientRuntime.Date?
        /// The final date that the certificate is valid.
        public var notAfterDate: ClientRuntime.Date?
        /// The earliest date that the certificate is valid.
        public var notBeforeDate: ClientRuntime.Date?
        /// The serial number for the certificate.
        public var serial: Swift.String?
        /// The certificate can be either ACTIVE, PENDING_ROTATION, or INACTIVE. PENDING_ROTATION means that this certificate will replace the current certificate when it expires.
        public var status: TransferClientTypes.CertificateStatusType?
        /// Key-value pairs that can be used to group and search for certificates.
        public var tags: [TransferClientTypes.Tag]?
        /// If a private key has been specified for the certificate, its type is CERTIFICATE_WITH_PRIVATE_KEY. If there is no private key, the type is CERTIFICATE.
        public var type: TransferClientTypes.CertificateType?
        /// Specifies whether this certificate is used for signing or encryption.
        public var usage: TransferClientTypes.CertificateUsageType?

        public init (
            activeDate: ClientRuntime.Date? = nil,
            arn: Swift.String? = nil,
            certificate: Swift.String? = nil,
            certificateChain: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            description: Swift.String? = nil,
            inactiveDate: ClientRuntime.Date? = nil,
            notAfterDate: ClientRuntime.Date? = nil,
            notBeforeDate: ClientRuntime.Date? = nil,
            serial: Swift.String? = nil,
            status: TransferClientTypes.CertificateStatusType? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            type: TransferClientTypes.CertificateType? = nil,
            usage: TransferClientTypes.CertificateUsageType? = nil
        )
        {
            self.activeDate = activeDate
            self.arn = arn
            self.certificate = certificate
            self.certificateChain = certificateChain
            self.certificateId = certificateId
            self.description = description
            self.inactiveDate = inactiveDate
            self.notAfterDate = notAfterDate
            self.notBeforeDate = notBeforeDate
            self.serial = serial
            self.status = status
            self.tags = tags
            self.type = type
            self.usage = usage
        }
    }

}

extension TransferClientTypes.DescribedConnector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case arn = "Arn"
        case as2Config = "As2Config"
        case connectorId = "ConnectorId"
        case loggingRole = "LoggingRole"
        case tags = "Tags"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = self.accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let as2Config = self.as2Config {
            try encodeContainer.encode(as2Config, forKey: .as2Config)
        }
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let as2ConfigDecoded = try containerValues.decodeIfPresent(TransferClientTypes.As2ConnectorConfig.self, forKey: .as2Config)
        as2Config = as2ConfigDecoded
        let accessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TransferClientTypes {
    /// Describes the parameters for the connector, as identified by the ConnectorId.
    public struct DescribedConnector: Swift.Equatable {
        /// With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the file’s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer.
        public var accessRole: Swift.String?
        /// The unique Amazon Resource Name (ARN) for the connector.
        /// This member is required.
        public var arn: Swift.String?
        /// A structure that contains the parameters for a connector object.
        public var as2Config: TransferClientTypes.As2ConnectorConfig?
        /// The unique identifier for the connector.
        public var connectorId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a connector to turn on CloudWatch logging for Amazon S3 events. When set, you can view connector activity in your CloudWatch logs.
        public var loggingRole: Swift.String?
        /// Key-value pairs that can be used to group and search for connectors.
        public var tags: [TransferClientTypes.Tag]?
        /// The URL of the partner's AS2 endpoint.
        public var url: Swift.String?

        public init (
            accessRole: Swift.String? = nil,
            arn: Swift.String? = nil,
            as2Config: TransferClientTypes.As2ConnectorConfig? = nil,
            connectorId: Swift.String? = nil,
            loggingRole: Swift.String? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            url: Swift.String? = nil
        )
        {
            self.accessRole = accessRole
            self.arn = arn
            self.as2Config = as2Config
            self.connectorId = connectorId
            self.loggingRole = loggingRole
            self.tags = tags
            self.url = url
        }
    }

}

extension TransferClientTypes.DescribedExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case executionRole = "ExecutionRole"
        case initialFileLocation = "InitialFileLocation"
        case loggingConfiguration = "LoggingConfiguration"
        case posixProfile = "PosixProfile"
        case results = "Results"
        case serviceMetadata = "ServiceMetadata"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let initialFileLocation = self.initialFileLocation {
            try encodeContainer.encode(initialFileLocation, forKey: .initialFileLocation)
        }
        if let loggingConfiguration = self.loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
        if let posixProfile = self.posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let results = self.results {
            try encodeContainer.encode(results, forKey: .results)
        }
        if let serviceMetadata = self.serviceMetadata {
            try encodeContainer.encode(serviceMetadata, forKey: .serviceMetadata)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let initialFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.FileLocation.self, forKey: .initialFileLocation)
        initialFileLocation = initialFileLocationDecoded
        let serviceMetadataDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ServiceMetadata.self, forKey: .serviceMetadata)
        serviceMetadata = serviceMetadataDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionResults.self, forKey: .results)
        results = resultsDecoded
    }
}

extension TransferClientTypes {
    /// The details for an execution object.
    public struct DescribedExecution: Swift.Equatable {
        /// A unique identifier for the execution of a workflow.
        public var executionId: Swift.String?
        /// The IAM role associated with the execution.
        public var executionRole: Swift.String?
        /// A structure that describes the Amazon S3 or EFS file location. This is the file location when the execution begins: if the file is being copied, this is the initial (as opposed to destination) file location.
        public var initialFileLocation: TransferClientTypes.FileLocation?
        /// The IAM logging role associated with the execution.
        public var loggingConfiguration: TransferClientTypes.LoggingConfiguration?
        /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
        public var posixProfile: TransferClientTypes.PosixProfile?
        /// A structure that describes the execution results. This includes a list of the steps along with the details of each step, error type and message (if any), and the OnExceptionSteps structure.
        public var results: TransferClientTypes.ExecutionResults?
        /// A container object for the session details that are associated with a workflow.
        public var serviceMetadata: TransferClientTypes.ServiceMetadata?
        /// The status is one of the execution. Can be in progress, completed, exception encountered, or handling the exception.
        public var status: TransferClientTypes.ExecutionStatus?

        public init (
            executionId: Swift.String? = nil,
            executionRole: Swift.String? = nil,
            initialFileLocation: TransferClientTypes.FileLocation? = nil,
            loggingConfiguration: TransferClientTypes.LoggingConfiguration? = nil,
            posixProfile: TransferClientTypes.PosixProfile? = nil,
            results: TransferClientTypes.ExecutionResults? = nil,
            serviceMetadata: TransferClientTypes.ServiceMetadata? = nil,
            status: TransferClientTypes.ExecutionStatus? = nil
        )
        {
            self.executionId = executionId
            self.executionRole = executionRole
            self.initialFileLocation = initialFileLocation
            self.loggingConfiguration = loggingConfiguration
            self.posixProfile = posixProfile
            self.results = results
            self.serviceMetadata = serviceMetadata
            self.status = status
        }
    }

}

extension TransferClientTypes.DescribedHostKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dateImported = "DateImported"
        case description = "Description"
        case hostKeyFingerprint = "HostKeyFingerprint"
        case hostKeyId = "HostKeyId"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateImported = self.dateImported {
            try encodeContainer.encodeTimestamp(dateImported, format: .epochSeconds, forKey: .dateImported)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hostKeyFingerprint = self.hostKeyFingerprint {
            try encodeContainer.encode(hostKeyFingerprint, forKey: .hostKeyFingerprint)
        }
        if let hostKeyId = self.hostKeyId {
            try encodeContainer.encode(hostKeyId, forKey: .hostKeyId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let hostKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyId)
        hostKeyId = hostKeyIdDecoded
        let hostKeyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyFingerprint)
        hostKeyFingerprint = hostKeyFingerprintDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let dateImportedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateImported)
        dateImported = dateImportedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TransferClientTypes {
    /// The details for a server host key.
    public struct DescribedHostKey: Swift.Equatable {
        /// The unique Amazon Resource Name (ARN) for the host key.
        /// This member is required.
        public var arn: Swift.String?
        /// The date on which the host key was added to the server.
        public var dateImported: ClientRuntime.Date?
        /// The text description for this host key.
        public var description: Swift.String?
        /// The public key fingerprint, which is a short sequence of bytes used to identify the longer public key.
        public var hostKeyFingerprint: Swift.String?
        /// A unique identifier for the host key.
        public var hostKeyId: Swift.String?
        /// Key-value pairs that can be used to group and search for host keys.
        public var tags: [TransferClientTypes.Tag]?
        /// The encryption algorithm that is used for the host key. The Type parameter is specified by using one of the following values:
        ///
        /// * ssh-rsa
        ///
        /// * ssh-ed25519
        ///
        /// * ecdsa-sha2-nistp256
        ///
        /// * ecdsa-sha2-nistp384
        ///
        /// * ecdsa-sha2-nistp521
        public var type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            dateImported: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            hostKeyFingerprint: Swift.String? = nil,
            hostKeyId: Swift.String? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.dateImported = dateImported
            self.description = description
            self.hostKeyFingerprint = hostKeyFingerprint
            self.hostKeyId = hostKeyId
            self.tags = tags
            self.type = type
        }
    }

}

extension TransferClientTypes.DescribedProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case as2Id = "As2Id"
        case certificateIds = "CertificateIds"
        case profileId = "ProfileId"
        case profileType = "ProfileType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let as2Id = self.as2Id {
            try encodeContainer.encode(as2Id, forKey: .as2Id)
        }
        if let certificateIds = certificateIds {
            var certificateIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateIds)
            for certificateid0 in certificateIds {
                try certificateIdsContainer.encode(certificateid0)
            }
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let profileType = self.profileType {
            try encodeContainer.encode(profileType.rawValue, forKey: .profileType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let profileTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProfileType.self, forKey: .profileType)
        profileType = profileTypeDecoded
        let as2IdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .as2Id)
        as2Id = as2IdDecoded
        let certificateIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .certificateIds)
        var certificateIdsDecoded0:[Swift.String]? = nil
        if let certificateIdsContainer = certificateIdsContainer {
            certificateIdsDecoded0 = [Swift.String]()
            for string0 in certificateIdsContainer {
                if let string0 = string0 {
                    certificateIdsDecoded0?.append(string0)
                }
            }
        }
        certificateIds = certificateIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TransferClientTypes {
    /// The details for a local or partner AS2 profile.
    public struct DescribedProfile: Swift.Equatable {
        /// The unique Amazon Resource Name (ARN) for the profile.
        /// This member is required.
        public var arn: Swift.String?
        /// The As2Id is the AS2-name, as defined in the [RFC 4130](https://datatracker.ietf.org/doc/html/rfc4130). For inbound transfers, this is the AS2-From header for the AS2 messages sent from the partner. For outbound connectors, this is the AS2-To header for the AS2 messages sent to the partner using the StartFileTransfer API operation. This ID cannot include spaces.
        public var as2Id: Swift.String?
        /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
        public var certificateIds: [Swift.String]?
        /// A unique identifier for the local or partner AS2 profile.
        public var profileId: Swift.String?
        /// Indicates whether to list only LOCAL type profiles or only PARTNER type profiles. If not supplied in the request, the command lists all types of profiles.
        public var profileType: TransferClientTypes.ProfileType?
        /// Key-value pairs that can be used to group and search for profiles.
        public var tags: [TransferClientTypes.Tag]?

        public init (
            arn: Swift.String? = nil,
            as2Id: Swift.String? = nil,
            certificateIds: [Swift.String]? = nil,
            profileId: Swift.String? = nil,
            profileType: TransferClientTypes.ProfileType? = nil,
            tags: [TransferClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.as2Id = as2Id
            self.certificateIds = certificateIds
            self.profileId = profileId
            self.profileType = profileType
            self.tags = tags
        }
    }

}

extension TransferClientTypes.DescribedSecurityPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fips = "Fips"
        case securityPolicyName = "SecurityPolicyName"
        case sshCiphers = "SshCiphers"
        case sshKexs = "SshKexs"
        case sshMacs = "SshMacs"
        case tlsCiphers = "TlsCiphers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fips = self.fips {
            try encodeContainer.encode(fips, forKey: .fips)
        }
        if let securityPolicyName = self.securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let sshCiphers = sshCiphers {
            var sshCiphersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshCiphers)
            for securitypolicyoption0 in sshCiphers {
                try sshCiphersContainer.encode(securitypolicyoption0)
            }
        }
        if let sshKexs = sshKexs {
            var sshKexsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshKexs)
            for securitypolicyoption0 in sshKexs {
                try sshKexsContainer.encode(securitypolicyoption0)
            }
        }
        if let sshMacs = sshMacs {
            var sshMacsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshMacs)
            for securitypolicyoption0 in sshMacs {
                try sshMacsContainer.encode(securitypolicyoption0)
            }
        }
        if let tlsCiphers = tlsCiphers {
            var tlsCiphersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tlsCiphers)
            for securitypolicyoption0 in tlsCiphers {
                try tlsCiphersContainer.encode(securitypolicyoption0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fipsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fips)
        fips = fipsDecoded
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let sshCiphersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sshCiphers)
        var sshCiphersDecoded0:[Swift.String]? = nil
        if let sshCiphersContainer = sshCiphersContainer {
            sshCiphersDecoded0 = [Swift.String]()
            for string0 in sshCiphersContainer {
                if let string0 = string0 {
                    sshCiphersDecoded0?.append(string0)
                }
            }
        }
        sshCiphers = sshCiphersDecoded0
        let sshKexsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sshKexs)
        var sshKexsDecoded0:[Swift.String]? = nil
        if let sshKexsContainer = sshKexsContainer {
            sshKexsDecoded0 = [Swift.String]()
            for string0 in sshKexsContainer {
                if let string0 = string0 {
                    sshKexsDecoded0?.append(string0)
                }
            }
        }
        sshKexs = sshKexsDecoded0
        let sshMacsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sshMacs)
        var sshMacsDecoded0:[Swift.String]? = nil
        if let sshMacsContainer = sshMacsContainer {
            sshMacsDecoded0 = [Swift.String]()
            for string0 in sshMacsContainer {
                if let string0 = string0 {
                    sshMacsDecoded0?.append(string0)
                }
            }
        }
        sshMacs = sshMacsDecoded0
        let tlsCiphersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tlsCiphers)
        var tlsCiphersDecoded0:[Swift.String]? = nil
        if let tlsCiphersContainer = tlsCiphersContainer {
            tlsCiphersDecoded0 = [Swift.String]()
            for string0 in tlsCiphersContainer {
                if let string0 = string0 {
                    tlsCiphersDecoded0?.append(string0)
                }
            }
        }
        tlsCiphers = tlsCiphersDecoded0
    }
}

extension TransferClientTypes {
    /// Describes the properties of a security policy that was specified. For more information about security policies, see [Working with security policies](https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html).
    public struct DescribedSecurityPolicy: Swift.Equatable {
        /// Specifies whether this policy enables Federal Information Processing Standards (FIPS).
        public var fips: Swift.Bool?
        /// Specifies the name of the security policy that is attached to the server.
        /// This member is required.
        public var securityPolicyName: Swift.String?
        /// Specifies the enabled Secure Shell (SSH) cipher encryption algorithms in the security policy that is attached to the server.
        public var sshCiphers: [Swift.String]?
        /// Specifies the enabled SSH key exchange (KEX) encryption algorithms in the security policy that is attached to the server.
        public var sshKexs: [Swift.String]?
        /// Specifies the enabled SSH message authentication code (MAC) encryption algorithms in the security policy that is attached to the server.
        public var sshMacs: [Swift.String]?
        /// Specifies the enabled Transport Layer Security (TLS) cipher encryption algorithms in the security policy that is attached to the server.
        public var tlsCiphers: [Swift.String]?

        public init (
            fips: Swift.Bool? = nil,
            securityPolicyName: Swift.String? = nil,
            sshCiphers: [Swift.String]? = nil,
            sshKexs: [Swift.String]? = nil,
            sshMacs: [Swift.String]? = nil,
            tlsCiphers: [Swift.String]? = nil
        )
        {
            self.fips = fips
            self.securityPolicyName = securityPolicyName
            self.sshCiphers = sshCiphers
            self.sshKexs = sshKexs
            self.sshMacs = sshMacs
            self.tlsCiphers = tlsCiphers
        }
    }

}

extension TransferClientTypes.DescribedServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKeyFingerprint = "HostKeyFingerprint"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case postAuthenticationLoginBanner = "PostAuthenticationLoginBanner"
        case preAuthenticationLoginBanner = "PreAuthenticationLoginBanner"
        case protocolDetails = "ProtocolDetails"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
        case state = "State"
        case tags = "Tags"
        case userCount = "UserCount"
        case workflowDetails = "WorkflowDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointDetails = self.endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKeyFingerprint = self.hostKeyFingerprint {
            try encodeContainer.encode(hostKeyFingerprint, forKey: .hostKeyFingerprint)
        }
        if let identityProviderDetails = self.identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let postAuthenticationLoginBanner = self.postAuthenticationLoginBanner {
            try encodeContainer.encode(postAuthenticationLoginBanner, forKey: .postAuthenticationLoginBanner)
        }
        if let preAuthenticationLoginBanner = self.preAuthenticationLoginBanner {
            try encodeContainer.encode(preAuthenticationLoginBanner, forKey: .preAuthenticationLoginBanner)
        }
        if let protocolDetails = self.protocolDetails {
            try encodeContainer.encode(protocolDetails, forKey: .protocolDetails)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocol0 in protocols {
                try protocolsContainer.encode(protocol0.rawValue)
            }
        }
        if let securityPolicyName = self.securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userCount = self.userCount {
            try encodeContainer.encode(userCount, forKey: .userCount)
        }
        if let workflowDetails = self.workflowDetails {
            try encodeContainer.encode(workflowDetails, forKey: .workflowDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let protocolDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProtocolDetails.self, forKey: .protocolDetails)
        protocolDetails = protocolDetailsDecoded
        let domainDecoded = try containerValues.decodeIfPresent(TransferClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyFingerprint)
        hostKeyFingerprint = hostKeyFingerprintDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let postAuthenticationLoginBannerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postAuthenticationLoginBanner)
        postAuthenticationLoginBanner = postAuthenticationLoginBannerDecoded
        let preAuthenticationLoginBannerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preAuthenticationLoginBanner)
        preAuthenticationLoginBanner = preAuthenticationLoginBannerDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[TransferClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [TransferClientTypes.ModelProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TransferClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userCount)
        userCount = userCountDecoded
        let workflowDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowDetails.self, forKey: .workflowDetails)
        workflowDetails = workflowDetailsDecoded
    }
}

extension TransferClientTypes {
    /// Describes the properties of a file transfer protocol-enabled server that was specified.
    public struct DescribedServer: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) of the server.
        /// This member is required.
        public var arn: Swift.String?
        /// Specifies the ARN of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when Protocols is set to FTPS.
        public var certificate: Swift.String?
        /// Specifies the domain of the storage system that is used for file transfers.
        public var domain: TransferClientTypes.Domain?
        /// The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make your endpoint accessible only to resources within your VPC, or you can attach Elastic IP addresses and make your endpoint accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.
        public var endpointDetails: TransferClientTypes.EndpointDetails?
        /// Defines the type of endpoint that your server is connected to. If your server is connected to a VPC endpoint, your server isn't accessible over the public internet.
        public var endpointType: TransferClientTypes.EndpointType?
        /// Specifies the Base64-encoded SHA256 fingerprint of the server's host key. This value is equivalent to the output of the ssh-keygen -l -f my-new-server-key command.
        public var hostKeyFingerprint: Swift.String?
        /// Specifies information to call a customer-supplied authentication API. This field is not populated when the IdentityProviderType of a server is AWS_DIRECTORY_SERVICE or SERVICE_MANAGED.
        public var identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
        /// The mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Transfer Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the IdentityProviderDetails parameter. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the IdentityProviderDetails parameter. Use the AWS_LAMBDA value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the Function parameter or the IdentityProviderDetails data type.
        public var identityProviderType: TransferClientTypes.IdentityProviderType?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
        public var loggingRole: Swift.String?
        /// Specifies a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
        public var postAuthenticationLoginBanner: Swift.String?
        /// Specifies a string to display when users connect to a server. This string is displayed before the user authenticates. For example, the following banner displays details about using the system: This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel.
        public var preAuthenticationLoginBanner: Swift.String?
        /// The protocol settings that are configured for your server.
        ///
        /// * To indicate passive mode (for FTP and FTPS protocols), use the PassiveIp parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
        ///
        /// * To ignore the error that is generated when the client attempts to use the SETSTAT command on a file that you are uploading to an Amazon S3 bucket, use the SetStatOption parameter. To have the Transfer Family server ignore the SETSTAT command and upload files without needing to make any changes to your SFTP client, set the value to ENABLE_NO_OP. If you set the SetStatOption parameter to ENABLE_NO_OP, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a SETSTAT call.
        ///
        /// * To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the TlsSessionResumptionMode parameter.
        ///
        /// * As2Transports indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
        public var protocolDetails: TransferClientTypes.ProtocolDetails?
        /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:
        ///
        /// * SFTP (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH
        ///
        /// * FTPS (File Transfer Protocol Secure): File transfer with TLS encryption
        ///
        /// * FTP (File Transfer Protocol): Unencrypted file transfer
        ///
        /// * AS2 (Applicability Statement 2): used for transporting structured business-to-business data
        ///
        ///
        ///
        ///
        /// * If you select FTPS, you must choose a certificate stored in Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS.
        ///
        /// * If Protocol includes either FTP or FTPS, then the EndpointType must be VPC and the IdentityProviderType must be either AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
        ///
        /// * If Protocol includes FTP, then AddressAllocationIds cannot be associated.
        ///
        /// * If Protocol is set only to SFTP, the EndpointType can be set to PUBLIC and the IdentityProviderType can be set any of the supported identity types: SERVICE_MANAGED, AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
        ///
        /// * If Protocol includes AS2, then the EndpointType must be VPC, and domain must be Amazon S3.
        public var protocols: [TransferClientTypes.ModelProtocol]?
        /// Specifies the name of the security policy that is attached to the server.
        public var securityPolicyName: Swift.String?
        /// Specifies the unique system-assigned identifier for a server that you instantiate.
        public var serverId: Swift.String?
        /// The condition of the server that was described. A value of ONLINE indicates that the server can accept jobs and transfer files. A State value of OFFLINE means that the server cannot perform file transfer operations. The states of STARTING and STOPPING indicate that the server is in an intermediate state, either not fully able to respond, or not fully offline. The values of START_FAILED or STOP_FAILED can indicate an error condition.
        public var state: TransferClientTypes.State?
        /// Specifies the key-value pairs that you can use to search for and group servers that were assigned to the server that was described.
        public var tags: [TransferClientTypes.Tag]?
        /// Specifies the number of users that are assigned to a server you specified with the ServerId.
        public var userCount: Swift.Int?
        /// Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow. In addition to a workflow to execute when a file is uploaded completely, WorkflowDetails can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when a file is open when the session disconnects.
        public var workflowDetails: TransferClientTypes.WorkflowDetails?

        public init (
            arn: Swift.String? = nil,
            certificate: Swift.String? = nil,
            domain: TransferClientTypes.Domain? = nil,
            endpointDetails: TransferClientTypes.EndpointDetails? = nil,
            endpointType: TransferClientTypes.EndpointType? = nil,
            hostKeyFingerprint: Swift.String? = nil,
            identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
            identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
            loggingRole: Swift.String? = nil,
            postAuthenticationLoginBanner: Swift.String? = nil,
            preAuthenticationLoginBanner: Swift.String? = nil,
            protocolDetails: TransferClientTypes.ProtocolDetails? = nil,
            protocols: [TransferClientTypes.ModelProtocol]? = nil,
            securityPolicyName: Swift.String? = nil,
            serverId: Swift.String? = nil,
            state: TransferClientTypes.State? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            userCount: Swift.Int? = nil,
            workflowDetails: TransferClientTypes.WorkflowDetails? = nil
        )
        {
            self.arn = arn
            self.certificate = certificate
            self.domain = domain
            self.endpointDetails = endpointDetails
            self.endpointType = endpointType
            self.hostKeyFingerprint = hostKeyFingerprint
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderType = identityProviderType
            self.loggingRole = loggingRole
            self.postAuthenticationLoginBanner = postAuthenticationLoginBanner
            self.preAuthenticationLoginBanner = preAuthenticationLoginBanner
            self.protocolDetails = protocolDetails
            self.protocols = protocols
            self.securityPolicyName = securityPolicyName
            self.serverId = serverId
            self.state = state
            self.tags = tags
            self.userCount = userCount
            self.workflowDetails = workflowDetails
        }
    }

}

extension TransferClientTypes.DescribedUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case sshPublicKeys = "SshPublicKeys"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymapentry0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymapentry0)
            }
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = self.posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let sshPublicKeys = sshPublicKeys {
            var sshPublicKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshPublicKeys)
            for sshpublickey0 in sshPublicKeys {
                try sshPublicKeysContainer.encode(sshpublickey0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let sshPublicKeysContainer = try containerValues.decodeIfPresent([TransferClientTypes.SshPublicKey?].self, forKey: .sshPublicKeys)
        var sshPublicKeysDecoded0:[TransferClientTypes.SshPublicKey]? = nil
        if let sshPublicKeysContainer = sshPublicKeysContainer {
            sshPublicKeysDecoded0 = [TransferClientTypes.SshPublicKey]()
            for structure0 in sshPublicKeysContainer {
                if let structure0 = structure0 {
                    sshPublicKeysDecoded0?.append(structure0)
                }
            }
        }
        sshPublicKeys = sshPublicKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension TransferClientTypes {
    /// Describes the properties of a user that was specified.
    public struct DescribedUser: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) for the user that was requested to be described.
        /// This member is required.
        public var arn: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
        public var homeDirectory: Swift.String?
        /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. In most cases, you can use this value instead of the session policy to lock your user down to the designated home directory ("chroot"). To do this, you can set Entry to '/' and set Target to the HomeDirectory parameter value.
        public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
        /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}.
        public var policy: Swift.String?
        /// Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon Elastic File System (Amazon EFS) file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
        public var posixProfile: TransferClientTypes.PosixProfile?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
        public var role: Swift.String?
        /// Specifies the public key portion of the Secure Shell (SSH) keys stored for the described user.
        public var sshPublicKeys: [TransferClientTypes.SshPublicKey]?
        /// Specifies the key-value pairs for the user requested. Tag can be used to search for and group users for a variety of purposes.
        public var tags: [TransferClientTypes.Tag]?
        /// Specifies the name of the user that was requested to be described. User names are used for authentication purposes. This is the string that will be used by your user when they log in to your server.
        public var userName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            policy: Swift.String? = nil,
            posixProfile: TransferClientTypes.PosixProfile? = nil,
            role: Swift.String? = nil,
            sshPublicKeys: [TransferClientTypes.SshPublicKey]? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.homeDirectory = homeDirectory
            self.homeDirectoryMappings = homeDirectoryMappings
            self.homeDirectoryType = homeDirectoryType
            self.policy = policy
            self.posixProfile = posixProfile
            self.role = role
            self.sshPublicKeys = sshPublicKeys
            self.tags = tags
            self.userName = userName
        }
    }

}

extension TransferClientTypes.DescribedWorkflow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case onExceptionSteps = "OnExceptionSteps"
        case steps = "Steps"
        case tags = "Tags"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let onExceptionSteps = onExceptionSteps {
            var onExceptionStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .onExceptionSteps)
            for workflowstep0 in onExceptionSteps {
                try onExceptionStepsContainer.encode(workflowstep0)
            }
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for workflowstep0 in steps {
                try stepsContainer.encode(workflowstep0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowStep?].self, forKey: .steps)
        var stepsDecoded0:[TransferClientTypes.WorkflowStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [TransferClientTypes.WorkflowStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let onExceptionStepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowStep?].self, forKey: .onExceptionSteps)
        var onExceptionStepsDecoded0:[TransferClientTypes.WorkflowStep]? = nil
        if let onExceptionStepsContainer = onExceptionStepsContainer {
            onExceptionStepsDecoded0 = [TransferClientTypes.WorkflowStep]()
            for structure0 in onExceptionStepsContainer {
                if let structure0 = structure0 {
                    onExceptionStepsDecoded0?.append(structure0)
                }
            }
        }
        onExceptionSteps = onExceptionStepsDecoded0
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TransferClientTypes {
    /// Describes the properties of the specified workflow
    public struct DescribedWorkflow: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) for the workflow.
        /// This member is required.
        public var arn: Swift.String?
        /// Specifies the text description for the workflow.
        public var description: Swift.String?
        /// Specifies the steps (actions) to take if errors are encountered during execution of the workflow.
        public var onExceptionSteps: [TransferClientTypes.WorkflowStep]?
        /// Specifies the details for the steps that are in the specified workflow.
        public var steps: [TransferClientTypes.WorkflowStep]?
        /// Key-value pairs that can be used to group and search for workflows. Tags are metadata attached to workflows for any purpose.
        public var tags: [TransferClientTypes.Tag]?
        /// A unique identifier for the workflow.
        public var workflowId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            onExceptionSteps: [TransferClientTypes.WorkflowStep]? = nil,
            steps: [TransferClientTypes.WorkflowStep]? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.onExceptionSteps = onExceptionSteps
            self.steps = steps
            self.tags = tags
            self.workflowId = workflowId
        }
    }

}

extension TransferClientTypes {
    public enum Domain: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case efs
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [Domain] {
            return [
                .efs,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .efs: return "EFS"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Domain(rawValue: rawValue) ?? Domain.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.EfsFileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "FileSystemId"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemId = self.fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the details for the file location for the file that's being used in the workflow. Only applicable if you are using Amazon Elastic File Systems (Amazon EFS) for storage.
    public struct EfsFileLocation: Swift.Equatable {
        /// The identifier of the file system, assigned by Amazon EFS.
        public var fileSystemId: Swift.String?
        /// The pathname for the folder being used by a workflow.
        public var path: Swift.String?

        public init (
            fileSystemId: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.fileSystemId = fileSystemId
            self.path = path
        }
    }

}

extension TransferClientTypes {
    public enum EncryptionAlg: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes128Cbc
        case aes192Cbc
        case aes256Cbc
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionAlg] {
            return [
                .aes128Cbc,
                .aes192Cbc,
                .aes256Cbc,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes128Cbc: return "AES128_CBC"
            case .aes192Cbc: return "AES192_CBC"
            case .aes256Cbc: return "AES256_CBC"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionAlg(rawValue: rawValue) ?? EncryptionAlg.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pgp
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .pgp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pgp: return "PGP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.EndpointDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressAllocationIds = "AddressAllocationIds"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcEndpointId = "VpcEndpointId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressAllocationIds = addressAllocationIds {
            var addressAllocationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addressAllocationIds)
            for addressallocationid0 in addressAllocationIds {
                try addressAllocationIdsContainer.encode(addressallocationid0)
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcEndpointId = self.vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressAllocationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .addressAllocationIds)
        var addressAllocationIdsDecoded0:[Swift.String]? = nil
        if let addressAllocationIdsContainer = addressAllocationIdsContainer {
            addressAllocationIdsDecoded0 = [Swift.String]()
            for string0 in addressAllocationIdsContainer {
                if let string0 = string0 {
                    addressAllocationIdsDecoded0?.append(string0)
                }
            }
        }
        addressAllocationIds = addressAllocationIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension TransferClientTypes {
    /// The virtual private cloud (VPC) endpoint settings that are configured for your file transfer protocol-enabled server. With a VPC endpoint, you can restrict access to your server and resources only within your VPC. To control incoming internet traffic, invoke the UpdateServer API and attach an Elastic IP address to your server's endpoint. After May 19, 2021, you won't be able to create a server using EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount if your account hasn't already done so before May 19, 2021. If you have already created servers with EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount on or before May 19, 2021, you will not be affected. After this date, use EndpointType=VPC. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.
    public struct EndpointDetails: Swift.Equatable {
        /// A list of address allocation IDs that are required to attach an Elastic IP address to your server's endpoint. This property can only be set when EndpointType is set to VPC and it is only valid in the UpdateServer API.
        public var addressAllocationIds: [Swift.String]?
        /// A list of security groups IDs that are available to attach to your server's endpoint. This property can only be set when EndpointType is set to VPC. You can edit the SecurityGroupIds property in the [UpdateServer](https://docs.aws.amazon.com/transfer/latest/userguide/API_UpdateServer.html) API only if you are changing the EndpointType from PUBLIC or VPC_ENDPOINT to VPC. To change security groups associated with your server's VPC endpoint after creation, use the Amazon EC2 [ModifyVpcEndpoint](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyVpcEndpoint.html) API.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs that are required to host your server endpoint in your VPC. This property can only be set when EndpointType is set to VPC.
        public var subnetIds: [Swift.String]?
        /// The identifier of the VPC endpoint. This property can only be set when EndpointType is set to VPC_ENDPOINT. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.
        public var vpcEndpointId: Swift.String?
        /// The VPC identifier of the VPC in which a server's endpoint will be hosted. This property can only be set when EndpointType is set to VPC.
        public var vpcId: Swift.String?

        public init (
            addressAllocationIds: [Swift.String]? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.addressAllocationIds = addressAllocationIds
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }

}

extension TransferClientTypes {
    public enum EndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `public`
        case vpc
        case vpcEndpoint
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .public,
                .vpc,
                .vpcEndpoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .public: return "PUBLIC"
            case .vpc: return "VPC"
            case .vpcEndpoint: return "VPC_ENDPOINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointType(rawValue: rawValue) ?? EndpointType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.ExecutionError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the error message and type, for an error that occurs during the execution of the workflow.
    public struct ExecutionError: Swift.Equatable {
        /// Specifies the descriptive message that corresponds to the ErrorType.
        /// This member is required.
        public var message: Swift.String?
        /// Specifies the error type.
        ///
        /// * ALREADY_EXISTS: occurs for a copy step, if the overwrite option is not selected and a file with the same name already exists in the target location.
        ///
        /// * BAD_REQUEST: a general bad request: for example, a step that attempts to tag an EFS file returns BAD_REQUEST, as only S3 files can be tagged.
        ///
        /// * CUSTOM_STEP_FAILED: occurs when the custom step provided a callback that indicates failure.
        ///
        /// * INTERNAL_SERVER_ERROR: a catch-all error that can occur for a variety of reasons.
        ///
        /// * NOT_FOUND: occurs when a requested entity, for example a source file for a copy step, does not exist.
        ///
        /// * PERMISSION_DENIED: occurs if your policy does not contain the correct permissions to complete one or more of the steps in the workflow.
        ///
        /// * TIMEOUT: occurs when the execution times out. You can set the TimeoutSeconds for a custom step, anywhere from 1 second to 1800 seconds (30 minutes).
        ///
        /// * THROTTLED: occurs if you exceed the new execution refill rate of one workflow per second.
        /// This member is required.
        public var type: TransferClientTypes.ExecutionErrorType?

        public init (
            message: Swift.String? = nil,
            type: TransferClientTypes.ExecutionErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension TransferClientTypes {
    public enum ExecutionErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alreadyExists
        case badRequest
        case customStepFailed
        case internalServerError
        case notFound
        case permissionDenied
        case throttled
        case timeout
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionErrorType] {
            return [
                .alreadyExists,
                .badRequest,
                .customStepFailed,
                .internalServerError,
                .notFound,
                .permissionDenied,
                .throttled,
                .timeout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alreadyExists: return "ALREADY_EXISTS"
            case .badRequest: return "BAD_REQUEST"
            case .customStepFailed: return "CUSTOM_STEP_FAILED"
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case .notFound: return "NOT_FOUND"
            case .permissionDenied: return "PERMISSION_DENIED"
            case .throttled: return "THROTTLED"
            case .timeout: return "TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionErrorType(rawValue: rawValue) ?? ExecutionErrorType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.ExecutionResults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case onExceptionSteps = "OnExceptionSteps"
        case steps = "Steps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onExceptionSteps = onExceptionSteps {
            var onExceptionStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .onExceptionSteps)
            for executionstepresult0 in onExceptionSteps {
                try onExceptionStepsContainer.encode(executionstepresult0)
            }
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for executionstepresult0 in steps {
                try stepsContainer.encode(executionstepresult0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ExecutionStepResult?].self, forKey: .steps)
        var stepsDecoded0:[TransferClientTypes.ExecutionStepResult]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [TransferClientTypes.ExecutionStepResult]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let onExceptionStepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ExecutionStepResult?].self, forKey: .onExceptionSteps)
        var onExceptionStepsDecoded0:[TransferClientTypes.ExecutionStepResult]? = nil
        if let onExceptionStepsContainer = onExceptionStepsContainer {
            onExceptionStepsDecoded0 = [TransferClientTypes.ExecutionStepResult]()
            for structure0 in onExceptionStepsContainer {
                if let structure0 = structure0 {
                    onExceptionStepsDecoded0?.append(structure0)
                }
            }
        }
        onExceptionSteps = onExceptionStepsDecoded0
    }
}

extension TransferClientTypes {
    /// Specifies the steps in the workflow, as well as the steps to execute in case of any errors during workflow execution.
    public struct ExecutionResults: Swift.Equatable {
        /// Specifies the steps (actions) to take if errors are encountered during execution of the workflow.
        public var onExceptionSteps: [TransferClientTypes.ExecutionStepResult]?
        /// Specifies the details for the steps that are in the specified workflow.
        public var steps: [TransferClientTypes.ExecutionStepResult]?

        public init (
            onExceptionSteps: [TransferClientTypes.ExecutionStepResult]? = nil,
            steps: [TransferClientTypes.ExecutionStepResult]? = nil
        )
        {
            self.onExceptionSteps = onExceptionSteps
            self.steps = steps
        }
    }

}

extension TransferClientTypes {
    public enum ExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case exception
        case handlingException
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .completed,
                .exception,
                .handlingException,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .exception: return "EXCEPTION"
            case .handlingException: return "HANDLING_EXCEPTION"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionStatus(rawValue: rawValue) ?? ExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.ExecutionStepResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case outputs = "Outputs"
        case stepType = "StepType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let outputs = self.outputs {
            try encodeContainer.encode(outputs, forKey: .outputs)
        }
        if let stepType = self.stepType {
            try encodeContainer.encode(stepType.rawValue, forKey: .stepType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowStepType.self, forKey: .stepType)
        stepType = stepTypeDecoded
        let outputsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputs)
        outputs = outputsDecoded
        let errorDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionError.self, forKey: .error)
        error = errorDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the following details for the step: error (if any), outputs (if any), and the step type.
    public struct ExecutionStepResult: Swift.Equatable {
        /// Specifies the details for an error, if it occurred during execution of the specified workflow step.
        public var error: TransferClientTypes.ExecutionError?
        /// The values for the key/value pair applied as a tag to the file. Only applicable if the step type is TAG.
        public var outputs: Swift.String?
        /// One of the available step types.
        ///
        /// * COPY - Copy the file to another location.
        ///
        /// * CUSTOM - Perform a custom step with an Lambda function target.
        ///
        /// * DECRYPT - Decrypt a file that was encrypted before it was uploaded.
        ///
        /// * DELETE - Delete the file.
        ///
        /// * TAG - Add a tag to the file.
        public var stepType: TransferClientTypes.WorkflowStepType?

        public init (
            error: TransferClientTypes.ExecutionError? = nil,
            outputs: Swift.String? = nil,
            stepType: TransferClientTypes.WorkflowStepType? = nil
        )
        {
            self.error = error
            self.outputs = outputs
            self.stepType = stepType
        }
    }

}

extension TransferClientTypes.FileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case efsFileLocation = "EfsFileLocation"
        case s3FileLocation = "S3FileLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let efsFileLocation = self.efsFileLocation {
            try encodeContainer.encode(efsFileLocation, forKey: .efsFileLocation)
        }
        if let s3FileLocation = self.s3FileLocation {
            try encodeContainer.encode(s3FileLocation, forKey: .s3FileLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3FileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.S3FileLocation.self, forKey: .s3FileLocation)
        s3FileLocation = s3FileLocationDecoded
        let efsFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EfsFileLocation.self, forKey: .efsFileLocation)
        efsFileLocation = efsFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the Amazon S3 or EFS file details to be used in the step.
    public struct FileLocation: Swift.Equatable {
        /// Specifies the Amazon EFS identifier and the path for the file being used.
        public var efsFileLocation: TransferClientTypes.EfsFileLocation?
        /// Specifies the S3 details for the file being used, such as bucket, ETag, and so forth.
        public var s3FileLocation: TransferClientTypes.S3FileLocation?

        public init (
            efsFileLocation: TransferClientTypes.EfsFileLocation? = nil,
            s3FileLocation: TransferClientTypes.S3FileLocation? = nil
        )
        {
            self.efsFileLocation = efsFileLocation
            self.s3FileLocation = s3FileLocation
        }
    }

}

extension TransferClientTypes.HomeDirectoryMapEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entry = "Entry"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entry = self.entry {
            try encodeContainer.encode(entry, forKey: .entry)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entry)
        entry = entryDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension TransferClientTypes {
    /// Represents an object that contains entries and targets for HomeDirectoryMappings. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public struct HomeDirectoryMapEntry: Swift.Equatable {
        /// Represents an entry for HomeDirectoryMappings.
        /// This member is required.
        public var entry: Swift.String?
        /// Represents the map target that is used in a HomeDirectorymapEntry.
        /// This member is required.
        public var target: Swift.String?

        public init (
            entry: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.entry = entry
            self.target = target
        }
    }

}

extension TransferClientTypes {
    public enum HomeDirectoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case logical
        case path
        case sdkUnknown(Swift.String)

        public static var allCases: [HomeDirectoryType] {
            return [
                .logical,
                .path,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .logical: return "LOGICAL"
            case .path: return "PATH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HomeDirectoryType(rawValue: rawValue) ?? HomeDirectoryType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.IdentityProviderDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case function = "Function"
        case invocationRole = "InvocationRole"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let function = self.function {
            try encodeContainer.encode(function, forKey: .function)
        }
        if let invocationRole = self.invocationRole {
            try encodeContainer.encode(invocationRole, forKey: .invocationRole)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let invocationRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationRole)
        invocationRole = invocationRoleDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let functionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .function)
        function = functionDecoded
    }
}

extension TransferClientTypes {
    /// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. A server can have only one method of authentication.
    public struct IdentityProviderDetails: Swift.Equatable {
        /// The identifier of the Directory Service directory that you want to stop sharing.
        public var directoryId: Swift.String?
        /// The ARN for a lambda function to use for the Identity provider.
        public var function: Swift.String?
        /// Provides the type of InvocationRole used to authenticate the user account.
        public var invocationRole: Swift.String?
        /// Provides the location of the service endpoint used to authenticate users.
        public var url: Swift.String?

        public init (
            directoryId: Swift.String? = nil,
            function: Swift.String? = nil,
            invocationRole: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.directoryId = directoryId
            self.function = function
            self.invocationRole = invocationRole
            self.url = url
        }
    }

}

extension TransferClientTypes {
    /// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. For AWS_DIRECTORY_SERVICE or SERVICE_MANAGED authentication, the Secure Shell (SSH) public keys are stored with a user on the server instance. For API_GATEWAY authentication, your custom authentication method is implemented by using an API call. The server can have only one method of authentication.
    public enum IdentityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiGateway
        case awsDirectoryService
        case awsLambda
        case serviceManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityProviderType] {
            return [
                .apiGateway,
                .awsDirectoryService,
                .awsLambda,
                .serviceManaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiGateway: return "API_GATEWAY"
            case .awsDirectoryService: return "AWS_DIRECTORY_SERVICE"
            case .awsLambda: return "AWS_LAMBDA"
            case .serviceManaged: return "SERVICE_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityProviderType(rawValue: rawValue) ?? IdentityProviderType.sdkUnknown(rawValue)
        }
    }
}

extension ImportCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportCertificateInput(activeDate: \(Swift.String(describing: activeDate)), description: \(Swift.String(describing: description)), inactiveDate: \(Swift.String(describing: inactiveDate)), tags: \(Swift.String(describing: tags)), usage: \(Swift.String(describing: usage)), certificate: \"CONTENT_REDACTED\", certificateChain: \"CONTENT_REDACTED\", privateKey: \"CONTENT_REDACTED\")"}
}

extension ImportCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDate = "ActiveDate"
        case certificate = "Certificate"
        case certificateChain = "CertificateChain"
        case description = "Description"
        case inactiveDate = "InactiveDate"
        case privateKey = "PrivateKey"
        case tags = "Tags"
        case usage = "Usage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDate = self.activeDate {
            try encodeContainer.encodeTimestamp(activeDate, format: .epochSeconds, forKey: .activeDate)
        }
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let certificateChain = self.certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inactiveDate = self.inactiveDate {
            try encodeContainer.encodeTimestamp(inactiveDate, format: .epochSeconds, forKey: .inactiveDate)
        }
        if let privateKey = self.privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let usage = self.usage {
            try encodeContainer.encode(usage.rawValue, forKey: .usage)
        }
    }
}

extension ImportCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportCertificateInput: Swift.Equatable {
    /// An optional date that specifies when the certificate becomes active.
    public var activeDate: ClientRuntime.Date?
    /// * For the CLI, provide a file path for a certificate in URI format. For example, --certificate file://encryption-cert.pem. Alternatively, you can provide the raw content.
    ///
    /// * For the SDK, specify the raw content of a certificate file. For example, --certificate "`cat encryption-cert.pem`".
    /// This member is required.
    public var certificate: Swift.String?
    /// An optional list of certificates that make up the chain for the certificate that's being imported.
    public var certificateChain: Swift.String?
    /// A short description that helps identify the certificate.
    public var description: Swift.String?
    /// An optional date that specifies when the certificate becomes inactive.
    public var inactiveDate: ClientRuntime.Date?
    /// * For the CLI, provide a file path for a private key in URI format.For example, --private-key file://encryption-key.pem. Alternatively, you can provide the raw content of the private key file.
    ///
    /// * For the SDK, specify the raw content of a private key file. For example, --private-key "`cat encryption-key.pem`"
    public var privateKey: Swift.String?
    /// Key-value pairs that can be used to group and search for certificates.
    public var tags: [TransferClientTypes.Tag]?
    /// Specifies whether this certificate is used for signing or encryption.
    /// This member is required.
    public var usage: TransferClientTypes.CertificateUsageType?

    public init (
        activeDate: ClientRuntime.Date? = nil,
        certificate: Swift.String? = nil,
        certificateChain: Swift.String? = nil,
        description: Swift.String? = nil,
        inactiveDate: ClientRuntime.Date? = nil,
        privateKey: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        usage: TransferClientTypes.CertificateUsageType? = nil
    )
    {
        self.activeDate = activeDate
        self.certificate = certificate
        self.certificateChain = certificateChain
        self.description = description
        self.inactiveDate = inactiveDate
        self.privateKey = privateKey
        self.tags = tags
        self.usage = usage
    }
}

struct ImportCertificateInputBody: Swift.Equatable {
    let usage: TransferClientTypes.CertificateUsageType?
    let certificate: Swift.String?
    let certificateChain: Swift.String?
    let privateKey: Swift.String?
    let activeDate: ClientRuntime.Date?
    let inactiveDate: ClientRuntime.Date?
    let description: Swift.String?
    let tags: [TransferClientTypes.Tag]?
}

extension ImportCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDate = "ActiveDate"
        case certificate = "Certificate"
        case certificateChain = "CertificateChain"
        case description = "Description"
        case inactiveDate = "InactiveDate"
        case privateKey = "PrivateKey"
        case tags = "Tags"
        case usage = "Usage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CertificateUsageType.self, forKey: .usage)
        usage = usageDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
        let activeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .activeDate)
        activeDate = activeDateDecoded
        let inactiveDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .inactiveDate)
        inactiveDate = inactiveDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportCertificateOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificateId = output.certificateId
        } else {
            self.certificateId = nil
        }
    }
}

public struct ImportCertificateOutputResponse: Swift.Equatable {
    /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
    /// This member is required.
    public var certificateId: Swift.String?

    public init (
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct ImportCertificateOutputResponseBody: Swift.Equatable {
    let certificateId: Swift.String?
}

extension ImportCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

extension ImportHostKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportHostKeyInput(description: \(Swift.String(describing: description)), serverId: \(Swift.String(describing: serverId)), tags: \(Swift.String(describing: tags)), hostKeyBody: \"CONTENT_REDACTED\")"}
}

extension ImportHostKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hostKeyBody = "HostKeyBody"
        case serverId = "ServerId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hostKeyBody = self.hostKeyBody {
            try encodeContainer.encode(hostKeyBody, forKey: .hostKeyBody)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension ImportHostKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportHostKeyInput: Swift.Equatable {
    /// The text description that identifies this host key.
    public var description: Swift.String?
    /// The private key portion of an SSH key pair. Transfer Family accepts RSA, ECDSA, and ED25519 keys.
    /// This member is required.
    public var hostKeyBody: Swift.String?
    /// The identifier of the server that contains the host key that you are importing.
    /// This member is required.
    public var serverId: Swift.String?
    /// Key-value pairs that can be used to group and search for host keys.
    public var tags: [TransferClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        hostKeyBody: Swift.String? = nil,
        serverId: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.hostKeyBody = hostKeyBody
        self.serverId = serverId
        self.tags = tags
    }
}

struct ImportHostKeyInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let hostKeyBody: Swift.String?
    let description: Swift.String?
    let tags: [TransferClientTypes.Tag]?
}

extension ImportHostKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hostKeyBody = "HostKeyBody"
        case serverId = "ServerId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let hostKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyBody)
        hostKeyBody = hostKeyBodyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportHostKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportHostKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportHostKeyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportHostKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportHostKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hostKeyId = output.hostKeyId
            self.serverId = output.serverId
        } else {
            self.hostKeyId = nil
            self.serverId = nil
        }
    }
}

public struct ImportHostKeyOutputResponse: Swift.Equatable {
    /// Returns the host key identifier for the imported key.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// Returns the server identifier that contains the imported key.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

struct ImportHostKeyOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let hostKeyId: Swift.String?
}

extension ImportHostKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let hostKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyId)
        hostKeyId = hostKeyIdDecoded
    }
}

extension ImportSshPublicKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyBody = self.sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension ImportSshPublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportSshPublicKeyInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server.
    /// This member is required.
    public var serverId: Swift.String?
    /// The public key portion of an SSH key pair. Transfer Family accepts RSA, ECDSA, and ED25519 keys.
    /// This member is required.
    public var sshPublicKeyBody: Swift.String?
    /// The name of the user account that is assigned to one or more servers.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        sshPublicKeyBody: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyBody = sshPublicKeyBody
        self.userName = userName
    }
}

struct ImportSshPublicKeyInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let sshPublicKeyBody: Swift.String?
    let userName: Swift.String?
}

extension ImportSshPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension ImportSshPublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportSshPublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportSshPublicKeyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportSshPublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportSshPublicKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.sshPublicKeyId = output.sshPublicKeyId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.sshPublicKeyId = nil
            self.userName = nil
        }
    }
}

/// Identifies the user, the server they belong to, and the identifier of the SSH public key associated with that user. A user can have more than one key on each server that they are associated with.
public struct ImportSshPublicKeyOutputResponse: Swift.Equatable {
    /// A system-assigned unique identifier for a server.
    /// This member is required.
    public var serverId: Swift.String?
    /// The name given to a public key by the system that was imported.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// A user name assigned to the ServerID value that you specified.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

struct ImportSshPublicKeyOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let sshPublicKeyId: Swift.String?
    let userName: Swift.String?
}

extension ImportSshPublicKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension TransferClientTypes.InputFileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case efsFileLocation = "EfsFileLocation"
        case s3FileLocation = "S3FileLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let efsFileLocation = self.efsFileLocation {
            try encodeContainer.encode(efsFileLocation, forKey: .efsFileLocation)
        }
        if let s3FileLocation = self.s3FileLocation {
            try encodeContainer.encode(s3FileLocation, forKey: .s3FileLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3FileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.S3InputFileLocation.self, forKey: .s3FileLocation)
        s3FileLocation = s3FileLocationDecoded
        let efsFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EfsFileLocation.self, forKey: .efsFileLocation)
        efsFileLocation = efsFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the location for the file that's being processed.
    public struct InputFileLocation: Swift.Equatable {
        /// Specifies the details for the Amazon Elastic File System (Amazon EFS) file that's being decrypted.
        public var efsFileLocation: TransferClientTypes.EfsFileLocation?
        /// Specifies the details for the Amazon S3 file that's being copied or decrypted.
        public var s3FileLocation: TransferClientTypes.S3InputFileLocation?

        public init (
            efsFileLocation: TransferClientTypes.EfsFileLocation? = nil,
            s3FileLocation: TransferClientTypes.S3InputFileLocation? = nil
        )
        {
            self.efsFileLocation = efsFileLocation
            self.s3FileLocation = s3FileLocation
        }
    }

}

extension InternalServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when an error occurs in the Amazon Web ServicesTransfer Family service.
public struct InternalServiceError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The NextToken parameter that was passed is invalid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the client submits a malformed request.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccessesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension ListAccessesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccessesInput: Swift.Equatable {
    /// Specifies the maximum number of access SIDs to return.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListAccesses call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional accesses.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that has users assigned to it.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListAccessesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let serverId: Swift.String?
}

extension ListAccessesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension ListAccessesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAccessesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAccessesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accesses = output.accesses
            self.nextToken = output.nextToken
            self.serverId = output.serverId
        } else {
            self.accesses = nil
            self.nextToken = nil
            self.serverId = nil
        }
    }
}

public struct ListAccessesOutputResponse: Swift.Equatable {
    /// Returns the accesses and their properties for the ServerId value that you specify.
    /// This member is required.
    public var accesses: [TransferClientTypes.ListedAccess]?
    /// When you can get additional results from the ListAccesses call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional accesses.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that has users assigned to it.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        accesses: [TransferClientTypes.ListedAccess]? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.accesses = accesses
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListAccessesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serverId: Swift.String?
    let accesses: [TransferClientTypes.ListedAccess]?
}

extension ListAccessesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accesses = "Accesses"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let accessesContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedAccess?].self, forKey: .accesses)
        var accessesDecoded0:[TransferClientTypes.ListedAccess]? = nil
        if let accessesContainer = accessesContainer {
            accessesDecoded0 = [TransferClientTypes.ListedAccess]()
            for structure0 in accessesContainer {
                if let structure0 = structure0 {
                    accessesDecoded0?.append(structure0)
                }
            }
        }
        accesses = accessesDecoded0
    }
}

extension ListAgreementsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension ListAgreementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAgreementsInput: Swift.Equatable {
    /// The maximum number of agreements to return.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListAgreements call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional agreements.
    public var nextToken: Swift.String?
    /// The identifier of the server for which you want a list of agreements.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListAgreementsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let serverId: Swift.String?
}

extension ListAgreementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension ListAgreementsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAgreementsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAgreementsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAgreementsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAgreementsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agreements = output.agreements
            self.nextToken = output.nextToken
        } else {
            self.agreements = nil
            self.nextToken = nil
        }
    }
}

public struct ListAgreementsOutputResponse: Swift.Equatable {
    /// Returns an array, where each item contains the details of an agreement.
    /// This member is required.
    public var agreements: [TransferClientTypes.ListedAgreement]?
    /// Returns a token that you can use to call ListAgreements again and receive additional results, if there are any.
    public var nextToken: Swift.String?

    public init (
        agreements: [TransferClientTypes.ListedAgreement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agreements = agreements
        self.nextToken = nextToken
    }
}

struct ListAgreementsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let agreements: [TransferClientTypes.ListedAgreement]?
}

extension ListAgreementsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreements = "Agreements"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let agreementsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedAgreement?].self, forKey: .agreements)
        var agreementsDecoded0:[TransferClientTypes.ListedAgreement]? = nil
        if let agreementsContainer = agreementsContainer {
            agreementsDecoded0 = [TransferClientTypes.ListedAgreement]()
            for structure0 in agreementsContainer {
                if let structure0 = structure0 {
                    agreementsDecoded0?.append(structure0)
                }
            }
        }
        agreements = agreementsDecoded0
    }
}

extension ListCertificatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCertificatesInput: Swift.Equatable {
    /// The maximum number of certificates to return.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListCertificates call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional certificates.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCertificatesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCertificatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCertificatesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificates = output.certificates
            self.nextToken = output.nextToken
        } else {
            self.certificates = nil
            self.nextToken = nil
        }
    }
}

public struct ListCertificatesOutputResponse: Swift.Equatable {
    /// Returns an array of the certificates that are specified in the ListCertificates call.
    /// This member is required.
    public var certificates: [TransferClientTypes.ListedCertificate]?
    /// Returns the next token, which you can use to list the next certificate.
    public var nextToken: Swift.String?

    public init (
        certificates: [TransferClientTypes.ListedCertificate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.nextToken = nextToken
    }
}

struct ListCertificatesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let certificates: [TransferClientTypes.ListedCertificate]?
}

extension ListCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificates = "Certificates"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let certificatesContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedCertificate?].self, forKey: .certificates)
        var certificatesDecoded0:[TransferClientTypes.ListedCertificate]? = nil
        if let certificatesContainer = certificatesContainer {
            certificatesDecoded0 = [TransferClientTypes.ListedCertificate]()
            for structure0 in certificatesContainer {
                if let structure0 = structure0 {
                    certificatesDecoded0?.append(structure0)
                }
            }
        }
        certificates = certificatesDecoded0
    }
}

extension ListConnectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListConnectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListConnectorsInput: Swift.Equatable {
    /// The maximum number of connectors to return.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListConnectors call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional connectors.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectorsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListConnectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListConnectorsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListConnectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectors = output.connectors
            self.nextToken = output.nextToken
        } else {
            self.connectors = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectorsOutputResponse: Swift.Equatable {
    /// Returns an array, where each item contains the details of a connector.
    /// This member is required.
    public var connectors: [TransferClientTypes.ListedConnector]?
    /// Returns a token that you can use to call ListConnectors again and receive additional results, if there are any.
    public var nextToken: Swift.String?

    public init (
        connectors: [TransferClientTypes.ListedConnector]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectors = connectors
        self.nextToken = nextToken
    }
}

struct ListConnectorsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let connectors: [TransferClientTypes.ListedConnector]?
}

extension ListConnectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectors = "Connectors"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let connectorsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedConnector?].self, forKey: .connectors)
        var connectorsDecoded0:[TransferClientTypes.ListedConnector]? = nil
        if let connectorsContainer = connectorsContainer {
            connectorsDecoded0 = [TransferClientTypes.ListedConnector]()
            for structure0 in connectorsContainer {
                if let structure0 = structure0 {
                    connectorsDecoded0?.append(structure0)
                }
            }
        }
        connectors = connectorsDecoded0
    }
}

extension ListExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension ListExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListExecutionsInput: Swift.Equatable {
    /// Specifies the maximum number of executions to return.
    public var maxResults: Swift.Int?
    /// ListExecutions returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional executions. This is useful for pagination, for instance. If you have 100 executions for a workflow, you might only want to list first 10. If so, call the API by specifying the max-results: aws transfer list-executions --max-results 10 This returns details for the first 10 executions, as well as the pointer (NextToken) to the eleventh execution. You can now call the API again, supplying the NextToken value you received: aws transfer list-executions --max-results 10 --next-token $somePointerReturnedFromPreviousListResult This call returns the next 10 executions, the 11th through the 20th. You can then repeat the call until the details for all 100 executions have been returned.
    public var nextToken: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowId = workflowId
    }
}

struct ListExecutionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let workflowId: Swift.String?
}

extension ListExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

extension ListExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListExecutionsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executions = output.executions
            self.nextToken = output.nextToken
            self.workflowId = output.workflowId
        } else {
            self.executions = nil
            self.nextToken = nil
            self.workflowId = nil
        }
    }
}

public struct ListExecutionsOutputResponse: Swift.Equatable {
    /// Returns the details for each execution.
    ///
    /// * NextToken: returned from a call to several APIs, you can use pass it to a subsequent command to continue listing additional executions.
    ///
    /// * StartTime: timestamp indicating when the execution began.
    ///
    /// * Executions: details of the execution, including the execution ID, initial file location, and Service metadata.
    ///
    /// * Status: one of the following values: IN_PROGRESS, COMPLETED, EXCEPTION, HANDLING_EXEPTION.
    /// This member is required.
    public var executions: [TransferClientTypes.ListedExecution]?
    /// ListExecutions returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional executions.
    public var nextToken: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        executions: [TransferClientTypes.ListedExecution]? = nil,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.executions = executions
        self.nextToken = nextToken
        self.workflowId = workflowId
    }
}

struct ListExecutionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workflowId: Swift.String?
    let executions: [TransferClientTypes.ListedExecution]?
}

extension ListExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executions = "Executions"
        case nextToken = "NextToken"
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let executionsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedExecution?].self, forKey: .executions)
        var executionsDecoded0:[TransferClientTypes.ListedExecution]? = nil
        if let executionsContainer = executionsContainer {
            executionsDecoded0 = [TransferClientTypes.ListedExecution]()
            for structure0 in executionsContainer {
                if let structure0 = structure0 {
                    executionsDecoded0?.append(structure0)
                }
            }
        }
        executions = executionsDecoded0
    }
}

extension ListHostKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension ListHostKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListHostKeysInput: Swift.Equatable {
    /// The maximum number of host keys to return.
    public var maxResults: Swift.Int?
    /// When there are additional results that were not returned, a NextToken parameter is returned. You can use that value for a subsequent call to ListHostKeys to continue listing results.
    public var nextToken: Swift.String?
    /// The identifier of the server that contains the host keys that you want to view.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListHostKeysInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let serverId: Swift.String?
}

extension ListHostKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension ListHostKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHostKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListHostKeysOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHostKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListHostKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hostKeys = output.hostKeys
            self.nextToken = output.nextToken
            self.serverId = output.serverId
        } else {
            self.hostKeys = nil
            self.nextToken = nil
            self.serverId = nil
        }
    }
}

public struct ListHostKeysOutputResponse: Swift.Equatable {
    /// Returns an array, where each item contains the details of a host key.
    /// This member is required.
    public var hostKeys: [TransferClientTypes.ListedHostKey]?
    /// Returns a token that you can use to call ListHostKeys again and receive additional results, if there are any.
    public var nextToken: Swift.String?
    /// Returns the server identifier that contains the listed host keys.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        hostKeys: [TransferClientTypes.ListedHostKey]? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeys = hostKeys
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListHostKeysOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serverId: Swift.String?
    let hostKeys: [TransferClientTypes.ListedHostKey]?
}

extension ListHostKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKeys = "HostKeys"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let hostKeysContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedHostKey?].self, forKey: .hostKeys)
        var hostKeysDecoded0:[TransferClientTypes.ListedHostKey]? = nil
        if let hostKeysContainer = hostKeysContainer {
            hostKeysDecoded0 = [TransferClientTypes.ListedHostKey]()
            for structure0 in hostKeysContainer {
                if let structure0 = structure0 {
                    hostKeysDecoded0?.append(structure0)
                }
            }
        }
        hostKeys = hostKeysDecoded0
    }
}

extension ListProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case profileType = "ProfileType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let profileType = self.profileType {
            try encodeContainer.encode(profileType.rawValue, forKey: .profileType)
        }
    }
}

extension ListProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProfilesInput: Swift.Equatable {
    /// The maximum number of profiles to return.
    public var maxResults: Swift.Int?
    /// When there are additional results that were not returned, a NextToken parameter is returned. You can use that value for a subsequent call to ListProfiles to continue listing results.
    public var nextToken: Swift.String?
    /// Indicates whether to list only LOCAL type profiles or only PARTNER type profiles. If not supplied in the request, the command lists all types of profiles.
    public var profileType: TransferClientTypes.ProfileType?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileType: TransferClientTypes.ProfileType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileType = profileType
    }
}

struct ListProfilesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let profileType: TransferClientTypes.ProfileType?
}

extension ListProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case profileType = "ProfileType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let profileTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProfileType.self, forKey: .profileType)
        profileType = profileTypeDecoded
    }
}

extension ListProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProfilesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profiles = output.profiles
        } else {
            self.nextToken = nil
            self.profiles = nil
        }
    }
}

public struct ListProfilesOutputResponse: Swift.Equatable {
    /// Returns a token that you can use to call ListProfiles again and receive additional results, if there are any.
    public var nextToken: Swift.String?
    /// Returns an array, where each item contains the details of a profile.
    /// This member is required.
    public var profiles: [TransferClientTypes.ListedProfile]?

    public init (
        nextToken: Swift.String? = nil,
        profiles: [TransferClientTypes.ListedProfile]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

struct ListProfilesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let profiles: [TransferClientTypes.ListedProfile]?
}

extension ListProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case profiles = "Profiles"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let profilesContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedProfile?].self, forKey: .profiles)
        var profilesDecoded0:[TransferClientTypes.ListedProfile]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [TransferClientTypes.ListedProfile]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
    }
}

extension ListSecurityPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSecurityPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSecurityPoliciesInput: Swift.Equatable {
    /// Specifies the number of security policies to return as a response to the ListSecurityPolicies query.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the ListSecurityPolicies command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional security policies.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSecurityPoliciesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSecurityPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSecurityPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecurityPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSecurityPoliciesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecurityPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSecurityPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityPolicyNames = output.securityPolicyNames
        } else {
            self.nextToken = nil
            self.securityPolicyNames = nil
        }
    }
}

public struct ListSecurityPoliciesOutputResponse: Swift.Equatable {
    /// When you can get additional results from the ListSecurityPolicies operation, a NextToken parameter is returned in the output. In a following command, you can pass in the NextToken parameter to continue listing security policies.
    public var nextToken: Swift.String?
    /// An array of security policies that were listed.
    /// This member is required.
    public var securityPolicyNames: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        securityPolicyNames: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityPolicyNames = securityPolicyNames
    }
}

struct ListSecurityPoliciesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let securityPolicyNames: [Swift.String]?
}

extension ListSecurityPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case securityPolicyNames = "SecurityPolicyNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let securityPolicyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityPolicyNames)
        var securityPolicyNamesDecoded0:[Swift.String]? = nil
        if let securityPolicyNamesContainer = securityPolicyNamesContainer {
            securityPolicyNamesDecoded0 = [Swift.String]()
            for string0 in securityPolicyNamesContainer {
                if let string0 = string0 {
                    securityPolicyNamesDecoded0?.append(string0)
                }
            }
        }
        securityPolicyNames = securityPolicyNamesDecoded0
    }
}

extension ListServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListServersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServersInput: Swift.Equatable {
    /// Specifies the number of servers to return as a response to the ListServers query.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the ListServers command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional servers.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListServersOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListServersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.servers = output.servers
        } else {
            self.nextToken = nil
            self.servers = nil
        }
    }
}

public struct ListServersOutputResponse: Swift.Equatable {
    /// When you can get additional results from the ListServers operation, a NextToken parameter is returned in the output. In a following command, you can pass in the NextToken parameter to continue listing additional servers.
    public var nextToken: Swift.String?
    /// An array of servers that were listed.
    /// This member is required.
    public var servers: [TransferClientTypes.ListedServer]?

    public init (
        nextToken: Swift.String? = nil,
        servers: [TransferClientTypes.ListedServer]? = nil
    )
    {
        self.nextToken = nextToken
        self.servers = servers
    }
}

struct ListServersOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let servers: [TransferClientTypes.ListedServer]?
}

extension ListServersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case servers = "Servers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serversContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedServer?].self, forKey: .servers)
        var serversDecoded0:[TransferClientTypes.ListedServer]? = nil
        if let serversContainer = serversContainer {
            serversDecoded0 = [TransferClientTypes.ListedServer]()
            for structure0 in serversContainer {
                if let structure0 = structure0 {
                    serversDecoded0?.append(structure0)
                }
            }
        }
        servers = serversDecoded0
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an identifier for a specific Amazon Web Services resource, such as a server, user, or role.
    /// This member is required.
    public var arn: Swift.String?
    /// Specifies the number of tags to return as a response to the ListTagsForResource request.
    public var maxResults: Swift.Int?
    /// When you request additional results from the ListTagsForResource operation, a NextToken parameter is returned in the input. You can then pass in a subsequent command to the NextToken parameter to continue listing additional tags.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.arn = nil
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The ARN you specified to list the tags of.
    public var arn: Swift.String?
    /// When you can get additional results from the ListTagsForResource call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional tags.
    public var nextToken: Swift.String?
    /// Key-value pairs that are assigned to a resource, usually for the purpose of grouping and searching for items. Tags are metadata that you define.
    public var tags: [TransferClientTypes.Tag]?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let nextToken: Swift.String?
    let tags: [TransferClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// Specifies the number of users to return as a response to the ListUsers request.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListUsers call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional users.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that has users assigned to it.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListUsersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let serverId: Swift.String?
}

extension ListUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serverId = output.serverId
            self.users = output.users
        } else {
            self.nextToken = nil
            self.serverId = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutputResponse: Swift.Equatable {
    /// When you can get additional results from the ListUsers call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional users.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that the users are assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// Returns the user accounts and their properties for the ServerId value that you specify.
    /// This member is required.
    public var users: [TransferClientTypes.ListedUser]?

    public init (
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil,
        users: [TransferClientTypes.ListedUser]? = nil
    )
    {
        self.nextToken = nextToken
        self.serverId = serverId
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serverId: Swift.String?
    let users: [TransferClientTypes.ListedUser]?
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serverId = "ServerId"
        case users = "Users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let usersContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedUser?].self, forKey: .users)
        var usersDecoded0:[TransferClientTypes.ListedUser]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [TransferClientTypes.ListedUser]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension ListWorkflowsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorkflowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWorkflowsInput: Swift.Equatable {
    /// Specifies the maximum number of workflows to return.
    public var maxResults: Swift.Int?
    /// ListWorkflows returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional workflows.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkflowsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListWorkflowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkflowsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkflowsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWorkflowsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkflowsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWorkflowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workflows = output.workflows
        } else {
            self.nextToken = nil
            self.workflows = nil
        }
    }
}

public struct ListWorkflowsOutputResponse: Swift.Equatable {
    /// ListWorkflows returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional workflows.
    public var nextToken: Swift.String?
    /// Returns the Arn, WorkflowId, and Description for each workflow.
    /// This member is required.
    public var workflows: [TransferClientTypes.ListedWorkflow]?

    public init (
        nextToken: Swift.String? = nil,
        workflows: [TransferClientTypes.ListedWorkflow]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflows = workflows
    }
}

struct ListWorkflowsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workflows: [TransferClientTypes.ListedWorkflow]?
}

extension ListWorkflowsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workflows = "Workflows"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workflowsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedWorkflow?].self, forKey: .workflows)
        var workflowsDecoded0:[TransferClientTypes.ListedWorkflow]? = nil
        if let workflowsContainer = workflowsContainer {
            workflowsDecoded0 = [TransferClientTypes.ListedWorkflow]()
            for structure0 in workflowsContainer {
                if let structure0 = structure0 {
                    workflowsDecoded0?.append(structure0)
                }
            }
        }
        workflows = workflowsDecoded0
    }
}

extension TransferClientTypes.ListedAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryType = "HomeDirectoryType"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension TransferClientTypes {
    /// Lists the properties for one or more specified associated accesses.
    public struct ListedAccess: Swift.Equatable {
        /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
        public var externalId: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
        public var homeDirectory: Swift.String?
        /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
        public var role: Swift.String?

        public init (
            externalId: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            role: Swift.String? = nil
        )
        {
            self.externalId = externalId
            self.homeDirectory = homeDirectory
            self.homeDirectoryType = homeDirectoryType
            self.role = role
        }
    }

}

extension TransferClientTypes.ListedAgreement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId = "AgreementId"
        case arn = "Arn"
        case description = "Description"
        case localProfileId = "LocalProfileId"
        case partnerProfileId = "PartnerProfileId"
        case serverId = "ServerId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agreementId = self.agreementId {
            try encodeContainer.encode(agreementId, forKey: .agreementId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let localProfileId = self.localProfileId {
            try encodeContainer.encode(localProfileId, forKey: .localProfileId)
        }
        if let partnerProfileId = self.partnerProfileId {
            try encodeContainer.encode(partnerProfileId, forKey: .partnerProfileId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.AgreementStatusType.self, forKey: .status)
        status = statusDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let localProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localProfileId)
        localProfileId = localProfileIdDecoded
        let partnerProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerProfileId)
        partnerProfileId = partnerProfileIdDecoded
    }
}

extension TransferClientTypes {
    /// Describes the properties of an agreement.
    public struct ListedAgreement: Swift.Equatable {
        /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
        public var agreementId: Swift.String?
        /// The Amazon Resource Name (ARN) of the specified agreement.
        public var arn: Swift.String?
        /// The current description for the agreement. You can change it by calling the UpdateAgreement operation and providing a new description.
        public var description: Swift.String?
        /// A unique identifier for the AS2 local profile.
        public var localProfileId: Swift.String?
        /// A unique identifier for the partner profile.
        public var partnerProfileId: Swift.String?
        /// The unique identifier for the agreement.
        public var serverId: Swift.String?
        /// The agreement can be either ACTIVE or INACTIVE.
        public var status: TransferClientTypes.AgreementStatusType?

        public init (
            agreementId: Swift.String? = nil,
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            localProfileId: Swift.String? = nil,
            partnerProfileId: Swift.String? = nil,
            serverId: Swift.String? = nil,
            status: TransferClientTypes.AgreementStatusType? = nil
        )
        {
            self.agreementId = agreementId
            self.arn = arn
            self.description = description
            self.localProfileId = localProfileId
            self.partnerProfileId = partnerProfileId
            self.serverId = serverId
            self.status = status
        }
    }

}

extension TransferClientTypes.ListedCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDate = "ActiveDate"
        case arn = "Arn"
        case certificateId = "CertificateId"
        case description = "Description"
        case inactiveDate = "InactiveDate"
        case status = "Status"
        case type = "Type"
        case usage = "Usage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDate = self.activeDate {
            try encodeContainer.encodeTimestamp(activeDate, format: .epochSeconds, forKey: .activeDate)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inactiveDate = self.inactiveDate {
            try encodeContainer.encodeTimestamp(inactiveDate, format: .epochSeconds, forKey: .inactiveDate)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let usage = self.usage {
            try encodeContainer.encode(usage.rawValue, forKey: .usage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let usageDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CertificateUsageType.self, forKey: .usage)
        usage = usageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CertificateStatusType.self, forKey: .status)
        status = statusDecoded
        let activeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .activeDate)
        activeDate = activeDateDecoded
        let inactiveDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .inactiveDate)
        inactiveDate = inactiveDateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CertificateType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension TransferClientTypes {
    /// Describes the properties of a certificate.
    public struct ListedCertificate: Swift.Equatable {
        /// An optional date that specifies when the certificate becomes active.
        public var activeDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the specified certificate.
        public var arn: Swift.String?
        /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
        public var certificateId: Swift.String?
        /// The name or short description that's used to identify the certificate.
        public var description: Swift.String?
        /// An optional date that specifies when the certificate becomes inactive.
        public var inactiveDate: ClientRuntime.Date?
        /// The certificate can be either ACTIVE, PENDING_ROTATION, or INACTIVE. PENDING_ROTATION means that this certificate will replace the current certificate when it expires.
        public var status: TransferClientTypes.CertificateStatusType?
        /// The type for the certificate. If a private key has been specified for the certificate, its type is CERTIFICATE_WITH_PRIVATE_KEY. If there is no private key, the type is CERTIFICATE.
        public var type: TransferClientTypes.CertificateType?
        /// Specifies whether this certificate is used for signing or encryption.
        public var usage: TransferClientTypes.CertificateUsageType?

        public init (
            activeDate: ClientRuntime.Date? = nil,
            arn: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            description: Swift.String? = nil,
            inactiveDate: ClientRuntime.Date? = nil,
            status: TransferClientTypes.CertificateStatusType? = nil,
            type: TransferClientTypes.CertificateType? = nil,
            usage: TransferClientTypes.CertificateUsageType? = nil
        )
        {
            self.activeDate = activeDate
            self.arn = arn
            self.certificateId = certificateId
            self.description = description
            self.inactiveDate = inactiveDate
            self.status = status
            self.type = type
            self.usage = usage
        }
    }

}

extension TransferClientTypes.ListedConnector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case connectorId = "ConnectorId"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension TransferClientTypes {
    /// Returns details of the connector that is specified.
    public struct ListedConnector: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the specified connector.
        public var arn: Swift.String?
        /// The unique identifier for the connector.
        public var connectorId: Swift.String?
        /// The URL of the partner's AS2 endpoint.
        public var url: Swift.String?

        public init (
            arn: Swift.String? = nil,
            connectorId: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.arn = arn
            self.connectorId = connectorId
            self.url = url
        }
    }

}

extension TransferClientTypes.ListedExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case initialFileLocation = "InitialFileLocation"
        case serviceMetadata = "ServiceMetadata"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let initialFileLocation = self.initialFileLocation {
            try encodeContainer.encode(initialFileLocation, forKey: .initialFileLocation)
        }
        if let serviceMetadata = self.serviceMetadata {
            try encodeContainer.encode(serviceMetadata, forKey: .serviceMetadata)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let initialFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.FileLocation.self, forKey: .initialFileLocation)
        initialFileLocation = initialFileLocationDecoded
        let serviceMetadataDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ServiceMetadata.self, forKey: .serviceMetadata)
        serviceMetadata = serviceMetadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension TransferClientTypes {
    /// Returns properties of the execution that is specified.
    public struct ListedExecution: Swift.Equatable {
        /// A unique identifier for the execution of a workflow.
        public var executionId: Swift.String?
        /// A structure that describes the Amazon S3 or EFS file location. This is the file location when the execution begins: if the file is being copied, this is the initial (as opposed to destination) file location.
        public var initialFileLocation: TransferClientTypes.FileLocation?
        /// A container object for the session details that are associated with a workflow.
        public var serviceMetadata: TransferClientTypes.ServiceMetadata?
        /// The status is one of the execution. Can be in progress, completed, exception encountered, or handling the exception.
        public var status: TransferClientTypes.ExecutionStatus?

        public init (
            executionId: Swift.String? = nil,
            initialFileLocation: TransferClientTypes.FileLocation? = nil,
            serviceMetadata: TransferClientTypes.ServiceMetadata? = nil,
            status: TransferClientTypes.ExecutionStatus? = nil
        )
        {
            self.executionId = executionId
            self.initialFileLocation = initialFileLocation
            self.serviceMetadata = serviceMetadata
            self.status = status
        }
    }

}

extension TransferClientTypes.ListedHostKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dateImported = "DateImported"
        case description = "Description"
        case fingerprint = "Fingerprint"
        case hostKeyId = "HostKeyId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateImported = self.dateImported {
            try encodeContainer.encodeTimestamp(dateImported, format: .epochSeconds, forKey: .dateImported)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fingerprint = self.fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
        if let hostKeyId = self.hostKeyId {
            try encodeContainer.encode(hostKeyId, forKey: .hostKeyId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let hostKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyId)
        hostKeyId = hostKeyIdDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let dateImportedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateImported)
        dateImported = dateImportedDecoded
    }
}

extension TransferClientTypes {
    /// Returns properties of the host key that's specified.
    public struct ListedHostKey: Swift.Equatable {
        /// The unique Amazon Resource Name (ARN) of the host key.
        /// This member is required.
        public var arn: Swift.String?
        /// The date on which the host key was added to the server.
        public var dateImported: ClientRuntime.Date?
        /// The current description for the host key. You can change it by calling the UpdateHostKey operation and providing a new description.
        public var description: Swift.String?
        /// The public key fingerprint, which is a short sequence of bytes used to identify the longer public key.
        public var fingerprint: Swift.String?
        /// A unique identifier for the host key.
        public var hostKeyId: Swift.String?
        /// The encryption algorithm that is used for the host key. The Type parameter is specified by using one of the following values:
        ///
        /// * ssh-rsa
        ///
        /// * ssh-ed25519
        ///
        /// * ecdsa-sha2-nistp256
        ///
        /// * ecdsa-sha2-nistp384
        ///
        /// * ecdsa-sha2-nistp521
        public var type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            dateImported: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            fingerprint: Swift.String? = nil,
            hostKeyId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.dateImported = dateImported
            self.description = description
            self.fingerprint = fingerprint
            self.hostKeyId = hostKeyId
            self.type = type
        }
    }

}

extension TransferClientTypes.ListedProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case as2Id = "As2Id"
        case profileId = "ProfileId"
        case profileType = "ProfileType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let as2Id = self.as2Id {
            try encodeContainer.encode(as2Id, forKey: .as2Id)
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let profileType = self.profileType {
            try encodeContainer.encode(profileType.rawValue, forKey: .profileType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let as2IdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .as2Id)
        as2Id = as2IdDecoded
        let profileTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProfileType.self, forKey: .profileType)
        profileType = profileTypeDecoded
    }
}

extension TransferClientTypes {
    /// Returns the properties of the profile that was specified.
    public struct ListedProfile: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the specified profile.
        public var arn: Swift.String?
        /// The As2Id is the AS2-name, as defined in the [RFC 4130](https://datatracker.ietf.org/doc/html/rfc4130). For inbound transfers, this is the AS2-From header for the AS2 messages sent from the partner. For outbound connectors, this is the AS2-To header for the AS2 messages sent to the partner using the StartFileTransfer API operation. This ID cannot include spaces.
        public var as2Id: Swift.String?
        /// A unique identifier for the local or partner AS2 profile.
        public var profileId: Swift.String?
        /// Indicates whether to list only LOCAL type profiles or only PARTNER type profiles. If not supplied in the request, the command lists all types of profiles.
        public var profileType: TransferClientTypes.ProfileType?

        public init (
            arn: Swift.String? = nil,
            as2Id: Swift.String? = nil,
            profileId: Swift.String? = nil,
            profileType: TransferClientTypes.ProfileType? = nil
        )
        {
            self.arn = arn
            self.as2Id = as2Id
            self.profileId = profileId
            self.profileType = profileType
        }
    }

}

extension TransferClientTypes.ListedServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case domain = "Domain"
        case endpointType = "EndpointType"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case serverId = "ServerId"
        case state = "State"
        case userCount = "UserCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userCount = self.userCount {
            try encodeContainer.encode(userCount, forKey: .userCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let domainDecoded = try containerValues.decodeIfPresent(TransferClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TransferClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let userCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userCount)
        userCount = userCountDecoded
    }
}

extension TransferClientTypes {
    /// Returns properties of a file transfer protocol-enabled server that was specified.
    public struct ListedServer: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) for a server to be listed.
        /// This member is required.
        public var arn: Swift.String?
        /// Specifies the domain of the storage system that is used for file transfers.
        public var domain: TransferClientTypes.Domain?
        /// Specifies the type of VPC endpoint that your server is connected to. If your server is connected to a VPC endpoint, your server isn't accessible over the public internet.
        public var endpointType: TransferClientTypes.EndpointType?
        /// The mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Transfer Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the IdentityProviderDetails parameter. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the IdentityProviderDetails parameter. Use the AWS_LAMBDA value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the Function parameter or the IdentityProviderDetails data type.
        public var identityProviderType: TransferClientTypes.IdentityProviderType?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
        public var loggingRole: Swift.String?
        /// Specifies the unique system assigned identifier for the servers that were listed.
        public var serverId: Swift.String?
        /// The condition of the server that was described. A value of ONLINE indicates that the server can accept jobs and transfer files. A State value of OFFLINE means that the server cannot perform file transfer operations. The states of STARTING and STOPPING indicate that the server is in an intermediate state, either not fully able to respond, or not fully offline. The values of START_FAILED or STOP_FAILED can indicate an error condition.
        public var state: TransferClientTypes.State?
        /// Specifies the number of users that are assigned to a server you specified with the ServerId.
        public var userCount: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            domain: TransferClientTypes.Domain? = nil,
            endpointType: TransferClientTypes.EndpointType? = nil,
            identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
            loggingRole: Swift.String? = nil,
            serverId: Swift.String? = nil,
            state: TransferClientTypes.State? = nil,
            userCount: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.domain = domain
            self.endpointType = endpointType
            self.identityProviderType = identityProviderType
            self.loggingRole = loggingRole
            self.serverId = serverId
            self.state = state
            self.userCount = userCount
        }
    }

}

extension TransferClientTypes.ListedUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryType = "HomeDirectoryType"
        case role = "Role"
        case sshPublicKeyCount = "SshPublicKeyCount"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let sshPublicKeyCount = self.sshPublicKeyCount {
            try encodeContainer.encode(sshPublicKeyCount, forKey: .sshPublicKeyCount)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let sshPublicKeyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sshPublicKeyCount)
        sshPublicKeyCount = sshPublicKeyCountDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension TransferClientTypes {
    /// Returns properties of the user that you specify.
    public struct ListedUser: Swift.Equatable {
        /// Provides the unique Amazon Resource Name (ARN) for the user that you want to learn about.
        /// This member is required.
        public var arn: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
        public var homeDirectory: Swift.String?
        /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests. The IAM role that controls your users' access to your Amazon S3 bucket for servers with Domain=S3, or your EFS file system for servers with Domain=EFS. The policies attached to this role determine the level of access you want to provide your users when transferring files into and out of your S3 buckets or EFS file systems.
        public var role: Swift.String?
        /// Specifies the number of SSH public keys stored for the user you specified.
        public var sshPublicKeyCount: Swift.Int?
        /// Specifies the name of the user whose ARN was specified. User names are used for authentication purposes.
        public var userName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            role: Swift.String? = nil,
            sshPublicKeyCount: Swift.Int? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.homeDirectory = homeDirectory
            self.homeDirectoryType = homeDirectoryType
            self.role = role
            self.sshPublicKeyCount = sshPublicKeyCount
            self.userName = userName
        }
    }

}

extension TransferClientTypes.ListedWorkflow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension TransferClientTypes {
    /// Contains the identifier, text description, and Amazon Resource Name (ARN) for the workflow.
    public struct ListedWorkflow: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) for the workflow.
        public var arn: Swift.String?
        /// Specifies the text description for the workflow.
        public var description: Swift.String?
        /// A unique identifier for the workflow.
        public var workflowId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.workflowId = workflowId
        }
    }

}

extension TransferClientTypes.LoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName = "LogGroupName"
        case loggingRole = "LoggingRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension TransferClientTypes {
    /// Consists of the logging role and the log group name.
    public struct LoggingConfiguration: Swift.Equatable {
        /// The name of the CloudWatch logging group for the Transfer Family server to which this workflow belongs.
        public var logGroupName: Swift.String?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
        public var loggingRole: Swift.String?

        public init (
            logGroupName: Swift.String? = nil,
            loggingRole: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
            self.loggingRole = loggingRole
        }
    }

}

extension TransferClientTypes {
    public enum MdnResponse: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case sync
        case sdkUnknown(Swift.String)

        public static var allCases: [MdnResponse] {
            return [
                .none,
                .sync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .sync: return "SYNC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MdnResponse(rawValue: rawValue) ?? MdnResponse.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum MdnSigningAlg: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case `none`
        case sha1
        case sha256
        case sha384
        case sha512
        case sdkUnknown(Swift.String)

        public static var allCases: [MdnSigningAlg] {
            return [
                .default,
                .none,
                .sha1,
                .sha256,
                .sha384,
                .sha512,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .none: return "NONE"
            case .sha1: return "SHA1"
            case .sha256: return "SHA256"
            case .sha384: return "SHA384"
            case .sha512: return "SHA512"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MdnSigningAlg(rawValue: rawValue) ?? MdnSigningAlg.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum OverwriteExisting: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [OverwriteExisting] {
            return [
                .false,
                .true,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OverwriteExisting(rawValue: rawValue) ?? OverwriteExisting.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.PosixProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gid = "Gid"
        case secondaryGids = "SecondaryGids"
        case uid = "Uid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gid = self.gid {
            try encodeContainer.encode(gid, forKey: .gid)
        }
        if let secondaryGids = secondaryGids {
            var secondaryGidsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryGids)
            for posixid0 in secondaryGids {
                try secondaryGidsContainer.encode(posixid0)
            }
        }
        if let uid = self.uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uid)
        uid = uidDecoded
        let gidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gid)
        gid = gidDecoded
        let secondaryGidsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .secondaryGids)
        var secondaryGidsDecoded0:[Swift.Int]? = nil
        if let secondaryGidsContainer = secondaryGidsContainer {
            secondaryGidsDecoded0 = [Swift.Int]()
            for long0 in secondaryGidsContainer {
                if let long0 = long0 {
                    secondaryGidsDecoded0?.append(long0)
                }
            }
        }
        secondaryGids = secondaryGidsDecoded0
    }
}

extension TransferClientTypes {
    /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public struct PosixProfile: Swift.Equatable {
        /// The POSIX group ID used for all EFS operations by this user.
        /// This member is required.
        public var gid: Swift.Int?
        /// The secondary POSIX group IDs used for all EFS operations by this user.
        public var secondaryGids: [Swift.Int]?
        /// The POSIX user ID used for all EFS operations by this user.
        /// This member is required.
        public var uid: Swift.Int?

        public init (
            gid: Swift.Int? = nil,
            secondaryGids: [Swift.Int]? = nil,
            uid: Swift.Int? = nil
        )
        {
            self.gid = gid
            self.secondaryGids = secondaryGids
            self.uid = uid
        }
    }

}

extension TransferClientTypes {
    public enum ProfileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case local
        case partner
        case sdkUnknown(Swift.String)

        public static var allCases: [ProfileType] {
            return [
                .local,
                .partner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .local: return "LOCAL"
            case .partner: return "PARTNER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProfileType(rawValue: rawValue) ?? ProfileType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case as2
        case ftp
        case ftps
        case sftp
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .as2,
                .ftp,
                .ftps,
                .sftp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .as2: return "AS2"
            case .ftp: return "FTP"
            case .ftps: return "FTPS"
            case .sftp: return "SFTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.ProtocolDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case as2Transports = "As2Transports"
        case passiveIp = "PassiveIp"
        case setStatOption = "SetStatOption"
        case tlsSessionResumptionMode = "TlsSessionResumptionMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let as2Transports = as2Transports {
            var as2TransportsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .as2Transports)
            for as2transport0 in as2Transports {
                try as2TransportsContainer.encode(as2transport0.rawValue)
            }
        }
        if let passiveIp = self.passiveIp {
            try encodeContainer.encode(passiveIp, forKey: .passiveIp)
        }
        if let setStatOption = self.setStatOption {
            try encodeContainer.encode(setStatOption.rawValue, forKey: .setStatOption)
        }
        if let tlsSessionResumptionMode = self.tlsSessionResumptionMode {
            try encodeContainer.encode(tlsSessionResumptionMode.rawValue, forKey: .tlsSessionResumptionMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let passiveIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .passiveIp)
        passiveIp = passiveIpDecoded
        let tlsSessionResumptionModeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.TlsSessionResumptionMode.self, forKey: .tlsSessionResumptionMode)
        tlsSessionResumptionMode = tlsSessionResumptionModeDecoded
        let setStatOptionDecoded = try containerValues.decodeIfPresent(TransferClientTypes.SetStatOption.self, forKey: .setStatOption)
        setStatOption = setStatOptionDecoded
        let as2TransportsContainer = try containerValues.decodeIfPresent([TransferClientTypes.As2Transport?].self, forKey: .as2Transports)
        var as2TransportsDecoded0:[TransferClientTypes.As2Transport]? = nil
        if let as2TransportsContainer = as2TransportsContainer {
            as2TransportsDecoded0 = [TransferClientTypes.As2Transport]()
            for enum0 in as2TransportsContainer {
                if let enum0 = enum0 {
                    as2TransportsDecoded0?.append(enum0)
                }
            }
        }
        as2Transports = as2TransportsDecoded0
    }
}

extension TransferClientTypes {
    /// The protocol settings that are configured for your server.
    public struct ProtocolDetails: Swift.Equatable {
        /// Indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
        public var as2Transports: [TransferClientTypes.As2Transport]?
        /// Indicates passive mode, for FTP and FTPS protocols. Enter a single IPv4 address, such as the public IP address of a firewall, router, or load balancer. For example: aws transfer update-server --protocol-details PassiveIp=0.0.0.0 Replace 0.0.0.0 in the example above with the actual IP address you want to use. If you change the PassiveIp value, you must stop and then restart your Transfer Family server for the change to take effect. For details on using passive mode (PASV) in a NAT environment, see [Configuring your FTPS server behind a firewall or NAT with Transfer Family](http://aws.amazon.com/blogs/storage/configuring-your-ftps-server-behind-a-firewall-or-nat-with-aws-transfer-family/). Special values The AUTO and 0.0.0.0 are special values for the PassiveIp parameter. The value PassiveIp=AUTO is assigned by default to FTP and FTPS type servers. In this case, the server automatically responds with one of the endpoint IPs within the PASV response. PassiveIp=0.0.0.0 has a more unique application for its usage. For example, if you have a High Availability (HA) Network Load Balancer (NLB) environment, where you have 3 subnets, you can only specify a single IP address using the PassiveIp parameter. This reduces the effectiveness of having High Availability. In this case, you can specify PassiveIp=0.0.0.0. This tells the client to use the same IP address as the Control connection and utilize all AZs for their connections. Note, however, that not all FTP clients support the PassiveIp=0.0.0.0 response. FileZilla and WinSCP do support it. If you are using other clients, check to see if your client supports the PassiveIp=0.0.0.0 response.
        public var passiveIp: Swift.String?
        /// Use the SetStatOption to ignore the error that is generated when the client attempts to use SETSTAT on a file you are uploading to an S3 bucket. Some SFTP file transfer clients can attempt to change the attributes of remote files, including timestamp and permissions, using commands, such as SETSTAT when uploading the file. However, these commands are not compatible with object storage systems, such as Amazon S3. Due to this incompatibility, file uploads from these clients can result in errors even when the file is otherwise successfully uploaded. Set the value to ENABLE_NO_OP to have the Transfer Family server ignore the SETSTAT command, and upload files without needing to make any changes to your SFTP client. While the SetStatOptionENABLE_NO_OP setting ignores the error, it does generate a log entry in Amazon CloudWatch Logs, so you can determine when the client is making a SETSTAT call. If you want to preserve the original timestamp for your file, and modify other file attributes using SETSTAT, you can use Amazon EFS as backend storage with Transfer Family.
        public var setStatOption: TransferClientTypes.SetStatOption?
        /// A property used with Transfer Family servers that use the FTPS protocol. TLS Session Resumption provides a mechanism to resume or share a negotiated secret key between the control and data connection for an FTPS session. TlsSessionResumptionMode determines whether or not the server resumes recent, negotiated sessions through a unique session ID. This property is available during CreateServer and UpdateServer calls. If a TlsSessionResumptionMode value is not specified during CreateServer, it is set to ENFORCED by default.
        ///
        /// * DISABLED: the server does not process TLS session resumption client requests and creates a new TLS session for each request.
        ///
        /// * ENABLED: the server processes and accepts clients that are performing TLS session resumption. The server doesn't reject client data connections that do not perform the TLS session resumption client processing.
        ///
        /// * ENFORCED: the server processes and accepts clients that are performing TLS session resumption. The server rejects client data connections that do not perform the TLS session resumption client processing. Before you set the value to ENFORCED, test your clients. Not all FTPS clients perform TLS session resumption. So, if you choose to enforce TLS session resumption, you prevent any connections from FTPS clients that don't perform the protocol negotiation. To determine whether or not you can use the ENFORCED value, you need to test your clients.
        public var tlsSessionResumptionMode: TransferClientTypes.TlsSessionResumptionMode?

        public init (
            as2Transports: [TransferClientTypes.As2Transport]? = nil,
            passiveIp: Swift.String? = nil,
            setStatOption: TransferClientTypes.SetStatOption? = nil,
            tlsSessionResumptionMode: TransferClientTypes.TlsSessionResumptionMode? = nil
        )
        {
            self.as2Transports = as2Transports
            self.passiveIp = passiveIp
            self.setStatOption = setStatOption
            self.tlsSessionResumptionMode = tlsSessionResumptionMode
        }
    }

}

extension ResourceExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resource = output.resource
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resource = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource does not exist.
public struct ResourceExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// This member is required.
    public var resource: Swift.String?
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct ResourceExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resource: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resource = "Resource"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resource = output.resource
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resource = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when a resource is not found by the Amazon Web ServicesTransfer Family service.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// This member is required.
    public var resource: Swift.String?
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resource: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resource = "Resource"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension TransferClientTypes.S3FileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case etag = "Etag"
        case key = "Key"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let etag = self.etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let etagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etag)
        etag = etagDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the details for the file location for the file that's being used in the workflow. Only applicable if you are using S3 storage.
    public struct S3FileLocation: Swift.Equatable {
        /// Specifies the S3 bucket that contains the file being used.
        public var bucket: Swift.String?
        /// The entity tag is a hash of the object. The ETag reflects changes only to the contents of an object, not its metadata.
        public var etag: Swift.String?
        /// The name assigned to the file when it was created in Amazon S3. You use the object key to retrieve the object.
        public var key: Swift.String?
        /// Specifies the file version.
        public var versionId: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            etag: Swift.String? = nil,
            key: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.etag = etag
            self.key = key
            self.versionId = versionId
        }
    }

}

extension TransferClientTypes.S3InputFileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the customer input Amazon S3 file location. If it is used inside copyStepDetails.DestinationFileLocation, it should be the S3 copy destination. You need to provide the bucket and key. The key can represent either a path or a file. This is determined by whether or not you end the key value with the forward slash (/) character. If the final character is "/", then your file is copied to the folder, and its name does not change. If, rather, the final character is alphanumeric, your uploaded file is renamed to the path value. In this case, if a file with that name already exists, it is overwritten. For example, if your path is shared-files/bob/, your uploaded files are copied to the shared-files/bob/, folder. If your path is shared-files/today, each uploaded file is copied to the shared-files folder and named today: each upload overwrites the previous version of the bob file.
    public struct S3InputFileLocation: Swift.Equatable {
        /// Specifies the S3 bucket for the customer input file.
        public var bucket: Swift.String?
        /// The name assigned to the file when it was created in Amazon S3. You use the object key to retrieve the object.
        public var key: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension TransferClientTypes.S3Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the key-value pair that are assigned to a file during the execution of a Tagging step.
    public struct S3Tag: Swift.Equatable {
        /// The name assigned to the tag that you create.
        /// This member is required.
        public var key: Swift.String?
        /// The value that corresponds to the key.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SendWorkflowStepStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case status = "Status"
        case token = "Token"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension SendWorkflowStepStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendWorkflowStepStateInput: Swift.Equatable {
    /// A unique identifier for the execution of a workflow.
    /// This member is required.
    public var executionId: Swift.String?
    /// Indicates whether the specified step succeeded or failed.
    /// This member is required.
    public var status: TransferClientTypes.CustomStepStatus?
    /// Used to distinguish between multiple callbacks for multiple Lambda steps within the same execution.
    /// This member is required.
    public var token: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        executionId: Swift.String? = nil,
        status: TransferClientTypes.CustomStepStatus? = nil,
        token: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.executionId = executionId
        self.status = status
        self.token = token
        self.workflowId = workflowId
    }
}

struct SendWorkflowStepStateInputBody: Swift.Equatable {
    let workflowId: Swift.String?
    let executionId: Swift.String?
    let token: Swift.String?
    let status: TransferClientTypes.CustomStepStatus?
}

extension SendWorkflowStepStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case status = "Status"
        case token = "Token"
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CustomStepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SendWorkflowStepStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendWorkflowStepStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SendWorkflowStepStateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendWorkflowStepStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SendWorkflowStepStateOutputResponse: Swift.Equatable {

    public init () { }
}

extension TransferClientTypes.ServiceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userDetails = "UserDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userDetails = self.userDetails {
            try encodeContainer.encode(userDetails, forKey: .userDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.UserDetails.self, forKey: .userDetails)
        userDetails = userDetailsDecoded
    }
}

extension TransferClientTypes {
    /// A container object for the session details that are associated with a workflow.
    public struct ServiceMetadata: Swift.Equatable {
        /// The Server ID (ServerId), Session ID (SessionId) and user (UserName) make up the UserDetails.
        /// This member is required.
        public var userDetails: TransferClientTypes.UserDetails?

        public init (
            userDetails: TransferClientTypes.UserDetails? = nil
        )
        {
            self.userDetails = userDetails
        }
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has failed because the Amazon Web ServicesTransfer Family service is not available.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransferClientTypes {
    public enum SetStatOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case enableNoOp
        case sdkUnknown(Swift.String)

        public static var allCases: [SetStatOption] {
            return [
                .default,
                .enableNoOp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .enableNoOp: return "ENABLE_NO_OP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SetStatOption(rawValue: rawValue) ?? SetStatOption.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes {
    public enum SigningAlg: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case sha1
        case sha256
        case sha384
        case sha512
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningAlg] {
            return [
                .none,
                .sha1,
                .sha256,
                .sha384,
                .sha512,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .sha1: return "SHA1"
            case .sha256: return "SHA256"
            case .sha384: return "SHA384"
            case .sha512: return "SHA512"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SigningAlg(rawValue: rawValue) ?? SigningAlg.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.SshPublicKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateImported = "DateImported"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case sshPublicKeyId = "SshPublicKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateImported = self.dateImported {
            try encodeContainer.encodeTimestamp(dateImported, format: .epochSeconds, forKey: .dateImported)
        }
        if let sshPublicKeyBody = self.sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let sshPublicKeyId = self.sshPublicKeyId {
            try encodeContainer.encode(sshPublicKeyId, forKey: .sshPublicKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateImportedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateImported)
        dateImported = dateImportedDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
    }
}

extension TransferClientTypes {
    /// Provides information about the public Secure Shell (SSH) key that is associated with a user account for the specific file transfer protocol-enabled server (as identified by ServerId). The information returned includes the date the key was imported, the public key contents, and the public key ID. A user can store more than one SSH public key associated with their user name on a specific server.
    public struct SshPublicKey: Swift.Equatable {
        /// Specifies the date that the public key was added to the user account.
        /// This member is required.
        public var dateImported: ClientRuntime.Date?
        /// Specifies the content of the SSH public key as specified by the PublicKeyId. Transfer Family accepts RSA, ECDSA, and ED25519 keys.
        /// This member is required.
        public var sshPublicKeyBody: Swift.String?
        /// Specifies the SshPublicKeyId parameter contains the identifier of the public key.
        /// This member is required.
        public var sshPublicKeyId: Swift.String?

        public init (
            dateImported: ClientRuntime.Date? = nil,
            sshPublicKeyBody: Swift.String? = nil,
            sshPublicKeyId: Swift.String? = nil
        )
        {
            self.dateImported = dateImported
            self.sshPublicKeyBody = sshPublicKeyBody
            self.sshPublicKeyId = sshPublicKeyId
        }
    }

}

extension StartFileTransferInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
        case sendFilePaths = "SendFilePaths"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
        if let sendFilePaths = sendFilePaths {
            var sendFilePathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sendFilePaths)
            for filepath0 in sendFilePaths {
                try sendFilePathsContainer.encode(filepath0)
            }
        }
    }
}

extension StartFileTransferInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartFileTransferInput: Swift.Equatable {
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?
    /// An array of strings. Each string represents the absolute path for one outbound file transfer. For example,  DOC-EXAMPLE-BUCKET/myfile.txt .
    /// This member is required.
    public var sendFilePaths: [Swift.String]?

    public init (
        connectorId: Swift.String? = nil,
        sendFilePaths: [Swift.String]? = nil
    )
    {
        self.connectorId = connectorId
        self.sendFilePaths = sendFilePaths
    }
}

struct StartFileTransferInputBody: Swift.Equatable {
    let connectorId: Swift.String?
    let sendFilePaths: [Swift.String]?
}

extension StartFileTransferInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
        case sendFilePaths = "SendFilePaths"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let sendFilePathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sendFilePaths)
        var sendFilePathsDecoded0:[Swift.String]? = nil
        if let sendFilePathsContainer = sendFilePathsContainer {
            sendFilePathsDecoded0 = [Swift.String]()
            for string0 in sendFilePathsContainer {
                if let string0 = string0 {
                    sendFilePathsDecoded0?.append(string0)
                }
            }
        }
        sendFilePaths = sendFilePathsDecoded0
    }
}

extension StartFileTransferOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFileTransferOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartFileTransferOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFileTransferOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartFileTransferOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transferId = output.transferId
        } else {
            self.transferId = nil
        }
    }
}

public struct StartFileTransferOutputResponse: Swift.Equatable {
    /// Returns the unique identifier for this file transfer.
    /// This member is required.
    public var transferId: Swift.String?

    public init (
        transferId: Swift.String? = nil
    )
    {
        self.transferId = transferId
    }
}

struct StartFileTransferOutputResponseBody: Swift.Equatable {
    let transferId: Swift.String?
}

extension StartFileTransferOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transferId = "TransferId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transferIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transferId)
        transferId = transferIdDecoded
    }
}

extension StartServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension StartServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartServerInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server that you start.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct StartServerInputBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension StartServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension StartServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartServerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartServerOutputResponse: Swift.Equatable {

    public init () { }
}

extension TransferClientTypes {
    /// Describes the condition of a file transfer protocol-enabled server with respect to its ability to perform file operations. There are six possible states: OFFLINE, ONLINE, STARTING, STOPPING, START_FAILED, and STOP_FAILED. OFFLINE indicates that the server exists, but that it is not available for file operations. ONLINE indicates that the server is available to perform file operations. STARTING indicates that the server's was instantiated, but the server is not yet available to perform file operations. Under normal conditions, it can take a couple of minutes for the server to be completely operational. Both START_FAILED and STOP_FAILED are error conditions.
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case offline
        case online
        case starting
        case startFailed
        case stopping
        case stopFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .offline,
                .online,
                .starting,
                .startFailed,
                .stopping,
                .stopFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .starting: return "STARTING"
            case .startFailed: return "START_FAILED"
            case .stopping: return "STOPPING"
            case .stopFailed: return "STOP_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension StopServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension StopServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopServerInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server that you stopped.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct StopServerInputBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension StopServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension StopServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopServerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopServerOutputResponse: Swift.Equatable {

    public init () { }
}

extension TransferClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TransferClientTypes {
    /// Creates a key-value pair for a specific resource. Tags are metadata that you can use to search for and group a resource for various purposes. You can apply tags to servers, users, and roles. A tag key can take more than one value. For example, to group servers for accounting purposes, you might create a tag called Group and assign the values Research and Accounting to that group.
    public struct Tag: Swift.Equatable {
        /// The name assigned to the tag that you create.
        /// This member is required.
        public var key: Swift.String?
        /// Contains one or more values that you assigned to the key name you create.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a server, user, or role.
    /// This member is required.
    public var arn: Swift.String?
    /// Key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to user accounts for any purpose.
    /// This member is required.
    public var tags: [TransferClientTypes.Tag]?

    public init (
        arn: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let tags: [TransferClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TransferClientTypes.TagStepDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sourceFileLocation = "SourceFileLocation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceFileLocation = self.sourceFileLocation {
            try encodeContainer.encode(sourceFileLocation, forKey: .sourceFileLocation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for s3tag0 in tags {
                try tagsContainer.encode(s3tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.S3Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.S3Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.S3Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let sourceFileLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileLocation)
        sourceFileLocation = sourceFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure. The key/value pairs used to tag a file during the execution of a workflow step.
    public struct TagStepDetails: Swift.Equatable {
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow.
        ///
        /// * To use the previous file as the input, enter ${previous.file}. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value.
        ///
        /// * To use the originally uploaded file location as input for this step, enter ${original.file}.
        public var sourceFileLocation: Swift.String?
        /// Array that contains from 1 to 10 key/value pairs.
        public var tags: [TransferClientTypes.S3Tag]?

        public init (
            name: Swift.String? = nil,
            sourceFileLocation: Swift.String? = nil,
            tags: [TransferClientTypes.S3Tag]? = nil
        )
        {
            self.name = name
            self.sourceFileLocation = sourceFileLocation
            self.tags = tags
        }
    }

}

extension TestIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestIdentityProviderInput(serverId: \(Swift.String(describing: serverId)), serverProtocol: \(Swift.String(describing: serverProtocol)), sourceIp: \(Swift.String(describing: sourceIp)), userName: \(Swift.String(describing: userName)), userPassword: \"CONTENT_REDACTED\")"}
}

extension TestIdentityProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case serverProtocol = "ServerProtocol"
        case sourceIp = "SourceIp"
        case userName = "UserName"
        case userPassword = "UserPassword"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let serverProtocol = self.serverProtocol {
            try encodeContainer.encode(serverProtocol.rawValue, forKey: .serverProtocol)
        }
        if let sourceIp = self.sourceIp {
            try encodeContainer.encode(sourceIp, forKey: .sourceIp)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userPassword = self.userPassword {
            try encodeContainer.encode(userPassword, forKey: .userPassword)
        }
    }
}

extension TestIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TestIdentityProviderInput: Swift.Equatable {
    /// A system-assigned identifier for a specific server. That server's user authentication method is tested with a user name and password.
    /// This member is required.
    public var serverId: Swift.String?
    /// The type of file transfer protocol to be tested. The available protocols are:
    ///
    /// * Secure Shell (SSH) File Transfer Protocol (SFTP)
    ///
    /// * File Transfer Protocol Secure (FTPS)
    ///
    /// * File Transfer Protocol (FTP)
    public var serverProtocol: TransferClientTypes.ModelProtocol?
    /// The source IP address of the user account to be tested.
    public var sourceIp: Swift.String?
    /// The name of the user account to be tested.
    /// This member is required.
    public var userName: Swift.String?
    /// The password of the user account to be tested.
    public var userPassword: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        serverProtocol: TransferClientTypes.ModelProtocol? = nil,
        sourceIp: Swift.String? = nil,
        userName: Swift.String? = nil,
        userPassword: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.serverProtocol = serverProtocol
        self.sourceIp = sourceIp
        self.userName = userName
        self.userPassword = userPassword
    }
}

struct TestIdentityProviderInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let serverProtocol: TransferClientTypes.ModelProtocol?
    let sourceIp: Swift.String?
    let userName: Swift.String?
    let userPassword: Swift.String?
}

extension TestIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case serverProtocol = "ServerProtocol"
        case sourceIp = "SourceIp"
        case userName = "UserName"
        case userPassword = "UserPassword"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let serverProtocolDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ModelProtocol.self, forKey: .serverProtocol)
        serverProtocol = serverProtocolDecoded
        let sourceIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIp)
        sourceIp = sourceIpDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPassword)
        userPassword = userPasswordDecoded
    }
}

extension TestIdentityProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestIdentityProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TestIdentityProviderOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TestIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.response = output.response
            self.statusCode = output.statusCode
            self.url = output.url
        } else {
            self.message = nil
            self.response = nil
            self.statusCode = 0
            self.url = nil
        }
    }
}

public struct TestIdentityProviderOutputResponse: Swift.Equatable {
    /// A message that indicates whether the test was successful or not. If an empty string is returned, the most likely cause is that the authentication failed due to an incorrect username or password.
    public var message: Swift.String?
    /// The response that is returned from your API Gateway.
    public var response: Swift.String?
    /// The HTTP status code that is the response from your API Gateway.
    /// This member is required.
    public var statusCode: Swift.Int
    /// The endpoint of the service used to authenticate a user.
    /// This member is required.
    public var url: Swift.String?

    public init (
        message: Swift.String? = nil,
        response: Swift.String? = nil,
        statusCode: Swift.Int = 0,
        url: Swift.String? = nil
    )
    {
        self.message = message
        self.response = response
        self.statusCode = statusCode
        self.url = url
    }
}

struct TestIdentityProviderOutputResponseBody: Swift.Equatable {
    let response: Swift.String?
    let statusCode: Swift.Int
    let message: Swift.String?
    let url: Swift.String?
}

extension TestIdentityProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case response = "Response"
        case statusCode = "StatusCode"
        case url = "Url"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .response)
        response = responseDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode) ?? 0
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var retryAfterSeconds: Swift.String?

    public init (
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.retryAfterSeconds = retryAfterSeconds
    }
}

extension TransferClientTypes {
    public enum TlsSessionResumptionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case enforced
        case sdkUnknown(Swift.String)

        public static var allCases: [TlsSessionResumptionMode] {
            return [
                .disabled,
                .enabled,
                .enforced,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .enforced: return "ENFORCED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TlsSessionResumptionMode(rawValue: rawValue) ?? TlsSessionResumptionMode.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The value of the resource that will have the tag removed. An Amazon Resource Name (ARN) is an identifier for a specific Amazon Web Services resource, such as a server, user, or role.
    /// This member is required.
    public var arn: Swift.String?
    /// TagKeys are key-value pairs assigned to ARNs that can be used to group and search for resources by type. This metadata can be attached to resources for any purpose.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymapentry0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymapentry0)
            }
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = self.posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension UpdateAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAccessInput: Swift.Equatable {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regular expression used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock down your user to the designated home directory ("chroot"). To do this, you can set Entry to / and set Target to the HomeDirectory parameter value. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use session policies. For session policies, Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Example session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Amazon Web ServicesSecurity Token Service API Reference.
    public var policy: Swift.String?
    /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
    }
}

struct UpdateAccessInputBody: Swift.Equatable {
    let homeDirectory: Swift.String?
    let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    let policy: Swift.String?
    let posixProfile: TransferClientTypes.PosixProfile?
    let role: Swift.String?
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension UpdateAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension UpdateAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.externalId = output.externalId
            self.serverId = output.serverId
        } else {
            self.externalId = nil
            self.serverId = nil
        }
    }
}

public struct UpdateAccessOutputResponse: Swift.Equatable {
    /// The external identifier of the group whose users have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Amazon Web ServicesTransfer Family.
    /// This member is required.
    public var externalId: Swift.String?
    /// The identifier of the server that the user is attached to.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct UpdateAccessOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension UpdateAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension UpdateAgreementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case agreementId = "AgreementId"
        case baseDirectory = "BaseDirectory"
        case description = "Description"
        case localProfileId = "LocalProfileId"
        case partnerProfileId = "PartnerProfileId"
        case serverId = "ServerId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = self.accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let agreementId = self.agreementId {
            try encodeContainer.encode(agreementId, forKey: .agreementId)
        }
        if let baseDirectory = self.baseDirectory {
            try encodeContainer.encode(baseDirectory, forKey: .baseDirectory)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let localProfileId = self.localProfileId {
            try encodeContainer.encode(localProfileId, forKey: .localProfileId)
        }
        if let partnerProfileId = self.partnerProfileId {
            try encodeContainer.encode(partnerProfileId, forKey: .partnerProfileId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateAgreementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAgreementInput: Swift.Equatable {
    /// With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the file’s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer.
    public var accessRole: Swift.String?
    /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
    /// This member is required.
    public var agreementId: Swift.String?
    /// To change the landing directory (folder) for files that are transferred, provide the bucket folder that you want to use; for example, /DOC-EXAMPLE-BUCKET/home/mydirectory .
    public var baseDirectory: Swift.String?
    /// To replace the existing description, provide a short description for the agreement.
    public var description: Swift.String?
    /// A unique identifier for the AS2 local profile. To change the local profile identifier, provide a new value here.
    public var localProfileId: Swift.String?
    /// A unique identifier for the partner profile. To change the partner profile identifier, provide a new value here.
    public var partnerProfileId: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that the agreement uses.
    /// This member is required.
    public var serverId: Swift.String?
    /// You can update the status for the agreement, either activating an inactive agreement or the reverse.
    public var status: TransferClientTypes.AgreementStatusType?

    public init (
        accessRole: Swift.String? = nil,
        agreementId: Swift.String? = nil,
        baseDirectory: Swift.String? = nil,
        description: Swift.String? = nil,
        localProfileId: Swift.String? = nil,
        partnerProfileId: Swift.String? = nil,
        serverId: Swift.String? = nil,
        status: TransferClientTypes.AgreementStatusType? = nil
    )
    {
        self.accessRole = accessRole
        self.agreementId = agreementId
        self.baseDirectory = baseDirectory
        self.description = description
        self.localProfileId = localProfileId
        self.partnerProfileId = partnerProfileId
        self.serverId = serverId
        self.status = status
    }
}

struct UpdateAgreementInputBody: Swift.Equatable {
    let agreementId: Swift.String?
    let serverId: Swift.String?
    let description: Swift.String?
    let status: TransferClientTypes.AgreementStatusType?
    let localProfileId: Swift.String?
    let partnerProfileId: Swift.String?
    let baseDirectory: Swift.String?
    let accessRole: Swift.String?
}

extension UpdateAgreementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case agreementId = "AgreementId"
        case baseDirectory = "BaseDirectory"
        case description = "Description"
        case localProfileId = "LocalProfileId"
        case partnerProfileId = "PartnerProfileId"
        case serverId = "ServerId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.AgreementStatusType.self, forKey: .status)
        status = statusDecoded
        let localProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localProfileId)
        localProfileId = localProfileIdDecoded
        let partnerProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerProfileId)
        partnerProfileId = partnerProfileIdDecoded
        let baseDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseDirectory)
        baseDirectory = baseDirectoryDecoded
        let accessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
    }
}

extension UpdateAgreementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAgreementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAgreementOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAgreementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAgreementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agreementId = output.agreementId
        } else {
            self.agreementId = nil
        }
    }
}

public struct UpdateAgreementOutputResponse: Swift.Equatable {
    /// A unique identifier for the agreement. This identifier is returned when you create an agreement.
    /// This member is required.
    public var agreementId: Swift.String?

    public init (
        agreementId: Swift.String? = nil
    )
    {
        self.agreementId = agreementId
    }
}

struct UpdateAgreementOutputResponseBody: Swift.Equatable {
    let agreementId: Swift.String?
}

extension UpdateAgreementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId = "AgreementId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
    }
}

extension UpdateCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDate = "ActiveDate"
        case certificateId = "CertificateId"
        case description = "Description"
        case inactiveDate = "InactiveDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDate = self.activeDate {
            try encodeContainer.encodeTimestamp(activeDate, format: .epochSeconds, forKey: .activeDate)
        }
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inactiveDate = self.inactiveDate {
            try encodeContainer.encodeTimestamp(inactiveDate, format: .epochSeconds, forKey: .inactiveDate)
        }
    }
}

extension UpdateCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCertificateInput: Swift.Equatable {
    /// An optional date that specifies when the certificate becomes active.
    public var activeDate: ClientRuntime.Date?
    /// The identifier of the certificate object that you are updating.
    /// This member is required.
    public var certificateId: Swift.String?
    /// A short description to help identify the certificate.
    public var description: Swift.String?
    /// An optional date that specifies when the certificate becomes inactive.
    public var inactiveDate: ClientRuntime.Date?

    public init (
        activeDate: ClientRuntime.Date? = nil,
        certificateId: Swift.String? = nil,
        description: Swift.String? = nil,
        inactiveDate: ClientRuntime.Date? = nil
    )
    {
        self.activeDate = activeDate
        self.certificateId = certificateId
        self.description = description
        self.inactiveDate = inactiveDate
    }
}

struct UpdateCertificateInputBody: Swift.Equatable {
    let certificateId: Swift.String?
    let activeDate: ClientRuntime.Date?
    let inactiveDate: ClientRuntime.Date?
    let description: Swift.String?
}

extension UpdateCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDate = "ActiveDate"
        case certificateId = "CertificateId"
        case description = "Description"
        case inactiveDate = "InactiveDate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let activeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .activeDate)
        activeDate = activeDateDecoded
        let inactiveDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .inactiveDate)
        inactiveDate = inactiveDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCertificateOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificateId = output.certificateId
        } else {
            self.certificateId = nil
        }
    }
}

public struct UpdateCertificateOutputResponse: Swift.Equatable {
    /// Returns the identifier of the certificate object that you are updating.
    /// This member is required.
    public var certificateId: Swift.String?

    public init (
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct UpdateCertificateOutputResponseBody: Swift.Equatable {
    let certificateId: Swift.String?
}

extension UpdateCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

extension UpdateConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case as2Config = "As2Config"
        case connectorId = "ConnectorId"
        case loggingRole = "LoggingRole"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = self.accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let as2Config = self.as2Config {
            try encodeContainer.encode(as2Config, forKey: .as2Config)
        }
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }
}

extension UpdateConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateConnectorInput: Swift.Equatable {
    /// With AS2, you can send files by calling StartFileTransfer and specifying the file paths in the request parameter, SendFilePaths. We use the file’s parent directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the AccessRole needs to provide read and write access to the parent directory of the file location used in the StartFileTransfer request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with StartFileTransfer.
    public var accessRole: Swift.String?
    /// A structure that contains the parameters for a connector object.
    public var as2Config: TransferClientTypes.As2ConnectorConfig?
    /// The unique identifier for the connector.
    /// This member is required.
    public var connectorId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a connector to turn on CloudWatch logging for Amazon S3 events. When set, you can view connector activity in your CloudWatch logs.
    public var loggingRole: Swift.String?
    /// The URL of the partner's AS2 endpoint.
    public var url: Swift.String?

    public init (
        accessRole: Swift.String? = nil,
        as2Config: TransferClientTypes.As2ConnectorConfig? = nil,
        connectorId: Swift.String? = nil,
        loggingRole: Swift.String? = nil,
        url: Swift.String? = nil
    )
    {
        self.accessRole = accessRole
        self.as2Config = as2Config
        self.connectorId = connectorId
        self.loggingRole = loggingRole
        self.url = url
    }
}

struct UpdateConnectorInputBody: Swift.Equatable {
    let connectorId: Swift.String?
    let url: Swift.String?
    let as2Config: TransferClientTypes.As2ConnectorConfig?
    let accessRole: Swift.String?
    let loggingRole: Swift.String?
}

extension UpdateConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole = "AccessRole"
        case as2Config = "As2Config"
        case connectorId = "ConnectorId"
        case loggingRole = "LoggingRole"
        case url = "Url"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let as2ConfigDecoded = try containerValues.decodeIfPresent(TransferClientTypes.As2ConnectorConfig.self, forKey: .as2Config)
        as2Config = as2ConfigDecoded
        let accessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
    }
}

extension UpdateConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateConnectorOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorId = output.connectorId
        } else {
            self.connectorId = nil
        }
    }
}

public struct UpdateConnectorOutputResponse: Swift.Equatable {
    /// Returns the identifier of the connector object that you are updating.
    /// This member is required.
    public var connectorId: Swift.String?

    public init (
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

struct UpdateConnectorOutputResponseBody: Swift.Equatable {
    let connectorId: Swift.String?
}

extension UpdateConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId = "ConnectorId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
    }
}

extension UpdateHostKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hostKeyId = self.hostKeyId {
            try encodeContainer.encode(hostKeyId, forKey: .hostKeyId)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension UpdateHostKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateHostKeyInput: Swift.Equatable {
    /// An updated description for the host key.
    /// This member is required.
    public var description: Swift.String?
    /// The identifier of the host key that you are updating.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// The identifier of the server that contains the host key that you are updating.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        description: Swift.String? = nil,
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.description = description
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

struct UpdateHostKeyInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let hostKeyId: Swift.String?
    let description: Swift.String?
}

extension UpdateHostKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let hostKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyId)
        hostKeyId = hostKeyIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateHostKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateHostKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateHostKeyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateHostKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateHostKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hostKeyId = output.hostKeyId
            self.serverId = output.serverId
        } else {
            self.hostKeyId = nil
            self.serverId = nil
        }
    }
}

public struct UpdateHostKeyOutputResponse: Swift.Equatable {
    /// Returns the host key identifier for the updated host key.
    /// This member is required.
    public var hostKeyId: Swift.String?
    /// Returns the server identifier for the server that contains the updated host key.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        hostKeyId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.hostKeyId = hostKeyId
        self.serverId = serverId
    }
}

struct UpdateHostKeyOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let hostKeyId: Swift.String?
}

extension UpdateHostKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostKeyId = "HostKeyId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let hostKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyId)
        hostKeyId = hostKeyIdDecoded
    }
}

extension UpdateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateIds = "CertificateIds"
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateIds = certificateIds {
            var certificateIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateIds)
            for certificateid0 in certificateIds {
                try certificateIdsContainer.encode(certificateid0)
            }
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
    }
}

extension UpdateProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProfileInput: Swift.Equatable {
    /// An array of identifiers for the imported certificates. You use this identifier for working with profiles and partner profiles.
    public var certificateIds: [Swift.String]?
    /// The identifier of the profile object that you are updating.
    /// This member is required.
    public var profileId: Swift.String?

    public init (
        certificateIds: [Swift.String]? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.certificateIds = certificateIds
        self.profileId = profileId
    }
}

struct UpdateProfileInputBody: Swift.Equatable {
    let profileId: Swift.String?
    let certificateIds: [Swift.String]?
}

extension UpdateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateIds = "CertificateIds"
        case profileId = "ProfileId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let certificateIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .certificateIds)
        var certificateIdsDecoded0:[Swift.String]? = nil
        if let certificateIdsContainer = certificateIdsContainer {
            certificateIdsDecoded0 = [Swift.String]()
            for string0 in certificateIdsContainer {
                if let string0 = string0 {
                    certificateIdsDecoded0?.append(string0)
                }
            }
        }
        certificateIds = certificateIdsDecoded0
    }
}

extension UpdateProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateProfileOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.profileId = output.profileId
        } else {
            self.profileId = nil
        }
    }
}

public struct UpdateProfileOutputResponse: Swift.Equatable {
    /// Returns the identifier for the profile that's being updated.
    /// This member is required.
    public var profileId: Swift.String?

    public init (
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct UpdateProfileOutputResponseBody: Swift.Equatable {
    let profileId: Swift.String?
}

extension UpdateProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

extension UpdateServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServerInput(certificate: \(Swift.String(describing: certificate)), endpointDetails: \(Swift.String(describing: endpointDetails)), endpointType: \(Swift.String(describing: endpointType)), identityProviderDetails: \(Swift.String(describing: identityProviderDetails)), loggingRole: \(Swift.String(describing: loggingRole)), postAuthenticationLoginBanner: \(Swift.String(describing: postAuthenticationLoginBanner)), preAuthenticationLoginBanner: \(Swift.String(describing: preAuthenticationLoginBanner)), protocolDetails: \(Swift.String(describing: protocolDetails)), protocols: \(Swift.String(describing: protocols)), securityPolicyName: \(Swift.String(describing: securityPolicyName)), serverId: \(Swift.String(describing: serverId)), workflowDetails: \(Swift.String(describing: workflowDetails)), hostKey: \"CONTENT_REDACTED\")"}
}

extension UpdateServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case loggingRole = "LoggingRole"
        case postAuthenticationLoginBanner = "PostAuthenticationLoginBanner"
        case preAuthenticationLoginBanner = "PreAuthenticationLoginBanner"
        case protocolDetails = "ProtocolDetails"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
        case workflowDetails = "WorkflowDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let endpointDetails = self.endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKey = self.hostKey {
            try encodeContainer.encode(hostKey, forKey: .hostKey)
        }
        if let identityProviderDetails = self.identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let loggingRole = self.loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let postAuthenticationLoginBanner = self.postAuthenticationLoginBanner {
            try encodeContainer.encode(postAuthenticationLoginBanner, forKey: .postAuthenticationLoginBanner)
        }
        if let preAuthenticationLoginBanner = self.preAuthenticationLoginBanner {
            try encodeContainer.encode(preAuthenticationLoginBanner, forKey: .preAuthenticationLoginBanner)
        }
        if let protocolDetails = self.protocolDetails {
            try encodeContainer.encode(protocolDetails, forKey: .protocolDetails)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocol0 in protocols {
                try protocolsContainer.encode(protocol0.rawValue)
            }
        }
        if let securityPolicyName = self.securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let workflowDetails = self.workflowDetails {
            try encodeContainer.encode(workflowDetails, forKey: .workflowDetails)
        }
    }
}

extension UpdateServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when Protocols is set to FTPS. To request a new public certificate, see [Request a public certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html) in the Amazon Web ServicesCertificate Manager User Guide. To import an existing certificate into ACM, see [Importing certificates into ACM](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the Amazon Web ServicesCertificate Manager User Guide. To request a private certificate to use FTPS through private IP addresses, see [Request a private certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html) in the Amazon Web ServicesCertificate Manager User Guide. Certificates with the following cryptographic algorithms and key sizes are supported:
    ///
    /// * 2048-bit RSA (RSA_2048)
    ///
    /// * 4096-bit RSA (RSA_4096)
    ///
    /// * Elliptic Prime Curve 256 bit (EC_prime256v1)
    ///
    /// * Elliptic Prime Curve 384 bit (EC_secp384r1)
    ///
    /// * Elliptic Prime Curve 521 bit (EC_secp521r1)
    ///
    ///
    /// The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP address specified and information about the issuer.
    public var certificate: Swift.String?
    /// The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make your endpoint accessible only to resources within your VPC, or you can attach Elastic IP addresses and make your endpoint accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.
    public var endpointDetails: TransferClientTypes.EndpointDetails?
    /// The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC) or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it. After May 19, 2021, you won't be able to create a server using EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount if your account hasn't already done so before May 19, 2021. If you have already created servers with EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount on or before May 19, 2021, you will not be affected. After this date, use EndpointType=VPC. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint. It is recommended that you use VPC as the EndpointType. With this endpoint type, you have the option to directly associate up to three Elastic IPv4 addresses (BYO IP included) with your server's endpoint and use VPC security groups to restrict traffic by the client's public IP address. This is not possible with EndpointType set to VPC_ENDPOINT.
    public var endpointType: TransferClientTypes.EndpointType?
    /// The RSA, ECDSA, or ED25519 private key to use for your SFTP-enabled server. You can add multiple host keys, in case you want to rotate keys, or have a set of active keys that use different algorithms. Use the following command to generate an RSA 2048 bit key with no passphrase: ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key. Use a minimum value of 2048 for the -b option. You can create a stronger key by using 3072 or 4096. Use the following command to generate an ECDSA 256 bit key with no passphrase: ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key. Valid values for the -b option for ECDSA are 256, 384, and 521. Use the following command to generate an ED25519 key with no passphrase: ssh-keygen -t ed25519 -N "" -f my-new-server-key. For all of these commands, you can replace my-new-server-key with a string of your choice. If you aren't planning to migrate existing users from an existing SFTP-enabled server to a new server, don't update the host key. Accidentally changing a server's host key can be disruptive. For more information, see [Manage host keys for your SFTP-enabled server](https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key) in the Transfer Family User Guide.
    public var hostKey: Swift.String?
    /// An array containing all of the information required to call a customer's authentication API method.
    public var identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
    public var loggingRole: Swift.String?
    /// Specifies a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
    public var postAuthenticationLoginBanner: Swift.String?
    /// Specifies a string to display when users connect to a server. This string is displayed before the user authenticates. For example, the following banner displays details about using the system: This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel.
    public var preAuthenticationLoginBanner: Swift.String?
    /// The protocol settings that are configured for your server.
    ///
    /// * To indicate passive mode (for FTP and FTPS protocols), use the PassiveIp parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
    ///
    /// * To ignore the error that is generated when the client attempts to use the SETSTAT command on a file that you are uploading to an Amazon S3 bucket, use the SetStatOption parameter. To have the Transfer Family server ignore the SETSTAT command and upload files without needing to make any changes to your SFTP client, set the value to ENABLE_NO_OP. If you set the SetStatOption parameter to ENABLE_NO_OP, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a SETSTAT call.
    ///
    /// * To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the TlsSessionResumptionMode parameter.
    ///
    /// * As2Transports indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
    public var protocolDetails: TransferClientTypes.ProtocolDetails?
    /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:
    ///
    /// * SFTP (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH
    ///
    /// * FTPS (File Transfer Protocol Secure): File transfer with TLS encryption
    ///
    /// * FTP (File Transfer Protocol): Unencrypted file transfer
    ///
    /// * AS2 (Applicability Statement 2): used for transporting structured business-to-business data
    ///
    ///
    ///
    ///
    /// * If you select FTPS, you must choose a certificate stored in Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS.
    ///
    /// * If Protocol includes either FTP or FTPS, then the EndpointType must be VPC and the IdentityProviderType must be either AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
    ///
    /// * If Protocol includes FTP, then AddressAllocationIds cannot be associated.
    ///
    /// * If Protocol is set only to SFTP, the EndpointType can be set to PUBLIC and the IdentityProviderType can be set any of the supported identity types: SERVICE_MANAGED, AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
    ///
    /// * If Protocol includes AS2, then the EndpointType must be VPC, and domain must be Amazon S3.
    public var protocols: [TransferClientTypes.ModelProtocol]?
    /// Specifies the name of the security policy that is attached to the server.
    public var securityPolicyName: Swift.String?
    /// A system-assigned unique identifier for a server instance that the user account is assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow. In addition to a workflow to execute when a file is uploaded completely, WorkflowDetails can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when a file is open when the session disconnects. To remove an associated workflow from a server, you can provide an empty OnUpload object, as in the following example. aws transfer update-server --server-id s-01234567890abcdef --workflow-details '{"OnUpload":[]}'
    public var workflowDetails: TransferClientTypes.WorkflowDetails?

    public init (
        certificate: Swift.String? = nil,
        endpointDetails: TransferClientTypes.EndpointDetails? = nil,
        endpointType: TransferClientTypes.EndpointType? = nil,
        hostKey: Swift.String? = nil,
        identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
        loggingRole: Swift.String? = nil,
        postAuthenticationLoginBanner: Swift.String? = nil,
        preAuthenticationLoginBanner: Swift.String? = nil,
        protocolDetails: TransferClientTypes.ProtocolDetails? = nil,
        protocols: [TransferClientTypes.ModelProtocol]? = nil,
        securityPolicyName: Swift.String? = nil,
        serverId: Swift.String? = nil,
        workflowDetails: TransferClientTypes.WorkflowDetails? = nil
    )
    {
        self.certificate = certificate
        self.endpointDetails = endpointDetails
        self.endpointType = endpointType
        self.hostKey = hostKey
        self.identityProviderDetails = identityProviderDetails
        self.loggingRole = loggingRole
        self.postAuthenticationLoginBanner = postAuthenticationLoginBanner
        self.preAuthenticationLoginBanner = preAuthenticationLoginBanner
        self.protocolDetails = protocolDetails
        self.protocols = protocols
        self.securityPolicyName = securityPolicyName
        self.serverId = serverId
        self.workflowDetails = workflowDetails
    }
}

struct UpdateServerInputBody: Swift.Equatable {
    let certificate: Swift.String?
    let protocolDetails: TransferClientTypes.ProtocolDetails?
    let endpointDetails: TransferClientTypes.EndpointDetails?
    let endpointType: TransferClientTypes.EndpointType?
    let hostKey: Swift.String?
    let identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    let loggingRole: Swift.String?
    let postAuthenticationLoginBanner: Swift.String?
    let preAuthenticationLoginBanner: Swift.String?
    let protocols: [TransferClientTypes.ModelProtocol]?
    let securityPolicyName: Swift.String?
    let serverId: Swift.String?
    let workflowDetails: TransferClientTypes.WorkflowDetails?
}

extension UpdateServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case loggingRole = "LoggingRole"
        case postAuthenticationLoginBanner = "PostAuthenticationLoginBanner"
        case preAuthenticationLoginBanner = "PreAuthenticationLoginBanner"
        case protocolDetails = "ProtocolDetails"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
        case workflowDetails = "WorkflowDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let protocolDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProtocolDetails.self, forKey: .protocolDetails)
        protocolDetails = protocolDetailsDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKey)
        hostKey = hostKeyDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let postAuthenticationLoginBannerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postAuthenticationLoginBanner)
        postAuthenticationLoginBanner = postAuthenticationLoginBannerDecoded
        let preAuthenticationLoginBannerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preAuthenticationLoginBanner)
        preAuthenticationLoginBanner = preAuthenticationLoginBannerDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[TransferClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [TransferClientTypes.ModelProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let workflowDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowDetails.self, forKey: .workflowDetails)
        workflowDetails = workflowDetailsDecoded
    }
}

extension UpdateServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateServerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
        } else {
            self.serverId = nil
        }
    }
}

public struct UpdateServerOutputResponse: Swift.Equatable {
    /// A system-assigned unique identifier for a server that the user account is assigned to.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct UpdateServerOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension UpdateServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeDirectory = self.homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymapentry0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymapentry0)
            }
        }
        if let homeDirectoryType = self.homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = self.posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock down your user to the designated home directory ("chroot"). To do this, you can set Entry to '/' and set Target to the HomeDirectory parameter value. The following is an Entry and Target pair example for chroot. [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use session policies. For session policies, Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Creating a session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Amazon Web Services Security Token Service API Reference.
    public var policy: Swift.String?
    /// Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon Elastic File Systems (Amazon EFS). The POSIX permissions that are set on files and directories in your file system determines the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a server instance that the user account is assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique string that identifies a user and is associated with a server as specified by the ServerId. This user name must be a minimum of 3 and a maximum of 100 characters long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen '-', period '.', and at sign '@'. The user name can't start with a hyphen, period, or at sign.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
        self.userName = userName
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let homeDirectory: Swift.String?
    let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    let policy: Swift.String?
    let posixProfile: TransferClientTypes.PosixProfile?
    let role: Swift.String?
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension UpdateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateUserOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.userName = nil
        }
    }
}

/// UpdateUserResponse returns the user name and identifier for the request to update a user's properties.
public struct UpdateUserOutputResponse: Swift.Equatable {
    /// A system-assigned unique identifier for a server instance that the user account is assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// The unique identifier for a user that is assigned to a server instance that was specified in the request.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct UpdateUserOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension UpdateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension TransferClientTypes.UserDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sessionId = "SessionId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the user name, server ID, and session ID for a workflow.
    public struct UserDetails: Swift.Equatable {
        /// The system-assigned unique identifier for a Transfer server instance.
        /// This member is required.
        public var serverId: Swift.String?
        /// The system-assigned unique identifier for a session that corresponds to the workflow.
        public var sessionId: Swift.String?
        /// A unique string that identifies a user account associated with a server.
        /// This member is required.
        public var userName: Swift.String?

        public init (
            serverId: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.serverId = serverId
            self.sessionId = sessionId
            self.userName = userName
        }
    }

}

extension TransferClientTypes.WorkflowDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionRole = "ExecutionRole"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow. In addition to a workflow to execute when a file is uploaded completely, WorkflowDetails can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when a file is open when the session disconnects.
    public struct WorkflowDetail: Swift.Equatable {
        /// Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources
        /// This member is required.
        public var executionRole: Swift.String?
        /// A unique identifier for the workflow.
        /// This member is required.
        public var workflowId: Swift.String?

        public init (
            executionRole: Swift.String? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.executionRole = executionRole
            self.workflowId = workflowId
        }
    }

}

extension TransferClientTypes.WorkflowDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case onPartialUpload = "OnPartialUpload"
        case onUpload = "OnUpload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onPartialUpload = onPartialUpload {
            var onPartialUploadContainer = encodeContainer.nestedUnkeyedContainer(forKey: .onPartialUpload)
            for workflowdetail0 in onPartialUpload {
                try onPartialUploadContainer.encode(workflowdetail0)
            }
        }
        if let onUpload = onUpload {
            var onUploadContainer = encodeContainer.nestedUnkeyedContainer(forKey: .onUpload)
            for workflowdetail0 in onUpload {
                try onUploadContainer.encode(workflowdetail0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onUploadContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowDetail?].self, forKey: .onUpload)
        var onUploadDecoded0:[TransferClientTypes.WorkflowDetail]? = nil
        if let onUploadContainer = onUploadContainer {
            onUploadDecoded0 = [TransferClientTypes.WorkflowDetail]()
            for structure0 in onUploadContainer {
                if let structure0 = structure0 {
                    onUploadDecoded0?.append(structure0)
                }
            }
        }
        onUpload = onUploadDecoded0
        let onPartialUploadContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowDetail?].self, forKey: .onPartialUpload)
        var onPartialUploadDecoded0:[TransferClientTypes.WorkflowDetail]? = nil
        if let onPartialUploadContainer = onPartialUploadContainer {
            onPartialUploadDecoded0 = [TransferClientTypes.WorkflowDetail]()
            for structure0 in onPartialUploadContainer {
                if let structure0 = structure0 {
                    onPartialUploadDecoded0?.append(structure0)
                }
            }
        }
        onPartialUpload = onPartialUploadDecoded0
    }
}

extension TransferClientTypes {
    /// Container for the WorkflowDetail data type. It is used by actions that trigger a workflow to begin execution.
    public struct WorkflowDetails: Swift.Equatable {
        /// A trigger that starts a workflow if a file is only partially uploaded. You can attach a workflow to a server that executes whenever there is a partial upload. A partial upload occurs when a file is open when the session disconnects.
        public var onPartialUpload: [TransferClientTypes.WorkflowDetail]?
        /// A trigger that starts a workflow: the workflow begins to execute after a file is uploaded. To remove an associated workflow from a server, you can provide an empty OnUpload object, as in the following example. aws transfer update-server --server-id s-01234567890abcdef --workflow-details '{"OnUpload":[]}'
        public var onUpload: [TransferClientTypes.WorkflowDetail]?

        public init (
            onPartialUpload: [TransferClientTypes.WorkflowDetail]? = nil,
            onUpload: [TransferClientTypes.WorkflowDetail]? = nil
        )
        {
            self.onPartialUpload = onPartialUpload
            self.onUpload = onUpload
        }
    }

}

extension TransferClientTypes.WorkflowStep: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyStepDetails = "CopyStepDetails"
        case customStepDetails = "CustomStepDetails"
        case decryptStepDetails = "DecryptStepDetails"
        case deleteStepDetails = "DeleteStepDetails"
        case tagStepDetails = "TagStepDetails"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copyStepDetails = self.copyStepDetails {
            try encodeContainer.encode(copyStepDetails, forKey: .copyStepDetails)
        }
        if let customStepDetails = self.customStepDetails {
            try encodeContainer.encode(customStepDetails, forKey: .customStepDetails)
        }
        if let decryptStepDetails = self.decryptStepDetails {
            try encodeContainer.encode(decryptStepDetails, forKey: .decryptStepDetails)
        }
        if let deleteStepDetails = self.deleteStepDetails {
            try encodeContainer.encode(deleteStepDetails, forKey: .deleteStepDetails)
        }
        if let tagStepDetails = self.tagStepDetails {
            try encodeContainer.encode(tagStepDetails, forKey: .tagStepDetails)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowStepType.self, forKey: .type)
        type = typeDecoded
        let copyStepDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CopyStepDetails.self, forKey: .copyStepDetails)
        copyStepDetails = copyStepDetailsDecoded
        let customStepDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CustomStepDetails.self, forKey: .customStepDetails)
        customStepDetails = customStepDetailsDecoded
        let deleteStepDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DeleteStepDetails.self, forKey: .deleteStepDetails)
        deleteStepDetails = deleteStepDetailsDecoded
        let tagStepDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.TagStepDetails.self, forKey: .tagStepDetails)
        tagStepDetails = tagStepDetailsDecoded
        let decryptStepDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DecryptStepDetails.self, forKey: .decryptStepDetails)
        decryptStepDetails = decryptStepDetailsDecoded
    }
}

extension TransferClientTypes {
    /// The basic building block of a workflow.
    public struct WorkflowStep: Swift.Equatable {
        /// Details for a step that performs a file copy. Consists of the following values:
        ///
        /// * A description
        ///
        /// * An Amazon S3 location for the destination of the file copy.
        ///
        /// * A flag that indicates whether to overwrite an existing file of the same name. The default is FALSE.
        public var copyStepDetails: TransferClientTypes.CopyStepDetails?
        /// Details for a step that invokes an Lambda function. Consists of the Lambda function's name, target, and timeout (in seconds).
        public var customStepDetails: TransferClientTypes.CustomStepDetails?
        /// Details for a step that decrypts an encrypted file. Consists of the following values:
        ///
        /// * A descriptive name
        ///
        /// * An Amazon S3 or Amazon Elastic File System (Amazon EFS) location for the source file to decrypt.
        ///
        /// * An S3 or Amazon EFS location for the destination of the file decryption.
        ///
        /// * A flag that indicates whether to overwrite an existing file of the same name. The default is FALSE.
        ///
        /// * The type of encryption that's used. Currently, only PGP encryption is supported.
        public var decryptStepDetails: TransferClientTypes.DecryptStepDetails?
        /// Details for a step that deletes the file.
        public var deleteStepDetails: TransferClientTypes.DeleteStepDetails?
        /// Details for a step that creates one or more tags. You specify one or more tags. Each tag contains a key-value pair.
        public var tagStepDetails: TransferClientTypes.TagStepDetails?
        /// Currently, the following step types are supported.
        ///
        /// * COPY - Copy the file to another location.
        ///
        /// * CUSTOM - Perform a custom step with an Lambda function target.
        ///
        /// * DECRYPT - Decrypt a file that was encrypted before it was uploaded.
        ///
        /// * DELETE - Delete the file.
        ///
        /// * TAG - Add a tag to the file.
        public var type: TransferClientTypes.WorkflowStepType?

        public init (
            copyStepDetails: TransferClientTypes.CopyStepDetails? = nil,
            customStepDetails: TransferClientTypes.CustomStepDetails? = nil,
            decryptStepDetails: TransferClientTypes.DecryptStepDetails? = nil,
            deleteStepDetails: TransferClientTypes.DeleteStepDetails? = nil,
            tagStepDetails: TransferClientTypes.TagStepDetails? = nil,
            type: TransferClientTypes.WorkflowStepType? = nil
        )
        {
            self.copyStepDetails = copyStepDetails
            self.customStepDetails = customStepDetails
            self.decryptStepDetails = decryptStepDetails
            self.deleteStepDetails = deleteStepDetails
            self.tagStepDetails = tagStepDetails
            self.type = type
        }
    }

}

extension TransferClientTypes {
    public enum WorkflowStepType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case copy
        case custom
        case decrypt
        case delete
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStepType] {
            return [
                .copy,
                .custom,
                .decrypt,
                .delete,
                .tag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .copy: return "COPY"
            case .custom: return "CUSTOM"
            case .decrypt: return "DECRYPT"
            case .delete: return "DELETE"
            case .tag: return "TAG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowStepType(rawValue: rawValue) ?? WorkflowStepType.sdkUnknown(rawValue)
        }
    }
}
