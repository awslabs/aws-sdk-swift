//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension CleanRoomsMLClient {
    /// Paginate over `[ListCollaborationConfiguredModelAlgorithmAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCollaborationConfiguredModelAlgorithmAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCollaborationConfiguredModelAlgorithmAssociationsOutput`
    public func listCollaborationConfiguredModelAlgorithmAssociationsPaginated(input: ListCollaborationConfiguredModelAlgorithmAssociationsInput) -> ClientRuntime.PaginatorSequence<ListCollaborationConfiguredModelAlgorithmAssociationsInput, ListCollaborationConfiguredModelAlgorithmAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListCollaborationConfiguredModelAlgorithmAssociationsInput, ListCollaborationConfiguredModelAlgorithmAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCollaborationConfiguredModelAlgorithmAssociations(input:))
    }
}

extension ListCollaborationConfiguredModelAlgorithmAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCollaborationConfiguredModelAlgorithmAssociationsInput {
        return ListCollaborationConfiguredModelAlgorithmAssociationsInput(
            collaborationIdentifier: self.collaborationIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListCollaborationConfiguredModelAlgorithmAssociationsInput, OperationStackOutput == ListCollaborationConfiguredModelAlgorithmAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCollaborationConfiguredModelAlgorithmAssociationsPaginated`
    /// to access the nested member `[CleanRoomsMLClientTypes.CollaborationConfiguredModelAlgorithmAssociationSummary]`
    /// - Returns: `[CleanRoomsMLClientTypes.CollaborationConfiguredModelAlgorithmAssociationSummary]`
    public func collaborationConfiguredModelAlgorithmAssociations() async throws -> [CleanRoomsMLClientTypes.CollaborationConfiguredModelAlgorithmAssociationSummary] {
        return try await self.asyncCompactMap { item in item.collaborationConfiguredModelAlgorithmAssociations }
    }
}
extension CleanRoomsMLClient {
    /// Paginate over `[ListCollaborationMLInputChannelsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCollaborationMLInputChannelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCollaborationMLInputChannelsOutput`
    public func listCollaborationMLInputChannelsPaginated(input: ListCollaborationMLInputChannelsInput) -> ClientRuntime.PaginatorSequence<ListCollaborationMLInputChannelsInput, ListCollaborationMLInputChannelsOutput> {
        return ClientRuntime.PaginatorSequence<ListCollaborationMLInputChannelsInput, ListCollaborationMLInputChannelsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCollaborationMLInputChannels(input:))
    }
}

extension ListCollaborationMLInputChannelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCollaborationMLInputChannelsInput {
        return ListCollaborationMLInputChannelsInput(
            collaborationIdentifier: self.collaborationIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListCollaborationMLInputChannelsInput, OperationStackOutput == ListCollaborationMLInputChannelsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCollaborationMLInputChannelsPaginated`
    /// to access the nested member `[CleanRoomsMLClientTypes.CollaborationMLInputChannelSummary]`
    /// - Returns: `[CleanRoomsMLClientTypes.CollaborationMLInputChannelSummary]`
    public func collaborationMLInputChannelsList() async throws -> [CleanRoomsMLClientTypes.CollaborationMLInputChannelSummary] {
        return try await self.asyncCompactMap { item in item.collaborationMLInputChannelsList }
    }
}
extension CleanRoomsMLClient {
    /// Paginate over `[ListCollaborationTrainedModelExportJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCollaborationTrainedModelExportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCollaborationTrainedModelExportJobsOutput`
    public func listCollaborationTrainedModelExportJobsPaginated(input: ListCollaborationTrainedModelExportJobsInput) -> ClientRuntime.PaginatorSequence<ListCollaborationTrainedModelExportJobsInput, ListCollaborationTrainedModelExportJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListCollaborationTrainedModelExportJobsInput, ListCollaborationTrainedModelExportJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCollaborationTrainedModelExportJobs(input:))
    }
}

extension ListCollaborationTrainedModelExportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCollaborationTrainedModelExportJobsInput {
        return ListCollaborationTrainedModelExportJobsInput(
            collaborationIdentifier: self.collaborationIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            trainedModelArn: self.trainedModelArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListCollaborationTrainedModelExportJobsInput, OperationStackOutput == ListCollaborationTrainedModelExportJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCollaborationTrainedModelExportJobsPaginated`
    /// to access the nested member `[CleanRoomsMLClientTypes.CollaborationTrainedModelExportJobSummary]`
    /// - Returns: `[CleanRoomsMLClientTypes.CollaborationTrainedModelExportJobSummary]`
    public func collaborationTrainedModelExportJobs() async throws -> [CleanRoomsMLClientTypes.CollaborationTrainedModelExportJobSummary] {
        return try await self.asyncCompactMap { item in item.collaborationTrainedModelExportJobs }
    }
}
extension CleanRoomsMLClient {
    /// Paginate over `[ListCollaborationTrainedModelInferenceJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCollaborationTrainedModelInferenceJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCollaborationTrainedModelInferenceJobsOutput`
    public func listCollaborationTrainedModelInferenceJobsPaginated(input: ListCollaborationTrainedModelInferenceJobsInput) -> ClientRuntime.PaginatorSequence<ListCollaborationTrainedModelInferenceJobsInput, ListCollaborationTrainedModelInferenceJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListCollaborationTrainedModelInferenceJobsInput, ListCollaborationTrainedModelInferenceJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCollaborationTrainedModelInferenceJobs(input:))
    }
}

extension ListCollaborationTrainedModelInferenceJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCollaborationTrainedModelInferenceJobsInput {
        return ListCollaborationTrainedModelInferenceJobsInput(
            collaborationIdentifier: self.collaborationIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            trainedModelArn: self.trainedModelArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListCollaborationTrainedModelInferenceJobsInput, OperationStackOutput == ListCollaborationTrainedModelInferenceJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCollaborationTrainedModelInferenceJobsPaginated`
    /// to access the nested member `[CleanRoomsMLClientTypes.CollaborationTrainedModelInferenceJobSummary]`
    /// - Returns: `[CleanRoomsMLClientTypes.CollaborationTrainedModelInferenceJobSummary]`
    public func collaborationTrainedModelInferenceJobs() async throws -> [CleanRoomsMLClientTypes.CollaborationTrainedModelInferenceJobSummary] {
        return try await self.asyncCompactMap { item in item.collaborationTrainedModelInferenceJobs }
    }
}
extension CleanRoomsMLClient {
    /// Paginate over `[ListCollaborationTrainedModelsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCollaborationTrainedModelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCollaborationTrainedModelsOutput`
    public func listCollaborationTrainedModelsPaginated(input: ListCollaborationTrainedModelsInput) -> ClientRuntime.PaginatorSequence<ListCollaborationTrainedModelsInput, ListCollaborationTrainedModelsOutput> {
        return ClientRuntime.PaginatorSequence<ListCollaborationTrainedModelsInput, ListCollaborationTrainedModelsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCollaborationTrainedModels(input:))
    }
}

extension ListCollaborationTrainedModelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCollaborationTrainedModelsInput {
        return ListCollaborationTrainedModelsInput(
            collaborationIdentifier: self.collaborationIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListCollaborationTrainedModelsInput, OperationStackOutput == ListCollaborationTrainedModelsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCollaborationTrainedModelsPaginated`
    /// to access the nested member `[CleanRoomsMLClientTypes.CollaborationTrainedModelSummary]`
    /// - Returns: `[CleanRoomsMLClientTypes.CollaborationTrainedModelSummary]`
    public func collaborationTrainedModels() async throws -> [CleanRoomsMLClientTypes.CollaborationTrainedModelSummary] {
        return try await self.asyncCompactMap { item in item.collaborationTrainedModels }
    }
}
