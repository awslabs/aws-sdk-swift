// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CleanRoomsMLClientTypes.AudienceDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Destination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Destination = self.s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DestinationDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.S3ConfigMap.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// Defines the Amazon S3 bucket where the configured audience is stored.
    public struct AudienceDestination: Swift.Equatable {
        /// The Amazon S3 bucket and path for the configured audience.
        /// This member is required.
        public var s3Destination: CleanRoomsMLClientTypes.S3ConfigMap?

        public init(
            s3Destination: CleanRoomsMLClientTypes.S3ConfigMap? = nil
        )
        {
            self.s3Destination = s3Destination
        }
    }

}

extension CleanRoomsMLClientTypes {
    public enum AudienceExportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case createPending
        case sdkUnknown(Swift.String)

        public static var allCases: [AudienceExportJobStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .createPending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createPending: return "CREATE_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AudienceExportJobStatus(rawValue: rawValue) ?? AudienceExportJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsMLClientTypes.AudienceExportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceGenerationJobArn
        case audienceSize
        case createTime
        case description
        case name
        case outputLocation
        case status
        case statusDetails
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audienceGenerationJobArn = self.audienceGenerationJobArn {
            try encodeContainer.encode(audienceGenerationJobArn, forKey: .audienceGenerationJobArn)
        }
        if let audienceSize = self.audienceSize {
            try encodeContainer.encode(audienceSize, forKey: .audienceSize)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = self.statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let audienceGenerationJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audienceGenerationJobArn)
        audienceGenerationJobArn = audienceGenerationJobArnDecoded
        let audienceSizeDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceSize.self, forKey: .audienceSize)
        audienceSize = audienceSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.StatusDetails.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// Provides information about the audience export job.
    public struct AudienceExportJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the audience generation job that was exported.
        /// This member is required.
        public var audienceGenerationJobArn: Swift.String?
        /// The size of the generated audience. Must match one of the sizes in the configured audience model.
        /// This member is required.
        public var audienceSize: CleanRoomsMLClientTypes.AudienceSize?
        /// The time at which the audience export job was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description of the audience export job.
        public var description: Swift.String?
        /// The name of the audience export job.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon S3 bucket where the audience export is stored.
        public var outputLocation: Swift.String?
        /// The status of the audience export job.
        /// This member is required.
        public var status: CleanRoomsMLClientTypes.AudienceExportJobStatus?
        /// Details about the status of a resource.
        public var statusDetails: CleanRoomsMLClientTypes.StatusDetails?
        /// The most recent time at which the audience export job was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            audienceGenerationJobArn: Swift.String? = nil,
            audienceSize: CleanRoomsMLClientTypes.AudienceSize? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            outputLocation: Swift.String? = nil,
            status: CleanRoomsMLClientTypes.AudienceExportJobStatus? = nil,
            statusDetails: CleanRoomsMLClientTypes.StatusDetails? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.audienceGenerationJobArn = audienceGenerationJobArn
            self.audienceSize = audienceSize
            self.createTime = createTime
            self.description = description
            self.name = name
            self.outputLocation = outputLocation
            self.status = status
            self.statusDetails = statusDetails
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsMLClientTypes.AudienceGenerationJobDataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.S3ConfigMap.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// Defines the Amazon S3 bucket where the training data for the configured audience is stored.
    public struct AudienceGenerationJobDataSource: Swift.Equatable {
        /// The Amazon S3 bucket where the training data for the configured audience is stored.
        /// This member is required.
        public var dataSource: CleanRoomsMLClientTypes.S3ConfigMap?
        /// The ARN of the IAM role that can read the Amazon S3 bucket where the training data is stored.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            dataSource: CleanRoomsMLClientTypes.S3ConfigMap? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.dataSource = dataSource
            self.roleArn = roleArn
        }
    }

}

extension CleanRoomsMLClientTypes {
    public enum AudienceGenerationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case createPending
        case deleteFailed
        case deleteInProgress
        case deletePending
        case sdkUnknown(Swift.String)

        public static var allCases: [AudienceGenerationJobStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .createPending,
                .deleteFailed,
                .deleteInProgress,
                .deletePending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createPending: return "CREATE_PENDING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .deletePending: return "DELETE_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AudienceGenerationJobStatus(rawValue: rawValue) ?? AudienceGenerationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsMLClientTypes.AudienceGenerationJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceGenerationJobArn
        case collaborationId
        case configuredAudienceModelArn
        case createTime
        case description
        case name
        case startedBy
        case status
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audienceGenerationJobArn = self.audienceGenerationJobArn {
            try encodeContainer.encode(audienceGenerationJobArn, forKey: .audienceGenerationJobArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let configuredAudienceModelArn = self.configuredAudienceModelArn {
            try encodeContainer.encode(configuredAudienceModelArn, forKey: .configuredAudienceModelArn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let startedBy = self.startedBy {
            try encodeContainer.encode(startedBy, forKey: .startedBy)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let audienceGenerationJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audienceGenerationJobArn)
        audienceGenerationJobArn = audienceGenerationJobArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceGenerationJobStatus.self, forKey: .status)
        status = statusDecoded
        let configuredAudienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelArn)
        configuredAudienceModelArn = configuredAudienceModelArnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let startedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedBy)
        startedBy = startedByDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// Provides information about the configured audience generation job.
    public struct AudienceGenerationJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the audience generation job.
        /// This member is required.
        public var audienceGenerationJobArn: Swift.String?
        /// The identifier of the collaboration that contains this audience generation job.
        public var collaborationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the configured audience model that was used for this audience generation job.
        /// This member is required.
        public var configuredAudienceModelArn: Swift.String?
        /// The time at which the audience generation job was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description of the audience generation job.
        public var description: Swift.String?
        /// The name of the audience generation job.
        /// This member is required.
        public var name: Swift.String?
        /// The AWS Account that submitted the job.
        public var startedBy: Swift.String?
        /// The status of the audience generation job.
        /// This member is required.
        public var status: CleanRoomsMLClientTypes.AudienceGenerationJobStatus?
        /// The most recent time at which the audience generation job was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            audienceGenerationJobArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            configuredAudienceModelArn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            startedBy: Swift.String? = nil,
            status: CleanRoomsMLClientTypes.AudienceGenerationJobStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.audienceGenerationJobArn = audienceGenerationJobArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.description = description
            self.name = name
            self.startedBy = startedBy
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsMLClientTypes.AudienceModelMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forTopKItemPredictions
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forTopKItemPredictions = self.forTopKItemPredictions {
            try encodeContainer.encode(forTopKItemPredictions, forKey: .forTopKItemPredictions)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceModelMetricType.self, forKey: .type)
        type = typeDecoded
        let forTopKItemPredictionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forTopKItemPredictions)
        forTopKItemPredictions = forTopKItemPredictionsDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// The audience model metrics.
    public struct AudienceModelMetric: Swift.Equatable {
        /// The number of users that were used to generate these model metrics.
        /// This member is required.
        public var forTopKItemPredictions: Swift.Int?
        /// The audience model metric.
        /// This member is required.
        public var type: CleanRoomsMLClientTypes.AudienceModelMetricType?
        /// The value of the audience model metric
        /// This member is required.
        public var value: Swift.Double?

        public init(
            forTopKItemPredictions: Swift.Int? = nil,
            type: CleanRoomsMLClientTypes.AudienceModelMetricType? = nil,
            value: Swift.Double? = nil
        )
        {
            self.forTopKItemPredictions = forTopKItemPredictions
            self.type = type
            self.value = value
        }
    }

}

extension CleanRoomsMLClientTypes {
    public enum AudienceModelMetricType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case meanReciprocalRank
        case normalizedDiscountedCumulativeGain
        case precision
        case recall
        case sdkUnknown(Swift.String)

        public static var allCases: [AudienceModelMetricType] {
            return [
                .meanReciprocalRank,
                .normalizedDiscountedCumulativeGain,
                .precision,
                .recall,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .meanReciprocalRank: return "MEAN_RECIPROCAL_RANK"
            case .normalizedDiscountedCumulativeGain: return "NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN"
            case .precision: return "PRECISION"
            case .recall: return "RECALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AudienceModelMetricType(rawValue: rawValue) ?? AudienceModelMetricType.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsMLClientTypes {
    public enum AudienceModelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case createPending
        case deleteFailed
        case deleteInProgress
        case deletePending
        case sdkUnknown(Swift.String)

        public static var allCases: [AudienceModelStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .createPending,
                .deleteFailed,
                .deleteInProgress,
                .deletePending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createPending: return "CREATE_PENDING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .deletePending: return "DELETE_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AudienceModelStatus(rawValue: rawValue) ?? AudienceModelStatus.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsMLClientTypes.AudienceModelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceModelArn
        case createTime
        case description
        case name
        case status
        case trainingDatasetArn
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audienceModelArn = self.audienceModelArn {
            try encodeContainer.encode(audienceModelArn, forKey: .audienceModelArn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let trainingDatasetArn = self.trainingDatasetArn {
            try encodeContainer.encode(trainingDatasetArn, forKey: .trainingDatasetArn)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let audienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audienceModelArn)
        audienceModelArn = audienceModelArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let trainingDatasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trainingDatasetArn)
        trainingDatasetArn = trainingDatasetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceModelStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// Information about the audience model.
    public struct AudienceModelSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the audience model.
        /// This member is required.
        public var audienceModelArn: Swift.String?
        /// The time at which the audience model was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description of the audience model.
        public var description: Swift.String?
        /// The name of the audience model.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the audience model.
        /// This member is required.
        public var status: CleanRoomsMLClientTypes.AudienceModelStatus?
        /// The Amazon Resource Name (ARN) of the training dataset that was used for the audience model.
        /// This member is required.
        public var trainingDatasetArn: Swift.String?
        /// The most recent time at which the audience model was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            audienceModelArn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            status: CleanRoomsMLClientTypes.AudienceModelStatus? = nil,
            trainingDatasetArn: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.audienceModelArn = audienceModelArn
            self.createTime = createTime
            self.description = description
            self.name = name
            self.status = status
            self.trainingDatasetArn = trainingDatasetArn
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsMLClientTypes.AudienceQualityMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relevanceMetrics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relevanceMetrics = relevanceMetrics {
            var relevanceMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relevanceMetrics)
            for relevancemetric0 in relevanceMetrics {
                try relevanceMetricsContainer.encode(relevancemetric0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relevanceMetricsContainer = try containerValues.decodeIfPresent([CleanRoomsMLClientTypes.RelevanceMetric?].self, forKey: .relevanceMetrics)
        var relevanceMetricsDecoded0:[CleanRoomsMLClientTypes.RelevanceMetric]? = nil
        if let relevanceMetricsContainer = relevanceMetricsContainer {
            relevanceMetricsDecoded0 = [CleanRoomsMLClientTypes.RelevanceMetric]()
            for structure0 in relevanceMetricsContainer {
                if let structure0 = structure0 {
                    relevanceMetricsDecoded0?.append(structure0)
                }
            }
        }
        relevanceMetrics = relevanceMetricsDecoded0
    }
}

extension CleanRoomsMLClientTypes {
    /// Metrics that describe the quality of the generated audience.
    public struct AudienceQualityMetrics: Swift.Equatable {
        /// The relevance scores of the generated audience.
        /// This member is required.
        public var relevanceMetrics: [CleanRoomsMLClientTypes.RelevanceMetric]?

        public init(
            relevanceMetrics: [CleanRoomsMLClientTypes.RelevanceMetric]? = nil
        )
        {
            self.relevanceMetrics = relevanceMetrics
        }
    }

}

extension CleanRoomsMLClientTypes.AudienceSize: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceSizeType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value)
        value = valueDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// The size of the generated audience. Must match one of the sizes in the configured audience model.
    public struct AudienceSize: Swift.Equatable {
        /// Whether the audience size is defined in absolute terms or as a percentage. You can use the ABSOLUTE[AudienceSize] to configure out audience sizes using the count of identifiers in the output. You can use the Percentage[AudienceSize] to configure sizes in the range 1-100 percent.
        /// This member is required.
        public var type: CleanRoomsMLClientTypes.AudienceSizeType?
        /// Specify an audience size value.
        /// This member is required.
        public var value: Swift.Int?

        public init(
            type: CleanRoomsMLClientTypes.AudienceSizeType? = nil,
            value: Swift.Int? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension CleanRoomsMLClientTypes.AudienceSizeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceSizeBins
        case audienceSizeType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audienceSizeBins = audienceSizeBins {
            var audienceSizeBinsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .audienceSizeBins)
            for audiencesizevalue0 in audienceSizeBins {
                try audienceSizeBinsContainer.encode(audiencesizevalue0)
            }
        }
        if let audienceSizeType = self.audienceSizeType {
            try encodeContainer.encode(audienceSizeType.rawValue, forKey: .audienceSizeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audienceSizeTypeDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceSizeType.self, forKey: .audienceSizeType)
        audienceSizeType = audienceSizeTypeDecoded
        let audienceSizeBinsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .audienceSizeBins)
        var audienceSizeBinsDecoded0:[Swift.Int]? = nil
        if let audienceSizeBinsContainer = audienceSizeBinsContainer {
            audienceSizeBinsDecoded0 = [Swift.Int]()
            for integer0 in audienceSizeBinsContainer {
                if let integer0 = integer0 {
                    audienceSizeBinsDecoded0?.append(integer0)
                }
            }
        }
        audienceSizeBins = audienceSizeBinsDecoded0
    }
}

extension CleanRoomsMLClientTypes {
    /// Configure the list of audience output sizes that can be created. A request to [StartAudienceGenerationJob] that uses this configured audience model must have an audienceSize selected from this list. You can use the ABSOLUTE[AudienceSize] to configure out audience sizes using the count of identifiers in the output. You can use the Percentage[AudienceSize] to configure sizes in the range 1-100 percent.
    public struct AudienceSizeConfig: Swift.Equatable {
        /// An array of the different audience output sizes.
        /// This member is required.
        public var audienceSizeBins: [Swift.Int]?
        /// Whether the audience output sizes are defined as an absolute number or a percentage.
        /// This member is required.
        public var audienceSizeType: CleanRoomsMLClientTypes.AudienceSizeType?

        public init(
            audienceSizeBins: [Swift.Int]? = nil,
            audienceSizeType: CleanRoomsMLClientTypes.AudienceSizeType? = nil
        )
        {
            self.audienceSizeBins = audienceSizeBins
            self.audienceSizeType = audienceSizeType
        }
    }

}

extension CleanRoomsMLClientTypes {
    public enum AudienceSizeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case absolute
        case percentage
        case sdkUnknown(Swift.String)

        public static var allCases: [AudienceSizeType] {
            return [
                .absolute,
                .percentage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .absolute: return "ABSOLUTE"
            case .percentage: return "PERCENTAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AudienceSizeType(rawValue: rawValue) ?? AudienceSizeType.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsMLClientTypes.ColumnSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnName
        case columnTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = self.columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let columnTypes = columnTypes {
            var columnTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnTypes)
            for columntype0 in columnTypes {
                try columnTypesContainer.encode(columntype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let columnTypesContainer = try containerValues.decodeIfPresent([CleanRoomsMLClientTypes.ColumnType?].self, forKey: .columnTypes)
        var columnTypesDecoded0:[CleanRoomsMLClientTypes.ColumnType]? = nil
        if let columnTypesContainer = columnTypesContainer {
            columnTypesDecoded0 = [CleanRoomsMLClientTypes.ColumnType]()
            for enum0 in columnTypesContainer {
                if let enum0 = enum0 {
                    columnTypesDecoded0?.append(enum0)
                }
            }
        }
        columnTypes = columnTypesDecoded0
    }
}

extension CleanRoomsMLClientTypes {
    /// Metadata for a column.
    public struct ColumnSchema: Swift.Equatable {
        /// The name of a column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The data type of column.
        /// This member is required.
        public var columnTypes: [CleanRoomsMLClientTypes.ColumnType]?

        public init(
            columnName: Swift.String? = nil,
            columnTypes: [CleanRoomsMLClientTypes.ColumnType]? = nil
        )
        {
            self.columnName = columnName
            self.columnTypes = columnTypes
        }
    }

}

extension CleanRoomsMLClientTypes {
    public enum ColumnType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case categoricalFeature
        case itemId
        case numericalFeature
        case timestamp
        case userId
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnType] {
            return [
                .categoricalFeature,
                .itemId,
                .numericalFeature,
                .timestamp,
                .userId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .categoricalFeature: return "CATEGORICAL_FEATURE"
            case .itemId: return "ITEM_ID"
            case .numericalFeature: return "NUMERICAL_FEATURE"
            case .timestamp: return "TIMESTAMP"
            case .userId: return "USER_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnType(rawValue: rawValue) ?? ColumnType.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceDestination.self, forKey: .destination)
        destination = destinationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// Configuration information necessary for the configure audience model output.
    public struct ConfiguredAudienceModelOutputConfig: Swift.Equatable {
        /// Defines the Amazon S3 bucket where the configured audience is stored.
        /// This member is required.
        public var destination: CleanRoomsMLClientTypes.AudienceDestination?
        /// The ARN of the IAM role that can write the Amazon S3 bucket.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            destination: CleanRoomsMLClientTypes.AudienceDestination? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.destination = destination
            self.roleArn = roleArn
        }
    }

}

extension CleanRoomsMLClientTypes {
    public enum ConfiguredAudienceModelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfiguredAudienceModelStatus] {
            return [
                .active,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfiguredAudienceModelStatus(rawValue: rawValue) ?? ConfiguredAudienceModelStatus.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsMLClientTypes.ConfiguredAudienceModelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceModelArn
        case configuredAudienceModelArn
        case createTime
        case description
        case name
        case outputConfig
        case status
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audienceModelArn = self.audienceModelArn {
            try encodeContainer.encode(audienceModelArn, forKey: .audienceModelArn)
        }
        if let configuredAudienceModelArn = self.configuredAudienceModelArn {
            try encodeContainer.encode(configuredAudienceModelArn, forKey: .configuredAudienceModelArn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputConfig = self.outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let audienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audienceModelArn)
        audienceModelArn = audienceModelArnDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let configuredAudienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelArn)
        configuredAudienceModelArn = configuredAudienceModelArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.ConfiguredAudienceModelStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// Information about the configured audience model.
    public struct ConfiguredAudienceModelSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the audience model that was used to create the configured audience model.
        /// This member is required.
        public var audienceModelArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the configured audience model that you are interested in.
        /// This member is required.
        public var configuredAudienceModelArn: Swift.String?
        /// The time at which the configured audience model was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description of the configured audience model.
        public var description: Swift.String?
        /// The name of the configured audience model.
        /// This member is required.
        public var name: Swift.String?
        /// The output configuration of the configured audience model.
        /// This member is required.
        public var outputConfig: CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig?
        /// The status of the configured audience model.
        /// This member is required.
        public var status: CleanRoomsMLClientTypes.ConfiguredAudienceModelStatus?
        /// The most recent time at which the configured audience model was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            audienceModelArn: Swift.String? = nil,
            configuredAudienceModelArn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            outputConfig: CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig? = nil,
            status: CleanRoomsMLClientTypes.ConfiguredAudienceModelStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.audienceModelArn = audienceModelArn
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.description = description
            self.name = name
            self.outputConfig = outputConfig
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource with that name already exists in this region.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAudienceModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case kmsKeyArn
        case name
        case tags
        case trainingDataEndTime
        case trainingDataStartTime
        case trainingDatasetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let trainingDataEndTime = self.trainingDataEndTime {
            try encodeContainer.encodeTimestamp(trainingDataEndTime, format: .dateTime, forKey: .trainingDataEndTime)
        }
        if let trainingDataStartTime = self.trainingDataStartTime {
            try encodeContainer.encodeTimestamp(trainingDataStartTime, format: .dateTime, forKey: .trainingDataStartTime)
        }
        if let trainingDatasetArn = self.trainingDatasetArn {
            try encodeContainer.encode(trainingDatasetArn, forKey: .trainingDatasetArn)
        }
    }
}

extension CreateAudienceModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audience-model"
    }
}

public struct CreateAudienceModelInput: Swift.Equatable {
    /// The description of the audience model.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key. This key is used to encrypt and decrypt customer-owned data in the trained ML model and the associated data.
    public var kmsKeyArn: Swift.String?
    /// The name of the audience model resource.
    /// This member is required.
    public var name: Swift.String?
    /// The optional metadata that you apply to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [Swift.String:Swift.String]?
    /// The end date and time of the training window.
    public var trainingDataEndTime: ClientRuntime.Date?
    /// The start date and time of the training window.
    public var trainingDataStartTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the training dataset for this audience model.
    /// This member is required.
    public var trainingDatasetArn: Swift.String?

    public init(
        description: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trainingDataEndTime: ClientRuntime.Date? = nil,
        trainingDataStartTime: ClientRuntime.Date? = nil,
        trainingDatasetArn: Swift.String? = nil
    )
    {
        self.description = description
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.tags = tags
        self.trainingDataEndTime = trainingDataEndTime
        self.trainingDataStartTime = trainingDataStartTime
        self.trainingDatasetArn = trainingDatasetArn
    }
}

struct CreateAudienceModelInputBody: Swift.Equatable {
    let trainingDataStartTime: ClientRuntime.Date?
    let trainingDataEndTime: ClientRuntime.Date?
    let name: Swift.String?
    let trainingDatasetArn: Swift.String?
    let kmsKeyArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let description: Swift.String?
}

extension CreateAudienceModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case kmsKeyArn
        case name
        case tags
        case trainingDataEndTime
        case trainingDataStartTime
        case trainingDatasetArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trainingDataStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .trainingDataStartTime)
        trainingDataStartTime = trainingDataStartTimeDecoded
        let trainingDataEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .trainingDataEndTime)
        trainingDataEndTime = trainingDataEndTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let trainingDatasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trainingDatasetArn)
        trainingDatasetArn = trainingDatasetArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateAudienceModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAudienceModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.audienceModelArn = output.audienceModelArn
        } else {
            self.audienceModelArn = nil
        }
    }
}

public struct CreateAudienceModelOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the audience model.
    /// This member is required.
    public var audienceModelArn: Swift.String?

    public init(
        audienceModelArn: Swift.String? = nil
    )
    {
        self.audienceModelArn = audienceModelArn
    }
}

struct CreateAudienceModelOutputBody: Swift.Equatable {
    let audienceModelArn: Swift.String?
}

extension CreateAudienceModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceModelArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audienceModelArn)
        audienceModelArn = audienceModelArnDecoded
    }
}

enum CreateAudienceModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConfiguredAudienceModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceModelArn
        case audienceSizeConfig
        case childResourceTagOnCreatePolicy
        case description
        case minMatchingSeedSize
        case name
        case outputConfig
        case sharedAudienceMetrics
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audienceModelArn = self.audienceModelArn {
            try encodeContainer.encode(audienceModelArn, forKey: .audienceModelArn)
        }
        if let audienceSizeConfig = self.audienceSizeConfig {
            try encodeContainer.encode(audienceSizeConfig, forKey: .audienceSizeConfig)
        }
        if let childResourceTagOnCreatePolicy = self.childResourceTagOnCreatePolicy {
            try encodeContainer.encode(childResourceTagOnCreatePolicy.rawValue, forKey: .childResourceTagOnCreatePolicy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let minMatchingSeedSize = self.minMatchingSeedSize {
            try encodeContainer.encode(minMatchingSeedSize, forKey: .minMatchingSeedSize)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputConfig = self.outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
        if let sharedAudienceMetrics = sharedAudienceMetrics {
            var sharedAudienceMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedAudienceMetrics)
            for sharedaudiencemetrics0 in sharedAudienceMetrics {
                try sharedAudienceMetricsContainer.encode(sharedaudiencemetrics0.rawValue)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateConfiguredAudienceModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configured-audience-model"
    }
}

public struct CreateConfiguredAudienceModelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the audience model to use for the configured audience model.
    /// This member is required.
    public var audienceModelArn: Swift.String?
    /// Configure the list of output sizes of audiences that can be created using this configured audience model. A request to [StartAudienceGenerationJob] that uses this configured audience model must have an audienceSize selected from this list. You can use the ABSOLUTE[AudienceSize] to configure out audience sizes using the count of identifiers in the output. You can use the Percentage[AudienceSize] to configure sizes in the range 1-100 percent.
    public var audienceSizeConfig: CleanRoomsMLClientTypes.AudienceSizeConfig?
    /// Configure how the service tags audience generation jobs created using this configured audience model. If you specify NONE, the tags from the [StartAudienceGenerationJob] request determine the tags of the audience generation job. If you specify FROM_PARENT_RESOURCE, the audience generation job inherits the tags from the configured audience model, by default. Tags in the [StartAudienceGenerationJob] will override the default. When the client is in a different account than the configured audience model, the tags from the client are never applied to a resource in the caller's account.
    public var childResourceTagOnCreatePolicy: CleanRoomsMLClientTypes.TagOnCreatePolicy?
    /// The description of the configured audience model.
    public var description: Swift.String?
    /// The minimum number of users from the seed audience that must match with users in the training data of the audience model.
    public var minMatchingSeedSize: Swift.Int?
    /// The name of the configured audience model.
    /// This member is required.
    public var name: Swift.String?
    /// Configure the Amazon S3 location and IAM Role for audiences created using this configured audience model. Each audience will have a unique location. The IAM Role must have s3:PutObject permission on the destination Amazon S3 location. If the destination is protected with Amazon S3 KMS-SSE, then the Role must also have the required KMS permissions.
    /// This member is required.
    public var outputConfig: CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig?
    /// Whether audience metrics are shared.
    /// This member is required.
    public var sharedAudienceMetrics: [CleanRoomsMLClientTypes.SharedAudienceMetrics]?
    /// The optional metadata that you apply to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [Swift.String:Swift.String]?

    public init(
        audienceModelArn: Swift.String? = nil,
        audienceSizeConfig: CleanRoomsMLClientTypes.AudienceSizeConfig? = nil,
        childResourceTagOnCreatePolicy: CleanRoomsMLClientTypes.TagOnCreatePolicy? = nil,
        description: Swift.String? = nil,
        minMatchingSeedSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        outputConfig: CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig? = nil,
        sharedAudienceMetrics: [CleanRoomsMLClientTypes.SharedAudienceMetrics]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.audienceModelArn = audienceModelArn
        self.audienceSizeConfig = audienceSizeConfig
        self.childResourceTagOnCreatePolicy = childResourceTagOnCreatePolicy
        self.description = description
        self.minMatchingSeedSize = minMatchingSeedSize
        self.name = name
        self.outputConfig = outputConfig
        self.sharedAudienceMetrics = sharedAudienceMetrics
        self.tags = tags
    }
}

struct CreateConfiguredAudienceModelInputBody: Swift.Equatable {
    let name: Swift.String?
    let audienceModelArn: Swift.String?
    let outputConfig: CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig?
    let description: Swift.String?
    let sharedAudienceMetrics: [CleanRoomsMLClientTypes.SharedAudienceMetrics]?
    let minMatchingSeedSize: Swift.Int?
    let audienceSizeConfig: CleanRoomsMLClientTypes.AudienceSizeConfig?
    let tags: [Swift.String:Swift.String]?
    let childResourceTagOnCreatePolicy: CleanRoomsMLClientTypes.TagOnCreatePolicy?
}

extension CreateConfiguredAudienceModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceModelArn
        case audienceSizeConfig
        case childResourceTagOnCreatePolicy
        case description
        case minMatchingSeedSize
        case name
        case outputConfig
        case sharedAudienceMetrics
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let audienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audienceModelArn)
        audienceModelArn = audienceModelArnDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sharedAudienceMetricsContainer = try containerValues.decodeIfPresent([CleanRoomsMLClientTypes.SharedAudienceMetrics?].self, forKey: .sharedAudienceMetrics)
        var sharedAudienceMetricsDecoded0:[CleanRoomsMLClientTypes.SharedAudienceMetrics]? = nil
        if let sharedAudienceMetricsContainer = sharedAudienceMetricsContainer {
            sharedAudienceMetricsDecoded0 = [CleanRoomsMLClientTypes.SharedAudienceMetrics]()
            for enum0 in sharedAudienceMetricsContainer {
                if let enum0 = enum0 {
                    sharedAudienceMetricsDecoded0?.append(enum0)
                }
            }
        }
        sharedAudienceMetrics = sharedAudienceMetricsDecoded0
        let minMatchingSeedSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minMatchingSeedSize)
        minMatchingSeedSize = minMatchingSeedSizeDecoded
        let audienceSizeConfigDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceSizeConfig.self, forKey: .audienceSizeConfig)
        audienceSizeConfig = audienceSizeConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let childResourceTagOnCreatePolicyDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.TagOnCreatePolicy.self, forKey: .childResourceTagOnCreatePolicy)
        childResourceTagOnCreatePolicy = childResourceTagOnCreatePolicyDecoded
    }
}

extension CreateConfiguredAudienceModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConfiguredAudienceModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredAudienceModelArn = output.configuredAudienceModelArn
        } else {
            self.configuredAudienceModelArn = nil
        }
    }
}

public struct CreateConfiguredAudienceModelOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configured audience model.
    /// This member is required.
    public var configuredAudienceModelArn: Swift.String?

    public init(
        configuredAudienceModelArn: Swift.String? = nil
    )
    {
        self.configuredAudienceModelArn = configuredAudienceModelArn
    }
}

struct CreateConfiguredAudienceModelOutputBody: Swift.Equatable {
    let configuredAudienceModelArn: Swift.String?
}

extension CreateConfiguredAudienceModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredAudienceModelArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredAudienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelArn)
        configuredAudienceModelArn = configuredAudienceModelArnDecoded
    }
}

enum CreateConfiguredAudienceModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTrainingDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case roleArn
        case tags
        case trainingData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let trainingData = trainingData {
            var trainingDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trainingData)
            for dataset0 in trainingData {
                try trainingDataContainer.encode(dataset0)
            }
        }
    }
}

extension CreateTrainingDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/training-dataset"
    }
}

public struct CreateTrainingDatasetInput: Swift.Equatable {
    /// The description of the training dataset.
    public var description: Swift.String?
    /// The name of the training dataset. This name must be unique in your account and region.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the IAM role that Clean Rooms ML can assume to read the data referred to in the dataSource field of each dataset. Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an AccessDeniedException error.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The optional metadata that you apply to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Clean Rooms ML considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [Swift.String:Swift.String]?
    /// An array of information that lists the Dataset objects, which specifies the dataset type and details on its location and schema. You must provide a role that has read access to these tables.
    /// This member is required.
    public var trainingData: [CleanRoomsMLClientTypes.Dataset]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trainingData: [CleanRoomsMLClientTypes.Dataset]? = nil
    )
    {
        self.description = description
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
        self.trainingData = trainingData
    }
}

struct CreateTrainingDatasetInputBody: Swift.Equatable {
    let name: Swift.String?
    let roleArn: Swift.String?
    let trainingData: [CleanRoomsMLClientTypes.Dataset]?
    let tags: [Swift.String:Swift.String]?
    let description: Swift.String?
}

extension CreateTrainingDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case roleArn
        case tags
        case trainingData
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let trainingDataContainer = try containerValues.decodeIfPresent([CleanRoomsMLClientTypes.Dataset?].self, forKey: .trainingData)
        var trainingDataDecoded0:[CleanRoomsMLClientTypes.Dataset]? = nil
        if let trainingDataContainer = trainingDataContainer {
            trainingDataDecoded0 = [CleanRoomsMLClientTypes.Dataset]()
            for structure0 in trainingDataContainer {
                if let structure0 = structure0 {
                    trainingDataDecoded0?.append(structure0)
                }
            }
        }
        trainingData = trainingDataDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateTrainingDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTrainingDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.trainingDatasetArn = output.trainingDatasetArn
        } else {
            self.trainingDatasetArn = nil
        }
    }
}

public struct CreateTrainingDatasetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the training dataset resource.
    /// This member is required.
    public var trainingDatasetArn: Swift.String?

    public init(
        trainingDatasetArn: Swift.String? = nil
    )
    {
        self.trainingDatasetArn = trainingDatasetArn
    }
}

struct CreateTrainingDatasetOutputBody: Swift.Equatable {
    let trainingDatasetArn: Swift.String?
}

extension CreateTrainingDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trainingDatasetArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trainingDatasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trainingDatasetArn)
        trainingDatasetArn = trainingDatasetArnDecoded
    }
}

enum CreateTrainingDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsMLClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case glueDataSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let glueDataSource = self.glueDataSource {
            try encodeContainer.encode(glueDataSource, forKey: .glueDataSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let glueDataSourceDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.GlueDataSource.self, forKey: .glueDataSource)
        glueDataSource = glueDataSourceDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// Defines information about the Glue data source that contains the training data.
    public struct DataSource: Swift.Equatable {
        /// A GlueDataSource object that defines the catalog ID, database name, and table name for the training data.
        /// This member is required.
        public var glueDataSource: CleanRoomsMLClientTypes.GlueDataSource?

        public init(
            glueDataSource: CleanRoomsMLClientTypes.GlueDataSource? = nil
        )
        {
            self.glueDataSource = glueDataSource
        }
    }

}

extension CleanRoomsMLClientTypes.Dataset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputConfig
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputConfig = self.inputConfig {
            try encodeContainer.encode(inputConfig, forKey: .inputConfig)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.DatasetType.self, forKey: .type)
        type = typeDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.DatasetInputConfig.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// Defines where the training dataset is located, what type of data it contains, and how to access the data.
    public struct Dataset: Swift.Equatable {
        /// A DatasetInputConfig object that defines the data source and schema mapping.
        /// This member is required.
        public var inputConfig: CleanRoomsMLClientTypes.DatasetInputConfig?
        /// What type of information is found in the dataset.
        /// This member is required.
        public var type: CleanRoomsMLClientTypes.DatasetType?

        public init(
            inputConfig: CleanRoomsMLClientTypes.DatasetInputConfig? = nil,
            type: CleanRoomsMLClientTypes.DatasetType? = nil
        )
        {
            self.inputConfig = inputConfig
            self.type = type
        }
    }

}

extension CleanRoomsMLClientTypes.DatasetInputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let schema = schema {
            var schemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schema)
            for columnschema0 in schema {
                try schemaContainer.encode(columnschema0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaContainer = try containerValues.decodeIfPresent([CleanRoomsMLClientTypes.ColumnSchema?].self, forKey: .schema)
        var schemaDecoded0:[CleanRoomsMLClientTypes.ColumnSchema]? = nil
        if let schemaContainer = schemaContainer {
            schemaDecoded0 = [CleanRoomsMLClientTypes.ColumnSchema]()
            for structure0 in schemaContainer {
                if let structure0 = structure0 {
                    schemaDecoded0?.append(structure0)
                }
            }
        }
        schema = schemaDecoded0
        let dataSourceDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// Defines the Glue data source and schema mapping information.
    public struct DatasetInputConfig: Swift.Equatable {
        /// A DataSource object that specifies the Glue data source for the training data.
        /// This member is required.
        public var dataSource: CleanRoomsMLClientTypes.DataSource?
        /// The schema information for the training data.
        /// This member is required.
        public var schema: [CleanRoomsMLClientTypes.ColumnSchema]?

        public init(
            dataSource: CleanRoomsMLClientTypes.DataSource? = nil,
            schema: [CleanRoomsMLClientTypes.ColumnSchema]? = nil
        )
        {
            self.dataSource = dataSource
            self.schema = schema
        }
    }

}

extension CleanRoomsMLClientTypes {
    public enum DatasetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case interactions
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetType] {
            return [
                .interactions,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .interactions: return "INTERACTIONS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetType(rawValue: rawValue) ?? DatasetType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAudienceGenerationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let audienceGenerationJobArn = audienceGenerationJobArn else {
            return nil
        }
        return "/audience-generation-job/\(audienceGenerationJobArn.urlPercentEncoding())"
    }
}

public struct DeleteAudienceGenerationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the audience generation job that you want to delete.
    /// This member is required.
    public var audienceGenerationJobArn: Swift.String?

    public init(
        audienceGenerationJobArn: Swift.String? = nil
    )
    {
        self.audienceGenerationJobArn = audienceGenerationJobArn
    }
}

struct DeleteAudienceGenerationJobInputBody: Swift.Equatable {
}

extension DeleteAudienceGenerationJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAudienceGenerationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAudienceGenerationJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAudienceGenerationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAudienceModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let audienceModelArn = audienceModelArn else {
            return nil
        }
        return "/audience-model/\(audienceModelArn.urlPercentEncoding())"
    }
}

public struct DeleteAudienceModelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the audience model that you want to delete.
    /// This member is required.
    public var audienceModelArn: Swift.String?

    public init(
        audienceModelArn: Swift.String? = nil
    )
    {
        self.audienceModelArn = audienceModelArn
    }
}

struct DeleteAudienceModelInputBody: Swift.Equatable {
}

extension DeleteAudienceModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAudienceModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAudienceModelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAudienceModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConfiguredAudienceModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configuredAudienceModelArn = configuredAudienceModelArn else {
            return nil
        }
        return "/configured-audience-model/\(configuredAudienceModelArn.urlPercentEncoding())"
    }
}

public struct DeleteConfiguredAudienceModelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configured audience model that you want to delete.
    /// This member is required.
    public var configuredAudienceModelArn: Swift.String?

    public init(
        configuredAudienceModelArn: Swift.String? = nil
    )
    {
        self.configuredAudienceModelArn = configuredAudienceModelArn
    }
}

struct DeleteConfiguredAudienceModelInputBody: Swift.Equatable {
}

extension DeleteConfiguredAudienceModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfiguredAudienceModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConfiguredAudienceModelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConfiguredAudienceModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConfiguredAudienceModelPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configuredAudienceModelArn = configuredAudienceModelArn else {
            return nil
        }
        return "/configured-audience-model/\(configuredAudienceModelArn.urlPercentEncoding())/policy"
    }
}

public struct DeleteConfiguredAudienceModelPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configured audience model policy that you want to delete.
    /// This member is required.
    public var configuredAudienceModelArn: Swift.String?

    public init(
        configuredAudienceModelArn: Swift.String? = nil
    )
    {
        self.configuredAudienceModelArn = configuredAudienceModelArn
    }
}

struct DeleteConfiguredAudienceModelPolicyInputBody: Swift.Equatable {
}

extension DeleteConfiguredAudienceModelPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfiguredAudienceModelPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConfiguredAudienceModelPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConfiguredAudienceModelPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTrainingDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trainingDatasetArn = trainingDatasetArn else {
            return nil
        }
        return "/training-dataset/\(trainingDatasetArn.urlPercentEncoding())"
    }
}

public struct DeleteTrainingDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the training dataset that you want to delete.
    /// This member is required.
    public var trainingDatasetArn: Swift.String?

    public init(
        trainingDatasetArn: Swift.String? = nil
    )
    {
        self.trainingDatasetArn = trainingDatasetArn
    }
}

struct DeleteTrainingDatasetInputBody: Swift.Equatable {
}

extension DeleteTrainingDatasetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTrainingDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTrainingDatasetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTrainingDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAudienceGenerationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let audienceGenerationJobArn = audienceGenerationJobArn else {
            return nil
        }
        return "/audience-generation-job/\(audienceGenerationJobArn.urlPercentEncoding())"
    }
}

public struct GetAudienceGenerationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the audience generation job that you are interested in.
    /// This member is required.
    public var audienceGenerationJobArn: Swift.String?

    public init(
        audienceGenerationJobArn: Swift.String? = nil
    )
    {
        self.audienceGenerationJobArn = audienceGenerationJobArn
    }
}

struct GetAudienceGenerationJobInputBody: Swift.Equatable {
}

extension GetAudienceGenerationJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAudienceGenerationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAudienceGenerationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.audienceGenerationJobArn = output.audienceGenerationJobArn
            self.collaborationId = output.collaborationId
            self.configuredAudienceModelArn = output.configuredAudienceModelArn
            self.createTime = output.createTime
            self.description = output.description
            self.includeSeedInOutput = output.includeSeedInOutput
            self.metrics = output.metrics
            self.name = output.name
            self.seedAudience = output.seedAudience
            self.startedBy = output.startedBy
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.audienceGenerationJobArn = nil
            self.collaborationId = nil
            self.configuredAudienceModelArn = nil
            self.createTime = nil
            self.description = nil
            self.includeSeedInOutput = nil
            self.metrics = nil
            self.name = nil
            self.seedAudience = nil
            self.startedBy = nil
            self.status = nil
            self.statusDetails = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct GetAudienceGenerationJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the audience generation job.
    /// This member is required.
    public var audienceGenerationJobArn: Swift.String?
    /// The identifier of the collaboration that this audience generation job is associated with.
    public var collaborationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the configured audience model used for this audience generation job.
    /// This member is required.
    public var configuredAudienceModelArn: Swift.String?
    /// The time at which the audience generation job was created.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The description of the audience generation job.
    public var description: Swift.String?
    /// Configure whether the seed users are included in the output audience. By default, Clean Rooms ML removes seed users from the output audience. If you specify TRUE, the seed users will appear first in the output. Clean Rooms ML does not explicitly reveal whether a user was in the seed, but the recipient of the audience will know that the first minimumSeedSize count of users are from the seed.
    public var includeSeedInOutput: Swift.Bool?
    /// The relevance scores for different audience sizes.
    public var metrics: CleanRoomsMLClientTypes.AudienceQualityMetrics?
    /// The name of the audience generation job.
    /// This member is required.
    public var name: Swift.String?
    /// The seed audience that was used for this audience generation job. This field will be null if the account calling the API is the account that started this audience generation job.
    public var seedAudience: CleanRoomsMLClientTypes.AudienceGenerationJobDataSource?
    /// The AWS account that started this audience generation job.
    public var startedBy: Swift.String?
    /// The status of the audience generation job.
    /// This member is required.
    public var status: CleanRoomsMLClientTypes.AudienceGenerationJobStatus?
    /// Details about the status of the audience generation job.
    public var statusDetails: CleanRoomsMLClientTypes.StatusDetails?
    /// The tags that are associated to this audience generation job.
    public var tags: [Swift.String:Swift.String]?
    /// The most recent time at which the audience generation job was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        audienceGenerationJobArn: Swift.String? = nil,
        collaborationId: Swift.String? = nil,
        configuredAudienceModelArn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        includeSeedInOutput: Swift.Bool? = nil,
        metrics: CleanRoomsMLClientTypes.AudienceQualityMetrics? = nil,
        name: Swift.String? = nil,
        seedAudience: CleanRoomsMLClientTypes.AudienceGenerationJobDataSource? = nil,
        startedBy: Swift.String? = nil,
        status: CleanRoomsMLClientTypes.AudienceGenerationJobStatus? = nil,
        statusDetails: CleanRoomsMLClientTypes.StatusDetails? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.audienceGenerationJobArn = audienceGenerationJobArn
        self.collaborationId = collaborationId
        self.configuredAudienceModelArn = configuredAudienceModelArn
        self.createTime = createTime
        self.description = description
        self.includeSeedInOutput = includeSeedInOutput
        self.metrics = metrics
        self.name = name
        self.seedAudience = seedAudience
        self.startedBy = startedBy
        self.status = status
        self.statusDetails = statusDetails
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct GetAudienceGenerationJobOutputBody: Swift.Equatable {
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let audienceGenerationJobArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let status: CleanRoomsMLClientTypes.AudienceGenerationJobStatus?
    let statusDetails: CleanRoomsMLClientTypes.StatusDetails?
    let configuredAudienceModelArn: Swift.String?
    let seedAudience: CleanRoomsMLClientTypes.AudienceGenerationJobDataSource?
    let includeSeedInOutput: Swift.Bool?
    let collaborationId: Swift.String?
    let metrics: CleanRoomsMLClientTypes.AudienceQualityMetrics?
    let startedBy: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetAudienceGenerationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceGenerationJobArn
        case collaborationId
        case configuredAudienceModelArn
        case createTime
        case description
        case includeSeedInOutput
        case metrics
        case name
        case seedAudience
        case startedBy
        case status
        case statusDetails
        case tags
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let audienceGenerationJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audienceGenerationJobArn)
        audienceGenerationJobArn = audienceGenerationJobArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceGenerationJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.StatusDetails.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let configuredAudienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelArn)
        configuredAudienceModelArn = configuredAudienceModelArnDecoded
        let seedAudienceDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceGenerationJobDataSource.self, forKey: .seedAudience)
        seedAudience = seedAudienceDecoded
        let includeSeedInOutputDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeSeedInOutput)
        includeSeedInOutput = includeSeedInOutputDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceQualityMetrics.self, forKey: .metrics)
        metrics = metricsDecoded
        let startedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedBy)
        startedBy = startedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetAudienceGenerationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAudienceModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let audienceModelArn = audienceModelArn else {
            return nil
        }
        return "/audience-model/\(audienceModelArn.urlPercentEncoding())"
    }
}

public struct GetAudienceModelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the audience model that you are interested in.
    /// This member is required.
    public var audienceModelArn: Swift.String?

    public init(
        audienceModelArn: Swift.String? = nil
    )
    {
        self.audienceModelArn = audienceModelArn
    }
}

struct GetAudienceModelInputBody: Swift.Equatable {
}

extension GetAudienceModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAudienceModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAudienceModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.audienceModelArn = output.audienceModelArn
            self.createTime = output.createTime
            self.description = output.description
            self.kmsKeyArn = output.kmsKeyArn
            self.metrics = output.metrics
            self.name = output.name
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.tags = output.tags
            self.trainingDataEndTime = output.trainingDataEndTime
            self.trainingDataStartTime = output.trainingDataStartTime
            self.trainingDatasetArn = output.trainingDatasetArn
            self.updateTime = output.updateTime
        } else {
            self.audienceModelArn = nil
            self.createTime = nil
            self.description = nil
            self.kmsKeyArn = nil
            self.metrics = nil
            self.name = nil
            self.status = nil
            self.statusDetails = nil
            self.tags = nil
            self.trainingDataEndTime = nil
            self.trainingDataStartTime = nil
            self.trainingDatasetArn = nil
            self.updateTime = nil
        }
    }
}

public struct GetAudienceModelOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the audience model.
    /// This member is required.
    public var audienceModelArn: Swift.String?
    /// The time at which the audience model was created.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The description of the audience model.
    public var description: Swift.String?
    /// The KMS key ARN used for the audience model.
    public var kmsKeyArn: Swift.String?
    /// Accuracy metrics for the model.
    public var metrics: [CleanRoomsMLClientTypes.AudienceModelMetric]?
    /// The name of the audience model.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the audience model.
    /// This member is required.
    public var status: CleanRoomsMLClientTypes.AudienceModelStatus?
    /// Details about the status of the audience model.
    public var statusDetails: CleanRoomsMLClientTypes.StatusDetails?
    /// The tags that are assigned to the audience model.
    public var tags: [Swift.String:Swift.String]?
    /// The end date specified for the training window.
    public var trainingDataEndTime: ClientRuntime.Date?
    /// The start date specified for the training window.
    public var trainingDataStartTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the training dataset that was used for this audience model.
    /// This member is required.
    public var trainingDatasetArn: Swift.String?
    /// The most recent time at which the audience model was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        audienceModelArn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        metrics: [CleanRoomsMLClientTypes.AudienceModelMetric]? = nil,
        name: Swift.String? = nil,
        status: CleanRoomsMLClientTypes.AudienceModelStatus? = nil,
        statusDetails: CleanRoomsMLClientTypes.StatusDetails? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trainingDataEndTime: ClientRuntime.Date? = nil,
        trainingDataStartTime: ClientRuntime.Date? = nil,
        trainingDatasetArn: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.audienceModelArn = audienceModelArn
        self.createTime = createTime
        self.description = description
        self.kmsKeyArn = kmsKeyArn
        self.metrics = metrics
        self.name = name
        self.status = status
        self.statusDetails = statusDetails
        self.tags = tags
        self.trainingDataEndTime = trainingDataEndTime
        self.trainingDataStartTime = trainingDataStartTime
        self.trainingDatasetArn = trainingDatasetArn
        self.updateTime = updateTime
    }
}

struct GetAudienceModelOutputBody: Swift.Equatable {
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let trainingDataStartTime: ClientRuntime.Date?
    let trainingDataEndTime: ClientRuntime.Date?
    let audienceModelArn: Swift.String?
    let name: Swift.String?
    let trainingDatasetArn: Swift.String?
    let status: CleanRoomsMLClientTypes.AudienceModelStatus?
    let statusDetails: CleanRoomsMLClientTypes.StatusDetails?
    let metrics: [CleanRoomsMLClientTypes.AudienceModelMetric]?
    let kmsKeyArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let description: Swift.String?
}

extension GetAudienceModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceModelArn
        case createTime
        case description
        case kmsKeyArn
        case metrics
        case name
        case status
        case statusDetails
        case tags
        case trainingDataEndTime
        case trainingDataStartTime
        case trainingDatasetArn
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let trainingDataStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .trainingDataStartTime)
        trainingDataStartTime = trainingDataStartTimeDecoded
        let trainingDataEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .trainingDataEndTime)
        trainingDataEndTime = trainingDataEndTimeDecoded
        let audienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audienceModelArn)
        audienceModelArn = audienceModelArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let trainingDatasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trainingDatasetArn)
        trainingDatasetArn = trainingDatasetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceModelStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.StatusDetails.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let metricsContainer = try containerValues.decodeIfPresent([CleanRoomsMLClientTypes.AudienceModelMetric?].self, forKey: .metrics)
        var metricsDecoded0:[CleanRoomsMLClientTypes.AudienceModelMetric]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [CleanRoomsMLClientTypes.AudienceModelMetric]()
            for structure0 in metricsContainer {
                if let structure0 = structure0 {
                    metricsDecoded0?.append(structure0)
                }
            }
        }
        metrics = metricsDecoded0
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum GetAudienceModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConfiguredAudienceModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configuredAudienceModelArn = configuredAudienceModelArn else {
            return nil
        }
        return "/configured-audience-model/\(configuredAudienceModelArn.urlPercentEncoding())"
    }
}

public struct GetConfiguredAudienceModelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configured audience model that you are interested in.
    /// This member is required.
    public var configuredAudienceModelArn: Swift.String?

    public init(
        configuredAudienceModelArn: Swift.String? = nil
    )
    {
        self.configuredAudienceModelArn = configuredAudienceModelArn
    }
}

struct GetConfiguredAudienceModelInputBody: Swift.Equatable {
}

extension GetConfiguredAudienceModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConfiguredAudienceModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConfiguredAudienceModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.audienceModelArn = output.audienceModelArn
            self.audienceSizeConfig = output.audienceSizeConfig
            self.childResourceTagOnCreatePolicy = output.childResourceTagOnCreatePolicy
            self.configuredAudienceModelArn = output.configuredAudienceModelArn
            self.createTime = output.createTime
            self.description = output.description
            self.minMatchingSeedSize = output.minMatchingSeedSize
            self.name = output.name
            self.outputConfig = output.outputConfig
            self.sharedAudienceMetrics = output.sharedAudienceMetrics
            self.status = output.status
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.audienceModelArn = nil
            self.audienceSizeConfig = nil
            self.childResourceTagOnCreatePolicy = nil
            self.configuredAudienceModelArn = nil
            self.createTime = nil
            self.description = nil
            self.minMatchingSeedSize = nil
            self.name = nil
            self.outputConfig = nil
            self.sharedAudienceMetrics = nil
            self.status = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct GetConfiguredAudienceModelOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the audience model used for this configured audience model.
    /// This member is required.
    public var audienceModelArn: Swift.String?
    /// The list of output sizes of audiences that can be created using this configured audience model. A request to [StartAudienceGenerationJob] that uses this configured audience model must have an audienceSize selected from this list. You can use the ABSOLUTE[AudienceSize] to configure out audience sizes using the count of identifiers in the output. You can use the Percentage[AudienceSize] to configure sizes in the range 1-100 percent.
    public var audienceSizeConfig: CleanRoomsMLClientTypes.AudienceSizeConfig?
    /// Provides the childResourceTagOnCreatePolicy that was used for this configured audience model.
    public var childResourceTagOnCreatePolicy: CleanRoomsMLClientTypes.TagOnCreatePolicy?
    /// The Amazon Resource Name (ARN) of the configured audience model.
    /// This member is required.
    public var configuredAudienceModelArn: Swift.String?
    /// The time at which the configured audience model was created.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The description of the configured audience model.
    public var description: Swift.String?
    /// The minimum number of users from the seed audience that must match with users in the training data of the audience model.
    public var minMatchingSeedSize: Swift.Int?
    /// The name of the configured audience model.
    /// This member is required.
    public var name: Swift.String?
    /// The output configuration of the configured audience model
    /// This member is required.
    public var outputConfig: CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig?
    /// Whether audience metrics are shared.
    /// This member is required.
    public var sharedAudienceMetrics: [CleanRoomsMLClientTypes.SharedAudienceMetrics]?
    /// The status of the configured audience model.
    /// This member is required.
    public var status: CleanRoomsMLClientTypes.ConfiguredAudienceModelStatus?
    /// The tags that are associated to this configured audience model.
    public var tags: [Swift.String:Swift.String]?
    /// The most recent time at which the configured audience model was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        audienceModelArn: Swift.String? = nil,
        audienceSizeConfig: CleanRoomsMLClientTypes.AudienceSizeConfig? = nil,
        childResourceTagOnCreatePolicy: CleanRoomsMLClientTypes.TagOnCreatePolicy? = nil,
        configuredAudienceModelArn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        minMatchingSeedSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        outputConfig: CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig? = nil,
        sharedAudienceMetrics: [CleanRoomsMLClientTypes.SharedAudienceMetrics]? = nil,
        status: CleanRoomsMLClientTypes.ConfiguredAudienceModelStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.audienceModelArn = audienceModelArn
        self.audienceSizeConfig = audienceSizeConfig
        self.childResourceTagOnCreatePolicy = childResourceTagOnCreatePolicy
        self.configuredAudienceModelArn = configuredAudienceModelArn
        self.createTime = createTime
        self.description = description
        self.minMatchingSeedSize = minMatchingSeedSize
        self.name = name
        self.outputConfig = outputConfig
        self.sharedAudienceMetrics = sharedAudienceMetrics
        self.status = status
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct GetConfiguredAudienceModelOutputBody: Swift.Equatable {
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let configuredAudienceModelArn: Swift.String?
    let name: Swift.String?
    let audienceModelArn: Swift.String?
    let outputConfig: CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig?
    let description: Swift.String?
    let status: CleanRoomsMLClientTypes.ConfiguredAudienceModelStatus?
    let sharedAudienceMetrics: [CleanRoomsMLClientTypes.SharedAudienceMetrics]?
    let minMatchingSeedSize: Swift.Int?
    let audienceSizeConfig: CleanRoomsMLClientTypes.AudienceSizeConfig?
    let tags: [Swift.String:Swift.String]?
    let childResourceTagOnCreatePolicy: CleanRoomsMLClientTypes.TagOnCreatePolicy?
}

extension GetConfiguredAudienceModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceModelArn
        case audienceSizeConfig
        case childResourceTagOnCreatePolicy
        case configuredAudienceModelArn
        case createTime
        case description
        case minMatchingSeedSize
        case name
        case outputConfig
        case sharedAudienceMetrics
        case status
        case tags
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let configuredAudienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelArn)
        configuredAudienceModelArn = configuredAudienceModelArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let audienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audienceModelArn)
        audienceModelArn = audienceModelArnDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.ConfiguredAudienceModelStatus.self, forKey: .status)
        status = statusDecoded
        let sharedAudienceMetricsContainer = try containerValues.decodeIfPresent([CleanRoomsMLClientTypes.SharedAudienceMetrics?].self, forKey: .sharedAudienceMetrics)
        var sharedAudienceMetricsDecoded0:[CleanRoomsMLClientTypes.SharedAudienceMetrics]? = nil
        if let sharedAudienceMetricsContainer = sharedAudienceMetricsContainer {
            sharedAudienceMetricsDecoded0 = [CleanRoomsMLClientTypes.SharedAudienceMetrics]()
            for enum0 in sharedAudienceMetricsContainer {
                if let enum0 = enum0 {
                    sharedAudienceMetricsDecoded0?.append(enum0)
                }
            }
        }
        sharedAudienceMetrics = sharedAudienceMetricsDecoded0
        let minMatchingSeedSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minMatchingSeedSize)
        minMatchingSeedSize = minMatchingSeedSizeDecoded
        let audienceSizeConfigDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceSizeConfig.self, forKey: .audienceSizeConfig)
        audienceSizeConfig = audienceSizeConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let childResourceTagOnCreatePolicyDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.TagOnCreatePolicy.self, forKey: .childResourceTagOnCreatePolicy)
        childResourceTagOnCreatePolicy = childResourceTagOnCreatePolicyDecoded
    }
}

enum GetConfiguredAudienceModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConfiguredAudienceModelPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configuredAudienceModelArn = configuredAudienceModelArn else {
            return nil
        }
        return "/configured-audience-model/\(configuredAudienceModelArn.urlPercentEncoding())/policy"
    }
}

public struct GetConfiguredAudienceModelPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configured audience model that you are interested in.
    /// This member is required.
    public var configuredAudienceModelArn: Swift.String?

    public init(
        configuredAudienceModelArn: Swift.String? = nil
    )
    {
        self.configuredAudienceModelArn = configuredAudienceModelArn
    }
}

struct GetConfiguredAudienceModelPolicyInputBody: Swift.Equatable {
}

extension GetConfiguredAudienceModelPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConfiguredAudienceModelPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConfiguredAudienceModelPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredAudienceModelArn = output.configuredAudienceModelArn
            self.configuredAudienceModelPolicy = output.configuredAudienceModelPolicy
            self.policyHash = output.policyHash
        } else {
            self.configuredAudienceModelArn = nil
            self.configuredAudienceModelPolicy = nil
            self.policyHash = nil
        }
    }
}

public struct GetConfiguredAudienceModelPolicyOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configured audience model.
    /// This member is required.
    public var configuredAudienceModelArn: Swift.String?
    /// The configured audience model policy. This is a JSON IAM resource policy.
    /// This member is required.
    public var configuredAudienceModelPolicy: Swift.String?
    /// A cryptographic hash of the contents of the policy used to prevent unexpected concurrent modification of the policy.
    /// This member is required.
    public var policyHash: Swift.String?

    public init(
        configuredAudienceModelArn: Swift.String? = nil,
        configuredAudienceModelPolicy: Swift.String? = nil,
        policyHash: Swift.String? = nil
    )
    {
        self.configuredAudienceModelArn = configuredAudienceModelArn
        self.configuredAudienceModelPolicy = configuredAudienceModelPolicy
        self.policyHash = policyHash
    }
}

struct GetConfiguredAudienceModelPolicyOutputBody: Swift.Equatable {
    let configuredAudienceModelArn: Swift.String?
    let configuredAudienceModelPolicy: Swift.String?
    let policyHash: Swift.String?
}

extension GetConfiguredAudienceModelPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredAudienceModelArn
        case configuredAudienceModelPolicy
        case policyHash
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredAudienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelArn)
        configuredAudienceModelArn = configuredAudienceModelArnDecoded
        let configuredAudienceModelPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelPolicy)
        configuredAudienceModelPolicy = configuredAudienceModelPolicyDecoded
        let policyHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyHash)
        policyHash = policyHashDecoded
    }
}

enum GetConfiguredAudienceModelPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTrainingDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trainingDatasetArn = trainingDatasetArn else {
            return nil
        }
        return "/training-dataset/\(trainingDatasetArn.urlPercentEncoding())"
    }
}

public struct GetTrainingDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the training dataset that you are interested in.
    /// This member is required.
    public var trainingDatasetArn: Swift.String?

    public init(
        trainingDatasetArn: Swift.String? = nil
    )
    {
        self.trainingDatasetArn = trainingDatasetArn
    }
}

struct GetTrainingDatasetInputBody: Swift.Equatable {
}

extension GetTrainingDatasetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTrainingDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTrainingDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.description = output.description
            self.name = output.name
            self.roleArn = output.roleArn
            self.status = output.status
            self.tags = output.tags
            self.trainingData = output.trainingData
            self.trainingDatasetArn = output.trainingDatasetArn
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.description = nil
            self.name = nil
            self.roleArn = nil
            self.status = nil
            self.tags = nil
            self.trainingData = nil
            self.trainingDatasetArn = nil
            self.updateTime = nil
        }
    }
}

public struct GetTrainingDatasetOutput: Swift.Equatable {
    /// The time at which the training dataset was created.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The description of the training dataset.
    public var description: Swift.String?
    /// The name of the training dataset.
    /// This member is required.
    public var name: Swift.String?
    /// The IAM role used to read the training data.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The status of the training dataset.
    /// This member is required.
    public var status: CleanRoomsMLClientTypes.TrainingDatasetStatus?
    /// The tags that are assigned to this training dataset.
    public var tags: [Swift.String:Swift.String]?
    /// Metadata about the requested training data.
    /// This member is required.
    public var trainingData: [CleanRoomsMLClientTypes.Dataset]?
    /// The Amazon Resource Name (ARN) of the training dataset.
    /// This member is required.
    public var trainingDatasetArn: Swift.String?
    /// The most recent time at which the training dataset was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        createTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: CleanRoomsMLClientTypes.TrainingDatasetStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trainingData: [CleanRoomsMLClientTypes.Dataset]? = nil,
        trainingDatasetArn: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.description = description
        self.name = name
        self.roleArn = roleArn
        self.status = status
        self.tags = tags
        self.trainingData = trainingData
        self.trainingDatasetArn = trainingDatasetArn
        self.updateTime = updateTime
    }
}

struct GetTrainingDatasetOutputBody: Swift.Equatable {
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let trainingDatasetArn: Swift.String?
    let name: Swift.String?
    let trainingData: [CleanRoomsMLClientTypes.Dataset]?
    let status: CleanRoomsMLClientTypes.TrainingDatasetStatus?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let description: Swift.String?
}

extension GetTrainingDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime
        case description
        case name
        case roleArn
        case status
        case tags
        case trainingData
        case trainingDatasetArn
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let trainingDatasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trainingDatasetArn)
        trainingDatasetArn = trainingDatasetArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let trainingDataContainer = try containerValues.decodeIfPresent([CleanRoomsMLClientTypes.Dataset?].self, forKey: .trainingData)
        var trainingDataDecoded0:[CleanRoomsMLClientTypes.Dataset]? = nil
        if let trainingDataContainer = trainingDataContainer {
            trainingDataDecoded0 = [CleanRoomsMLClientTypes.Dataset]()
            for structure0 in trainingDataContainer {
                if let structure0 = structure0 {
                    trainingDataDecoded0?.append(structure0)
                }
            }
        }
        trainingData = trainingDataDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.TrainingDatasetStatus.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum GetTrainingDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsMLClientTypes.GlueDataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId
        case databaseName
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// Defines the Glue data source that contains the training data.
    public struct GlueDataSource: Swift.Equatable {
        /// The Glue catalog that contains the training data.
        public var catalogId: Swift.String?
        /// The Glue database that contains the training data.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The Glue table that contains the training data.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            catalogId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
        }
    }

}

extension ListAudienceExportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let audienceGenerationJobArn = audienceGenerationJobArn {
                let audienceGenerationJobArnQueryItem = ClientRuntime.URLQueryItem(name: "audienceGenerationJobArn".urlPercentEncoding(), value: Swift.String(audienceGenerationJobArn).urlPercentEncoding())
                items.append(audienceGenerationJobArnQueryItem)
            }
            return items
        }
    }
}

extension ListAudienceExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audience-export-job"
    }
}

public struct ListAudienceExportJobsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the audience generation job that you are interested in.
    public var audienceGenerationJobArn: Swift.String?
    /// The maximum size of the results that is returned per call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        audienceGenerationJobArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.audienceGenerationJobArn = audienceGenerationJobArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAudienceExportJobsInputBody: Swift.Equatable {
}

extension ListAudienceExportJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAudienceExportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAudienceExportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.audienceExportJobs = output.audienceExportJobs
            self.nextToken = output.nextToken
        } else {
            self.audienceExportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListAudienceExportJobsOutput: Swift.Equatable {
    /// The audience export jobs that match the request.
    /// This member is required.
    public var audienceExportJobs: [CleanRoomsMLClientTypes.AudienceExportJobSummary]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        audienceExportJobs: [CleanRoomsMLClientTypes.AudienceExportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.audienceExportJobs = audienceExportJobs
        self.nextToken = nextToken
    }
}

struct ListAudienceExportJobsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let audienceExportJobs: [CleanRoomsMLClientTypes.AudienceExportJobSummary]?
}

extension ListAudienceExportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceExportJobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let audienceExportJobsContainer = try containerValues.decodeIfPresent([CleanRoomsMLClientTypes.AudienceExportJobSummary?].self, forKey: .audienceExportJobs)
        var audienceExportJobsDecoded0:[CleanRoomsMLClientTypes.AudienceExportJobSummary]? = nil
        if let audienceExportJobsContainer = audienceExportJobsContainer {
            audienceExportJobsDecoded0 = [CleanRoomsMLClientTypes.AudienceExportJobSummary]()
            for structure0 in audienceExportJobsContainer {
                if let structure0 = structure0 {
                    audienceExportJobsDecoded0?.append(structure0)
                }
            }
        }
        audienceExportJobs = audienceExportJobsDecoded0
    }
}

enum ListAudienceExportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAudienceGenerationJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let configuredAudienceModelArn = configuredAudienceModelArn {
                let configuredAudienceModelArnQueryItem = ClientRuntime.URLQueryItem(name: "configuredAudienceModelArn".urlPercentEncoding(), value: Swift.String(configuredAudienceModelArn).urlPercentEncoding())
                items.append(configuredAudienceModelArnQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let collaborationId = collaborationId {
                let collaborationIdQueryItem = ClientRuntime.URLQueryItem(name: "collaborationId".urlPercentEncoding(), value: Swift.String(collaborationId).urlPercentEncoding())
                items.append(collaborationIdQueryItem)
            }
            return items
        }
    }
}

extension ListAudienceGenerationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audience-generation-job"
    }
}

public struct ListAudienceGenerationJobsInput: Swift.Equatable {
    /// The identifier of the collaboration that contains the audience generation jobs that you are interested in.
    public var collaborationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the configured audience model that was used for the audience generation jobs that you are interested in.
    public var configuredAudienceModelArn: Swift.String?
    /// The maximum size of the results that is returned per call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        collaborationId: Swift.String? = nil,
        configuredAudienceModelArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationId = collaborationId
        self.configuredAudienceModelArn = configuredAudienceModelArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAudienceGenerationJobsInputBody: Swift.Equatable {
}

extension ListAudienceGenerationJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAudienceGenerationJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAudienceGenerationJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.audienceGenerationJobs = output.audienceGenerationJobs
            self.nextToken = output.nextToken
        } else {
            self.audienceGenerationJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListAudienceGenerationJobsOutput: Swift.Equatable {
    /// The audience generation jobs that match the request.
    /// This member is required.
    public var audienceGenerationJobs: [CleanRoomsMLClientTypes.AudienceGenerationJobSummary]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        audienceGenerationJobs: [CleanRoomsMLClientTypes.AudienceGenerationJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.audienceGenerationJobs = audienceGenerationJobs
        self.nextToken = nextToken
    }
}

struct ListAudienceGenerationJobsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let audienceGenerationJobs: [CleanRoomsMLClientTypes.AudienceGenerationJobSummary]?
}

extension ListAudienceGenerationJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceGenerationJobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let audienceGenerationJobsContainer = try containerValues.decodeIfPresent([CleanRoomsMLClientTypes.AudienceGenerationJobSummary?].self, forKey: .audienceGenerationJobs)
        var audienceGenerationJobsDecoded0:[CleanRoomsMLClientTypes.AudienceGenerationJobSummary]? = nil
        if let audienceGenerationJobsContainer = audienceGenerationJobsContainer {
            audienceGenerationJobsDecoded0 = [CleanRoomsMLClientTypes.AudienceGenerationJobSummary]()
            for structure0 in audienceGenerationJobsContainer {
                if let structure0 = structure0 {
                    audienceGenerationJobsDecoded0?.append(structure0)
                }
            }
        }
        audienceGenerationJobs = audienceGenerationJobsDecoded0
    }
}

enum ListAudienceGenerationJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAudienceModelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAudienceModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audience-model"
    }
}

public struct ListAudienceModelsInput: Swift.Equatable {
    /// The maximum size of the results that is returned per call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAudienceModelsInputBody: Swift.Equatable {
}

extension ListAudienceModelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAudienceModelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAudienceModelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.audienceModels = output.audienceModels
            self.nextToken = output.nextToken
        } else {
            self.audienceModels = nil
            self.nextToken = nil
        }
    }
}

public struct ListAudienceModelsOutput: Swift.Equatable {
    /// The audience models that match the request.
    /// This member is required.
    public var audienceModels: [CleanRoomsMLClientTypes.AudienceModelSummary]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        audienceModels: [CleanRoomsMLClientTypes.AudienceModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.audienceModels = audienceModels
        self.nextToken = nextToken
    }
}

struct ListAudienceModelsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let audienceModels: [CleanRoomsMLClientTypes.AudienceModelSummary]?
}

extension ListAudienceModelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceModels
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let audienceModelsContainer = try containerValues.decodeIfPresent([CleanRoomsMLClientTypes.AudienceModelSummary?].self, forKey: .audienceModels)
        var audienceModelsDecoded0:[CleanRoomsMLClientTypes.AudienceModelSummary]? = nil
        if let audienceModelsContainer = audienceModelsContainer {
            audienceModelsDecoded0 = [CleanRoomsMLClientTypes.AudienceModelSummary]()
            for structure0 in audienceModelsContainer {
                if let structure0 = structure0 {
                    audienceModelsDecoded0?.append(structure0)
                }
            }
        }
        audienceModels = audienceModelsDecoded0
    }
}

enum ListAudienceModelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConfiguredAudienceModelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListConfiguredAudienceModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configured-audience-model"
    }
}

public struct ListConfiguredAudienceModelsInput: Swift.Equatable {
    /// The maximum size of the results that is returned per call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfiguredAudienceModelsInputBody: Swift.Equatable {
}

extension ListConfiguredAudienceModelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConfiguredAudienceModelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConfiguredAudienceModelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredAudienceModels = output.configuredAudienceModels
            self.nextToken = output.nextToken
        } else {
            self.configuredAudienceModels = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfiguredAudienceModelsOutput: Swift.Equatable {
    /// The configured audience models.
    /// This member is required.
    public var configuredAudienceModels: [CleanRoomsMLClientTypes.ConfiguredAudienceModelSummary]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        configuredAudienceModels: [CleanRoomsMLClientTypes.ConfiguredAudienceModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configuredAudienceModels = configuredAudienceModels
        self.nextToken = nextToken
    }
}

struct ListConfiguredAudienceModelsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let configuredAudienceModels: [CleanRoomsMLClientTypes.ConfiguredAudienceModelSummary]?
}

extension ListConfiguredAudienceModelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredAudienceModels
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let configuredAudienceModelsContainer = try containerValues.decodeIfPresent([CleanRoomsMLClientTypes.ConfiguredAudienceModelSummary?].self, forKey: .configuredAudienceModels)
        var configuredAudienceModelsDecoded0:[CleanRoomsMLClientTypes.ConfiguredAudienceModelSummary]? = nil
        if let configuredAudienceModelsContainer = configuredAudienceModelsContainer {
            configuredAudienceModelsDecoded0 = [CleanRoomsMLClientTypes.ConfiguredAudienceModelSummary]()
            for structure0 in configuredAudienceModelsContainer {
                if let structure0 = structure0 {
                    configuredAudienceModelsDecoded0?.append(structure0)
                }
            }
        }
        configuredAudienceModels = configuredAudienceModelsDecoded0
    }
}

enum ListConfiguredAudienceModelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you are interested in.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags that are associated with the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTrainingDatasetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTrainingDatasetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/training-dataset"
    }
}

public struct ListTrainingDatasetsInput: Swift.Equatable {
    /// The maximum size of the results that is returned per call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTrainingDatasetsInputBody: Swift.Equatable {
}

extension ListTrainingDatasetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTrainingDatasetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTrainingDatasetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.trainingDatasets = output.trainingDatasets
        } else {
            self.nextToken = nil
            self.trainingDatasets = nil
        }
    }
}

public struct ListTrainingDatasetsOutput: Swift.Equatable {
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// The training datasets that match the request.
    /// This member is required.
    public var trainingDatasets: [CleanRoomsMLClientTypes.TrainingDatasetSummary]?

    public init(
        nextToken: Swift.String? = nil,
        trainingDatasets: [CleanRoomsMLClientTypes.TrainingDatasetSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.trainingDatasets = trainingDatasets
    }
}

struct ListTrainingDatasetsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let trainingDatasets: [CleanRoomsMLClientTypes.TrainingDatasetSummary]?
}

extension ListTrainingDatasetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case trainingDatasets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let trainingDatasetsContainer = try containerValues.decodeIfPresent([CleanRoomsMLClientTypes.TrainingDatasetSummary?].self, forKey: .trainingDatasets)
        var trainingDatasetsDecoded0:[CleanRoomsMLClientTypes.TrainingDatasetSummary]? = nil
        if let trainingDatasetsContainer = trainingDatasetsContainer {
            trainingDatasetsDecoded0 = [CleanRoomsMLClientTypes.TrainingDatasetSummary]()
            for structure0 in trainingDatasetsContainer {
                if let structure0 = structure0 {
                    trainingDatasetsDecoded0?.append(structure0)
                }
            }
        }
        trainingDatasets = trainingDatasetsDecoded0
    }
}

enum ListTrainingDatasetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsMLClientTypes {
    public enum PolicyExistenceCondition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case policyMustExist
        case policyMustNotExist
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyExistenceCondition] {
            return [
                .policyMustExist,
                .policyMustNotExist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .policyMustExist: return "POLICY_MUST_EXIST"
            case .policyMustNotExist: return "POLICY_MUST_NOT_EXIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyExistenceCondition(rawValue: rawValue) ?? PolicyExistenceCondition.sdkUnknown(rawValue)
        }
    }
}

extension PutConfiguredAudienceModelPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredAudienceModelPolicy
        case policyExistenceCondition
        case previousPolicyHash
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuredAudienceModelPolicy = self.configuredAudienceModelPolicy {
            try encodeContainer.encode(configuredAudienceModelPolicy, forKey: .configuredAudienceModelPolicy)
        }
        if let policyExistenceCondition = self.policyExistenceCondition {
            try encodeContainer.encode(policyExistenceCondition.rawValue, forKey: .policyExistenceCondition)
        }
        if let previousPolicyHash = self.previousPolicyHash {
            try encodeContainer.encode(previousPolicyHash, forKey: .previousPolicyHash)
        }
    }
}

extension PutConfiguredAudienceModelPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configuredAudienceModelArn = configuredAudienceModelArn else {
            return nil
        }
        return "/configured-audience-model/\(configuredAudienceModelArn.urlPercentEncoding())/policy"
    }
}

public struct PutConfiguredAudienceModelPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configured audience model that the resource policy will govern.
    /// This member is required.
    public var configuredAudienceModelArn: Swift.String?
    /// The IAM resource policy.
    /// This member is required.
    public var configuredAudienceModelPolicy: Swift.String?
    /// Use this to prevent unexpected concurrent modification of the policy.
    public var policyExistenceCondition: CleanRoomsMLClientTypes.PolicyExistenceCondition?
    /// A cryptographic hash of the contents of the policy used to prevent unexpected concurrent modification of the policy.
    public var previousPolicyHash: Swift.String?

    public init(
        configuredAudienceModelArn: Swift.String? = nil,
        configuredAudienceModelPolicy: Swift.String? = nil,
        policyExistenceCondition: CleanRoomsMLClientTypes.PolicyExistenceCondition? = nil,
        previousPolicyHash: Swift.String? = nil
    )
    {
        self.configuredAudienceModelArn = configuredAudienceModelArn
        self.configuredAudienceModelPolicy = configuredAudienceModelPolicy
        self.policyExistenceCondition = policyExistenceCondition
        self.previousPolicyHash = previousPolicyHash
    }
}

struct PutConfiguredAudienceModelPolicyInputBody: Swift.Equatable {
    let configuredAudienceModelPolicy: Swift.String?
    let previousPolicyHash: Swift.String?
    let policyExistenceCondition: CleanRoomsMLClientTypes.PolicyExistenceCondition?
}

extension PutConfiguredAudienceModelPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredAudienceModelPolicy
        case policyExistenceCondition
        case previousPolicyHash
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredAudienceModelPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelPolicy)
        configuredAudienceModelPolicy = configuredAudienceModelPolicyDecoded
        let previousPolicyHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previousPolicyHash)
        previousPolicyHash = previousPolicyHashDecoded
        let policyExistenceConditionDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.PolicyExistenceCondition.self, forKey: .policyExistenceCondition)
        policyExistenceCondition = policyExistenceConditionDecoded
    }
}

extension PutConfiguredAudienceModelPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutConfiguredAudienceModelPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredAudienceModelPolicy = output.configuredAudienceModelPolicy
            self.policyHash = output.policyHash
        } else {
            self.configuredAudienceModelPolicy = nil
            self.policyHash = nil
        }
    }
}

public struct PutConfiguredAudienceModelPolicyOutput: Swift.Equatable {
    /// The IAM resource policy.
    /// This member is required.
    public var configuredAudienceModelPolicy: Swift.String?
    /// A cryptographic hash of the contents of the policy used to prevent unexpected concurrent modification of the policy.
    /// This member is required.
    public var policyHash: Swift.String?

    public init(
        configuredAudienceModelPolicy: Swift.String? = nil,
        policyHash: Swift.String? = nil
    )
    {
        self.configuredAudienceModelPolicy = configuredAudienceModelPolicy
        self.policyHash = policyHash
    }
}

struct PutConfiguredAudienceModelPolicyOutputBody: Swift.Equatable {
    let configuredAudienceModelPolicy: Swift.String?
    let policyHash: Swift.String?
}

extension PutConfiguredAudienceModelPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredAudienceModelPolicy
        case policyHash
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredAudienceModelPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelPolicy)
        configuredAudienceModelPolicy = configuredAudienceModelPolicyDecoded
        let policyHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyHash)
        policyHash = policyHashDecoded
    }
}

enum PutConfiguredAudienceModelPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsMLClientTypes.RelevanceMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceSize
        case score
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audienceSize = self.audienceSize {
            try encodeContainer.encode(audienceSize, forKey: .audienceSize)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audienceSizeDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceSize.self, forKey: .audienceSize)
        audienceSize = audienceSizeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score)
        score = scoreDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// The relevance score of a generated audience.
    public struct RelevanceMetric: Swift.Equatable {
        /// The size of the generated audience. Must match one of the sizes in the configured audience model.
        /// This member is required.
        public var audienceSize: CleanRoomsMLClientTypes.AudienceSize?
        /// The relevance score of the generated audience.
        public var score: Swift.Double?

        public init(
            audienceSize: CleanRoomsMLClientTypes.AudienceSize? = nil,
            score: Swift.Double? = nil
        )
        {
            self.audienceSize = audienceSize
            self.score = score
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource you are requesting does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CleanRoomsMLClientTypes.S3ConfigMap: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// Provides information about an Amazon S3 bucket and path.
    public struct S3ConfigMap: Swift.Equatable {
        /// The Amazon S3 location URI.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded your service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CleanRoomsMLClientTypes {
    public enum SharedAudienceMetrics: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [SharedAudienceMetrics] {
            return [
                .all,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SharedAudienceMetrics(rawValue: rawValue) ?? SharedAudienceMetrics.sdkUnknown(rawValue)
        }
    }
}

extension StartAudienceExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceGenerationJobArn
        case audienceSize
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audienceGenerationJobArn = self.audienceGenerationJobArn {
            try encodeContainer.encode(audienceGenerationJobArn, forKey: .audienceGenerationJobArn)
        }
        if let audienceSize = self.audienceSize {
            try encodeContainer.encode(audienceSize, forKey: .audienceSize)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StartAudienceExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audience-export-job"
    }
}

public struct StartAudienceExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the audience generation job that you want to export.
    /// This member is required.
    public var audienceGenerationJobArn: Swift.String?
    /// The size of the generated audience. Must match one of the sizes in the configured audience model.
    /// This member is required.
    public var audienceSize: CleanRoomsMLClientTypes.AudienceSize?
    /// The description of the audience export job.
    public var description: Swift.String?
    /// The name of the audience export job.
    /// This member is required.
    public var name: Swift.String?

    public init(
        audienceGenerationJobArn: Swift.String? = nil,
        audienceSize: CleanRoomsMLClientTypes.AudienceSize? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.audienceGenerationJobArn = audienceGenerationJobArn
        self.audienceSize = audienceSize
        self.description = description
        self.name = name
    }
}

struct StartAudienceExportJobInputBody: Swift.Equatable {
    let name: Swift.String?
    let audienceGenerationJobArn: Swift.String?
    let audienceSize: CleanRoomsMLClientTypes.AudienceSize?
    let description: Swift.String?
}

extension StartAudienceExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceGenerationJobArn
        case audienceSize
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let audienceGenerationJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audienceGenerationJobArn)
        audienceGenerationJobArn = audienceGenerationJobArnDecoded
        let audienceSizeDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceSize.self, forKey: .audienceSize)
        audienceSize = audienceSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension StartAudienceExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartAudienceExportJobOutput: Swift.Equatable {

    public init() { }
}

enum StartAudienceExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartAudienceGenerationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaborationId
        case configuredAudienceModelArn
        case description
        case includeSeedInOutput
        case name
        case seedAudience
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let configuredAudienceModelArn = self.configuredAudienceModelArn {
            try encodeContainer.encode(configuredAudienceModelArn, forKey: .configuredAudienceModelArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let includeSeedInOutput = self.includeSeedInOutput {
            try encodeContainer.encode(includeSeedInOutput, forKey: .includeSeedInOutput)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let seedAudience = self.seedAudience {
            try encodeContainer.encode(seedAudience, forKey: .seedAudience)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartAudienceGenerationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audience-generation-job"
    }
}

public struct StartAudienceGenerationJobInput: Swift.Equatable {
    /// The identifier of the collaboration that contains the audience generation job.
    public var collaborationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the configured audience model that is used for this audience generation job.
    /// This member is required.
    public var configuredAudienceModelArn: Swift.String?
    /// The description of the audience generation job.
    public var description: Swift.String?
    /// Whether the seed audience is included in the audience generation output.
    public var includeSeedInOutput: Swift.Bool?
    /// The name of the audience generation job.
    /// This member is required.
    public var name: Swift.String?
    /// The seed audience that is used to generate the audience.
    /// This member is required.
    public var seedAudience: CleanRoomsMLClientTypes.AudienceGenerationJobDataSource?
    /// The optional metadata that you apply to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [Swift.String:Swift.String]?

    public init(
        collaborationId: Swift.String? = nil,
        configuredAudienceModelArn: Swift.String? = nil,
        description: Swift.String? = nil,
        includeSeedInOutput: Swift.Bool? = nil,
        name: Swift.String? = nil,
        seedAudience: CleanRoomsMLClientTypes.AudienceGenerationJobDataSource? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.collaborationId = collaborationId
        self.configuredAudienceModelArn = configuredAudienceModelArn
        self.description = description
        self.includeSeedInOutput = includeSeedInOutput
        self.name = name
        self.seedAudience = seedAudience
        self.tags = tags
    }
}

struct StartAudienceGenerationJobInputBody: Swift.Equatable {
    let name: Swift.String?
    let configuredAudienceModelArn: Swift.String?
    let seedAudience: CleanRoomsMLClientTypes.AudienceGenerationJobDataSource?
    let includeSeedInOutput: Swift.Bool?
    let collaborationId: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartAudienceGenerationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaborationId
        case configuredAudienceModelArn
        case description
        case includeSeedInOutput
        case name
        case seedAudience
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configuredAudienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelArn)
        configuredAudienceModelArn = configuredAudienceModelArnDecoded
        let seedAudienceDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceGenerationJobDataSource.self, forKey: .seedAudience)
        seedAudience = seedAudienceDecoded
        let includeSeedInOutputDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeSeedInOutput)
        includeSeedInOutput = includeSeedInOutputDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartAudienceGenerationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartAudienceGenerationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.audienceGenerationJobArn = output.audienceGenerationJobArn
        } else {
            self.audienceGenerationJobArn = nil
        }
    }
}

public struct StartAudienceGenerationJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the audience generation job.
    /// This member is required.
    public var audienceGenerationJobArn: Swift.String?

    public init(
        audienceGenerationJobArn: Swift.String? = nil
    )
    {
        self.audienceGenerationJobArn = audienceGenerationJobArn
    }
}

struct StartAudienceGenerationJobOutputBody: Swift.Equatable {
    let audienceGenerationJobArn: Swift.String?
}

extension StartAudienceGenerationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceGenerationJobArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audienceGenerationJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audienceGenerationJobArn)
        audienceGenerationJobArn = audienceGenerationJobArnDecoded
    }
}

enum StartAudienceGenerationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsMLClientTypes.StatusDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// Details about the status of a resource.
    public struct StatusDetails: Swift.Equatable {
        /// The error message that was returned. The message is intended for human consumption and can change at any time. Use the statusCode for programmatic error handling.
        public var message: Swift.String?
        /// The status code that was returned. The status code is intended for programmatic error handling. Clean Rooms ML will not change the status code for existing error conditions.
        public var statusCode: Swift.String?

        public init(
            message: Swift.String? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.message = message
            self.statusCode = statusCode
        }
    }

}

extension CleanRoomsMLClientTypes {
    public enum TagOnCreatePolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fromParentResource
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [TagOnCreatePolicy] {
            return [
                .fromParentResource,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fromParentResource: return "FROM_PARENT_RESOURCE"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TagOnCreatePolicy(rawValue: rawValue) ?? TagOnCreatePolicy.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to assign tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The optional metadata that you apply to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsMLClientTypes {
    public enum TrainingDatasetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [TrainingDatasetStatus] {
            return [
                .active,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrainingDatasetStatus(rawValue: rawValue) ?? TrainingDatasetStatus.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsMLClientTypes.TrainingDatasetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime
        case description
        case name
        case status
        case trainingDatasetArn
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let trainingDatasetArn = self.trainingDatasetArn {
            try encodeContainer.encode(trainingDatasetArn, forKey: .trainingDatasetArn)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let trainingDatasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trainingDatasetArn)
        trainingDatasetArn = trainingDatasetArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.TrainingDatasetStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CleanRoomsMLClientTypes {
    /// Provides information about the training dataset.
    public struct TrainingDatasetSummary: Swift.Equatable {
        /// The time at which the training dataset was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description of the training dataset.
        public var description: Swift.String?
        /// The name of the training dataset.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the training dataset.
        /// This member is required.
        public var status: CleanRoomsMLClientTypes.TrainingDatasetStatus?
        /// The Amazon Resource Name (ARN) of the training dataset.
        /// This member is required.
        public var trainingDatasetArn: Swift.String?
        /// The most recent time at which the training dataset was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            status: CleanRoomsMLClientTypes.TrainingDatasetStatus? = nil,
            trainingDatasetArn: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.description = description
            self.name = name
            self.status = status
            self.trainingDatasetArn = trainingDatasetArn
            self.updateTime = updateTime
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key values of tags that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConfiguredAudienceModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceModelArn
        case audienceSizeConfig
        case description
        case minMatchingSeedSize
        case outputConfig
        case sharedAudienceMetrics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audienceModelArn = self.audienceModelArn {
            try encodeContainer.encode(audienceModelArn, forKey: .audienceModelArn)
        }
        if let audienceSizeConfig = self.audienceSizeConfig {
            try encodeContainer.encode(audienceSizeConfig, forKey: .audienceSizeConfig)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let minMatchingSeedSize = self.minMatchingSeedSize {
            try encodeContainer.encode(minMatchingSeedSize, forKey: .minMatchingSeedSize)
        }
        if let outputConfig = self.outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
        if let sharedAudienceMetrics = sharedAudienceMetrics {
            var sharedAudienceMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedAudienceMetrics)
            for sharedaudiencemetrics0 in sharedAudienceMetrics {
                try sharedAudienceMetricsContainer.encode(sharedaudiencemetrics0.rawValue)
            }
        }
    }
}

extension UpdateConfiguredAudienceModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configuredAudienceModelArn = configuredAudienceModelArn else {
            return nil
        }
        return "/configured-audience-model/\(configuredAudienceModelArn.urlPercentEncoding())"
    }
}

public struct UpdateConfiguredAudienceModelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new audience model that you want to use.
    public var audienceModelArn: Swift.String?
    /// The new audience size configuration.
    public var audienceSizeConfig: CleanRoomsMLClientTypes.AudienceSizeConfig?
    /// The Amazon Resource Name (ARN) of the configured audience model that you want to update.
    /// This member is required.
    public var configuredAudienceModelArn: Swift.String?
    /// The new description of the configured audience model.
    public var description: Swift.String?
    /// The minimum number of users from the seed audience that must match with users in the training data of the audience model.
    public var minMatchingSeedSize: Swift.Int?
    /// The new output configuration.
    public var outputConfig: CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig?
    /// The new value for whether to share audience metrics.
    public var sharedAudienceMetrics: [CleanRoomsMLClientTypes.SharedAudienceMetrics]?

    public init(
        audienceModelArn: Swift.String? = nil,
        audienceSizeConfig: CleanRoomsMLClientTypes.AudienceSizeConfig? = nil,
        configuredAudienceModelArn: Swift.String? = nil,
        description: Swift.String? = nil,
        minMatchingSeedSize: Swift.Int? = nil,
        outputConfig: CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig? = nil,
        sharedAudienceMetrics: [CleanRoomsMLClientTypes.SharedAudienceMetrics]? = nil
    )
    {
        self.audienceModelArn = audienceModelArn
        self.audienceSizeConfig = audienceSizeConfig
        self.configuredAudienceModelArn = configuredAudienceModelArn
        self.description = description
        self.minMatchingSeedSize = minMatchingSeedSize
        self.outputConfig = outputConfig
        self.sharedAudienceMetrics = sharedAudienceMetrics
    }
}

struct UpdateConfiguredAudienceModelInputBody: Swift.Equatable {
    let outputConfig: CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig?
    let audienceModelArn: Swift.String?
    let sharedAudienceMetrics: [CleanRoomsMLClientTypes.SharedAudienceMetrics]?
    let minMatchingSeedSize: Swift.Int?
    let audienceSizeConfig: CleanRoomsMLClientTypes.AudienceSizeConfig?
    let description: Swift.String?
}

extension UpdateConfiguredAudienceModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audienceModelArn
        case audienceSizeConfig
        case description
        case minMatchingSeedSize
        case outputConfig
        case sharedAudienceMetrics
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputConfigDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.ConfiguredAudienceModelOutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let audienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audienceModelArn)
        audienceModelArn = audienceModelArnDecoded
        let sharedAudienceMetricsContainer = try containerValues.decodeIfPresent([CleanRoomsMLClientTypes.SharedAudienceMetrics?].self, forKey: .sharedAudienceMetrics)
        var sharedAudienceMetricsDecoded0:[CleanRoomsMLClientTypes.SharedAudienceMetrics]? = nil
        if let sharedAudienceMetricsContainer = sharedAudienceMetricsContainer {
            sharedAudienceMetricsDecoded0 = [CleanRoomsMLClientTypes.SharedAudienceMetrics]()
            for enum0 in sharedAudienceMetricsContainer {
                if let enum0 = enum0 {
                    sharedAudienceMetricsDecoded0?.append(enum0)
                }
            }
        }
        sharedAudienceMetrics = sharedAudienceMetricsDecoded0
        let minMatchingSeedSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minMatchingSeedSize)
        minMatchingSeedSize = minMatchingSeedSizeDecoded
        let audienceSizeConfigDecoded = try containerValues.decodeIfPresent(CleanRoomsMLClientTypes.AudienceSizeConfig.self, forKey: .audienceSizeConfig)
        audienceSizeConfig = audienceSizeConfigDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateConfiguredAudienceModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConfiguredAudienceModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredAudienceModelArn = output.configuredAudienceModelArn
        } else {
            self.configuredAudienceModelArn = nil
        }
    }
}

public struct UpdateConfiguredAudienceModelOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configured audience model that was updated.
    /// This member is required.
    public var configuredAudienceModelArn: Swift.String?

    public init(
        configuredAudienceModelArn: Swift.String? = nil
    )
    {
        self.configuredAudienceModelArn = configuredAudienceModelArn
    }
}

struct UpdateConfiguredAudienceModelOutputBody: Swift.Equatable {
    let configuredAudienceModelArn: Swift.String?
}

extension UpdateConfiguredAudienceModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredAudienceModelArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredAudienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelArn)
        configuredAudienceModelArn = configuredAudienceModelArnDecoded
    }
}

enum UpdateConfiguredAudienceModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request parameters for this request are incorrect.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
