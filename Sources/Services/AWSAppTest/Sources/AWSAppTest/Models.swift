//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// The account or role doesn't have the right permissions to make the request.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An unexpected error occurred during the processing of the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to retry the query.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID of the resource not found.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type of the resource not found.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The number of requests made exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code of requests that exceed the limit.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to retry after for requests that exceed the limit.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The service code of requests that exceed the limit.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension AppTestClientTypes {

    /// Specifies a validation exception field.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The message stating reason for why service validation failed.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation exception field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension AppTestClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// One or more parameter provided in the request is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field list of the validation exception.
        public internal(set) var fieldList: [AppTestClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation exception.
        public internal(set) var reason: AppTestClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [AppTestClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: AppTestClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags of the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

/// One or more quotas for AWS Application Testing exceeds the limit.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quote codes of AWS Application Testing that exceeded the limit.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The resource ID of AWS Application Testing that exceeded the limit.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type of AWS Application Testing that exceeded the limit.
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code of AWS Application Testing that exceeded the limit.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the tag resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags of the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

/// The parameters provided in the request conflict with existing resources.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID of the conflicts with existing resources.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type of the conflicts with existing resources.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension AppTestClientTypes {

    public enum CaptureTool: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsDms
        case precisely
        case sdkUnknown(Swift.String)

        public static var allCases: [CaptureTool] {
            return [
                .awsDms,
                .precisely
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsDms: return "AWS DMS"
            case .precisely: return "Precisely"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    public enum SourceDatabase: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case zOsDb2
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceDatabase] {
            return [
                .zOsDb2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .zOsDb2: return "z/OS-DB2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the source database metadata.
    public struct SourceDatabaseMetadata: Swift.Sendable {
        /// The capture tool of the source database metadata.
        /// This member is required.
        public var captureTool: AppTestClientTypes.CaptureTool?
        /// The type of the source database metadata.
        /// This member is required.
        public var type: AppTestClientTypes.SourceDatabase?

        public init(
            captureTool: AppTestClientTypes.CaptureTool? = nil,
            type: AppTestClientTypes.SourceDatabase? = nil
        )
        {
            self.captureTool = captureTool
            self.type = type
        }
    }
}

extension AppTestClientTypes {

    public enum TargetDatabase: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case postgresql
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDatabase] {
            return [
                .postgresql
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .postgresql: return "PostgreSQL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Specifies a target database metadata.
    public struct TargetDatabaseMetadata: Swift.Sendable {
        /// The capture tool of the target database metadata.
        /// This member is required.
        public var captureTool: AppTestClientTypes.CaptureTool?
        /// The type of the target database metadata.
        /// This member is required.
        public var type: AppTestClientTypes.TargetDatabase?

        public init(
            captureTool: AppTestClientTypes.CaptureTool? = nil,
            type: AppTestClientTypes.TargetDatabase? = nil
        )
        {
            self.captureTool = captureTool
            self.type = type
        }
    }
}

extension AppTestClientTypes {

    /// Defines the Change Data Capture (CDC) of the database.
    public struct DatabaseCDC: Swift.Sendable {
        /// The source metadata of the database CDC.
        /// This member is required.
        public var sourceMetadata: AppTestClientTypes.SourceDatabaseMetadata?
        /// The target metadata of the database CDC.
        /// This member is required.
        public var targetMetadata: AppTestClientTypes.TargetDatabaseMetadata?

        public init(
            sourceMetadata: AppTestClientTypes.SourceDatabaseMetadata? = nil,
            targetMetadata: AppTestClientTypes.TargetDatabaseMetadata? = nil
        )
        {
            self.sourceMetadata = sourceMetadata
            self.targetMetadata = targetMetadata
        }
    }
}

extension AppTestClientTypes {

    public enum Format: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fixed
        case lineSequential
        case variable
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .fixed,
                .lineSequential,
                .variable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fixed: return "FIXED"
            case .lineSequential: return "LINE_SEQUENTIAL"
            case .variable: return "VARIABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    public enum DataSetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ps
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSetType] {
            return [
                .ps
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ps: return "PS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Defines a data set.
    public struct DataSet: Swift.Sendable {
        /// The CCSID of the data set.
        /// This member is required.
        public var ccsid: Swift.String?
        /// The format of the data set.
        /// This member is required.
        public var format: AppTestClientTypes.Format?
        /// The length of the data set.
        /// This member is required.
        public var length: Swift.Int?
        /// The name of the data set.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the data set.
        /// This member is required.
        public var type: AppTestClientTypes.DataSetType?

        public init(
            ccsid: Swift.String? = nil,
            format: AppTestClientTypes.Format? = nil,
            length: Swift.Int? = nil,
            name: Swift.String? = nil,
            type: AppTestClientTypes.DataSetType? = nil
        )
        {
            self.ccsid = ccsid
            self.format = format
            self.length = length
            self.name = name
            self.type = type
        }
    }
}

extension AppTestClientTypes {

    /// Specifies a file metadata.
    public enum FileMetadata: Swift.Sendable {
        /// The data sets of the file metadata.
        case datasets([AppTestClientTypes.DataSet])
        /// The database CDC of the file metadata.
        case databasecdc(AppTestClientTypes.DatabaseCDC)
        case sdkUnknown(Swift.String)
    }
}

extension AppTestClientTypes {

    /// Specifies the input file.
    public struct InputFile: Swift.Sendable {
        /// The file metadata of the input file.
        /// This member is required.
        public var fileMetadata: AppTestClientTypes.FileMetadata?
        /// The source location of the input file.
        /// This member is required.
        public var sourceLocation: Swift.String?
        /// The target location of the input file.
        /// This member is required.
        public var targetLocation: Swift.String?

        public init(
            fileMetadata: AppTestClientTypes.FileMetadata? = nil,
            sourceLocation: Swift.String? = nil,
            targetLocation: Swift.String? = nil
        )
        {
            self.fileMetadata = fileMetadata
            self.sourceLocation = sourceLocation
            self.targetLocation = targetLocation
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the input.
    public enum Input: Swift.Sendable {
        /// The file in the input.
        case file(AppTestClientTypes.InputFile)
        case sdkUnknown(Swift.String)
    }
}

extension AppTestClientTypes {

    /// Specifies an output file.
    public struct OutputFile: Swift.Sendable {
        /// The file location of the output file.
        public var fileLocation: Swift.String?

        public init(
            fileLocation: Swift.String? = nil
        )
        {
            self.fileLocation = fileLocation
        }
    }
}

extension AppTestClientTypes {

    /// Specifies an output.
    public enum Output: Swift.Sendable {
        /// The file of the output.
        case file(AppTestClientTypes.OutputFile)
        case sdkUnknown(Swift.String)
    }
}

extension AppTestClientTypes {

    /// Compares the action.
    public struct CompareAction: Swift.Sendable {
        /// The input of the compare action.
        /// This member is required.
        public var input: AppTestClientTypes.Input?
        /// The output of the compare action.
        public var output: AppTestClientTypes.Output?

        public init(
            input: AppTestClientTypes.Input? = nil,
            output: AppTestClientTypes.Output? = nil
        )
        {
            self.input = input
            self.output = output
        }
    }
}

extension AppTestClientTypes {

    /// Defines a batch.
    public struct Batch: Swift.Sendable {
        /// The job name of the batch.
        /// This member is required.
        public var batchJobName: Swift.String?
        /// The batch job parameters of the batch.
        public var batchJobParameters: [Swift.String: Swift.String]?
        /// The export data set names of the batch.
        public var exportDataSetNames: [Swift.String]?

        public init(
            batchJobName: Swift.String? = nil,
            batchJobParameters: [Swift.String: Swift.String]? = nil,
            exportDataSetNames: [Swift.String]? = nil
        )
        {
            self.batchJobName = batchJobName
            self.batchJobParameters = batchJobParameters
            self.exportDataSetNames = exportDataSetNames
        }
    }
}

extension AppTestClientTypes {

    public enum ScriptType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case selenium
        case sdkUnknown(Swift.String)

        public static var allCases: [ScriptType] {
            return [
                .selenium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .selenium: return "Selenium"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the script.
    public struct Script: Swift.Sendable {
        /// The script location of the scripts.
        /// This member is required.
        public var scriptLocation: Swift.String?
        /// The type of the scripts.
        /// This member is required.
        public var type: AppTestClientTypes.ScriptType?

        public init(
            scriptLocation: Swift.String? = nil,
            type: AppTestClientTypes.ScriptType? = nil
        )
        {
            self.scriptLocation = scriptLocation
            self.type = type
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the TN3270 protocol.
    public struct TN3270: Swift.Sendable {
        /// The data set names of the TN3270 protocol.
        public var exportDataSetNames: [Swift.String]?
        /// The script of the TN3270 protocol.
        /// This member is required.
        public var script: AppTestClientTypes.Script?

        public init(
            exportDataSetNames: [Swift.String]? = nil,
            script: AppTestClientTypes.Script? = nil
        )
        {
            self.exportDataSetNames = exportDataSetNames
            self.script = script
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the mainframe action type.
    public enum MainframeActionType: Swift.Sendable {
        /// The batch of the mainframe action type.
        case batch(AppTestClientTypes.Batch)
        /// The tn3270 port of the mainframe action type.
        case tn3270(AppTestClientTypes.TN3270)
        case sdkUnknown(Swift.String)
    }
}

extension AppTestClientTypes {

    /// Specifies the mainframe action properties.
    public struct MainframeActionProperties: Swift.Sendable {
        /// The DMS task ARN of the mainframe action properties.
        public var dmsTaskArn: Swift.String?

        public init(
            dmsTaskArn: Swift.String? = nil
        )
        {
            self.dmsTaskArn = dmsTaskArn
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the mainframe action.
    public struct MainframeAction: Swift.Sendable {
        /// The action type of the mainframe action.
        /// This member is required.
        public var actionType: AppTestClientTypes.MainframeActionType?
        /// The properties of the mainframe action.
        public var properties: AppTestClientTypes.MainframeActionProperties?
        /// The resource of the mainframe action.
        /// This member is required.
        public var resource: Swift.String?

        public init(
            actionType: AppTestClientTypes.MainframeActionType? = nil,
            properties: AppTestClientTypes.MainframeActionProperties? = nil,
            resource: Swift.String? = nil
        )
        {
            self.actionType = actionType
            self.properties = properties
            self.resource = resource
        }
    }
}

extension AppTestClientTypes {

    public enum CloudFormationActionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case create
        case delete
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudFormationActionType] {
            return [
                .create,
                .delete
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .create: return "Create"
            case .delete: return "Delete"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the CloudFormation action.
    public struct CloudFormationAction: Swift.Sendable {
        /// The action type of the CloudFormation action.
        public var actionType: AppTestClientTypes.CloudFormationActionType?
        /// The resource of the CloudFormation action.
        /// This member is required.
        public var resource: Swift.String?

        public init(
            actionType: AppTestClientTypes.CloudFormationActionType? = nil,
            resource: Swift.String? = nil
        )
        {
            self.actionType = actionType
            self.resource = resource
        }
    }
}

extension AppTestClientTypes {

    public enum M2ManagedActionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case configure
        case deconfigure
        case sdkUnknown(Swift.String)

        public static var allCases: [M2ManagedActionType] {
            return [
                .configure,
                .deconfigure
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configure: return "Configure"
            case .deconfigure: return "Deconfigure"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the AWS Mainframe Modernization managed action properties.
    public struct M2ManagedActionProperties: Swift.Sendable {
        /// Force stops the AWS Mainframe Modernization managed action properties.
        public var forceStop: Swift.Bool?
        /// The import data set location of the AWS Mainframe Modernization managed action properties.
        public var importDataSetLocation: Swift.String?

        public init(
            forceStop: Swift.Bool? = nil,
            importDataSetLocation: Swift.String? = nil
        )
        {
            self.forceStop = forceStop
            self.importDataSetLocation = importDataSetLocation
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the AWS Mainframe Modernization managed application action.
    public struct M2ManagedApplicationAction: Swift.Sendable {
        /// The action type of the AWS Mainframe Modernization managed application action.
        /// This member is required.
        public var actionType: AppTestClientTypes.M2ManagedActionType?
        /// The properties of the AWS Mainframe Modernization managed application action.
        public var properties: AppTestClientTypes.M2ManagedActionProperties?
        /// The resource of the AWS Mainframe Modernization managed application action.
        /// This member is required.
        public var resource: Swift.String?

        public init(
            actionType: AppTestClientTypes.M2ManagedActionType? = nil,
            properties: AppTestClientTypes.M2ManagedActionProperties? = nil,
            resource: Swift.String? = nil
        )
        {
            self.actionType = actionType
            self.properties = properties
            self.resource = resource
        }
    }
}

extension AppTestClientTypes {

    public enum M2NonManagedActionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case configure
        case deconfigure
        case sdkUnknown(Swift.String)

        public static var allCases: [M2NonManagedActionType] {
            return [
                .configure,
                .deconfigure
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configure: return "Configure"
            case .deconfigure: return "Deconfigure"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the AWS Mainframe Modernization non-managed application action.
    public struct M2NonManagedApplicationAction: Swift.Sendable {
        /// The action type of the AWS Mainframe Modernization non-managed application action.
        /// This member is required.
        public var actionType: AppTestClientTypes.M2NonManagedActionType?
        /// The resource of the AWS Mainframe Modernization non-managed application action.
        /// This member is required.
        public var resource: Swift.String?

        public init(
            actionType: AppTestClientTypes.M2NonManagedActionType? = nil,
            resource: Swift.String? = nil
        )
        {
            self.actionType = actionType
            self.resource = resource
        }
    }
}

extension AppTestClientTypes {

    /// Specifies a resource action.
    public enum ResourceAction: Swift.Sendable {
        /// The AWS Mainframe Modernization managed application action of the resource action.
        case m2managedapplicationaction(AppTestClientTypes.M2ManagedApplicationAction)
        /// The AWS Mainframe Modernization non-managed application action of the resource action.
        case m2nonmanagedapplicationaction(AppTestClientTypes.M2NonManagedApplicationAction)
        /// The CloudFormation action of the resource action.
        case cloudformationaction(AppTestClientTypes.CloudFormationAction)
        case sdkUnknown(Swift.String)
    }
}

extension AppTestClientTypes {

    /// Specifies a step action.
    public enum StepAction: Swift.Sendable {
        /// The resource action of the step action.
        case resourceaction(AppTestClientTypes.ResourceAction)
        /// The mainframe action of the step action.
        case mainframeaction(AppTestClientTypes.MainframeAction)
        /// The compare action of the step action.
        case compareaction(AppTestClientTypes.CompareAction)
        case sdkUnknown(Swift.String)
    }
}

extension AppTestClientTypes {

    /// Defines a step.
    public struct Step: Swift.Sendable {
        /// The action of the step.
        /// This member is required.
        public var action: AppTestClientTypes.StepAction?
        /// The description of the step.
        public var description: Swift.String?
        /// The name of the step.
        /// This member is required.
        public var name: Swift.String?

        public init(
            action: AppTestClientTypes.StepAction? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.action = action
            self.description = description
            self.name = name
        }
    }
}

public struct CreateTestCaseInput: Swift.Sendable {
    /// The client token of the test case.
    public var clientToken: Swift.String?
    /// The description of the test case.
    public var description: Swift.String?
    /// The name of the test case.
    /// This member is required.
    public var name: Swift.String?
    /// The steps in the test case.
    /// This member is required.
    public var steps: [AppTestClientTypes.Step]?
    /// The specified tags of the test case.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        steps: [AppTestClientTypes.Step]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.steps = steps
        self.tags = tags
    }
}

public struct CreateTestCaseOutput: Swift.Sendable {
    /// The test case ID of the test case.
    /// This member is required.
    public var testCaseId: Swift.String?
    /// The test case version of the test case.
    /// This member is required.
    public var testCaseVersion: Swift.Int?

    public init(
        testCaseId: Swift.String? = nil,
        testCaseVersion: Swift.Int? = nil
    )
    {
        self.testCaseId = testCaseId
        self.testCaseVersion = testCaseVersion
    }
}

public struct DeleteTestCaseInput: Swift.Sendable {
    /// The test case ID of the test case.
    /// This member is required.
    public var testCaseId: Swift.String?

    public init(
        testCaseId: Swift.String? = nil
    )
    {
        self.testCaseId = testCaseId
    }
}

public struct DeleteTestCaseOutput: Swift.Sendable {

    public init() { }
}

public struct GetTestCaseInput: Swift.Sendable {
    /// The request test ID of the test case.
    /// This member is required.
    public var testCaseId: Swift.String?
    /// The test case version of the test case.
    public var testCaseVersion: Swift.Int?

    public init(
        testCaseId: Swift.String? = nil,
        testCaseVersion: Swift.Int? = nil
    )
    {
        self.testCaseId = testCaseId
        self.testCaseVersion = testCaseVersion
    }
}

extension AppTestClientTypes {

    public enum TestCaseLifecycle: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [TestCaseLifecycle] {
            return [
                .active,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleting: return "Deleting"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the latest version of a test case.
    public struct TestCaseLatestVersion: Swift.Sendable {
        /// The status of the test case latest version.
        /// This member is required.
        public var status: AppTestClientTypes.TestCaseLifecycle?
        /// The status reason of the test case latest version.
        public var statusReason: Swift.String?
        /// The version of the test case latest version.
        /// This member is required.
        public var version: Swift.Int?

        public init(
            status: AppTestClientTypes.TestCaseLifecycle? = nil,
            statusReason: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.status = status
            self.statusReason = statusReason
            self.version = version
        }
    }
}

public struct GetTestCaseOutput: Swift.Sendable {
    /// The creation time of the test case.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The description of the test case.
    public var description: Swift.String?
    /// The last update time of the test case.
    /// This member is required.
    public var lastUpdateTime: Foundation.Date?
    /// The latest version of the test case.
    /// This member is required.
    public var latestVersion: AppTestClientTypes.TestCaseLatestVersion?
    /// The name of the test case.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the test case.
    /// This member is required.
    public var status: AppTestClientTypes.TestCaseLifecycle?
    /// The status reason of the test case.
    public var statusReason: Swift.String?
    /// The steps of the test case.
    /// This member is required.
    public var steps: [AppTestClientTypes.Step]?
    /// The tags of the test case.
    public var tags: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (ARN) of the test case.
    /// This member is required.
    public var testCaseArn: Swift.String?
    /// The response test ID of the test case.
    /// This member is required.
    public var testCaseId: Swift.String?
    /// The case version of the test case.
    /// This member is required.
    public var testCaseVersion: Swift.Int?

    public init(
        creationTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        lastUpdateTime: Foundation.Date? = nil,
        latestVersion: AppTestClientTypes.TestCaseLatestVersion? = nil,
        name: Swift.String? = nil,
        status: AppTestClientTypes.TestCaseLifecycle? = nil,
        statusReason: Swift.String? = nil,
        steps: [AppTestClientTypes.Step]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        testCaseArn: Swift.String? = nil,
        testCaseId: Swift.String? = nil,
        testCaseVersion: Swift.Int? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.lastUpdateTime = lastUpdateTime
        self.latestVersion = latestVersion
        self.name = name
        self.status = status
        self.statusReason = statusReason
        self.steps = steps
        self.tags = tags
        self.testCaseArn = testCaseArn
        self.testCaseId = testCaseId
        self.testCaseVersion = testCaseVersion
    }
}

public struct ListTestCasesInput: Swift.Sendable {
    /// The maximum results of the test case.
    public var maxResults: Swift.Int?
    /// The next token of the test cases.
    public var nextToken: Swift.String?
    /// The IDs of the test cases.
    public var testCaseIds: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        testCaseIds: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.testCaseIds = testCaseIds
    }
}

extension AppTestClientTypes {

    /// Specifies a test case summary.
    public struct TestCaseSummary: Swift.Sendable {
        /// The creation time of the test case summary.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The last update time of the test case summary.
        /// This member is required.
        public var lastUpdateTime: Foundation.Date?
        /// The latest version of the test case summary.
        /// This member is required.
        public var latestVersion: Swift.Int?
        /// The name of the test case summary.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the test case summary.
        /// This member is required.
        public var status: AppTestClientTypes.TestCaseLifecycle?
        /// The status reason of the test case summary.
        public var statusReason: Swift.String?
        /// The test case Amazon Resource Name (ARN) of the test case summary.
        /// This member is required.
        public var testCaseArn: Swift.String?
        /// The test case ID of the test case summary.
        /// This member is required.
        public var testCaseId: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            latestVersion: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: AppTestClientTypes.TestCaseLifecycle? = nil,
            statusReason: Swift.String? = nil,
            testCaseArn: Swift.String? = nil,
            testCaseId: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.latestVersion = latestVersion
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.testCaseArn = testCaseArn
            self.testCaseId = testCaseId
        }
    }
}

public struct ListTestCasesOutput: Swift.Sendable {
    /// The next token in test cases.
    public var nextToken: Swift.String?
    /// The test cases in an application.
    /// This member is required.
    public var testCases: [AppTestClientTypes.TestCaseSummary]?

    public init(
        nextToken: Swift.String? = nil,
        testCases: [AppTestClientTypes.TestCaseSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.testCases = testCases
    }
}

public struct UpdateTestCaseInput: Swift.Sendable {
    /// The description of the test case.
    public var description: Swift.String?
    /// The steps of the test case.
    public var steps: [AppTestClientTypes.Step]?
    /// The test case ID of the test case.
    /// This member is required.
    public var testCaseId: Swift.String?

    public init(
        description: Swift.String? = nil,
        steps: [AppTestClientTypes.Step]? = nil,
        testCaseId: Swift.String? = nil
    )
    {
        self.description = description
        self.steps = steps
        self.testCaseId = testCaseId
    }
}

public struct UpdateTestCaseOutput: Swift.Sendable {
    /// The test case ID of the test case.
    /// This member is required.
    public var testCaseId: Swift.String?
    /// The test case version of the test case.
    /// This member is required.
    public var testCaseVersion: Swift.Int?

    public init(
        testCaseId: Swift.String? = nil,
        testCaseVersion: Swift.Int? = nil
    )
    {
        self.testCaseId = testCaseId
        self.testCaseVersion = testCaseVersion
    }
}

extension AppTestClientTypes {

    /// Specifies the CloudFormation template and its parameters.
    public struct CloudFormation: Swift.Sendable {
        /// The CloudFormation properties in the CloudFormation template.
        public var parameters: [Swift.String: Swift.String]?
        /// The template location of the CloudFormation template.
        /// This member is required.
        public var templateLocation: Swift.String?

        public init(
            parameters: [Swift.String: Swift.String]? = nil,
            templateLocation: Swift.String? = nil
        )
        {
            self.parameters = parameters
            self.templateLocation = templateLocation
        }
    }
}

extension AppTestClientTypes {

    public enum M2ManagedRuntime: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case microfocus
        case sdkUnknown(Swift.String)

        public static var allCases: [M2ManagedRuntime] {
            return [
                .microfocus
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .microfocus: return "MicroFocus"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the AWS Mainframe Modernization managed application.
    public struct M2ManagedApplication: Swift.Sendable {
        /// The application ID of the AWS Mainframe Modernization managed application.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The listener port of the AWS Mainframe Modernization managed application.
        public var listenerPort: Swift.String?
        /// The runtime of the AWS Mainframe Modernization managed application.
        /// This member is required.
        public var runtime: AppTestClientTypes.M2ManagedRuntime?
        /// The VPC endpoint service name of the AWS Mainframe Modernization managed application.
        public var vpcEndpointServiceName: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            listenerPort: Swift.String? = nil,
            runtime: AppTestClientTypes.M2ManagedRuntime? = nil,
            vpcEndpointServiceName: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.listenerPort = listenerPort
            self.runtime = runtime
            self.vpcEndpointServiceName = vpcEndpointServiceName
        }
    }
}

extension AppTestClientTypes {

    public enum M2NonManagedRuntime: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bluage
        case sdkUnknown(Swift.String)

        public static var allCases: [M2NonManagedRuntime] {
            return [
                .bluage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bluage: return "BluAge"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the AWS Mainframe Modernization non-managed application.
    public struct M2NonManagedApplication: Swift.Sendable {
        /// The listener port of the AWS Mainframe Modernization non-managed application.
        /// This member is required.
        public var listenerPort: Swift.String?
        /// The runtime of the AWS Mainframe Modernization non-managed application.
        /// This member is required.
        public var runtime: AppTestClientTypes.M2NonManagedRuntime?
        /// The VPC endpoint service name of the AWS Mainframe Modernization non-managed application.
        /// This member is required.
        public var vpcEndpointServiceName: Swift.String?
        /// The web application name of the AWS Mainframe Modernization non-managed application.
        public var webAppName: Swift.String?

        public init(
            listenerPort: Swift.String? = nil,
            runtime: AppTestClientTypes.M2NonManagedRuntime? = nil,
            vpcEndpointServiceName: Swift.String? = nil,
            webAppName: Swift.String? = nil
        )
        {
            self.listenerPort = listenerPort
            self.runtime = runtime
            self.vpcEndpointServiceName = vpcEndpointServiceName
            self.webAppName = webAppName
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the resource type.
    public enum ResourceType: Swift.Sendable {
        /// The CloudFormation template of the resource type.
        case cloudformation(AppTestClientTypes.CloudFormation)
        /// The AWS Mainframe Modernization managed application of the resource type.
        case m2managedapplication(AppTestClientTypes.M2ManagedApplication)
        /// The AWS Mainframe Modernization non-managed application of the resource type.
        case m2nonmanagedapplication(AppTestClientTypes.M2NonManagedApplication)
        case sdkUnknown(Swift.String)
    }
}

extension AppTestClientTypes {

    /// Specifies a resource.
    public struct Resource: Swift.Sendable {
        /// The name of the resource.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the resource.
        /// This member is required.
        public var type: AppTestClientTypes.ResourceType?

        public init(
            name: Swift.String? = nil,
            type: AppTestClientTypes.ResourceType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the service settings.
    public struct ServiceSettings: Swift.Sendable {
        /// The KMS key ID of the service settings.
        public var kmsKeyId: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
        }
    }
}

public struct CreateTestConfigurationInput: Swift.Sendable {
    /// The client token of the test configuration.
    public var clientToken: Swift.String?
    /// The description of the test configuration.
    public var description: Swift.String?
    /// The name of the test configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The properties of the test configuration.
    public var properties: [Swift.String: Swift.String]?
    /// The defined resources of the test configuration.
    /// This member is required.
    public var resources: [AppTestClientTypes.Resource]?
    /// The service settings of the test configuration.
    public var serviceSettings: AppTestClientTypes.ServiceSettings?
    /// The tags of the test configuration.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        properties: [Swift.String: Swift.String]? = nil,
        resources: [AppTestClientTypes.Resource]? = nil,
        serviceSettings: AppTestClientTypes.ServiceSettings? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.properties = properties
        self.resources = resources
        self.serviceSettings = serviceSettings
        self.tags = tags
    }
}

public struct CreateTestConfigurationOutput: Swift.Sendable {
    /// The test configuration ID.
    /// This member is required.
    public var testConfigurationId: Swift.String?
    /// The test configuration version.
    /// This member is required.
    public var testConfigurationVersion: Swift.Int?

    public init(
        testConfigurationId: Swift.String? = nil,
        testConfigurationVersion: Swift.Int? = nil
    )
    {
        self.testConfigurationId = testConfigurationId
        self.testConfigurationVersion = testConfigurationVersion
    }
}

public struct DeleteTestConfigurationInput: Swift.Sendable {
    /// The test ID of the test configuration.
    /// This member is required.
    public var testConfigurationId: Swift.String?

    public init(
        testConfigurationId: Swift.String? = nil
    )
    {
        self.testConfigurationId = testConfigurationId
    }
}

public struct DeleteTestConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct GetTestConfigurationInput: Swift.Sendable {
    /// The request test configuration ID.
    /// This member is required.
    public var testConfigurationId: Swift.String?
    /// The test configuration version.
    public var testConfigurationVersion: Swift.Int?

    public init(
        testConfigurationId: Swift.String? = nil,
        testConfigurationVersion: Swift.Int? = nil
    )
    {
        self.testConfigurationId = testConfigurationId
        self.testConfigurationVersion = testConfigurationVersion
    }
}

extension AppTestClientTypes {

    public enum TestConfigurationLifecycle: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [TestConfigurationLifecycle] {
            return [
                .active,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleting: return "Deleting"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the latest version of the test configuration.
    public struct TestConfigurationLatestVersion: Swift.Sendable {
        /// The status of the test configuration latest version.
        /// This member is required.
        public var status: AppTestClientTypes.TestConfigurationLifecycle?
        /// The status reason of the test configuration latest version.
        public var statusReason: Swift.String?
        /// The version of the test configuration latest version.
        /// This member is required.
        public var version: Swift.Int?

        public init(
            status: AppTestClientTypes.TestConfigurationLifecycle? = nil,
            statusReason: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.status = status
            self.statusReason = statusReason
            self.version = version
        }
    }
}

public struct GetTestConfigurationOutput: Swift.Sendable {
    /// The creation time of the test configuration.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The description of the test configuration.
    public var description: Swift.String?
    /// The last update time of the test configuration.
    /// This member is required.
    public var lastUpdateTime: Foundation.Date?
    /// The latest version of the test configuration.
    /// This member is required.
    public var latestVersion: AppTestClientTypes.TestConfigurationLatestVersion?
    /// The test configuration name
    /// This member is required.
    public var name: Swift.String?
    /// The properties of the test configuration.
    /// This member is required.
    public var properties: [Swift.String: Swift.String]?
    /// The resources of the test configuration.
    /// This member is required.
    public var resources: [AppTestClientTypes.Resource]?
    /// The service settings of the test configuration.
    public var serviceSettings: AppTestClientTypes.ServiceSettings?
    /// The status of the test configuration.
    /// This member is required.
    public var status: AppTestClientTypes.TestConfigurationLifecycle?
    /// The status reason of the test configuration.
    public var statusReason: Swift.String?
    /// The tags of the test configuration.
    public var tags: [Swift.String: Swift.String]?
    /// The test configuration Amazon Resource Name (ARN).
    /// This member is required.
    public var testConfigurationArn: Swift.String?
    /// The response test configuration ID.
    /// This member is required.
    public var testConfigurationId: Swift.String?
    /// The test configuration version.
    /// This member is required.
    public var testConfigurationVersion: Swift.Int?

    public init(
        creationTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        lastUpdateTime: Foundation.Date? = nil,
        latestVersion: AppTestClientTypes.TestConfigurationLatestVersion? = nil,
        name: Swift.String? = nil,
        properties: [Swift.String: Swift.String]? = nil,
        resources: [AppTestClientTypes.Resource]? = nil,
        serviceSettings: AppTestClientTypes.ServiceSettings? = nil,
        status: AppTestClientTypes.TestConfigurationLifecycle? = nil,
        statusReason: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        testConfigurationArn: Swift.String? = nil,
        testConfigurationId: Swift.String? = nil,
        testConfigurationVersion: Swift.Int? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.lastUpdateTime = lastUpdateTime
        self.latestVersion = latestVersion
        self.name = name
        self.properties = properties
        self.resources = resources
        self.serviceSettings = serviceSettings
        self.status = status
        self.statusReason = statusReason
        self.tags = tags
        self.testConfigurationArn = testConfigurationArn
        self.testConfigurationId = testConfigurationId
        self.testConfigurationVersion = testConfigurationVersion
    }
}

public struct ListTestConfigurationsInput: Swift.Sendable {
    /// The maximum results of the test configuration.
    public var maxResults: Swift.Int?
    /// The next token for the test configurations.
    public var nextToken: Swift.String?
    /// The configuration IDs of the test configurations.
    public var testConfigurationIds: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        testConfigurationIds: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.testConfigurationIds = testConfigurationIds
    }
}

extension AppTestClientTypes {

    /// Specifies a test configuration summary.
    public struct TestConfigurationSummary: Swift.Sendable {
        /// The creation time of the test configuration summary.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The last update time of the test configuration summary.
        /// This member is required.
        public var lastUpdateTime: Foundation.Date?
        /// The latest version of the test configuration summary.
        /// This member is required.
        public var latestVersion: Swift.Int?
        /// The name of the test configuration summary.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the test configuration summary.
        /// This member is required.
        public var status: AppTestClientTypes.TestConfigurationLifecycle?
        /// The status reason of the test configuration summary.
        public var statusReason: Swift.String?
        /// The test configuration ARN of the test configuration summary.
        /// This member is required.
        public var testConfigurationArn: Swift.String?
        /// The test configuration ID of the test configuration summary.
        /// This member is required.
        public var testConfigurationId: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            latestVersion: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: AppTestClientTypes.TestConfigurationLifecycle? = nil,
            statusReason: Swift.String? = nil,
            testConfigurationArn: Swift.String? = nil,
            testConfigurationId: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.latestVersion = latestVersion
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.testConfigurationArn = testConfigurationArn
            self.testConfigurationId = testConfigurationId
        }
    }
}

public struct ListTestConfigurationsOutput: Swift.Sendable {
    /// The next token in the test configurations.
    public var nextToken: Swift.String?
    /// The test configurations.
    /// This member is required.
    public var testConfigurations: [AppTestClientTypes.TestConfigurationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        testConfigurations: [AppTestClientTypes.TestConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.testConfigurations = testConfigurations
    }
}

public struct UpdateTestConfigurationInput: Swift.Sendable {
    /// The description of the test configuration.
    public var description: Swift.String?
    /// The properties of the test configuration.
    public var properties: [Swift.String: Swift.String]?
    /// The resources of the test configuration.
    public var resources: [AppTestClientTypes.Resource]?
    /// The service settings of the test configuration.
    public var serviceSettings: AppTestClientTypes.ServiceSettings?
    /// The test configuration ID of the test configuration.
    /// This member is required.
    public var testConfigurationId: Swift.String?

    public init(
        description: Swift.String? = nil,
        properties: [Swift.String: Swift.String]? = nil,
        resources: [AppTestClientTypes.Resource]? = nil,
        serviceSettings: AppTestClientTypes.ServiceSettings? = nil,
        testConfigurationId: Swift.String? = nil
    )
    {
        self.description = description
        self.properties = properties
        self.resources = resources
        self.serviceSettings = serviceSettings
        self.testConfigurationId = testConfigurationId
    }
}

public struct UpdateTestConfigurationOutput: Swift.Sendable {
    /// The configuration ID of the test configuration.
    /// This member is required.
    public var testConfigurationId: Swift.String?
    /// The configuration version of the test configuration.
    /// This member is required.
    public var testConfigurationVersion: Swift.Int?

    public init(
        testConfigurationId: Swift.String? = nil,
        testConfigurationVersion: Swift.Int? = nil
    )
    {
        self.testConfigurationId = testConfigurationId
        self.testConfigurationVersion = testConfigurationVersion
    }
}

public struct DeleteTestRunInput: Swift.Sendable {
    /// The run ID of the test run.
    /// This member is required.
    public var testRunId: Swift.String?

    public init(
        testRunId: Swift.String? = nil
    )
    {
        self.testRunId = testRunId
    }
}

public struct DeleteTestRunOutput: Swift.Sendable {

    public init() { }
}

public struct GetTestRunStepInput: Swift.Sendable {
    /// The step name of the test run step.
    /// This member is required.
    public var stepName: Swift.String?
    /// The test case ID of a test run step.
    public var testCaseId: Swift.String?
    /// The test run ID of the test run step.
    /// This member is required.
    public var testRunId: Swift.String?
    /// The test suite ID of a test run step.
    public var testSuiteId: Swift.String?

    public init(
        stepName: Swift.String? = nil,
        testCaseId: Swift.String? = nil,
        testRunId: Swift.String? = nil,
        testSuiteId: Swift.String? = nil
    )
    {
        self.stepName = stepName
        self.testCaseId = testCaseId
        self.testRunId = testRunId
        self.testSuiteId = testSuiteId
    }
}

extension AppTestClientTypes {

    public enum StepRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case running
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [StepRunStatus] {
            return [
                .failed,
                .running,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .running: return "Running"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Compares the database Change Data Capture (CDC) step input.
    public struct CompareDatabaseCDCStepInput: Swift.Sendable {
        /// The output location of the compare database CDC step input.
        public var outputLocation: Swift.String?
        /// The source location of the compare database CDC step input.
        /// This member is required.
        public var sourceLocation: Swift.String?
        /// The source metadata of the compare database CDC step input.
        /// This member is required.
        public var sourceMetadata: AppTestClientTypes.SourceDatabaseMetadata?
        /// The target location of the compare database CDC step input.
        /// This member is required.
        public var targetLocation: Swift.String?
        /// The target metadata location of the compare database CDC step input.
        /// This member is required.
        public var targetMetadata: AppTestClientTypes.TargetDatabaseMetadata?

        public init(
            outputLocation: Swift.String? = nil,
            sourceLocation: Swift.String? = nil,
            sourceMetadata: AppTestClientTypes.SourceDatabaseMetadata? = nil,
            targetLocation: Swift.String? = nil,
            targetMetadata: AppTestClientTypes.TargetDatabaseMetadata? = nil
        )
        {
            self.outputLocation = outputLocation
            self.sourceLocation = sourceLocation
            self.sourceMetadata = sourceMetadata
            self.targetLocation = targetLocation
            self.targetMetadata = targetMetadata
        }
    }
}

extension AppTestClientTypes {

    public enum ComparisonStatusEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case different
        case equal
        case equivalent
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonStatusEnum] {
            return [
                .different,
                .equal,
                .equivalent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .different: return "Different"
            case .equal: return "Equal"
            case .equivalent: return "Equivalent"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Compares the database CDC step output.
    public struct CompareDatabaseCDCStepOutput: Swift.Sendable {
        /// The comparison output of the compare database CDC step output.
        /// This member is required.
        public var comparisonOutputLocation: Swift.String?
        /// The comparison status of the compare database CDC step output.
        /// This member is required.
        public var comparisonStatus: AppTestClientTypes.ComparisonStatusEnum?

        public init(
            comparisonOutputLocation: Swift.String? = nil,
            comparisonStatus: AppTestClientTypes.ComparisonStatusEnum? = nil
        )
        {
            self.comparisonOutputLocation = comparisonOutputLocation
            self.comparisonStatus = comparisonStatus
        }
    }
}

extension AppTestClientTypes {

    /// Compares the database CDC summary.
    public struct CompareDatabaseCDCSummary: Swift.Sendable {
        /// The step input of the compare database CDC summary.
        /// This member is required.
        public var stepInput: AppTestClientTypes.CompareDatabaseCDCStepInput?
        /// The step output of the compare database CDC summary.
        public var stepOutput: AppTestClientTypes.CompareDatabaseCDCStepOutput?

        public init(
            stepInput: AppTestClientTypes.CompareDatabaseCDCStepInput? = nil,
            stepOutput: AppTestClientTypes.CompareDatabaseCDCStepOutput? = nil
        )
        {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the compare data sets step input.
    public struct CompareDataSetsStepInput: Swift.Sendable {
        /// The source data sets of the compare data sets step input location.
        /// This member is required.
        public var sourceDataSets: [AppTestClientTypes.DataSet]?
        /// The source location of the compare data sets step input location.
        /// This member is required.
        public var sourceLocation: Swift.String?
        /// The target data sets of the compare data sets step input location.
        /// This member is required.
        public var targetDataSets: [AppTestClientTypes.DataSet]?
        /// The target location of the compare data sets step input location.
        /// This member is required.
        public var targetLocation: Swift.String?

        public init(
            sourceDataSets: [AppTestClientTypes.DataSet]? = nil,
            sourceLocation: Swift.String? = nil,
            targetDataSets: [AppTestClientTypes.DataSet]? = nil,
            targetLocation: Swift.String? = nil
        )
        {
            self.sourceDataSets = sourceDataSets
            self.sourceLocation = sourceLocation
            self.targetDataSets = targetDataSets
            self.targetLocation = targetLocation
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the compare data sets step output.
    public struct CompareDataSetsStepOutput: Swift.Sendable {
        /// The comparison output location of the compare data sets step output.
        /// This member is required.
        public var comparisonOutputLocation: Swift.String?
        /// The comparison status of the compare data sets step output.
        /// This member is required.
        public var comparisonStatus: AppTestClientTypes.ComparisonStatusEnum?

        public init(
            comparisonOutputLocation: Swift.String? = nil,
            comparisonStatus: AppTestClientTypes.ComparisonStatusEnum? = nil
        )
        {
            self.comparisonOutputLocation = comparisonOutputLocation
            self.comparisonStatus = comparisonStatus
        }
    }
}

extension AppTestClientTypes {

    /// Compares data sets summary.
    public struct CompareDataSetsSummary: Swift.Sendable {
        /// The step input of the compare data sets summary.
        /// This member is required.
        public var stepInput: AppTestClientTypes.CompareDataSetsStepInput?
        /// The step output of the compare data sets summary.
        public var stepOutput: AppTestClientTypes.CompareDataSetsStepOutput?

        public init(
            stepInput: AppTestClientTypes.CompareDataSetsStepInput? = nil,
            stepOutput: AppTestClientTypes.CompareDataSetsStepOutput? = nil
        )
        {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }
    }
}

extension AppTestClientTypes {

    /// Compares the file type.
    public enum CompareFileType: Swift.Sendable {
        /// The data sets in the compare file type.
        case datasets(AppTestClientTypes.CompareDataSetsSummary)
        /// The database CDC of the compare file type.
        case databasecdc(AppTestClientTypes.CompareDatabaseCDCSummary)
        case sdkUnknown(Swift.String)
    }
}

extension AppTestClientTypes {

    /// Defines a file.
    public enum File: Swift.Sendable {
        /// The file type of the file.
        case filetype(AppTestClientTypes.CompareFileType)
        case sdkUnknown(Swift.String)
    }
}

extension AppTestClientTypes {

    /// Specifies the compare action summary.
    public struct CompareActionSummary: Swift.Sendable {
        /// The type of the compare action summary.
        /// This member is required.
        public var type: AppTestClientTypes.File?

        public init(
            type: AppTestClientTypes.File? = nil
        )
        {
            self.type = type
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the AWS Mainframe Modernization managed application summary.
    public struct M2ManagedApplicationSummary: Swift.Sendable {
        /// The application ID of the AWS Mainframe Modernization managed application summary.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The listener port of the AWS Mainframe Modernization managed application summary.
        public var listenerPort: Swift.Int?
        /// The runtime of the AWS Mainframe Modernization managed application summary.
        /// This member is required.
        public var runtime: AppTestClientTypes.M2ManagedRuntime?

        public init(
            applicationId: Swift.String? = nil,
            listenerPort: Swift.Int? = nil,
            runtime: AppTestClientTypes.M2ManagedRuntime? = nil
        )
        {
            self.applicationId = applicationId
            self.listenerPort = listenerPort
            self.runtime = runtime
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the AWS Mainframe Modernization non-managed application summary.
    public struct M2NonManagedApplicationSummary: Swift.Sendable {
        /// The listener port of the AWS Mainframe Modernization non-managed application summary.
        /// This member is required.
        public var listenerPort: Swift.Int?
        /// The runtime of the AWS Mainframe Modernization non-managed application summary.
        /// This member is required.
        public var runtime: AppTestClientTypes.M2NonManagedRuntime?
        /// The VPC endpoint service name of the AWS Mainframe Modernization non-managed application summary.
        /// This member is required.
        public var vpcEndpointServiceName: Swift.String?
        /// The web application name of the AWS Mainframe Modernization non-managed application summary.
        public var webAppName: Swift.String?

        public init(
            listenerPort: Swift.Int? = nil,
            runtime: AppTestClientTypes.M2NonManagedRuntime? = nil,
            vpcEndpointServiceName: Swift.String? = nil,
            webAppName: Swift.String? = nil
        )
        {
            self.listenerPort = listenerPort
            self.runtime = runtime
            self.vpcEndpointServiceName = vpcEndpointServiceName
            self.webAppName = webAppName
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the mainframe resource summary.
    public enum MainframeResourceSummary: Swift.Sendable {
        /// The AWS Mainframe Modernization managed application in the mainframe resource summary.
        case m2managedapplication(AppTestClientTypes.M2ManagedApplicationSummary)
        /// The AWS Mainframe Modernization non-managed application in the mainframe resource summary.
        case m2nonmanagedapplication(AppTestClientTypes.M2NonManagedApplicationSummary)
        case sdkUnknown(Swift.String)
    }
}

extension AppTestClientTypes {

    /// Defines a batch step input.
    public struct BatchStepInput: Swift.Sendable {
        /// The batch job name of the batch step input.
        /// This member is required.
        public var batchJobName: Swift.String?
        /// The batch job parameters of the batch step input.
        public var batchJobParameters: [Swift.String: Swift.String]?
        /// The export data set names of the batch step input.
        public var exportDataSetNames: [Swift.String]?
        /// The properties of the batch step input.
        public var properties: AppTestClientTypes.MainframeActionProperties?
        /// The resource of the batch step input.
        /// This member is required.
        public var resource: AppTestClientTypes.MainframeResourceSummary?

        public init(
            batchJobName: Swift.String? = nil,
            batchJobParameters: [Swift.String: Swift.String]? = nil,
            exportDataSetNames: [Swift.String]? = nil,
            properties: AppTestClientTypes.MainframeActionProperties? = nil,
            resource: AppTestClientTypes.MainframeResourceSummary? = nil
        )
        {
            self.batchJobName = batchJobName
            self.batchJobParameters = batchJobParameters
            self.exportDataSetNames = exportDataSetNames
            self.properties = properties
            self.resource = resource
        }
    }
}

extension AppTestClientTypes {

    /// Defines a batch step output.
    public struct BatchStepOutput: Swift.Sendable {
        /// The data set details of the batch step output.
        public var dataSetDetails: [AppTestClientTypes.DataSet]?
        /// The data set export location of the batch step output.
        public var dataSetExportLocation: Swift.String?
        /// The Database Migration Service (DMS) output location of the batch step output.
        public var dmsOutputLocation: Swift.String?

        public init(
            dataSetDetails: [AppTestClientTypes.DataSet]? = nil,
            dataSetExportLocation: Swift.String? = nil,
            dmsOutputLocation: Swift.String? = nil
        )
        {
            self.dataSetDetails = dataSetDetails
            self.dataSetExportLocation = dataSetExportLocation
            self.dmsOutputLocation = dmsOutputLocation
        }
    }
}

extension AppTestClientTypes {

    /// Summarizes a batch job.
    public struct BatchSummary: Swift.Sendable {
        /// The step input of the batch summary.
        /// This member is required.
        public var stepInput: AppTestClientTypes.BatchStepInput?
        /// The step output of the batch summary.
        public var stepOutput: AppTestClientTypes.BatchStepOutput?

        public init(
            stepInput: AppTestClientTypes.BatchStepInput? = nil,
            stepOutput: AppTestClientTypes.BatchStepOutput? = nil
        )
        {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the scripts summary.
    public struct ScriptSummary: Swift.Sendable {
        /// The script location of the script summary.
        /// This member is required.
        public var scriptLocation: Swift.String?
        /// The type of the script summary.
        /// This member is required.
        public var type: AppTestClientTypes.ScriptType?

        public init(
            scriptLocation: Swift.String? = nil,
            type: AppTestClientTypes.ScriptType? = nil
        )
        {
            self.scriptLocation = scriptLocation
            self.type = type
        }
    }
}

extension AppTestClientTypes {

    /// Specifies a TN3270 step input.
    public struct TN3270StepInput: Swift.Sendable {
        /// The export data set names of the TN3270 step input.
        public var exportDataSetNames: [Swift.String]?
        /// The properties of the TN3270 step input.
        public var properties: AppTestClientTypes.MainframeActionProperties?
        /// The resource of the TN3270 step input.
        /// This member is required.
        public var resource: AppTestClientTypes.MainframeResourceSummary?
        /// The script of the TN3270 step input.
        /// This member is required.
        public var script: AppTestClientTypes.ScriptSummary?

        public init(
            exportDataSetNames: [Swift.String]? = nil,
            properties: AppTestClientTypes.MainframeActionProperties? = nil,
            resource: AppTestClientTypes.MainframeResourceSummary? = nil,
            script: AppTestClientTypes.ScriptSummary? = nil
        )
        {
            self.exportDataSetNames = exportDataSetNames
            self.properties = properties
            self.resource = resource
            self.script = script
        }
    }
}

extension AppTestClientTypes {

    /// Specifies a TN3270 step output.
    public struct TN3270StepOutput: Swift.Sendable {
        /// The data set details of the TN3270 step output.
        public var dataSetDetails: [AppTestClientTypes.DataSet]?
        /// The data set export location of the TN3270 step output.
        public var dataSetExportLocation: Swift.String?
        /// The output location of the TN3270 step output.
        public var dmsOutputLocation: Swift.String?
        /// The script output location of the TN3270 step output.
        /// This member is required.
        public var scriptOutputLocation: Swift.String?

        public init(
            dataSetDetails: [AppTestClientTypes.DataSet]? = nil,
            dataSetExportLocation: Swift.String? = nil,
            dmsOutputLocation: Swift.String? = nil,
            scriptOutputLocation: Swift.String? = nil
        )
        {
            self.dataSetDetails = dataSetDetails
            self.dataSetExportLocation = dataSetExportLocation
            self.dmsOutputLocation = dmsOutputLocation
            self.scriptOutputLocation = scriptOutputLocation
        }
    }
}

extension AppTestClientTypes {

    /// Specifies a TN3270 summary.
    public struct TN3270Summary: Swift.Sendable {
        /// The step input of the TN3270 summary.
        /// This member is required.
        public var stepInput: AppTestClientTypes.TN3270StepInput?
        /// The step output of the TN3270 summary.
        public var stepOutput: AppTestClientTypes.TN3270StepOutput?

        public init(
            stepInput: AppTestClientTypes.TN3270StepInput? = nil,
            stepOutput: AppTestClientTypes.TN3270StepOutput? = nil
        )
        {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the mainframe action summary.
    public enum MainframeActionSummary: Swift.Sendable {
        /// The batch of the mainframe action summary.
        case batch(AppTestClientTypes.BatchSummary)
        /// The tn3270 port of the mainframe action summary.
        case tn3270(AppTestClientTypes.TN3270Summary)
        case sdkUnknown(Swift.String)
    }
}

extension AppTestClientTypes {

    /// Creates the CloudFormation step input.
    public struct CreateCloudFormationStepInput: Swift.Sendable {
        /// The CloudFormation properties of the CloudFormation step input.
        public var parameters: [Swift.String: Swift.String]?
        /// The template location of the CloudFormation step input.
        /// This member is required.
        public var templateLocation: Swift.String?

        public init(
            parameters: [Swift.String: Swift.String]? = nil,
            templateLocation: Swift.String? = nil
        )
        {
            self.parameters = parameters
            self.templateLocation = templateLocation
        }
    }
}

extension AppTestClientTypes {

    /// Creates a CloudFormation step output.
    public struct CreateCloudFormationStepOutput: Swift.Sendable {
        /// The exports of the CloudFormation step output.
        public var exports: [Swift.String: Swift.String]?
        /// The stack ID of the CloudFormation step output.
        /// This member is required.
        public var stackId: Swift.String?

        public init(
            exports: [Swift.String: Swift.String]? = nil,
            stackId: Swift.String? = nil
        )
        {
            self.exports = exports
            self.stackId = stackId
        }
    }
}

extension AppTestClientTypes {

    /// Creates a CloudFormation summary.
    public struct CreateCloudFormationSummary: Swift.Sendable {
        /// The step input of the CloudFormation summary.
        /// This member is required.
        public var stepInput: AppTestClientTypes.CreateCloudFormationStepInput?
        /// The step output of the CloudFormation summary.
        public var stepOutput: AppTestClientTypes.CreateCloudFormationStepOutput?

        public init(
            stepInput: AppTestClientTypes.CreateCloudFormationStepInput? = nil,
            stepOutput: AppTestClientTypes.CreateCloudFormationStepOutput? = nil
        )
        {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }
    }
}

extension AppTestClientTypes {

    /// Deletes the CloudFormation step input.
    public struct DeleteCloudFormationStepInput: Swift.Sendable {
        /// The stack ID of the deleted CloudFormation step input.
        /// This member is required.
        public var stackId: Swift.String?

        public init(
            stackId: Swift.String? = nil
        )
        {
            self.stackId = stackId
        }
    }
}

extension AppTestClientTypes {

    /// Deletes the CloudFormation summary step output.
    public struct DeleteCloudFormationStepOutput: Swift.Sendable {

        public init() { }
    }
}

extension AppTestClientTypes {

    /// Deletes the CloudFormation summary.
    public struct DeleteCloudFormationSummary: Swift.Sendable {
        /// The step input of the deleted CloudFormation summary.
        /// This member is required.
        public var stepInput: AppTestClientTypes.DeleteCloudFormationStepInput?
        /// The step output of the deleted CloudFormation summary.
        public var stepOutput: AppTestClientTypes.DeleteCloudFormationStepOutput?

        public init(
            stepInput: AppTestClientTypes.DeleteCloudFormationStepInput? = nil,
            stepOutput: AppTestClientTypes.DeleteCloudFormationStepOutput? = nil
        )
        {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the CloudFormation step summary.
    public enum CloudFormationStepSummary: Swift.Sendable {
        /// Creates the CloudFormation summary of the step.
        case createcloudformation(AppTestClientTypes.CreateCloudFormationSummary)
        /// Deletes the CloudFormation summary of the CloudFormation step summary.
        case deletecloudformation(AppTestClientTypes.DeleteCloudFormationSummary)
        case sdkUnknown(Swift.String)
    }
}

extension AppTestClientTypes {

    /// Specifies the AWS Mainframe Modernization managed application step input.
    public struct M2ManagedApplicationStepInput: Swift.Sendable {
        /// The action type of the AWS Mainframe Modernization managed application step input.
        /// This member is required.
        public var actionType: AppTestClientTypes.M2ManagedActionType?
        /// The application ID of the AWS Mainframe Modernization managed application step input.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The listener port of the AWS Mainframe Modernization managed application step input.
        public var listenerPort: Swift.Int?
        /// The properties of the AWS Mainframe Modernization managed application step input.
        public var properties: AppTestClientTypes.M2ManagedActionProperties?
        /// The runtime of the AWS Mainframe Modernization managed application step input.
        /// This member is required.
        public var runtime: Swift.String?
        /// The VPC endpoint service name of the AWS Mainframe Modernization managed application step input.
        public var vpcEndpointServiceName: Swift.String?

        public init(
            actionType: AppTestClientTypes.M2ManagedActionType? = nil,
            applicationId: Swift.String? = nil,
            listenerPort: Swift.Int? = nil,
            properties: AppTestClientTypes.M2ManagedActionProperties? = nil,
            runtime: Swift.String? = nil,
            vpcEndpointServiceName: Swift.String? = nil
        )
        {
            self.actionType = actionType
            self.applicationId = applicationId
            self.listenerPort = listenerPort
            self.properties = properties
            self.runtime = runtime
            self.vpcEndpointServiceName = vpcEndpointServiceName
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the AWS Mainframe Modernization managed application step output.
    public struct M2ManagedApplicationStepOutput: Swift.Sendable {
        /// The import data set summary of the AWS Mainframe Modernization managed application step output.
        public var importDataSetSummary: [Swift.String: Swift.String]?

        public init(
            importDataSetSummary: [Swift.String: Swift.String]? = nil
        )
        {
            self.importDataSetSummary = importDataSetSummary
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the AWS Mainframe Modernization managed application step summary.
    public struct M2ManagedApplicationStepSummary: Swift.Sendable {
        /// The step input of the AWS Mainframe Modernization managed application step summary.
        /// This member is required.
        public var stepInput: AppTestClientTypes.M2ManagedApplicationStepInput?
        /// The step output of the AWS Mainframe Modernization managed application step summary.
        public var stepOutput: AppTestClientTypes.M2ManagedApplicationStepOutput?

        public init(
            stepInput: AppTestClientTypes.M2ManagedApplicationStepInput? = nil,
            stepOutput: AppTestClientTypes.M2ManagedApplicationStepOutput? = nil
        )
        {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the AWS Mainframe Modernization non-managed application step input.
    public struct M2NonManagedApplicationStepInput: Swift.Sendable {
        /// The action type of the AWS Mainframe Modernization non-managed application step input.
        /// This member is required.
        public var actionType: AppTestClientTypes.M2NonManagedActionType?
        /// The listener port of the AWS Mainframe Modernization non-managed application step input.
        /// This member is required.
        public var listenerPort: Swift.Int?
        /// The runtime of the AWS Mainframe Modernization non-managed application step input.
        /// This member is required.
        public var runtime: AppTestClientTypes.M2NonManagedRuntime?
        /// The VPC endpoint service name of the AWS Mainframe Modernization non-managed application step input.
        /// This member is required.
        public var vpcEndpointServiceName: Swift.String?
        /// The web app name of the AWS Mainframe Modernization non-managed application step input.
        public var webAppName: Swift.String?

        public init(
            actionType: AppTestClientTypes.M2NonManagedActionType? = nil,
            listenerPort: Swift.Int? = nil,
            runtime: AppTestClientTypes.M2NonManagedRuntime? = nil,
            vpcEndpointServiceName: Swift.String? = nil,
            webAppName: Swift.String? = nil
        )
        {
            self.actionType = actionType
            self.listenerPort = listenerPort
            self.runtime = runtime
            self.vpcEndpointServiceName = vpcEndpointServiceName
            self.webAppName = webAppName
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the AWS Mainframe Modernization non-managed application step output.
    public struct M2NonManagedApplicationStepOutput: Swift.Sendable {

        public init() { }
    }
}

extension AppTestClientTypes {

    /// Specifies the AWS Mainframe Modernization non-managed application step summary.
    public struct M2NonManagedApplicationStepSummary: Swift.Sendable {
        /// The step input of the AWS Mainframe Modernization non-managed application step summary.
        /// This member is required.
        public var stepInput: AppTestClientTypes.M2NonManagedApplicationStepInput?
        /// The step output of the AWS Mainframe Modernization non-managed application step summary.
        public var stepOutput: AppTestClientTypes.M2NonManagedApplicationStepOutput?

        public init(
            stepInput: AppTestClientTypes.M2NonManagedApplicationStepInput? = nil,
            stepOutput: AppTestClientTypes.M2NonManagedApplicationStepOutput? = nil
        )
        {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the resource action summary.
    public enum ResourceActionSummary: Swift.Sendable {
        /// The CloudFormation template of the resource action summary.
        case cloudformation(AppTestClientTypes.CloudFormationStepSummary)
        /// The AWS Mainframe Modernization managed application of the resource action summary.
        case m2managedapplication(AppTestClientTypes.M2ManagedApplicationStepSummary)
        /// The AWS Mainframe Modernization non-managed application of the resource action summary.
        case m2nonmanagedapplication(AppTestClientTypes.M2NonManagedApplicationStepSummary)
        case sdkUnknown(Swift.String)
    }
}

extension AppTestClientTypes {

    /// Defines the step run summary.
    public enum StepRunSummary: Swift.Sendable {
        /// The mainframe action of the step run summary.
        case mainframeaction(AppTestClientTypes.MainframeActionSummary)
        /// The compare action of the step run summary.
        case compareaction(AppTestClientTypes.CompareActionSummary)
        /// The resource action of the step run summary.
        case resourceaction(AppTestClientTypes.ResourceActionSummary)
        case sdkUnknown(Swift.String)
    }
}

public struct GetTestRunStepOutput: Swift.Sendable {
    /// The after steps of the test run step.
    public var afterStep: Swift.Bool?
    /// The before steps of the test run step.
    public var beforeStep: Swift.Bool?
    /// The run end time of the test run step.
    public var runEndTime: Foundation.Date?
    /// The run start time of the test run step.
    /// This member is required.
    public var runStartTime: Foundation.Date?
    /// The status of the test run step.
    /// This member is required.
    public var status: AppTestClientTypes.StepRunStatus?
    /// The status reason of the test run step.
    public var statusReason: Swift.String?
    /// The step name of the test run step.
    /// This member is required.
    public var stepName: Swift.String?
    /// The step run summary of the test run step.
    public var stepRunSummary: AppTestClientTypes.StepRunSummary?
    /// The test case ID of the test run step.
    public var testCaseId: Swift.String?
    /// The test case version of the test run step.
    public var testCaseVersion: Swift.Int?
    /// The test run ID of the test run step.
    /// This member is required.
    public var testRunId: Swift.String?
    /// The test suite ID of the test run step.
    public var testSuiteId: Swift.String?
    /// The test suite version of the test run step.
    public var testSuiteVersion: Swift.Int?

    public init(
        afterStep: Swift.Bool? = nil,
        beforeStep: Swift.Bool? = nil,
        runEndTime: Foundation.Date? = nil,
        runStartTime: Foundation.Date? = nil,
        status: AppTestClientTypes.StepRunStatus? = nil,
        statusReason: Swift.String? = nil,
        stepName: Swift.String? = nil,
        stepRunSummary: AppTestClientTypes.StepRunSummary? = nil,
        testCaseId: Swift.String? = nil,
        testCaseVersion: Swift.Int? = nil,
        testRunId: Swift.String? = nil,
        testSuiteId: Swift.String? = nil,
        testSuiteVersion: Swift.Int? = nil
    )
    {
        self.afterStep = afterStep
        self.beforeStep = beforeStep
        self.runEndTime = runEndTime
        self.runStartTime = runStartTime
        self.status = status
        self.statusReason = statusReason
        self.stepName = stepName
        self.stepRunSummary = stepRunSummary
        self.testCaseId = testCaseId
        self.testCaseVersion = testCaseVersion
        self.testRunId = testRunId
        self.testSuiteId = testSuiteId
        self.testSuiteVersion = testSuiteVersion
    }
}

public struct ListTestRunsInput: Swift.Sendable {
    /// The maximum number of test runs to return in one page of results.
    public var maxResults: Swift.Int?
    /// The token from the previous request to retrieve the next page of test run results.
    public var nextToken: Swift.String?
    /// The test run IDs of the test runs.
    public var testRunIds: [Swift.String]?
    /// The test suite ID of the test runs.
    public var testSuiteId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        testRunIds: [Swift.String]? = nil,
        testSuiteId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.testRunIds = testRunIds
        self.testSuiteId = testSuiteId
    }
}

extension AppTestClientTypes {

    public enum TestRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleting
        case failed
        case running
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [TestRunStatus] {
            return [
                .deleting,
                .failed,
                .running,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .running: return "Running"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Specifies a test run summary.
    public struct TestRunSummary: Swift.Sendable {
        /// The run end time of the test run summary.
        public var runEndTime: Foundation.Date?
        /// The run start time of the test run summary.
        /// This member is required.
        public var runStartTime: Foundation.Date?
        /// The status of the test run summary.
        /// This member is required.
        public var status: AppTestClientTypes.TestRunStatus?
        /// The status reason of the test run summary.
        public var statusReason: Swift.String?
        /// The test configuration ID of the test run summary.
        public var testConfigurationId: Swift.String?
        /// The test configuration version of the test run summary.
        public var testConfigurationVersion: Swift.Int?
        /// The test run ARN of the test run summary.
        /// This member is required.
        public var testRunArn: Swift.String?
        /// The test run ID of the test run summary.
        /// This member is required.
        public var testRunId: Swift.String?
        /// The test suite ID of the test run summary.
        /// This member is required.
        public var testSuiteId: Swift.String?
        /// The test suite version of the test run summary.
        /// This member is required.
        public var testSuiteVersion: Swift.Int?

        public init(
            runEndTime: Foundation.Date? = nil,
            runStartTime: Foundation.Date? = nil,
            status: AppTestClientTypes.TestRunStatus? = nil,
            statusReason: Swift.String? = nil,
            testConfigurationId: Swift.String? = nil,
            testConfigurationVersion: Swift.Int? = nil,
            testRunArn: Swift.String? = nil,
            testRunId: Swift.String? = nil,
            testSuiteId: Swift.String? = nil,
            testSuiteVersion: Swift.Int? = nil
        )
        {
            self.runEndTime = runEndTime
            self.runStartTime = runStartTime
            self.status = status
            self.statusReason = statusReason
            self.testConfigurationId = testConfigurationId
            self.testConfigurationVersion = testConfigurationVersion
            self.testRunArn = testRunArn
            self.testRunId = testRunId
            self.testSuiteId = testSuiteId
            self.testSuiteVersion = testSuiteVersion
        }
    }
}

public struct ListTestRunsOutput: Swift.Sendable {
    /// The token from the previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The test runs of the response query.
    /// This member is required.
    public var testRuns: [AppTestClientTypes.TestRunSummary]?

    public init(
        nextToken: Swift.String? = nil,
        testRuns: [AppTestClientTypes.TestRunSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.testRuns = testRuns
    }
}

public struct ListTestRunStepsInput: Swift.Sendable {
    /// The maximum number of test run steps to return in one page of results.
    public var maxResults: Swift.Int?
    /// The token from a previous step to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The test case ID of the test run steps.
    public var testCaseId: Swift.String?
    /// The test run ID of the test run steps.
    /// This member is required.
    public var testRunId: Swift.String?
    /// The test suite ID of the test run steps.
    public var testSuiteId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        testCaseId: Swift.String? = nil,
        testRunId: Swift.String? = nil,
        testSuiteId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.testCaseId = testCaseId
        self.testRunId = testRunId
        self.testSuiteId = testSuiteId
    }
}

extension AppTestClientTypes {

    /// Specifies a test run step summary.
    public struct TestRunStepSummary: Swift.Sendable {
        /// The after step of the test run step summary.
        public var afterStep: Swift.Bool?
        /// The before step of the test run step summary.
        public var beforeStep: Swift.Bool?
        /// The run end time of the test run step summary.
        public var runEndTime: Foundation.Date?
        /// The run start time of the test run step summary.
        /// This member is required.
        public var runStartTime: Foundation.Date?
        /// The status of the test run step summary.
        /// This member is required.
        public var status: AppTestClientTypes.StepRunStatus?
        /// The status reason of the test run step summary.
        public var statusReason: Swift.String?
        /// The step name of the test run step summary.
        /// This member is required.
        public var stepName: Swift.String?
        /// The test case ID of the test run step summary.
        public var testCaseId: Swift.String?
        /// The test case version of the test run step summary.
        public var testCaseVersion: Swift.Int?
        /// The test run ID of the test run step summary.
        /// This member is required.
        public var testRunId: Swift.String?
        /// The test suite ID of the test run step summary.
        public var testSuiteId: Swift.String?
        /// The test suite version of the test run step summary.
        public var testSuiteVersion: Swift.Int?

        public init(
            afterStep: Swift.Bool? = nil,
            beforeStep: Swift.Bool? = nil,
            runEndTime: Foundation.Date? = nil,
            runStartTime: Foundation.Date? = nil,
            status: AppTestClientTypes.StepRunStatus? = nil,
            statusReason: Swift.String? = nil,
            stepName: Swift.String? = nil,
            testCaseId: Swift.String? = nil,
            testCaseVersion: Swift.Int? = nil,
            testRunId: Swift.String? = nil,
            testSuiteId: Swift.String? = nil,
            testSuiteVersion: Swift.Int? = nil
        )
        {
            self.afterStep = afterStep
            self.beforeStep = beforeStep
            self.runEndTime = runEndTime
            self.runStartTime = runStartTime
            self.status = status
            self.statusReason = statusReason
            self.stepName = stepName
            self.testCaseId = testCaseId
            self.testCaseVersion = testCaseVersion
            self.testRunId = testRunId
            self.testSuiteId = testSuiteId
            self.testSuiteVersion = testSuiteVersion
        }
    }
}

public struct ListTestRunStepsOutput: Swift.Sendable {
    /// The token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The test run steps of the response query.
    /// This member is required.
    public var testRunSteps: [AppTestClientTypes.TestRunStepSummary]?

    public init(
        nextToken: Swift.String? = nil,
        testRunSteps: [AppTestClientTypes.TestRunStepSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.testRunSteps = testRunSteps
    }
}

public struct ListTestRunTestCasesInput: Swift.Sendable {
    /// The maximum number of test run test cases to return in one page of results.
    public var maxResults: Swift.Int?
    /// The token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The test run ID of the test cases.
    /// This member is required.
    public var testRunId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        testRunId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.testRunId = testRunId
    }
}

extension AppTestClientTypes {

    public enum TestCaseRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case running
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [TestCaseRunStatus] {
            return [
                .failed,
                .running,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .running: return "Running"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the test case run summary.
    public struct TestCaseRunSummary: Swift.Sendable {
        /// The run end time of the test case run summary.
        public var runEndTime: Foundation.Date?
        /// The run start time of the test case run summary.
        /// This member is required.
        public var runStartTime: Foundation.Date?
        /// The status of the test case run summary.
        /// This member is required.
        public var status: AppTestClientTypes.TestCaseRunStatus?
        /// The status reason of the test case run summary.
        public var statusReason: Swift.String?
        /// The test case id of the test case run summary.
        /// This member is required.
        public var testCaseId: Swift.String?
        /// The test case version of the test case run summary.
        /// This member is required.
        public var testCaseVersion: Swift.Int?
        /// The test run id of the test case run summary.
        /// This member is required.
        public var testRunId: Swift.String?

        public init(
            runEndTime: Foundation.Date? = nil,
            runStartTime: Foundation.Date? = nil,
            status: AppTestClientTypes.TestCaseRunStatus? = nil,
            statusReason: Swift.String? = nil,
            testCaseId: Swift.String? = nil,
            testCaseVersion: Swift.Int? = nil,
            testRunId: Swift.String? = nil
        )
        {
            self.runEndTime = runEndTime
            self.runStartTime = runStartTime
            self.status = status
            self.statusReason = statusReason
            self.testCaseId = testCaseId
            self.testCaseVersion = testCaseVersion
            self.testRunId = testRunId
        }
    }
}

public struct ListTestRunTestCasesOutput: Swift.Sendable {
    /// The token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The test run of the test cases.
    /// This member is required.
    public var testRunTestCases: [AppTestClientTypes.TestCaseRunSummary]?

    public init(
        nextToken: Swift.String? = nil,
        testRunTestCases: [AppTestClientTypes.TestCaseRunSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.testRunTestCases = testRunTestCases
    }
}

public struct StartTestRunInput: Swift.Sendable {
    /// The client token of the test run.
    public var clientToken: Swift.String?
    /// The tags of the test run.
    public var tags: [Swift.String: Swift.String]?
    /// The configuration ID of the test run.
    public var testConfigurationId: Swift.String?
    /// The test suite ID of the test run.
    /// This member is required.
    public var testSuiteId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        testConfigurationId: Swift.String? = nil,
        testSuiteId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.tags = tags
        self.testConfigurationId = testConfigurationId
        self.testSuiteId = testSuiteId
    }
}

public struct StartTestRunOutput: Swift.Sendable {
    /// The test run ID of the test run.
    /// This member is required.
    public var testRunId: Swift.String?
    /// The test run status of the test run.
    /// This member is required.
    public var testRunStatus: AppTestClientTypes.TestRunStatus?

    public init(
        testRunId: Swift.String? = nil,
        testRunStatus: AppTestClientTypes.TestRunStatus? = nil
    )
    {
        self.testRunId = testRunId
        self.testRunStatus = testRunStatus
    }
}

extension AppTestClientTypes {

    /// Specifies test cases.
    public enum TestCases: Swift.Sendable {
        /// The sequential of the test case.
        case sequential([Swift.String])
        case sdkUnknown(Swift.String)
    }
}

public struct CreateTestSuiteInput: Swift.Sendable {
    /// The after steps of the test suite.
    public var afterSteps: [AppTestClientTypes.Step]?
    /// The before steps of the test suite.
    public var beforeSteps: [AppTestClientTypes.Step]?
    /// The client token of the test suite.
    public var clientToken: Swift.String?
    /// The description of the test suite.
    public var description: Swift.String?
    /// The name of the test suite.
    /// This member is required.
    public var name: Swift.String?
    /// The tags of the test suite.
    public var tags: [Swift.String: Swift.String]?
    /// The test cases in the test suite.
    /// This member is required.
    public var testCases: AppTestClientTypes.TestCases?

    public init(
        afterSteps: [AppTestClientTypes.Step]? = nil,
        beforeSteps: [AppTestClientTypes.Step]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        testCases: AppTestClientTypes.TestCases? = nil
    )
    {
        self.afterSteps = afterSteps
        self.beforeSteps = beforeSteps
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
        self.testCases = testCases
    }
}

public struct CreateTestSuiteOutput: Swift.Sendable {
    /// The suite ID of the test suite.
    /// This member is required.
    public var testSuiteId: Swift.String?
    /// The suite version of the test suite.
    /// This member is required.
    public var testSuiteVersion: Swift.Int?

    public init(
        testSuiteId: Swift.String? = nil,
        testSuiteVersion: Swift.Int? = nil
    )
    {
        self.testSuiteId = testSuiteId
        self.testSuiteVersion = testSuiteVersion
    }
}

public struct DeleteTestSuiteInput: Swift.Sendable {
    /// The test ID of the test suite.
    /// This member is required.
    public var testSuiteId: Swift.String?

    public init(
        testSuiteId: Swift.String? = nil
    )
    {
        self.testSuiteId = testSuiteId
    }
}

public struct DeleteTestSuiteOutput: Swift.Sendable {

    public init() { }
}

public struct GetTestSuiteInput: Swift.Sendable {
    /// The ID of the test suite.
    /// This member is required.
    public var testSuiteId: Swift.String?
    /// The version of the test suite.
    public var testSuiteVersion: Swift.Int?

    public init(
        testSuiteId: Swift.String? = nil,
        testSuiteVersion: Swift.Int? = nil
    )
    {
        self.testSuiteId = testSuiteId
        self.testSuiteVersion = testSuiteVersion
    }
}

extension AppTestClientTypes {

    public enum TestSuiteLifecycle: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [TestSuiteLifecycle] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .creating: return "Creating"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppTestClientTypes {

    /// Specifies the latest version of a test suite.
    public struct TestSuiteLatestVersion: Swift.Sendable {
        /// The status of the test suite latest version.
        /// This member is required.
        public var status: AppTestClientTypes.TestSuiteLifecycle?
        /// The status reason of the test suite latest version.
        public var statusReason: Swift.String?
        /// The version of the test suite latest version.
        /// This member is required.
        public var version: Swift.Int?

        public init(
            status: AppTestClientTypes.TestSuiteLifecycle? = nil,
            statusReason: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.status = status
            self.statusReason = statusReason
            self.version = version
        }
    }
}

public struct GetTestSuiteOutput: Swift.Sendable {
    /// The after steps of the test suite.
    /// This member is required.
    public var afterSteps: [AppTestClientTypes.Step]?
    /// The before steps of the test suite.
    /// This member is required.
    public var beforeSteps: [AppTestClientTypes.Step]?
    /// The creation time of the test suite.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The description of the test suite.
    public var description: Swift.String?
    /// The last update time of the test suite.
    /// This member is required.
    public var lastUpdateTime: Foundation.Date?
    /// The latest version of the test suite.
    /// This member is required.
    public var latestVersion: AppTestClientTypes.TestSuiteLatestVersion?
    /// The name of the test suite.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the test suite.
    public var status: AppTestClientTypes.TestSuiteLifecycle?
    /// The status reason of the test suite.
    public var statusReason: Swift.String?
    /// The tags of the test suite.
    public var tags: [Swift.String: Swift.String]?
    /// The test cases of the test suite.
    /// This member is required.
    public var testCases: AppTestClientTypes.TestCases?
    /// The test suite Amazon Resource Name (ARN).
    /// This member is required.
    public var testSuiteArn: Swift.String?
    /// The response ID of the test suite.
    /// This member is required.
    public var testSuiteId: Swift.String?
    /// The version of the test suite.
    /// This member is required.
    public var testSuiteVersion: Swift.Int?

    public init(
        afterSteps: [AppTestClientTypes.Step]? = nil,
        beforeSteps: [AppTestClientTypes.Step]? = nil,
        creationTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        lastUpdateTime: Foundation.Date? = nil,
        latestVersion: AppTestClientTypes.TestSuiteLatestVersion? = nil,
        name: Swift.String? = nil,
        status: AppTestClientTypes.TestSuiteLifecycle? = nil,
        statusReason: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        testCases: AppTestClientTypes.TestCases? = nil,
        testSuiteArn: Swift.String? = nil,
        testSuiteId: Swift.String? = nil,
        testSuiteVersion: Swift.Int? = nil
    )
    {
        self.afterSteps = afterSteps
        self.beforeSteps = beforeSteps
        self.creationTime = creationTime
        self.description = description
        self.lastUpdateTime = lastUpdateTime
        self.latestVersion = latestVersion
        self.name = name
        self.status = status
        self.statusReason = statusReason
        self.tags = tags
        self.testCases = testCases
        self.testSuiteArn = testSuiteArn
        self.testSuiteId = testSuiteId
        self.testSuiteVersion = testSuiteVersion
    }
}

public struct ListTestSuitesInput: Swift.Sendable {
    /// The maximum number of test suites to return in one page of results.
    public var maxResults: Swift.Int?
    /// The token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The suite ID of the test suites.
    public var testSuiteIds: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        testSuiteIds: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.testSuiteIds = testSuiteIds
    }
}

extension AppTestClientTypes {

    /// Specifies the test suite summary.
    public struct TestSuiteSummary: Swift.Sendable {
        /// The creation time of the test suite summary.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The last update time of the test suite summary.
        /// This member is required.
        public var lastUpdateTime: Foundation.Date?
        /// The latest version of the test suite summary.
        /// This member is required.
        public var latestVersion: Swift.Int?
        /// The name of the test suite summary.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the test suite summary.
        /// This member is required.
        public var status: AppTestClientTypes.TestSuiteLifecycle?
        /// The status reason of the test suite summary.
        public var statusReason: Swift.String?
        /// The test suite Amazon Resource Name (ARN) of the test suite summary.
        /// This member is required.
        public var testSuiteArn: Swift.String?
        /// The test suite ID of the test suite summary.
        /// This member is required.
        public var testSuiteId: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            latestVersion: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: AppTestClientTypes.TestSuiteLifecycle? = nil,
            statusReason: Swift.String? = nil,
            testSuiteArn: Swift.String? = nil,
            testSuiteId: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.latestVersion = latestVersion
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.testSuiteArn = testSuiteArn
            self.testSuiteId = testSuiteId
        }
    }
}

public struct ListTestSuitesOutput: Swift.Sendable {
    /// The token from a previous request to retrieve the next page of test suites results.
    public var nextToken: Swift.String?
    /// The test suites returned with the response query.
    /// This member is required.
    public var testSuites: [AppTestClientTypes.TestSuiteSummary]?

    public init(
        nextToken: Swift.String? = nil,
        testSuites: [AppTestClientTypes.TestSuiteSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.testSuites = testSuites
    }
}

public struct UpdateTestSuiteInput: Swift.Sendable {
    /// The after steps of the test suite.
    public var afterSteps: [AppTestClientTypes.Step]?
    /// The before steps for the test suite.
    public var beforeSteps: [AppTestClientTypes.Step]?
    /// The description of the test suite.
    public var description: Swift.String?
    /// The test cases in the test suite.
    public var testCases: AppTestClientTypes.TestCases?
    /// The test suite ID of the test suite.
    /// This member is required.
    public var testSuiteId: Swift.String?

    public init(
        afterSteps: [AppTestClientTypes.Step]? = nil,
        beforeSteps: [AppTestClientTypes.Step]? = nil,
        description: Swift.String? = nil,
        testCases: AppTestClientTypes.TestCases? = nil,
        testSuiteId: Swift.String? = nil
    )
    {
        self.afterSteps = afterSteps
        self.beforeSteps = beforeSteps
        self.description = description
        self.testCases = testCases
        self.testSuiteId = testSuiteId
    }
}

public struct UpdateTestSuiteOutput: Swift.Sendable {
    /// The test suite ID of the test suite.
    /// This member is required.
    public var testSuiteId: Swift.String?
    /// The test suite version of the test suite.
    public var testSuiteVersion: Swift.Int?

    public init(
        testSuiteId: Swift.String? = nil,
        testSuiteVersion: Swift.Int? = nil
    )
    {
        self.testSuiteId = testSuiteId
        self.testSuiteVersion = testSuiteVersion
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CreateTestCaseInput {

    static func urlPathProvider(_ value: CreateTestCaseInput) -> Swift.String? {
        return "/testcase"
    }
}

extension CreateTestConfigurationInput {

    static func urlPathProvider(_ value: CreateTestConfigurationInput) -> Swift.String? {
        return "/testconfiguration"
    }
}

extension CreateTestSuiteInput {

    static func urlPathProvider(_ value: CreateTestSuiteInput) -> Swift.String? {
        return "/testsuite"
    }
}

extension DeleteTestCaseInput {

    static func urlPathProvider(_ value: DeleteTestCaseInput) -> Swift.String? {
        guard let testCaseId = value.testCaseId else {
            return nil
        }
        return "/testcases/\(testCaseId.urlPercentEncoding())"
    }
}

extension DeleteTestConfigurationInput {

    static func urlPathProvider(_ value: DeleteTestConfigurationInput) -> Swift.String? {
        guard let testConfigurationId = value.testConfigurationId else {
            return nil
        }
        return "/testconfigurations/\(testConfigurationId.urlPercentEncoding())"
    }
}

extension DeleteTestRunInput {

    static func urlPathProvider(_ value: DeleteTestRunInput) -> Swift.String? {
        guard let testRunId = value.testRunId else {
            return nil
        }
        return "/testruns/\(testRunId.urlPercentEncoding())"
    }
}

extension DeleteTestSuiteInput {

    static func urlPathProvider(_ value: DeleteTestSuiteInput) -> Swift.String? {
        guard let testSuiteId = value.testSuiteId else {
            return nil
        }
        return "/testsuites/\(testSuiteId.urlPercentEncoding())"
    }
}

extension GetTestCaseInput {

    static func urlPathProvider(_ value: GetTestCaseInput) -> Swift.String? {
        guard let testCaseId = value.testCaseId else {
            return nil
        }
        return "/testcases/\(testCaseId.urlPercentEncoding())"
    }
}

extension GetTestCaseInput {

    static func queryItemProvider(_ value: GetTestCaseInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let testCaseVersion = value.testCaseVersion {
            let testCaseVersionQueryItem = Smithy.URIQueryItem(name: "testCaseVersion".urlPercentEncoding(), value: Swift.String(testCaseVersion).urlPercentEncoding())
            items.append(testCaseVersionQueryItem)
        }
        return items
    }
}

extension GetTestConfigurationInput {

    static func urlPathProvider(_ value: GetTestConfigurationInput) -> Swift.String? {
        guard let testConfigurationId = value.testConfigurationId else {
            return nil
        }
        return "/testconfigurations/\(testConfigurationId.urlPercentEncoding())"
    }
}

extension GetTestConfigurationInput {

    static func queryItemProvider(_ value: GetTestConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let testConfigurationVersion = value.testConfigurationVersion {
            let testConfigurationVersionQueryItem = Smithy.URIQueryItem(name: "testConfigurationVersion".urlPercentEncoding(), value: Swift.String(testConfigurationVersion).urlPercentEncoding())
            items.append(testConfigurationVersionQueryItem)
        }
        return items
    }
}

extension GetTestRunStepInput {

    static func urlPathProvider(_ value: GetTestRunStepInput) -> Swift.String? {
        guard let testRunId = value.testRunId else {
            return nil
        }
        guard let stepName = value.stepName else {
            return nil
        }
        return "/testruns/\(testRunId.urlPercentEncoding())/steps/\(stepName.urlPercentEncoding())"
    }
}

extension GetTestRunStepInput {

    static func queryItemProvider(_ value: GetTestRunStepInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let testSuiteId = value.testSuiteId {
            let testSuiteIdQueryItem = Smithy.URIQueryItem(name: "testSuiteId".urlPercentEncoding(), value: Swift.String(testSuiteId).urlPercentEncoding())
            items.append(testSuiteIdQueryItem)
        }
        if let testCaseId = value.testCaseId {
            let testCaseIdQueryItem = Smithy.URIQueryItem(name: "testCaseId".urlPercentEncoding(), value: Swift.String(testCaseId).urlPercentEncoding())
            items.append(testCaseIdQueryItem)
        }
        return items
    }
}

extension GetTestSuiteInput {

    static func urlPathProvider(_ value: GetTestSuiteInput) -> Swift.String? {
        guard let testSuiteId = value.testSuiteId else {
            return nil
        }
        return "/testsuites/\(testSuiteId.urlPercentEncoding())"
    }
}

extension GetTestSuiteInput {

    static func queryItemProvider(_ value: GetTestSuiteInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let testSuiteVersion = value.testSuiteVersion {
            let testSuiteVersionQueryItem = Smithy.URIQueryItem(name: "testSuiteVersion".urlPercentEncoding(), value: Swift.String(testSuiteVersion).urlPercentEncoding())
            items.append(testSuiteVersionQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListTestCasesInput {

    static func urlPathProvider(_ value: ListTestCasesInput) -> Swift.String? {
        return "/testcases"
    }
}

extension ListTestCasesInput {

    static func queryItemProvider(_ value: ListTestCasesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let testCaseIds = value.testCaseIds {
            testCaseIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "testCaseIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListTestConfigurationsInput {

    static func urlPathProvider(_ value: ListTestConfigurationsInput) -> Swift.String? {
        return "/testconfigurations"
    }
}

extension ListTestConfigurationsInput {

    static func queryItemProvider(_ value: ListTestConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let testConfigurationIds = value.testConfigurationIds {
            testConfigurationIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "testConfigurationIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListTestRunsInput {

    static func urlPathProvider(_ value: ListTestRunsInput) -> Swift.String? {
        return "/testruns"
    }
}

extension ListTestRunsInput {

    static func queryItemProvider(_ value: ListTestRunsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let testSuiteId = value.testSuiteId {
            let testSuiteIdQueryItem = Smithy.URIQueryItem(name: "testSuiteId".urlPercentEncoding(), value: Swift.String(testSuiteId).urlPercentEncoding())
            items.append(testSuiteIdQueryItem)
        }
        if let testRunIds = value.testRunIds {
            testRunIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "testrunIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListTestRunStepsInput {

    static func urlPathProvider(_ value: ListTestRunStepsInput) -> Swift.String? {
        guard let testRunId = value.testRunId else {
            return nil
        }
        return "/testruns/\(testRunId.urlPercentEncoding())/steps"
    }
}

extension ListTestRunStepsInput {

    static func queryItemProvider(_ value: ListTestRunStepsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let testSuiteId = value.testSuiteId {
            let testSuiteIdQueryItem = Smithy.URIQueryItem(name: "testSuiteId".urlPercentEncoding(), value: Swift.String(testSuiteId).urlPercentEncoding())
            items.append(testSuiteIdQueryItem)
        }
        if let testCaseId = value.testCaseId {
            let testCaseIdQueryItem = Smithy.URIQueryItem(name: "testCaseId".urlPercentEncoding(), value: Swift.String(testCaseId).urlPercentEncoding())
            items.append(testCaseIdQueryItem)
        }
        return items
    }
}

extension ListTestRunTestCasesInput {

    static func urlPathProvider(_ value: ListTestRunTestCasesInput) -> Swift.String? {
        guard let testRunId = value.testRunId else {
            return nil
        }
        return "/testruns/\(testRunId.urlPercentEncoding())/testcases"
    }
}

extension ListTestRunTestCasesInput {

    static func queryItemProvider(_ value: ListTestRunTestCasesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTestSuitesInput {

    static func urlPathProvider(_ value: ListTestSuitesInput) -> Swift.String? {
        return "/testsuites"
    }
}

extension ListTestSuitesInput {

    static func queryItemProvider(_ value: ListTestSuitesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let testSuiteIds = value.testSuiteIds {
            testSuiteIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "testSuiteIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension StartTestRunInput {

    static func urlPathProvider(_ value: StartTestRunInput) -> Swift.String? {
        return "/testrun"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateTestCaseInput {

    static func urlPathProvider(_ value: UpdateTestCaseInput) -> Swift.String? {
        guard let testCaseId = value.testCaseId else {
            return nil
        }
        return "/testcases/\(testCaseId.urlPercentEncoding())"
    }
}

extension UpdateTestConfigurationInput {

    static func urlPathProvider(_ value: UpdateTestConfigurationInput) -> Swift.String? {
        guard let testConfigurationId = value.testConfigurationId else {
            return nil
        }
        return "/testconfigurations/\(testConfigurationId.urlPercentEncoding())"
    }
}

extension UpdateTestSuiteInput {

    static func urlPathProvider(_ value: UpdateTestSuiteInput) -> Swift.String? {
        guard let testSuiteId = value.testSuiteId else {
            return nil
        }
        return "/testsuites/\(testSuiteId.urlPercentEncoding())"
    }
}

extension CreateTestCaseInput {

    static func write(value: CreateTestCaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["steps"].writeList(value.steps, memberWritingClosure: AppTestClientTypes.Step.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateTestConfigurationInput {

    static func write(value: CreateTestConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["properties"].writeMap(value.properties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resources"].writeList(value.resources, memberWritingClosure: AppTestClientTypes.Resource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["serviceSettings"].write(value.serviceSettings, with: AppTestClientTypes.ServiceSettings.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateTestSuiteInput {

    static func write(value: CreateTestSuiteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["afterSteps"].writeList(value.afterSteps, memberWritingClosure: AppTestClientTypes.Step.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["beforeSteps"].writeList(value.beforeSteps, memberWritingClosure: AppTestClientTypes.Step.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["testCases"].write(value.testCases, with: AppTestClientTypes.TestCases.write(value:to:))
    }
}

extension StartTestRunInput {

    static func write(value: StartTestRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["testConfigurationId"].write(value.testConfigurationId)
        try writer["testSuiteId"].write(value.testSuiteId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateTestCaseInput {

    static func write(value: UpdateTestCaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["steps"].writeList(value.steps, memberWritingClosure: AppTestClientTypes.Step.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateTestConfigurationInput {

    static func write(value: UpdateTestConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["properties"].writeMap(value.properties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resources"].writeList(value.resources, memberWritingClosure: AppTestClientTypes.Resource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["serviceSettings"].write(value.serviceSettings, with: AppTestClientTypes.ServiceSettings.write(value:to:))
    }
}

extension UpdateTestSuiteInput {

    static func write(value: UpdateTestSuiteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["afterSteps"].writeList(value.afterSteps, memberWritingClosure: AppTestClientTypes.Step.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["beforeSteps"].writeList(value.beforeSteps, memberWritingClosure: AppTestClientTypes.Step.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["testCases"].write(value.testCases, with: AppTestClientTypes.TestCases.write(value:to:))
    }
}

extension CreateTestCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTestCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTestCaseOutput()
        value.testCaseId = try reader["testCaseId"].readIfPresent() ?? ""
        value.testCaseVersion = try reader["testCaseVersion"].readIfPresent() ?? 0
        return value
    }
}

extension CreateTestConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTestConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTestConfigurationOutput()
        value.testConfigurationId = try reader["testConfigurationId"].readIfPresent() ?? ""
        value.testConfigurationVersion = try reader["testConfigurationVersion"].readIfPresent() ?? 0
        return value
    }
}

extension CreateTestSuiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTestSuiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTestSuiteOutput()
        value.testSuiteId = try reader["testSuiteId"].readIfPresent() ?? ""
        value.testSuiteVersion = try reader["testSuiteVersion"].readIfPresent() ?? 0
        return value
    }
}

extension DeleteTestCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTestCaseOutput {
        return DeleteTestCaseOutput()
    }
}

extension DeleteTestConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTestConfigurationOutput {
        return DeleteTestConfigurationOutput()
    }
}

extension DeleteTestRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTestRunOutput {
        return DeleteTestRunOutput()
    }
}

extension DeleteTestSuiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTestSuiteOutput {
        return DeleteTestSuiteOutput()
    }
}

extension GetTestCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTestCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTestCaseOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.latestVersion = try reader["latestVersion"].readIfPresent(with: AppTestClientTypes.TestCaseLatestVersion.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.steps = try reader["steps"].readListIfPresent(memberReadingClosure: AppTestClientTypes.Step.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.testCaseArn = try reader["testCaseArn"].readIfPresent() ?? ""
        value.testCaseId = try reader["testCaseId"].readIfPresent() ?? ""
        value.testCaseVersion = try reader["testCaseVersion"].readIfPresent() ?? 0
        return value
    }
}

extension GetTestConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTestConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTestConfigurationOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.latestVersion = try reader["latestVersion"].readIfPresent(with: AppTestClientTypes.TestConfigurationLatestVersion.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.properties = try reader["properties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.resources = try reader["resources"].readListIfPresent(memberReadingClosure: AppTestClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.serviceSettings = try reader["serviceSettings"].readIfPresent(with: AppTestClientTypes.ServiceSettings.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.testConfigurationArn = try reader["testConfigurationArn"].readIfPresent() ?? ""
        value.testConfigurationId = try reader["testConfigurationId"].readIfPresent() ?? ""
        value.testConfigurationVersion = try reader["testConfigurationVersion"].readIfPresent() ?? 0
        return value
    }
}

extension GetTestRunStepOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTestRunStepOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTestRunStepOutput()
        value.afterStep = try reader["afterStep"].readIfPresent()
        value.beforeStep = try reader["beforeStep"].readIfPresent()
        value.runEndTime = try reader["runEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.runStartTime = try reader["runStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.stepName = try reader["stepName"].readIfPresent() ?? ""
        value.stepRunSummary = try reader["stepRunSummary"].readIfPresent(with: AppTestClientTypes.StepRunSummary.read(from:))
        value.testCaseId = try reader["testCaseId"].readIfPresent()
        value.testCaseVersion = try reader["testCaseVersion"].readIfPresent()
        value.testRunId = try reader["testRunId"].readIfPresent() ?? ""
        value.testSuiteId = try reader["testSuiteId"].readIfPresent()
        value.testSuiteVersion = try reader["testSuiteVersion"].readIfPresent()
        return value
    }
}

extension GetTestSuiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTestSuiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTestSuiteOutput()
        value.afterSteps = try reader["afterSteps"].readListIfPresent(memberReadingClosure: AppTestClientTypes.Step.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.beforeSteps = try reader["beforeSteps"].readListIfPresent(memberReadingClosure: AppTestClientTypes.Step.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.latestVersion = try reader["latestVersion"].readIfPresent(with: AppTestClientTypes.TestSuiteLatestVersion.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.testCases = try reader["testCases"].readIfPresent(with: AppTestClientTypes.TestCases.read(from:))
        value.testSuiteArn = try reader["testSuiteArn"].readIfPresent() ?? ""
        value.testSuiteId = try reader["testSuiteId"].readIfPresent() ?? ""
        value.testSuiteVersion = try reader["testSuiteVersion"].readIfPresent() ?? 0
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension ListTestCasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTestCasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTestCasesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.testCases = try reader["testCases"].readListIfPresent(memberReadingClosure: AppTestClientTypes.TestCaseSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTestConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTestConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTestConfigurationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.testConfigurations = try reader["testConfigurations"].readListIfPresent(memberReadingClosure: AppTestClientTypes.TestConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTestRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTestRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTestRunsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.testRuns = try reader["testRuns"].readListIfPresent(memberReadingClosure: AppTestClientTypes.TestRunSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTestRunStepsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTestRunStepsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTestRunStepsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.testRunSteps = try reader["testRunSteps"].readListIfPresent(memberReadingClosure: AppTestClientTypes.TestRunStepSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTestRunTestCasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTestRunTestCasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTestRunTestCasesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.testRunTestCases = try reader["testRunTestCases"].readListIfPresent(memberReadingClosure: AppTestClientTypes.TestCaseRunSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTestSuitesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTestSuitesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTestSuitesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.testSuites = try reader["testSuites"].readListIfPresent(memberReadingClosure: AppTestClientTypes.TestSuiteSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension StartTestRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartTestRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartTestRunOutput()
        value.testRunId = try reader["testRunId"].readIfPresent() ?? ""
        value.testRunStatus = try reader["testRunStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateTestCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTestCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTestCaseOutput()
        value.testCaseId = try reader["testCaseId"].readIfPresent() ?? ""
        value.testCaseVersion = try reader["testCaseVersion"].readIfPresent() ?? 0
        return value
    }
}

extension UpdateTestConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTestConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTestConfigurationOutput()
        value.testConfigurationId = try reader["testConfigurationId"].readIfPresent() ?? ""
        value.testConfigurationVersion = try reader["testConfigurationVersion"].readIfPresent() ?? 0
        return value
    }
}

extension UpdateTestSuiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTestSuiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTestSuiteOutput()
        value.testSuiteId = try reader["testSuiteId"].readIfPresent() ?? ""
        value.testSuiteVersion = try reader["testSuiteVersion"].readIfPresent()
        return value
    }
}

enum CreateTestCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTestConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTestSuiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTestCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTestConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTestRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTestSuiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTestCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTestConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTestRunStepOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTestSuiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTestCasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTestConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTestRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTestRunStepsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTestRunTestCasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTestSuitesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartTestRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTestCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTestConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTestSuiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: AppTestClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AppTestClientTypes.TestCaseLatestVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TestCaseLatestVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.TestCaseLatestVersion()
        value.version = try reader["version"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension AppTestClientTypes.Step {

    static func write(value: AppTestClientTypes.Step?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: AppTestClientTypes.StepAction.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.Step {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.Step()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.action = try reader["action"].readIfPresent(with: AppTestClientTypes.StepAction.read(from:))
        return value
    }
}

extension AppTestClientTypes.StepAction {

    static func write(value: AppTestClientTypes.StepAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .compareaction(compareaction):
                try writer["compareAction"].write(compareaction, with: AppTestClientTypes.CompareAction.write(value:to:))
            case let .mainframeaction(mainframeaction):
                try writer["mainframeAction"].write(mainframeaction, with: AppTestClientTypes.MainframeAction.write(value:to:))
            case let .resourceaction(resourceaction):
                try writer["resourceAction"].write(resourceaction, with: AppTestClientTypes.ResourceAction.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.StepAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "resourceAction":
                return .resourceaction(try reader["resourceAction"].read(with: AppTestClientTypes.ResourceAction.read(from:)))
            case "mainframeAction":
                return .mainframeaction(try reader["mainframeAction"].read(with: AppTestClientTypes.MainframeAction.read(from:)))
            case "compareAction":
                return .compareaction(try reader["compareAction"].read(with: AppTestClientTypes.CompareAction.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.CompareAction {

    static func write(value: AppTestClientTypes.CompareAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["input"].write(value.input, with: AppTestClientTypes.Input.write(value:to:))
        try writer["output"].write(value.output, with: AppTestClientTypes.Output.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CompareAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.CompareAction()
        value.input = try reader["input"].readIfPresent(with: AppTestClientTypes.Input.read(from:))
        value.output = try reader["output"].readIfPresent(with: AppTestClientTypes.Output.read(from:))
        return value
    }
}

extension AppTestClientTypes.Output {

    static func write(value: AppTestClientTypes.Output?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .file(file):
                try writer["file"].write(file, with: AppTestClientTypes.OutputFile.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.Output {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "file":
                return .file(try reader["file"].read(with: AppTestClientTypes.OutputFile.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.OutputFile {

    static func write(value: AppTestClientTypes.OutputFile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileLocation"].write(value.fileLocation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.OutputFile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.OutputFile()
        value.fileLocation = try reader["fileLocation"].readIfPresent()
        return value
    }
}

extension AppTestClientTypes.Input {

    static func write(value: AppTestClientTypes.Input?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .file(file):
                try writer["file"].write(file, with: AppTestClientTypes.InputFile.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.Input {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "file":
                return .file(try reader["file"].read(with: AppTestClientTypes.InputFile.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.InputFile {

    static func write(value: AppTestClientTypes.InputFile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileMetadata"].write(value.fileMetadata, with: AppTestClientTypes.FileMetadata.write(value:to:))
        try writer["sourceLocation"].write(value.sourceLocation)
        try writer["targetLocation"].write(value.targetLocation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.InputFile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.InputFile()
        value.sourceLocation = try reader["sourceLocation"].readIfPresent() ?? ""
        value.targetLocation = try reader["targetLocation"].readIfPresent() ?? ""
        value.fileMetadata = try reader["fileMetadata"].readIfPresent(with: AppTestClientTypes.FileMetadata.read(from:))
        return value
    }
}

extension AppTestClientTypes.FileMetadata {

    static func write(value: AppTestClientTypes.FileMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .datasets(datasets):
                try writer["dataSets"].writeList(datasets, memberWritingClosure: AppTestClientTypes.DataSet.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .databasecdc(databasecdc):
                try writer["databaseCDC"].write(databasecdc, with: AppTestClientTypes.DatabaseCDC.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.FileMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "dataSets":
                return .datasets(try reader["dataSets"].readList(memberReadingClosure: AppTestClientTypes.DataSet.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "databaseCDC":
                return .databasecdc(try reader["databaseCDC"].read(with: AppTestClientTypes.DatabaseCDC.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.DatabaseCDC {

    static func write(value: AppTestClientTypes.DatabaseCDC?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sourceMetadata"].write(value.sourceMetadata, with: AppTestClientTypes.SourceDatabaseMetadata.write(value:to:))
        try writer["targetMetadata"].write(value.targetMetadata, with: AppTestClientTypes.TargetDatabaseMetadata.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.DatabaseCDC {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.DatabaseCDC()
        value.sourceMetadata = try reader["sourceMetadata"].readIfPresent(with: AppTestClientTypes.SourceDatabaseMetadata.read(from:))
        value.targetMetadata = try reader["targetMetadata"].readIfPresent(with: AppTestClientTypes.TargetDatabaseMetadata.read(from:))
        return value
    }
}

extension AppTestClientTypes.TargetDatabaseMetadata {

    static func write(value: AppTestClientTypes.TargetDatabaseMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["captureTool"].write(value.captureTool)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TargetDatabaseMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.TargetDatabaseMetadata()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.captureTool = try reader["captureTool"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppTestClientTypes.SourceDatabaseMetadata {

    static func write(value: AppTestClientTypes.SourceDatabaseMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["captureTool"].write(value.captureTool)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.SourceDatabaseMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.SourceDatabaseMetadata()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.captureTool = try reader["captureTool"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppTestClientTypes.DataSet {

    static func write(value: AppTestClientTypes.DataSet?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ccsid"].write(value.ccsid)
        try writer["format"].write(value.format)
        try writer["length"].write(value.length)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.DataSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.DataSet()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.ccsid = try reader["ccsid"].readIfPresent() ?? ""
        value.format = try reader["format"].readIfPresent() ?? .sdkUnknown("")
        value.length = try reader["length"].readIfPresent() ?? 0
        return value
    }
}

extension AppTestClientTypes.MainframeAction {

    static func write(value: AppTestClientTypes.MainframeAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionType"].write(value.actionType, with: AppTestClientTypes.MainframeActionType.write(value:to:))
        try writer["properties"].write(value.properties, with: AppTestClientTypes.MainframeActionProperties.write(value:to:))
        try writer["resource"].write(value.resource)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.MainframeAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.MainframeAction()
        value.resource = try reader["resource"].readIfPresent() ?? ""
        value.actionType = try reader["actionType"].readIfPresent(with: AppTestClientTypes.MainframeActionType.read(from:))
        value.properties = try reader["properties"].readIfPresent(with: AppTestClientTypes.MainframeActionProperties.read(from:))
        return value
    }
}

extension AppTestClientTypes.MainframeActionProperties {

    static func write(value: AppTestClientTypes.MainframeActionProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dmsTaskArn"].write(value.dmsTaskArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.MainframeActionProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.MainframeActionProperties()
        value.dmsTaskArn = try reader["dmsTaskArn"].readIfPresent()
        return value
    }
}

extension AppTestClientTypes.MainframeActionType {

    static func write(value: AppTestClientTypes.MainframeActionType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .batch(batch):
                try writer["batch"].write(batch, with: AppTestClientTypes.Batch.write(value:to:))
            case let .tn3270(tn3270):
                try writer["tn3270"].write(tn3270, with: AppTestClientTypes.TN3270.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.MainframeActionType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "batch":
                return .batch(try reader["batch"].read(with: AppTestClientTypes.Batch.read(from:)))
            case "tn3270":
                return .tn3270(try reader["tn3270"].read(with: AppTestClientTypes.TN3270.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.TN3270 {

    static func write(value: AppTestClientTypes.TN3270?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exportDataSetNames"].writeList(value.exportDataSetNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["script"].write(value.script, with: AppTestClientTypes.Script.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TN3270 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.TN3270()
        value.script = try reader["script"].readIfPresent(with: AppTestClientTypes.Script.read(from:))
        value.exportDataSetNames = try reader["exportDataSetNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppTestClientTypes.Script {

    static func write(value: AppTestClientTypes.Script?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["scriptLocation"].write(value.scriptLocation)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.Script {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.Script()
        value.scriptLocation = try reader["scriptLocation"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppTestClientTypes.Batch {

    static func write(value: AppTestClientTypes.Batch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["batchJobName"].write(value.batchJobName)
        try writer["batchJobParameters"].writeMap(value.batchJobParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["exportDataSetNames"].writeList(value.exportDataSetNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.Batch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.Batch()
        value.batchJobName = try reader["batchJobName"].readIfPresent() ?? ""
        value.batchJobParameters = try reader["batchJobParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.exportDataSetNames = try reader["exportDataSetNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppTestClientTypes.ResourceAction {

    static func write(value: AppTestClientTypes.ResourceAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .cloudformationaction(cloudformationaction):
                try writer["cloudFormationAction"].write(cloudformationaction, with: AppTestClientTypes.CloudFormationAction.write(value:to:))
            case let .m2managedapplicationaction(m2managedapplicationaction):
                try writer["m2ManagedApplicationAction"].write(m2managedapplicationaction, with: AppTestClientTypes.M2ManagedApplicationAction.write(value:to:))
            case let .m2nonmanagedapplicationaction(m2nonmanagedapplicationaction):
                try writer["m2NonManagedApplicationAction"].write(m2nonmanagedapplicationaction, with: AppTestClientTypes.M2NonManagedApplicationAction.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.ResourceAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "m2ManagedApplicationAction":
                return .m2managedapplicationaction(try reader["m2ManagedApplicationAction"].read(with: AppTestClientTypes.M2ManagedApplicationAction.read(from:)))
            case "m2NonManagedApplicationAction":
                return .m2nonmanagedapplicationaction(try reader["m2NonManagedApplicationAction"].read(with: AppTestClientTypes.M2NonManagedApplicationAction.read(from:)))
            case "cloudFormationAction":
                return .cloudformationaction(try reader["cloudFormationAction"].read(with: AppTestClientTypes.CloudFormationAction.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.CloudFormationAction {

    static func write(value: AppTestClientTypes.CloudFormationAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionType"].write(value.actionType)
        try writer["resource"].write(value.resource)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CloudFormationAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.CloudFormationAction()
        value.resource = try reader["resource"].readIfPresent() ?? ""
        value.actionType = try reader["actionType"].readIfPresent()
        return value
    }
}

extension AppTestClientTypes.M2NonManagedApplicationAction {

    static func write(value: AppTestClientTypes.M2NonManagedApplicationAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionType"].write(value.actionType)
        try writer["resource"].write(value.resource)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.M2NonManagedApplicationAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.M2NonManagedApplicationAction()
        value.resource = try reader["resource"].readIfPresent() ?? ""
        value.actionType = try reader["actionType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppTestClientTypes.M2ManagedApplicationAction {

    static func write(value: AppTestClientTypes.M2ManagedApplicationAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionType"].write(value.actionType)
        try writer["properties"].write(value.properties, with: AppTestClientTypes.M2ManagedActionProperties.write(value:to:))
        try writer["resource"].write(value.resource)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.M2ManagedApplicationAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.M2ManagedApplicationAction()
        value.resource = try reader["resource"].readIfPresent() ?? ""
        value.actionType = try reader["actionType"].readIfPresent() ?? .sdkUnknown("")
        value.properties = try reader["properties"].readIfPresent(with: AppTestClientTypes.M2ManagedActionProperties.read(from:))
        return value
    }
}

extension AppTestClientTypes.M2ManagedActionProperties {

    static func write(value: AppTestClientTypes.M2ManagedActionProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["forceStop"].write(value.forceStop)
        try writer["importDataSetLocation"].write(value.importDataSetLocation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.M2ManagedActionProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.M2ManagedActionProperties()
        value.forceStop = try reader["forceStop"].readIfPresent()
        value.importDataSetLocation = try reader["importDataSetLocation"].readIfPresent()
        return value
    }
}

extension AppTestClientTypes.TestConfigurationLatestVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TestConfigurationLatestVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.TestConfigurationLatestVersion()
        value.version = try reader["version"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension AppTestClientTypes.Resource {

    static func write(value: AppTestClientTypes.Resource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["type"].write(value.type, with: AppTestClientTypes.ResourceType.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.Resource()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent(with: AppTestClientTypes.ResourceType.read(from:))
        return value
    }
}

extension AppTestClientTypes.ResourceType {

    static func write(value: AppTestClientTypes.ResourceType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .cloudformation(cloudformation):
                try writer["cloudFormation"].write(cloudformation, with: AppTestClientTypes.CloudFormation.write(value:to:))
            case let .m2managedapplication(m2managedapplication):
                try writer["m2ManagedApplication"].write(m2managedapplication, with: AppTestClientTypes.M2ManagedApplication.write(value:to:))
            case let .m2nonmanagedapplication(m2nonmanagedapplication):
                try writer["m2NonManagedApplication"].write(m2nonmanagedapplication, with: AppTestClientTypes.M2NonManagedApplication.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.ResourceType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "cloudFormation":
                return .cloudformation(try reader["cloudFormation"].read(with: AppTestClientTypes.CloudFormation.read(from:)))
            case "m2ManagedApplication":
                return .m2managedapplication(try reader["m2ManagedApplication"].read(with: AppTestClientTypes.M2ManagedApplication.read(from:)))
            case "m2NonManagedApplication":
                return .m2nonmanagedapplication(try reader["m2NonManagedApplication"].read(with: AppTestClientTypes.M2NonManagedApplication.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.M2NonManagedApplication {

    static func write(value: AppTestClientTypes.M2NonManagedApplication?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["listenerPort"].write(value.listenerPort)
        try writer["runtime"].write(value.runtime)
        try writer["vpcEndpointServiceName"].write(value.vpcEndpointServiceName)
        try writer["webAppName"].write(value.webAppName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.M2NonManagedApplication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.M2NonManagedApplication()
        value.vpcEndpointServiceName = try reader["vpcEndpointServiceName"].readIfPresent() ?? ""
        value.listenerPort = try reader["listenerPort"].readIfPresent() ?? ""
        value.runtime = try reader["runtime"].readIfPresent() ?? .sdkUnknown("")
        value.webAppName = try reader["webAppName"].readIfPresent()
        return value
    }
}

extension AppTestClientTypes.M2ManagedApplication {

    static func write(value: AppTestClientTypes.M2ManagedApplication?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationId"].write(value.applicationId)
        try writer["listenerPort"].write(value.listenerPort)
        try writer["runtime"].write(value.runtime)
        try writer["vpcEndpointServiceName"].write(value.vpcEndpointServiceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.M2ManagedApplication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.M2ManagedApplication()
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.runtime = try reader["runtime"].readIfPresent() ?? .sdkUnknown("")
        value.vpcEndpointServiceName = try reader["vpcEndpointServiceName"].readIfPresent()
        value.listenerPort = try reader["listenerPort"].readIfPresent()
        return value
    }
}

extension AppTestClientTypes.CloudFormation {

    static func write(value: AppTestClientTypes.CloudFormation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["templateLocation"].write(value.templateLocation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CloudFormation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.CloudFormation()
        value.templateLocation = try reader["templateLocation"].readIfPresent() ?? ""
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AppTestClientTypes.ServiceSettings {

    static func write(value: AppTestClientTypes.ServiceSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyId"].write(value.kmsKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.ServiceSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.ServiceSettings()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        return value
    }
}

extension AppTestClientTypes.StepRunSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.StepRunSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "mainframeAction":
                return .mainframeaction(try reader["mainframeAction"].read(with: AppTestClientTypes.MainframeActionSummary.read(from:)))
            case "compareAction":
                return .compareaction(try reader["compareAction"].read(with: AppTestClientTypes.CompareActionSummary.read(from:)))
            case "resourceAction":
                return .resourceaction(try reader["resourceAction"].read(with: AppTestClientTypes.ResourceActionSummary.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.ResourceActionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.ResourceActionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "cloudFormation":
                return .cloudformation(try reader["cloudFormation"].read(with: AppTestClientTypes.CloudFormationStepSummary.read(from:)))
            case "m2ManagedApplication":
                return .m2managedapplication(try reader["m2ManagedApplication"].read(with: AppTestClientTypes.M2ManagedApplicationStepSummary.read(from:)))
            case "m2NonManagedApplication":
                return .m2nonmanagedapplication(try reader["m2NonManagedApplication"].read(with: AppTestClientTypes.M2NonManagedApplicationStepSummary.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.M2NonManagedApplicationStepSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.M2NonManagedApplicationStepSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.M2NonManagedApplicationStepSummary()
        value.stepInput = try reader["stepInput"].readIfPresent(with: AppTestClientTypes.M2NonManagedApplicationStepInput.read(from:))
        value.stepOutput = try reader["stepOutput"].readIfPresent(with: AppTestClientTypes.M2NonManagedApplicationStepOutput.read(from:))
        return value
    }
}

extension AppTestClientTypes.M2NonManagedApplicationStepOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.M2NonManagedApplicationStepOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppTestClientTypes.M2NonManagedApplicationStepOutput()
    }
}

extension AppTestClientTypes.M2NonManagedApplicationStepInput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.M2NonManagedApplicationStepInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.M2NonManagedApplicationStepInput()
        value.vpcEndpointServiceName = try reader["vpcEndpointServiceName"].readIfPresent() ?? ""
        value.listenerPort = try reader["listenerPort"].readIfPresent() ?? 0
        value.runtime = try reader["runtime"].readIfPresent() ?? .sdkUnknown("")
        value.webAppName = try reader["webAppName"].readIfPresent()
        value.actionType = try reader["actionType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppTestClientTypes.M2ManagedApplicationStepSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.M2ManagedApplicationStepSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.M2ManagedApplicationStepSummary()
        value.stepInput = try reader["stepInput"].readIfPresent(with: AppTestClientTypes.M2ManagedApplicationStepInput.read(from:))
        value.stepOutput = try reader["stepOutput"].readIfPresent(with: AppTestClientTypes.M2ManagedApplicationStepOutput.read(from:))
        return value
    }
}

extension AppTestClientTypes.M2ManagedApplicationStepOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.M2ManagedApplicationStepOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.M2ManagedApplicationStepOutput()
        value.importDataSetSummary = try reader["importDataSetSummary"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AppTestClientTypes.M2ManagedApplicationStepInput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.M2ManagedApplicationStepInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.M2ManagedApplicationStepInput()
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.runtime = try reader["runtime"].readIfPresent() ?? ""
        value.vpcEndpointServiceName = try reader["vpcEndpointServiceName"].readIfPresent()
        value.listenerPort = try reader["listenerPort"].readIfPresent()
        value.actionType = try reader["actionType"].readIfPresent() ?? .sdkUnknown("")
        value.properties = try reader["properties"].readIfPresent(with: AppTestClientTypes.M2ManagedActionProperties.read(from:))
        return value
    }
}

extension AppTestClientTypes.CloudFormationStepSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CloudFormationStepSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "createCloudformation":
                return .createcloudformation(try reader["createCloudformation"].read(with: AppTestClientTypes.CreateCloudFormationSummary.read(from:)))
            case "deleteCloudformation":
                return .deletecloudformation(try reader["deleteCloudformation"].read(with: AppTestClientTypes.DeleteCloudFormationSummary.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.DeleteCloudFormationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.DeleteCloudFormationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.DeleteCloudFormationSummary()
        value.stepInput = try reader["stepInput"].readIfPresent(with: AppTestClientTypes.DeleteCloudFormationStepInput.read(from:))
        value.stepOutput = try reader["stepOutput"].readIfPresent(with: AppTestClientTypes.DeleteCloudFormationStepOutput.read(from:))
        return value
    }
}

extension AppTestClientTypes.DeleteCloudFormationStepOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.DeleteCloudFormationStepOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppTestClientTypes.DeleteCloudFormationStepOutput()
    }
}

extension AppTestClientTypes.DeleteCloudFormationStepInput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.DeleteCloudFormationStepInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.DeleteCloudFormationStepInput()
        value.stackId = try reader["stackId"].readIfPresent() ?? ""
        return value
    }
}

extension AppTestClientTypes.CreateCloudFormationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CreateCloudFormationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.CreateCloudFormationSummary()
        value.stepInput = try reader["stepInput"].readIfPresent(with: AppTestClientTypes.CreateCloudFormationStepInput.read(from:))
        value.stepOutput = try reader["stepOutput"].readIfPresent(with: AppTestClientTypes.CreateCloudFormationStepOutput.read(from:))
        return value
    }
}

extension AppTestClientTypes.CreateCloudFormationStepOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CreateCloudFormationStepOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.CreateCloudFormationStepOutput()
        value.stackId = try reader["stackId"].readIfPresent() ?? ""
        value.exports = try reader["exports"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AppTestClientTypes.CreateCloudFormationStepInput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CreateCloudFormationStepInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.CreateCloudFormationStepInput()
        value.templateLocation = try reader["templateLocation"].readIfPresent() ?? ""
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AppTestClientTypes.CompareActionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CompareActionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.CompareActionSummary()
        value.type = try reader["type"].readIfPresent(with: AppTestClientTypes.File.read(from:))
        return value
    }
}

extension AppTestClientTypes.File {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.File {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "fileType":
                return .filetype(try reader["fileType"].read(with: AppTestClientTypes.CompareFileType.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.CompareFileType {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CompareFileType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "datasets":
                return .datasets(try reader["datasets"].read(with: AppTestClientTypes.CompareDataSetsSummary.read(from:)))
            case "databaseCDC":
                return .databasecdc(try reader["databaseCDC"].read(with: AppTestClientTypes.CompareDatabaseCDCSummary.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.CompareDatabaseCDCSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CompareDatabaseCDCSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.CompareDatabaseCDCSummary()
        value.stepInput = try reader["stepInput"].readIfPresent(with: AppTestClientTypes.CompareDatabaseCDCStepInput.read(from:))
        value.stepOutput = try reader["stepOutput"].readIfPresent(with: AppTestClientTypes.CompareDatabaseCDCStepOutput.read(from:))
        return value
    }
}

extension AppTestClientTypes.CompareDatabaseCDCStepOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CompareDatabaseCDCStepOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.CompareDatabaseCDCStepOutput()
        value.comparisonOutputLocation = try reader["comparisonOutputLocation"].readIfPresent() ?? ""
        value.comparisonStatus = try reader["comparisonStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppTestClientTypes.CompareDatabaseCDCStepInput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CompareDatabaseCDCStepInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.CompareDatabaseCDCStepInput()
        value.sourceLocation = try reader["sourceLocation"].readIfPresent() ?? ""
        value.targetLocation = try reader["targetLocation"].readIfPresent() ?? ""
        value.outputLocation = try reader["outputLocation"].readIfPresent()
        value.sourceMetadata = try reader["sourceMetadata"].readIfPresent(with: AppTestClientTypes.SourceDatabaseMetadata.read(from:))
        value.targetMetadata = try reader["targetMetadata"].readIfPresent(with: AppTestClientTypes.TargetDatabaseMetadata.read(from:))
        return value
    }
}

extension AppTestClientTypes.CompareDataSetsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CompareDataSetsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.CompareDataSetsSummary()
        value.stepInput = try reader["stepInput"].readIfPresent(with: AppTestClientTypes.CompareDataSetsStepInput.read(from:))
        value.stepOutput = try reader["stepOutput"].readIfPresent(with: AppTestClientTypes.CompareDataSetsStepOutput.read(from:))
        return value
    }
}

extension AppTestClientTypes.CompareDataSetsStepOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CompareDataSetsStepOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.CompareDataSetsStepOutput()
        value.comparisonOutputLocation = try reader["comparisonOutputLocation"].readIfPresent() ?? ""
        value.comparisonStatus = try reader["comparisonStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppTestClientTypes.CompareDataSetsStepInput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.CompareDataSetsStepInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.CompareDataSetsStepInput()
        value.sourceLocation = try reader["sourceLocation"].readIfPresent() ?? ""
        value.targetLocation = try reader["targetLocation"].readIfPresent() ?? ""
        value.sourceDataSets = try reader["sourceDataSets"].readListIfPresent(memberReadingClosure: AppTestClientTypes.DataSet.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.targetDataSets = try reader["targetDataSets"].readListIfPresent(memberReadingClosure: AppTestClientTypes.DataSet.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension AppTestClientTypes.MainframeActionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.MainframeActionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "batch":
                return .batch(try reader["batch"].read(with: AppTestClientTypes.BatchSummary.read(from:)))
            case "tn3270":
                return .tn3270(try reader["tn3270"].read(with: AppTestClientTypes.TN3270Summary.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.TN3270Summary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TN3270Summary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.TN3270Summary()
        value.stepInput = try reader["stepInput"].readIfPresent(with: AppTestClientTypes.TN3270StepInput.read(from:))
        value.stepOutput = try reader["stepOutput"].readIfPresent(with: AppTestClientTypes.TN3270StepOutput.read(from:))
        return value
    }
}

extension AppTestClientTypes.TN3270StepOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TN3270StepOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.TN3270StepOutput()
        value.dataSetExportLocation = try reader["dataSetExportLocation"].readIfPresent()
        value.dmsOutputLocation = try reader["dmsOutputLocation"].readIfPresent()
        value.dataSetDetails = try reader["dataSetDetails"].readListIfPresent(memberReadingClosure: AppTestClientTypes.DataSet.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.scriptOutputLocation = try reader["scriptOutputLocation"].readIfPresent() ?? ""
        return value
    }
}

extension AppTestClientTypes.TN3270StepInput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TN3270StepInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.TN3270StepInput()
        value.resource = try reader["resource"].readIfPresent(with: AppTestClientTypes.MainframeResourceSummary.read(from:))
        value.script = try reader["script"].readIfPresent(with: AppTestClientTypes.ScriptSummary.read(from:))
        value.exportDataSetNames = try reader["exportDataSetNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties = try reader["properties"].readIfPresent(with: AppTestClientTypes.MainframeActionProperties.read(from:))
        return value
    }
}

extension AppTestClientTypes.ScriptSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.ScriptSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.ScriptSummary()
        value.scriptLocation = try reader["scriptLocation"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppTestClientTypes.MainframeResourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.MainframeResourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "m2ManagedApplication":
                return .m2managedapplication(try reader["m2ManagedApplication"].read(with: AppTestClientTypes.M2ManagedApplicationSummary.read(from:)))
            case "m2NonManagedApplication":
                return .m2nonmanagedapplication(try reader["m2NonManagedApplication"].read(with: AppTestClientTypes.M2NonManagedApplicationSummary.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.M2NonManagedApplicationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.M2NonManagedApplicationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.M2NonManagedApplicationSummary()
        value.vpcEndpointServiceName = try reader["vpcEndpointServiceName"].readIfPresent() ?? ""
        value.listenerPort = try reader["listenerPort"].readIfPresent() ?? 0
        value.runtime = try reader["runtime"].readIfPresent() ?? .sdkUnknown("")
        value.webAppName = try reader["webAppName"].readIfPresent()
        return value
    }
}

extension AppTestClientTypes.M2ManagedApplicationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.M2ManagedApplicationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.M2ManagedApplicationSummary()
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.runtime = try reader["runtime"].readIfPresent() ?? .sdkUnknown("")
        value.listenerPort = try reader["listenerPort"].readIfPresent()
        return value
    }
}

extension AppTestClientTypes.BatchSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.BatchSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.BatchSummary()
        value.stepInput = try reader["stepInput"].readIfPresent(with: AppTestClientTypes.BatchStepInput.read(from:))
        value.stepOutput = try reader["stepOutput"].readIfPresent(with: AppTestClientTypes.BatchStepOutput.read(from:))
        return value
    }
}

extension AppTestClientTypes.BatchStepOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.BatchStepOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.BatchStepOutput()
        value.dataSetExportLocation = try reader["dataSetExportLocation"].readIfPresent()
        value.dmsOutputLocation = try reader["dmsOutputLocation"].readIfPresent()
        value.dataSetDetails = try reader["dataSetDetails"].readListIfPresent(memberReadingClosure: AppTestClientTypes.DataSet.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppTestClientTypes.BatchStepInput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.BatchStepInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.BatchStepInput()
        value.resource = try reader["resource"].readIfPresent(with: AppTestClientTypes.MainframeResourceSummary.read(from:))
        value.batchJobName = try reader["batchJobName"].readIfPresent() ?? ""
        value.batchJobParameters = try reader["batchJobParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.exportDataSetNames = try reader["exportDataSetNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties = try reader["properties"].readIfPresent(with: AppTestClientTypes.MainframeActionProperties.read(from:))
        return value
    }
}

extension AppTestClientTypes.TestSuiteLatestVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TestSuiteLatestVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.TestSuiteLatestVersion()
        value.version = try reader["version"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension AppTestClientTypes.TestCases {

    static func write(value: AppTestClientTypes.TestCases?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .sequential(sequential):
                try writer["sequential"].writeList(sequential, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TestCases {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "sequential":
                return .sequential(try reader["sequential"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppTestClientTypes.TestCaseSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TestCaseSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.TestCaseSummary()
        value.testCaseId = try reader["testCaseId"].readIfPresent() ?? ""
        value.testCaseArn = try reader["testCaseArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.latestVersion = try reader["latestVersion"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AppTestClientTypes.TestConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TestConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.TestConfigurationSummary()
        value.testConfigurationId = try reader["testConfigurationId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.latestVersion = try reader["latestVersion"].readIfPresent() ?? 0
        value.testConfigurationArn = try reader["testConfigurationArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AppTestClientTypes.TestRunSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TestRunSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.TestRunSummary()
        value.testRunId = try reader["testRunId"].readIfPresent() ?? ""
        value.testRunArn = try reader["testRunArn"].readIfPresent() ?? ""
        value.testSuiteId = try reader["testSuiteId"].readIfPresent() ?? ""
        value.testSuiteVersion = try reader["testSuiteVersion"].readIfPresent() ?? 0
        value.testConfigurationId = try reader["testConfigurationId"].readIfPresent()
        value.testConfigurationVersion = try reader["testConfigurationVersion"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.runStartTime = try reader["runStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.runEndTime = try reader["runEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AppTestClientTypes.TestRunStepSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TestRunStepSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.TestRunStepSummary()
        value.stepName = try reader["stepName"].readIfPresent() ?? ""
        value.testRunId = try reader["testRunId"].readIfPresent() ?? ""
        value.testCaseId = try reader["testCaseId"].readIfPresent()
        value.testCaseVersion = try reader["testCaseVersion"].readIfPresent()
        value.testSuiteId = try reader["testSuiteId"].readIfPresent()
        value.testSuiteVersion = try reader["testSuiteVersion"].readIfPresent()
        value.beforeStep = try reader["beforeStep"].readIfPresent()
        value.afterStep = try reader["afterStep"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.runStartTime = try reader["runStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.runEndTime = try reader["runEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AppTestClientTypes.TestCaseRunSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TestCaseRunSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.TestCaseRunSummary()
        value.testCaseId = try reader["testCaseId"].readIfPresent() ?? ""
        value.testCaseVersion = try reader["testCaseVersion"].readIfPresent() ?? 0
        value.testRunId = try reader["testRunId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.runStartTime = try reader["runStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.runEndTime = try reader["runEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AppTestClientTypes.TestSuiteSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.TestSuiteSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.TestSuiteSummary()
        value.testSuiteId = try reader["testSuiteId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.latestVersion = try reader["latestVersion"].readIfPresent() ?? 0
        value.testSuiteArn = try reader["testSuiteArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AppTestClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> AppTestClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppTestClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

public enum AppTestClientTypes {}
