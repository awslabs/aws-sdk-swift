//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BillingAccessDenied" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BillingClientTypes {

    /// A time range with a start and end time.
    public struct ActiveTimeRange: Swift.Sendable {
        /// The inclusive time range start date.
        /// This member is required.
        public var activeAfterInclusive: Foundation.Date?
        /// The inclusive time range end date.
        /// This member is required.
        public var activeBeforeInclusive: Foundation.Date?

        public init(
            activeAfterInclusive: Foundation.Date? = nil,
            activeBeforeInclusive: Foundation.Date? = nil
        ) {
            self.activeAfterInclusive = activeAfterInclusive
            self.activeBeforeInclusive = activeBeforeInclusive
        }
    }
}

/// Exception thrown when a billing view's health status prevents an operation from being performed. This may occur if the billing view is in a state other than HEALTHY.
public struct BillingViewHealthStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BillingViewHealthStatusException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier for the service resource associated with the request.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource associated with the request.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BillingConflict" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request processing failed because of an unknown error, exception, or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BillingInternalServer" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The specified ARN in the request doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Value is a list of resource IDs that were not found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Value is the type of resource that was not found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BillingResourceNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// You've reached the limit of resources you can create, or exceeded the size of an individual resource.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The container for the quotaCode.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of Amazon Web Services resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The container for the serviceCode.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BillingServiceQuotaExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BillingThrottling" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BillingClientTypes {

    /// The field's information of a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The message describing why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

extension BillingClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var fieldList: [BillingClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        /// This member is required.
        public internal(set) var reason: BillingClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BillingValidation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [BillingClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: BillingClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AssociateSourceViewsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the billing view to associate source views with.
    /// This member is required.
    public var arn: Swift.String?
    /// A list of ARNs of the source billing views to associate.
    /// This member is required.
    public var sourceViews: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        sourceViews: [Swift.String]? = nil
    ) {
        self.arn = arn
        self.sourceViews = sourceViews
    }
}

public struct AssociateSourceViewsOutput: Swift.Sendable {
    /// The ARN of the billing view that the source views were associated with.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

extension BillingClientTypes {

    public enum Dimension: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linkedAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [Dimension] {
            return [
                .linkedAccount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linkedAccount: return "LINKED_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BillingClientTypes {

    /// The metadata that you can use to filter and group your results.
    public struct DimensionValues: Swift.Sendable {
        /// The names of the metadata types that you can use to filter and group your results.
        /// This member is required.
        public var key: BillingClientTypes.Dimension?
        /// The metadata values that you can use to filter and group your results.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: BillingClientTypes.Dimension? = nil,
            values: [Swift.String]? = nil
        ) {
            self.key = key
            self.values = values
        }
    }
}

extension BillingClientTypes {

    /// The values that are available for a tag.
    public struct TagValues: Swift.Sendable {
        /// The key for the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The specific value of the tag.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        ) {
            self.key = key
            self.values = values
        }
    }
}

extension BillingClientTypes {

    /// Specifies a time range with inclusive begin and end dates.
    public struct TimeRange: Swift.Sendable {
        /// The inclusive start date of the time range.
        public var beginDateInclusive: Foundation.Date?
        /// The inclusive end date of the time range.
        public var endDateInclusive: Foundation.Date?

        public init(
            beginDateInclusive: Foundation.Date? = nil,
            endDateInclusive: Foundation.Date? = nil
        ) {
            self.beginDateInclusive = beginDateInclusive
            self.endDateInclusive = endDateInclusive
        }
    }
}

extension BillingClientTypes {

    /// See [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_billing_Expression.html). Billing view only supports LINKED_ACCOUNT and Tags.
    public struct Expression: Swift.Sendable {
        /// The specific Dimension to use for Expression.
        public var dimensions: BillingClientTypes.DimensionValues?
        /// The specific Tag to use for Expression.
        public var tags: BillingClientTypes.TagValues?
        /// Specifies a time range filter for the billing view data.
        public var timeRange: BillingClientTypes.TimeRange?

        public init(
            dimensions: BillingClientTypes.DimensionValues? = nil,
            tags: BillingClientTypes.TagValues? = nil,
            timeRange: BillingClientTypes.TimeRange? = nil
        ) {
            self.dimensions = dimensions
            self.tags = tags
            self.timeRange = timeRange
        }
    }
}

extension BillingClientTypes {

    /// The tag structure that contains a tag key and value.
    public struct ResourceTag: Swift.Sendable {
        /// The key that's associated with the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value that's associated with the tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateBillingViewInput: Swift.Sendable {
    /// A unique, case-sensitive identifier you specify to ensure idempotency of the request. Idempotency ensures that an API request completes no more than one time. If the original request completes successfully, any subsequent retries complete successfully without performing any further actions with an idempotent request.
    public var clientToken: Swift.String?
    /// See [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_billing_Expression.html). Billing view only supports LINKED_ACCOUNT and Tags.
    public var dataFilterExpression: BillingClientTypes.Expression?
    /// The description of the billing view.
    public var description: Swift.String?
    /// The name of the billing view.
    /// This member is required.
    public var name: Swift.String?
    /// A list of key value map specifying tags associated to the billing view being created.
    public var resourceTags: [BillingClientTypes.ResourceTag]?
    /// A list of billing views used as the data source for the custom billing view.
    /// This member is required.
    public var sourceViews: [Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        dataFilterExpression: BillingClientTypes.Expression? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceTags: [BillingClientTypes.ResourceTag]? = nil,
        sourceViews: [Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.dataFilterExpression = dataFilterExpression
        self.description = description
        self.name = name
        self.resourceTags = resourceTags
        self.sourceViews = sourceViews
    }
}

extension CreateBillingViewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBillingViewInput(clientToken: \(Swift.String(describing: clientToken)), dataFilterExpression: \(Swift.String(describing: dataFilterExpression)), resourceTags: \(Swift.String(describing: resourceTags)), sourceViews: \(Swift.String(describing: sourceViews)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateBillingViewOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that can be used to uniquely identify the billing view.
    /// This member is required.
    public var arn: Swift.String?
    /// The time when the billing view was created.
    public var createdAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
    }
}

public struct DeleteBillingViewInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that can be used to uniquely identify the billing view.
    /// This member is required.
    public var arn: Swift.String?
    /// If set to true, forces deletion of the billing view even if it has derived resources (e.g. other billing views or budgets). Use with caution as this may break dependent resources.
    public var force: Swift.Bool?

    public init(
        arn: Swift.String? = nil,
        force: Swift.Bool? = nil
    ) {
        self.arn = arn
        self.force = force
    }
}

public struct DeleteBillingViewOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that can be used to uniquely identify the billing view.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct DisassociateSourceViewsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the billing view to disassociate source views from.
    /// This member is required.
    public var arn: Swift.String?
    /// A list of ARNs of the source billing views to disassociate.
    /// This member is required.
    public var sourceViews: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        sourceViews: [Swift.String]? = nil
    ) {
        self.arn = arn
        self.sourceViews = sourceViews
    }
}

public struct DisassociateSourceViewsOutput: Swift.Sendable {
    /// The ARN of the billing view that the source views were disassociated from.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct GetBillingViewInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that can be used to uniquely identify the billing view.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

extension BillingClientTypes {

    public enum BillingViewType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case billingGroup
        case billingTransfer
        case billingTransferShowback
        case custom
        case primary
        case sdkUnknown(Swift.String)

        public static var allCases: [BillingViewType] {
            return [
                .billingGroup,
                .billingTransfer,
                .billingTransferShowback,
                .custom,
                .primary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .billingGroup: return "BILLING_GROUP"
            case .billingTransfer: return "BILLING_TRANSFER"
            case .billingTransferShowback: return "BILLING_TRANSFER_SHOWBACK"
            case .custom: return "CUSTOM"
            case .primary: return "PRIMARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BillingClientTypes {

    public enum BillingViewStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case healthy
        case unhealthy
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [BillingViewStatus] {
            return [
                .creating,
                .healthy,
                .unhealthy,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BillingClientTypes {

    public enum BillingViewStatusReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aggregateSource
        case cyclicDependency
        case sourceViewAccessDenied
        case sourceViewDepthExceeded
        case sourceViewNotFound
        case sourceViewUnhealthy
        case sourceViewUpdating
        case viewOwnerNotManagementAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [BillingViewStatusReason] {
            return [
                .aggregateSource,
                .cyclicDependency,
                .sourceViewAccessDenied,
                .sourceViewDepthExceeded,
                .sourceViewNotFound,
                .sourceViewUnhealthy,
                .sourceViewUpdating,
                .viewOwnerNotManagementAccount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aggregateSource: return "AGGREGATE_SOURCE"
            case .cyclicDependency: return "CYCLIC_DEPENDENCY"
            case .sourceViewAccessDenied: return "SOURCE_VIEW_ACCESS_DENIED"
            case .sourceViewDepthExceeded: return "SOURCE_VIEW_DEPTH_EXCEEDED"
            case .sourceViewNotFound: return "SOURCE_VIEW_NOT_FOUND"
            case .sourceViewUnhealthy: return "SOURCE_VIEW_UNHEALTHY"
            case .sourceViewUpdating: return "SOURCE_VIEW_UPDATING"
            case .viewOwnerNotManagementAccount: return "VIEW_OWNER_NOT_MANAGEMENT_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BillingClientTypes {

    /// Represents the health status of a billing view, including a status code and optional reasons for the status.
    public struct BillingViewHealthStatus: Swift.Sendable {
        /// The current health status code of the billing view.
        public var statusCode: BillingClientTypes.BillingViewStatus?
        /// A list of reasons explaining the current health status, if applicable.
        public var statusReasons: [BillingClientTypes.BillingViewStatusReason]?

        public init(
            statusCode: BillingClientTypes.BillingViewStatus? = nil,
            statusReasons: [BillingClientTypes.BillingViewStatusReason]? = nil
        ) {
            self.statusCode = statusCode
            self.statusReasons = statusReasons
        }
    }
}

extension BillingClientTypes {

    /// The metadata associated to the billing view.
    public struct BillingViewElement: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that can be used to uniquely identify the billing view.
        public var arn: Swift.String?
        /// The type of billing group.
        public var billingViewType: BillingClientTypes.BillingViewType?
        /// The time when the billing view was created.
        public var createdAt: Foundation.Date?
        /// See [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_billing_Expression.html). Billing view only supports LINKED_ACCOUNT and Tags.
        public var dataFilterExpression: BillingClientTypes.Expression?
        /// The number of billing views that use this billing view as a source.
        public var derivedViewCount: Swift.Int?
        /// The description of the billing view.
        public var description: Swift.String?
        /// The current health status of the billing view.
        public var healthStatus: BillingClientTypes.BillingViewHealthStatus?
        /// The account name of the billing view.
        public var name: Swift.String?
        /// The account owner of the billing view.
        public var ownerAccountId: Swift.String?
        /// The Amazon Web Services account ID that owns the source billing view, if this is a derived billing view.
        public var sourceAccountId: Swift.String?
        /// The number of source views associated with this billing view.
        public var sourceViewCount: Swift.Int?
        /// The time when the billing view was last updated.
        public var updatedAt: Foundation.Date?
        /// The timestamp of when the billing view definition was last updated.
        public var viewDefinitionLastUpdatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            billingViewType: BillingClientTypes.BillingViewType? = nil,
            createdAt: Foundation.Date? = nil,
            dataFilterExpression: BillingClientTypes.Expression? = nil,
            derivedViewCount: Swift.Int? = nil,
            description: Swift.String? = nil,
            healthStatus: BillingClientTypes.BillingViewHealthStatus? = nil,
            name: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            sourceAccountId: Swift.String? = nil,
            sourceViewCount: Swift.Int? = nil,
            updatedAt: Foundation.Date? = nil,
            viewDefinitionLastUpdatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.billingViewType = billingViewType
            self.createdAt = createdAt
            self.dataFilterExpression = dataFilterExpression
            self.derivedViewCount = derivedViewCount
            self.description = description
            self.healthStatus = healthStatus
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.sourceAccountId = sourceAccountId
            self.sourceViewCount = sourceViewCount
            self.updatedAt = updatedAt
            self.viewDefinitionLastUpdatedAt = viewDefinitionLastUpdatedAt
        }
    }
}

extension BillingClientTypes.BillingViewElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BillingViewElement(arn: \(Swift.String(describing: arn)), billingViewType: \(Swift.String(describing: billingViewType)), createdAt: \(Swift.String(describing: createdAt)), dataFilterExpression: \(Swift.String(describing: dataFilterExpression)), derivedViewCount: \(Swift.String(describing: derivedViewCount)), healthStatus: \(Swift.String(describing: healthStatus)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), sourceAccountId: \(Swift.String(describing: sourceAccountId)), sourceViewCount: \(Swift.String(describing: sourceViewCount)), updatedAt: \(Swift.String(describing: updatedAt)), viewDefinitionLastUpdatedAt: \(Swift.String(describing: viewDefinitionLastUpdatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct GetBillingViewOutput: Swift.Sendable {
    /// The billing view element associated with the specified ARN.
    /// This member is required.
    public var billingView: BillingClientTypes.BillingViewElement?

    public init(
        billingView: BillingClientTypes.BillingViewElement? = nil
    ) {
        self.billingView = billingView
    }
}

public struct GetResourcePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the billing view resource to which the policy is attached to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct GetResourcePolicyOutput: Swift.Sendable {
    /// The resource-based policy document attached to the resource in JSON format.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the billing view resource to which the policy is attached to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    ) {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

extension BillingClientTypes {

    public enum SearchOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchOption] {
            return [
                .startsWith
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BillingClientTypes {

    /// A structure that defines how to search for string values. You can specify a search option and the value to search for.
    public struct StringSearch: Swift.Sendable {
        /// The type of search operation to perform on the string value. Determines how the search value is matched against the target field.
        /// This member is required.
        public var searchOption: BillingClientTypes.SearchOption?
        /// The string value to use in the search operation. This value is compared against the target field using the specified search option.
        /// This member is required.
        public var searchValue: Swift.String?

        public init(
            searchOption: BillingClientTypes.SearchOption? = nil,
            searchValue: Swift.String? = nil
        ) {
            self.searchOption = searchOption
            self.searchValue = searchValue
        }
    }
}

public struct ListBillingViewsInput: Swift.Sendable {
    /// The time range for the billing views listed. PRIMARY billing view is always listed. BILLING_GROUP billing views are listed for time ranges when the associated billing group resource in Billing Conductor is active. The time range must be within one calendar month.
    public var activeTimeRange: BillingClientTypes.ActiveTimeRange?
    /// The Amazon Resource Name (ARN) that can be used to uniquely identify the billing view.
    public var arns: [Swift.String]?
    /// The type of billing view.
    public var billingViewTypes: [BillingClientTypes.BillingViewType]?
    /// The maximum number of billing views to retrieve. Default is 100.
    public var maxResults: Swift.Int?
    /// Filters the list of billing views by name. You can specify search criteria to match billing view names based on the search option provided.
    public var names: [BillingClientTypes.StringSearch]?
    /// The pagination token that is used on subsequent calls to list billing views.
    public var nextToken: Swift.String?
    /// The list of owners of the billing view.
    public var ownerAccountId: Swift.String?
    /// Filters the results to include only billing views that use the specified account as a source.
    public var sourceAccountId: Swift.String?

    public init(
        activeTimeRange: BillingClientTypes.ActiveTimeRange? = nil,
        arns: [Swift.String]? = nil,
        billingViewTypes: [BillingClientTypes.BillingViewType]? = nil,
        maxResults: Swift.Int? = nil,
        names: [BillingClientTypes.StringSearch]? = nil,
        nextToken: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        sourceAccountId: Swift.String? = nil
    ) {
        self.activeTimeRange = activeTimeRange
        self.arns = arns
        self.billingViewTypes = billingViewTypes
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
        self.ownerAccountId = ownerAccountId
        self.sourceAccountId = sourceAccountId
    }
}

extension BillingClientTypes {

    /// A representation of a billing view.
    public struct BillingViewListElement: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that can be used to uniquely identify the billing view.
        public var arn: Swift.String?
        /// The type of billing view.
        public var billingViewType: BillingClientTypes.BillingViewType?
        /// The description of the billing view.
        public var description: Swift.String?
        /// The current health status of the billing view.
        public var healthStatus: BillingClientTypes.BillingViewHealthStatus?
        /// A list of names of the Billing view.
        public var name: Swift.String?
        /// The list of owners of the Billing view.
        public var ownerAccountId: Swift.String?
        /// The Amazon Web Services account ID that owns the source billing view, if this is a derived billing view.
        public var sourceAccountId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            billingViewType: BillingClientTypes.BillingViewType? = nil,
            description: Swift.String? = nil,
            healthStatus: BillingClientTypes.BillingViewHealthStatus? = nil,
            name: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            sourceAccountId: Swift.String? = nil
        ) {
            self.arn = arn
            self.billingViewType = billingViewType
            self.description = description
            self.healthStatus = healthStatus
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.sourceAccountId = sourceAccountId
        }
    }
}

extension BillingClientTypes.BillingViewListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BillingViewListElement(arn: \(Swift.String(describing: arn)), billingViewType: \(Swift.String(describing: billingViewType)), healthStatus: \(Swift.String(describing: healthStatus)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), sourceAccountId: \(Swift.String(describing: sourceAccountId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListBillingViewsOutput: Swift.Sendable {
    /// A list of BillingViewListElement retrieved.
    /// This member is required.
    public var billingViews: [BillingClientTypes.BillingViewListElement]?
    /// The pagination token to use on subsequent calls to list billing views.
    public var nextToken: Swift.String?

    public init(
        billingViews: [BillingClientTypes.BillingViewListElement]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.billingViews = billingViews
        self.nextToken = nextToken
    }
}

public struct ListSourceViewsForBillingViewInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that can be used to uniquely identify the billing view.
    /// This member is required.
    public var arn: Swift.String?
    /// The number of entries a paginated response contains.
    public var maxResults: Swift.Int?
    /// The pagination token that is used on subsequent calls to list billing views.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListSourceViewsForBillingViewOutput: Swift.Sendable {
    /// The pagination token that is used on subsequent calls to list billing views.
    public var nextToken: Swift.String?
    /// A list of billing views used as the data source for the custom billing view.
    /// This member is required.
    public var sourceViews: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        sourceViews: [Swift.String]? = nil
    ) {
        self.nextToken = nextToken
        self.sourceViews = sourceViews
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of tag key value pairs that are associated with the resource.
    public var resourceTags: [BillingClientTypes.ResourceTag]?

    public init(
        resourceTags: [BillingClientTypes.ResourceTag]? = nil
    ) {
        self.resourceTags = resourceTags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag key value pairs that are associated with the resource.
    /// This member is required.
    public var resourceTags: [BillingClientTypes.ResourceTag]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTags: [BillingClientTypes.ResourceTag]? = nil
    ) {
        self.resourceArn = resourceArn
        self.resourceTags = resourceTags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag key value pairs that are associated with the resource.
    /// This member is required.
    public var resourceTagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.resourceTagKeys = resourceTagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateBillingViewInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that can be used to uniquely identify the billing view.
    /// This member is required.
    public var arn: Swift.String?
    /// See [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_billing_Expression.html). Billing view only supports LINKED_ACCOUNT and Tags.
    public var dataFilterExpression: BillingClientTypes.Expression?
    /// The description of the billing view.
    public var description: Swift.String?
    /// The name of the billing view.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        dataFilterExpression: BillingClientTypes.Expression? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.arn = arn
        self.dataFilterExpression = dataFilterExpression
        self.description = description
        self.name = name
    }
}

extension UpdateBillingViewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBillingViewInput(arn: \(Swift.String(describing: arn)), dataFilterExpression: \(Swift.String(describing: dataFilterExpression)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateBillingViewOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that can be used to uniquely identify the billing view.
    /// This member is required.
    public var arn: Swift.String?
    /// The time when the billing view was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.updatedAt = updatedAt
    }
}

extension AssociateSourceViewsInput {

    static func urlPathProvider(_ value: AssociateSourceViewsInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBillingViewInput {

    static func urlPathProvider(_ value: CreateBillingViewInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteBillingViewInput {

    static func urlPathProvider(_ value: DeleteBillingViewInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateSourceViewsInput {

    static func urlPathProvider(_ value: DisassociateSourceViewsInput) -> Swift.String? {
        return "/"
    }
}

extension GetBillingViewInput {

    static func urlPathProvider(_ value: GetBillingViewInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension ListBillingViewsInput {

    static func urlPathProvider(_ value: ListBillingViewsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSourceViewsForBillingViewInput {

    static func urlPathProvider(_ value: ListSourceViewsForBillingViewInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateBillingViewInput {

    static func urlPathProvider(_ value: UpdateBillingViewInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateSourceViewsInput {

    static func write(value: AssociateSourceViewsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["sourceViews"].writeList(value.sourceViews, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateBillingViewInput {

    static func write(value: CreateBillingViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["dataFilterExpression"].write(value.dataFilterExpression, with: BillingClientTypes.Expression.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["resourceTags"].writeList(value.resourceTags, memberWritingClosure: BillingClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sourceViews"].writeList(value.sourceViews, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteBillingViewInput {

    static func write(value: DeleteBillingViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["force"].write(value.force)
    }
}

extension DisassociateSourceViewsInput {

    static func write(value: DisassociateSourceViewsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["sourceViews"].writeList(value.sourceViews, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetBillingViewInput {

    static func write(value: GetBillingViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetResourcePolicyInput {

    static func write(value: GetResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension ListBillingViewsInput {

    static func write(value: ListBillingViewsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["activeTimeRange"].write(value.activeTimeRange, with: BillingClientTypes.ActiveTimeRange.write(value:to:))
        try writer["arns"].writeList(value.arns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["billingViewTypes"].writeList(value.billingViewTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BillingClientTypes.BillingViewType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["names"].writeList(value.names, memberWritingClosure: BillingClientTypes.StringSearch.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["nextToken"].write(value.nextToken)
        try writer["ownerAccountId"].write(value.ownerAccountId)
        try writer["sourceAccountId"].write(value.sourceAccountId)
    }
}

extension ListSourceViewsForBillingViewInput {

    static func write(value: ListSourceViewsForBillingViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["resourceTags"].writeList(value.resourceTags, memberWritingClosure: BillingClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["resourceTagKeys"].writeList(value.resourceTagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateBillingViewInput {

    static func write(value: UpdateBillingViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["dataFilterExpression"].write(value.dataFilterExpression, with: BillingClientTypes.Expression.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension AssociateSourceViewsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateSourceViewsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateSourceViewsOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateBillingViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBillingViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBillingViewOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DeleteBillingViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBillingViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBillingViewOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension DisassociateSourceViewsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateSourceViewsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateSourceViewsOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension GetBillingViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBillingViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBillingViewOutput()
        value.billingView = try reader["billingView"].readIfPresent(with: BillingClientTypes.BillingViewElement.read(from:))
        return value
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.policy = try reader["policy"].readIfPresent()
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        return value
    }
}

extension ListBillingViewsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBillingViewsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBillingViewsOutput()
        value.billingViews = try reader["billingViews"].readListIfPresent(memberReadingClosure: BillingClientTypes.BillingViewListElement.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSourceViewsForBillingViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSourceViewsForBillingViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSourceViewsForBillingViewOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sourceViews = try reader["sourceViews"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceTags = try reader["resourceTags"].readListIfPresent(memberReadingClosure: BillingClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateBillingViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBillingViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBillingViewOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

enum AssociateSourceViewsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "BillingViewHealthStatusException": return try BillingViewHealthStatusException.makeError(baseError: baseError)
            case "BillingConflict": return try ConflictException.makeError(baseError: baseError)
            case "BillingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "BillingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "BillingServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "BillingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "BillingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBillingViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "BillingViewHealthStatusException": return try BillingViewHealthStatusException.makeError(baseError: baseError)
            case "BillingConflict": return try ConflictException.makeError(baseError: baseError)
            case "BillingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "BillingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "BillingServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "BillingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "BillingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBillingViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "BillingConflict": return try ConflictException.makeError(baseError: baseError)
            case "BillingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "BillingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "BillingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateSourceViewsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "BillingViewHealthStatusException": return try BillingViewHealthStatusException.makeError(baseError: baseError)
            case "BillingConflict": return try ConflictException.makeError(baseError: baseError)
            case "BillingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "BillingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "BillingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "BillingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBillingViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "BillingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "BillingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "BillingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "BillingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "BillingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "BillingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "BillingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "BillingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBillingViewsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "BillingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "BillingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "BillingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSourceViewsForBillingViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "BillingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "BillingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "BillingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "BillingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "BillingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "BillingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "BillingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "BillingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "BillingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "BillingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "BillingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "BillingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "BillingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "BillingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "BillingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "BillingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBillingViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "BillingViewHealthStatusException": return try BillingViewHealthStatusException.makeError(baseError: baseError)
            case "BillingConflict": return try ConflictException.makeError(baseError: baseError)
            case "BillingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "BillingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "BillingServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "BillingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "BillingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BillingViewHealthStatusException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> BillingViewHealthStatusException {
        let reader = baseError.errorBodyReader
        var value = BillingViewHealthStatusException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: BillingClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BillingClientTypes.BillingViewElement {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingClientTypes.BillingViewElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingClientTypes.BillingViewElement()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.billingViewType = try reader["billingViewType"].readIfPresent()
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent()
        value.sourceAccountId = try reader["sourceAccountId"].readIfPresent()
        value.dataFilterExpression = try reader["dataFilterExpression"].readIfPresent(with: BillingClientTypes.Expression.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.derivedViewCount = try reader["derivedViewCount"].readIfPresent()
        value.sourceViewCount = try reader["sourceViewCount"].readIfPresent()
        value.viewDefinitionLastUpdatedAt = try reader["viewDefinitionLastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.healthStatus = try reader["healthStatus"].readIfPresent(with: BillingClientTypes.BillingViewHealthStatus.read(from:))
        return value
    }
}

extension BillingClientTypes.BillingViewHealthStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingClientTypes.BillingViewHealthStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingClientTypes.BillingViewHealthStatus()
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.statusReasons = try reader["statusReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BillingClientTypes.BillingViewStatusReason>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BillingClientTypes.Expression {

    static func write(value: BillingClientTypes.Expression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dimensions"].write(value.dimensions, with: BillingClientTypes.DimensionValues.write(value:to:))
        try writer["tags"].write(value.tags, with: BillingClientTypes.TagValues.write(value:to:))
        try writer["timeRange"].write(value.timeRange, with: BillingClientTypes.TimeRange.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BillingClientTypes.Expression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingClientTypes.Expression()
        value.dimensions = try reader["dimensions"].readIfPresent(with: BillingClientTypes.DimensionValues.read(from:))
        value.tags = try reader["tags"].readIfPresent(with: BillingClientTypes.TagValues.read(from:))
        value.timeRange = try reader["timeRange"].readIfPresent(with: BillingClientTypes.TimeRange.read(from:))
        return value
    }
}

extension BillingClientTypes.TimeRange {

    static func write(value: BillingClientTypes.TimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["beginDateInclusive"].writeTimestamp(value.beginDateInclusive, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["endDateInclusive"].writeTimestamp(value.endDateInclusive, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BillingClientTypes.TimeRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingClientTypes.TimeRange()
        value.beginDateInclusive = try reader["beginDateInclusive"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endDateInclusive = try reader["endDateInclusive"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BillingClientTypes.TagValues {

    static func write(value: BillingClientTypes.TagValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BillingClientTypes.TagValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingClientTypes.TagValues()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BillingClientTypes.DimensionValues {

    static func write(value: BillingClientTypes.DimensionValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BillingClientTypes.DimensionValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingClientTypes.DimensionValues()
        value.key = try reader["key"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BillingClientTypes.BillingViewListElement {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingClientTypes.BillingViewListElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingClientTypes.BillingViewListElement()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent()
        value.sourceAccountId = try reader["sourceAccountId"].readIfPresent()
        value.billingViewType = try reader["billingViewType"].readIfPresent()
        value.healthStatus = try reader["healthStatus"].readIfPresent(with: BillingClientTypes.BillingViewHealthStatus.read(from:))
        return value
    }
}

extension BillingClientTypes.ResourceTag {

    static func write(value: BillingClientTypes.ResourceTag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BillingClientTypes.ResourceTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingClientTypes.ResourceTag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension BillingClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension BillingClientTypes.ActiveTimeRange {

    static func write(value: BillingClientTypes.ActiveTimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["activeAfterInclusive"].writeTimestamp(value.activeAfterInclusive, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["activeBeforeInclusive"].writeTimestamp(value.activeBeforeInclusive, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension BillingClientTypes.StringSearch {

    static func write(value: BillingClientTypes.StringSearch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["searchOption"].write(value.searchOption)
        try writer["searchValue"].write(value.searchValue)
    }
}

public enum BillingClientTypes {}
