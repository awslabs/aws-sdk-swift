// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ChatbotClientTypes.AccountPreferences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trainingDataCollectionEnabled = "TrainingDataCollectionEnabled"
        case userAuthorizationRequired = "UserAuthorizationRequired"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trainingDataCollectionEnabled = self.trainingDataCollectionEnabled {
            try encodeContainer.encode(trainingDataCollectionEnabled, forKey: .trainingDataCollectionEnabled)
        }
        if let userAuthorizationRequired = self.userAuthorizationRequired {
            try encodeContainer.encode(userAuthorizationRequired, forKey: .userAuthorizationRequired)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAuthorizationRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userAuthorizationRequired)
        userAuthorizationRequired = userAuthorizationRequiredDecoded
        let trainingDataCollectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .trainingDataCollectionEnabled)
        trainingDataCollectionEnabled = trainingDataCollectionEnabledDecoded
    }
}

extension ChatbotClientTypes {
    /// Preferences which apply for AWS Chatbot usage in the calling AWS account.
    public struct AccountPreferences: Swift.Equatable {
        /// Turns on training data collection. This helps improve the AWS Chatbot experience by allowing AWS Chatbot to store and use your customer information, such as AWS Chatbot configurations, notifications, user inputs, AWS Chatbot generated responses, and interaction data. This data helps us to continuously improve and develop Artificial Intelligence (AI) technologies. Your data is not shared with any third parties and is protected using sophisticated controls to prevent unauthorized access and misuse. AWS Chatbot does not store or use interactions in chat channels with Amazon Q for training AWS Chatbot’s AI technologies.
        public var trainingDataCollectionEnabled: Swift.Bool?
        /// Enables use of a user role requirement in your chat configuration.
        public var userAuthorizationRequired: Swift.Bool?

        public init(
            trainingDataCollectionEnabled: Swift.Bool? = nil,
            userAuthorizationRequired: Swift.Bool? = nil
        )
        {
            self.trainingDataCollectionEnabled = trainingDataCollectionEnabled
            self.userAuthorizationRequired = userAuthorizationRequired
        }
    }

}

public enum ChatbotClientTypes {}

extension ChatbotClientTypes.ChimeWebhookConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case configurationName = "ConfigurationName"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case snsTopicArns = "SnsTopicArns"
        case webhookDescription = "WebhookDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
        if let configurationName = self.configurationName {
            try encodeContainer.encode(configurationName, forKey: .configurationName)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let loggingLevel = self.loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if let snsTopicArns = snsTopicArns {
            var snsTopicArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snsTopicArns)
            for arn0 in snsTopicArns {
                try snsTopicArnsContainer.encode(arn0)
            }
        }
        if let webhookDescription = self.webhookDescription {
            try encodeContainer.encode(webhookDescription, forKey: .webhookDescription)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webhookDescription)
        webhookDescription = webhookDescriptionDecoded
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let snsTopicArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .snsTopicArns)
        var snsTopicArnsDecoded0:[Swift.String]? = nil
        if let snsTopicArnsContainer = snsTopicArnsContainer {
            snsTopicArnsDecoded0 = [Swift.String]()
            for string0 in snsTopicArnsContainer {
                if let string0 = string0 {
                    snsTopicArnsDecoded0?.append(string0)
                }
            }
        }
        snsTopicArns = snsTopicArnsDecoded0
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
    }
}

extension ChatbotClientTypes {
    /// An AWS Chatbot configuration for Amazon Chime.
    public struct ChimeWebhookConfiguration: Swift.Equatable {
        /// The ARN of the ChimeWebhookConfiguration.
        /// This member is required.
        public var chatConfigurationArn: Swift.String?
        /// The name of the configuration.
        public var configurationName: Swift.String?
        /// The ARN of the IAM role that defines the permissions for AWS Chatbot. This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see IAM Policies for AWS Chatbot.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// Specifies the logging level for this configuration. This property affects the log entries pushed to Amazon CloudWatch Logs.Logging levels include ERROR, INFO, or NONE.
        public var loggingLevel: Swift.String?
        /// The ARNs of the SNS topics that deliver notifications to AWS Chatbot.
        /// This member is required.
        public var snsTopicArns: [Swift.String]?
        /// Description of the webhook. Recommend using the convention RoomName/WebhookName. See Chime setup tutorial for more details: https://docs.aws.amazon.com/chatbot/latest/adminguide/chime-setup.html.
        /// This member is required.
        public var webhookDescription: Swift.String?

        public init(
            chatConfigurationArn: Swift.String? = nil,
            configurationName: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            loggingLevel: Swift.String? = nil,
            snsTopicArns: [Swift.String]? = nil,
            webhookDescription: Swift.String? = nil
        )
        {
            self.chatConfigurationArn = chatConfigurationArn
            self.configurationName = configurationName
            self.iamRoleArn = iamRoleArn
            self.loggingLevel = loggingLevel
            self.snsTopicArns = snsTopicArns
            self.webhookDescription = webhookDescription
        }
    }

}

extension ChatbotClientTypes.ConfiguredTeam: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case teamId = "TeamId"
        case teamName = "TeamName"
        case tenantId = "TenantId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
        if let teamName = self.teamName {
            try encodeContainer.encode(teamName, forKey: .teamName)
        }
        if let tenantId = self.tenantId {
            try encodeContainer.encode(tenantId, forKey: .tenantId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tenantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenantId)
        tenantId = tenantIdDecoded
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let teamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamName)
        teamName = teamNameDecoded
    }
}

extension ChatbotClientTypes {
    /// A Microsoft Teams team that has been authorized with AWS Chatbot.
    public struct ConfiguredTeam: Swift.Equatable {
        /// The ID of the Microsoft Team authorized with AWS Chatbot. To get the team ID, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console. Then you can copy and paste the team ID from the console. For more details, see steps 1-4 in Get started with Microsoft Teams in the AWS Chatbot Administrator Guide.
        /// This member is required.
        public var teamId: Swift.String?
        /// The name of the Microsoft Teams Team.
        public var teamName: Swift.String?
        /// The ID of the Microsoft Teams tenant.
        /// This member is required.
        public var tenantId: Swift.String?

        public init(
            teamId: Swift.String? = nil,
            teamName: Swift.String? = nil,
            tenantId: Swift.String? = nil
        )
        {
            self.teamId = teamId
            self.teamName = teamName
            self.tenantId = tenantId
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an issue processing your request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateChimeWebhookConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateChimeWebhookConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct CreateChimeWebhookConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CreateChimeWebhookConfigurationException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CreateChimeWebhookConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CreateChimeWebhookConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateChimeWebhookConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationName = "ConfigurationName"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case snsTopicArns = "SnsTopicArns"
        case webhookDescription = "WebhookDescription"
        case webhookUrl = "WebhookUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationName = self.configurationName {
            try encodeContainer.encode(configurationName, forKey: .configurationName)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let loggingLevel = self.loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if let snsTopicArns = snsTopicArns {
            var snsTopicArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snsTopicArns)
            for arn0 in snsTopicArns {
                try snsTopicArnsContainer.encode(arn0)
            }
        }
        if let webhookDescription = self.webhookDescription {
            try encodeContainer.encode(webhookDescription, forKey: .webhookDescription)
        }
        if let webhookUrl = self.webhookUrl {
            try encodeContainer.encode(webhookUrl, forKey: .webhookUrl)
        }
    }
}

extension CreateChimeWebhookConfigurationInput {

    static func urlPathProvider(_ value: CreateChimeWebhookConfigurationInput) -> Swift.String? {
        return "/create-chime-webhook-configuration"
    }
}

public struct CreateChimeWebhookConfigurationInput: Swift.Equatable {
    /// The name of the configuration.
    /// This member is required.
    public var configurationName: Swift.String?
    /// This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see IAM Policies for AWS Chatbot.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// Logging levels include ERROR, INFO, or NONE.
    public var loggingLevel: Swift.String?
    /// The ARNs of the SNS topics that deliver notifications to AWS Chatbot.
    /// This member is required.
    public var snsTopicArns: [Swift.String]?
    /// Description of the webhook. Recommend using the convention RoomName/WebhookName. See Chime setup tutorial for more details: https://docs.aws.amazon.com/chatbot/latest/adminguide/chime-setup.html.
    /// This member is required.
    public var webhookDescription: Swift.String?
    /// URL for the Chime webhook.
    /// This member is required.
    public var webhookUrl: Swift.String?

    public init(
        configurationName: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        loggingLevel: Swift.String? = nil,
        snsTopicArns: [Swift.String]? = nil,
        webhookDescription: Swift.String? = nil,
        webhookUrl: Swift.String? = nil
    )
    {
        self.configurationName = configurationName
        self.iamRoleArn = iamRoleArn
        self.loggingLevel = loggingLevel
        self.snsTopicArns = snsTopicArns
        self.webhookDescription = webhookDescription
        self.webhookUrl = webhookUrl
    }
}

struct CreateChimeWebhookConfigurationInputBody: Swift.Equatable {
    let webhookDescription: Swift.String?
    let webhookUrl: Swift.String?
    let snsTopicArns: [Swift.String]?
    let iamRoleArn: Swift.String?
    let configurationName: Swift.String?
    let loggingLevel: Swift.String?
}

extension CreateChimeWebhookConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationName = "ConfigurationName"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case snsTopicArns = "SnsTopicArns"
        case webhookDescription = "WebhookDescription"
        case webhookUrl = "WebhookUrl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webhookDescription)
        webhookDescription = webhookDescriptionDecoded
        let webhookUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webhookUrl)
        webhookUrl = webhookUrlDecoded
        let snsTopicArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .snsTopicArns)
        var snsTopicArnsDecoded0:[Swift.String]? = nil
        if let snsTopicArnsContainer = snsTopicArnsContainer {
            snsTopicArnsDecoded0 = [Swift.String]()
            for string0 in snsTopicArnsContainer {
                if let string0 = string0 {
                    snsTopicArnsDecoded0?.append(string0)
                }
            }
        }
        snsTopicArns = snsTopicArnsDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
    }
}

extension CreateChimeWebhookConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateChimeWebhookConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.webhookConfiguration = output.webhookConfiguration
        } else {
            self.webhookConfiguration = nil
        }
    }
}

public struct CreateChimeWebhookConfigurationOutput: Swift.Equatable {
    /// Chime webhook configuration.
    public var webhookConfiguration: ChatbotClientTypes.ChimeWebhookConfiguration?

    public init(
        webhookConfiguration: ChatbotClientTypes.ChimeWebhookConfiguration? = nil
    )
    {
        self.webhookConfiguration = webhookConfiguration
    }
}

struct CreateChimeWebhookConfigurationOutputBody: Swift.Equatable {
    let webhookConfiguration: ChatbotClientTypes.ChimeWebhookConfiguration?
}

extension CreateChimeWebhookConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webhookConfiguration = "WebhookConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookConfigurationDecoded = try containerValues.decodeIfPresent(ChatbotClientTypes.ChimeWebhookConfiguration.self, forKey: .webhookConfiguration)
        webhookConfiguration = webhookConfigurationDecoded
    }
}

enum CreateChimeWebhookConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CreateChimeWebhookConfigurationException": return try await CreateChimeWebhookConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMicrosoftTeamsChannelConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId = "ChannelId"
        case channelName = "ChannelName"
        case configurationName = "ConfigurationName"
        case guardrailPolicyArns = "GuardrailPolicyArns"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case snsTopicArns = "SnsTopicArns"
        case teamId = "TeamId"
        case teamName = "TeamName"
        case tenantId = "TenantId"
        case userAuthorizationRequired = "UserAuthorizationRequired"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let configurationName = self.configurationName {
            try encodeContainer.encode(configurationName, forKey: .configurationName)
        }
        if let guardrailPolicyArns = guardrailPolicyArns {
            var guardrailPolicyArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .guardrailPolicyArns)
            for guardrailpolicyarn0 in guardrailPolicyArns {
                try guardrailPolicyArnsContainer.encode(guardrailpolicyarn0)
            }
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let loggingLevel = self.loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if let snsTopicArns = snsTopicArns {
            var snsTopicArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snsTopicArns)
            for arn0 in snsTopicArns {
                try snsTopicArnsContainer.encode(arn0)
            }
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
        if let teamName = self.teamName {
            try encodeContainer.encode(teamName, forKey: .teamName)
        }
        if let tenantId = self.tenantId {
            try encodeContainer.encode(tenantId, forKey: .tenantId)
        }
        if let userAuthorizationRequired = self.userAuthorizationRequired {
            try encodeContainer.encode(userAuthorizationRequired, forKey: .userAuthorizationRequired)
        }
    }
}

extension CreateMicrosoftTeamsChannelConfigurationInput {

    static func urlPathProvider(_ value: CreateMicrosoftTeamsChannelConfigurationInput) -> Swift.String? {
        return "/create-ms-teams-channel-configuration"
    }
}

public struct CreateMicrosoftTeamsChannelConfigurationInput: Swift.Equatable {
    /// The ID of the Microsoft Teams channel.
    /// This member is required.
    public var channelId: Swift.String?
    /// The name of the Microsoft Teams channel.
    public var channelName: Swift.String?
    /// The name of the configuration.
    /// This member is required.
    public var configurationName: Swift.String?
    /// The list of IAM policy ARNs that are applied as channel guardrails. The AWS managed 'AdministratorAccess' policy is applied by default if this is not set.
    public var guardrailPolicyArns: [Swift.String]?
    /// The ARN of the IAM role that defines the permissions for AWS Chatbot. This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see IAM Policies for AWS Chatbot.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// Logging levels include ERROR, INFO, or NONE.
    public var loggingLevel: Swift.String?
    /// The ARNs of the SNS topics that deliver notifications to AWS Chatbot.
    public var snsTopicArns: [Swift.String]?
    /// The ID of the Microsoft Team authorized with AWS Chatbot. To get the team ID, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console. Then you can copy and paste the team ID from the console. For more details, see steps 1-4 in Get started with Microsoft Teams in the AWS Chatbot Administrator Guide.
    /// This member is required.
    public var teamId: Swift.String?
    /// The name of the Microsoft Teams Team.
    public var teamName: Swift.String?
    /// The ID of the Microsoft Teams tenant.
    /// This member is required.
    public var tenantId: Swift.String?
    /// Enables use of a user role requirement in your chat configuration.
    public var userAuthorizationRequired: Swift.Bool?

    public init(
        channelId: Swift.String? = nil,
        channelName: Swift.String? = nil,
        configurationName: Swift.String? = nil,
        guardrailPolicyArns: [Swift.String]? = nil,
        iamRoleArn: Swift.String? = nil,
        loggingLevel: Swift.String? = nil,
        snsTopicArns: [Swift.String]? = nil,
        teamId: Swift.String? = nil,
        teamName: Swift.String? = nil,
        tenantId: Swift.String? = nil,
        userAuthorizationRequired: Swift.Bool? = nil
    )
    {
        self.channelId = channelId
        self.channelName = channelName
        self.configurationName = configurationName
        self.guardrailPolicyArns = guardrailPolicyArns
        self.iamRoleArn = iamRoleArn
        self.loggingLevel = loggingLevel
        self.snsTopicArns = snsTopicArns
        self.teamId = teamId
        self.teamName = teamName
        self.tenantId = tenantId
        self.userAuthorizationRequired = userAuthorizationRequired
    }
}

struct CreateMicrosoftTeamsChannelConfigurationInputBody: Swift.Equatable {
    let channelId: Swift.String?
    let channelName: Swift.String?
    let teamId: Swift.String?
    let teamName: Swift.String?
    let tenantId: Swift.String?
    let snsTopicArns: [Swift.String]?
    let iamRoleArn: Swift.String?
    let configurationName: Swift.String?
    let loggingLevel: Swift.String?
    let guardrailPolicyArns: [Swift.String]?
    let userAuthorizationRequired: Swift.Bool?
}

extension CreateMicrosoftTeamsChannelConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId = "ChannelId"
        case channelName = "ChannelName"
        case configurationName = "ConfigurationName"
        case guardrailPolicyArns = "GuardrailPolicyArns"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case snsTopicArns = "SnsTopicArns"
        case teamId = "TeamId"
        case teamName = "TeamName"
        case tenantId = "TenantId"
        case userAuthorizationRequired = "UserAuthorizationRequired"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let teamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamName)
        teamName = teamNameDecoded
        let tenantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenantId)
        tenantId = tenantIdDecoded
        let snsTopicArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .snsTopicArns)
        var snsTopicArnsDecoded0:[Swift.String]? = nil
        if let snsTopicArnsContainer = snsTopicArnsContainer {
            snsTopicArnsDecoded0 = [Swift.String]()
            for string0 in snsTopicArnsContainer {
                if let string0 = string0 {
                    snsTopicArnsDecoded0?.append(string0)
                }
            }
        }
        snsTopicArns = snsTopicArnsDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let guardrailPolicyArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .guardrailPolicyArns)
        var guardrailPolicyArnsDecoded0:[Swift.String]? = nil
        if let guardrailPolicyArnsContainer = guardrailPolicyArnsContainer {
            guardrailPolicyArnsDecoded0 = [Swift.String]()
            for string0 in guardrailPolicyArnsContainer {
                if let string0 = string0 {
                    guardrailPolicyArnsDecoded0?.append(string0)
                }
            }
        }
        guardrailPolicyArns = guardrailPolicyArnsDecoded0
        let userAuthorizationRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userAuthorizationRequired)
        userAuthorizationRequired = userAuthorizationRequiredDecoded
    }
}

extension CreateMicrosoftTeamsChannelConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMicrosoftTeamsChannelConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelConfiguration = output.channelConfiguration
        } else {
            self.channelConfiguration = nil
        }
    }
}

public struct CreateMicrosoftTeamsChannelConfigurationOutput: Swift.Equatable {
    /// The configuration for a Microsoft Teams channel configured with AWS Chatbot.
    public var channelConfiguration: ChatbotClientTypes.TeamsChannelConfiguration?

    public init(
        channelConfiguration: ChatbotClientTypes.TeamsChannelConfiguration? = nil
    )
    {
        self.channelConfiguration = channelConfiguration
    }
}

struct CreateMicrosoftTeamsChannelConfigurationOutputBody: Swift.Equatable {
    let channelConfiguration: ChatbotClientTypes.TeamsChannelConfiguration?
}

extension CreateMicrosoftTeamsChannelConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelConfiguration = "ChannelConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelConfigurationDecoded = try containerValues.decodeIfPresent(ChatbotClientTypes.TeamsChannelConfiguration.self, forKey: .channelConfiguration)
        channelConfiguration = channelConfigurationDecoded
    }
}

enum CreateMicrosoftTeamsChannelConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CreateTeamsChannelConfigurationException": return try await CreateTeamsChannelConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSlackChannelConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSlackChannelConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct CreateSlackChannelConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CreateSlackChannelConfigurationException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CreateSlackChannelConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CreateSlackChannelConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateSlackChannelConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationName = "ConfigurationName"
        case guardrailPolicyArns = "GuardrailPolicyArns"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case slackChannelId = "SlackChannelId"
        case slackChannelName = "SlackChannelName"
        case slackTeamId = "SlackTeamId"
        case snsTopicArns = "SnsTopicArns"
        case userAuthorizationRequired = "UserAuthorizationRequired"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationName = self.configurationName {
            try encodeContainer.encode(configurationName, forKey: .configurationName)
        }
        if let guardrailPolicyArns = guardrailPolicyArns {
            var guardrailPolicyArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .guardrailPolicyArns)
            for guardrailpolicyarn0 in guardrailPolicyArns {
                try guardrailPolicyArnsContainer.encode(guardrailpolicyarn0)
            }
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let loggingLevel = self.loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if let slackChannelId = self.slackChannelId {
            try encodeContainer.encode(slackChannelId, forKey: .slackChannelId)
        }
        if let slackChannelName = self.slackChannelName {
            try encodeContainer.encode(slackChannelName, forKey: .slackChannelName)
        }
        if let slackTeamId = self.slackTeamId {
            try encodeContainer.encode(slackTeamId, forKey: .slackTeamId)
        }
        if let snsTopicArns = snsTopicArns {
            var snsTopicArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snsTopicArns)
            for arn0 in snsTopicArns {
                try snsTopicArnsContainer.encode(arn0)
            }
        }
        if let userAuthorizationRequired = self.userAuthorizationRequired {
            try encodeContainer.encode(userAuthorizationRequired, forKey: .userAuthorizationRequired)
        }
    }
}

extension CreateSlackChannelConfigurationInput {

    static func urlPathProvider(_ value: CreateSlackChannelConfigurationInput) -> Swift.String? {
        return "/create-slack-channel-configuration"
    }
}

public struct CreateSlackChannelConfigurationInput: Swift.Equatable {
    /// The name of the configuration.
    /// This member is required.
    public var configurationName: Swift.String?
    /// The list of IAM policy ARNs that are applied as channel guardrails. The AWS managed 'AdministratorAccess' policy is applied by default if this is not set.
    public var guardrailPolicyArns: [Swift.String]?
    /// The ARN of the IAM role that defines the permissions for AWS Chatbot. This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see IAM Policies for AWS Chatbot.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// Logging levels include ERROR, INFO, or NONE.
    public var loggingLevel: Swift.String?
    /// The ID of the Slack channel. To get the ID, open Slack, right click on the channel name in the left pane, then choose Copy Link. The channel ID is the 9-character string at the end of the URL. For example, ABCBBLZZZ.
    /// This member is required.
    public var slackChannelId: Swift.String?
    /// The name of the Slack Channel.
    public var slackChannelName: Swift.String?
    /// The ID of the Slack workspace authorized with AWS Chatbot.
    /// This member is required.
    public var slackTeamId: Swift.String?
    /// The ARNs of the SNS topics that deliver notifications to AWS Chatbot.
    public var snsTopicArns: [Swift.String]?
    /// Enables use of a user role requirement in your chat configuration.
    public var userAuthorizationRequired: Swift.Bool?

    public init(
        configurationName: Swift.String? = nil,
        guardrailPolicyArns: [Swift.String]? = nil,
        iamRoleArn: Swift.String? = nil,
        loggingLevel: Swift.String? = nil,
        slackChannelId: Swift.String? = nil,
        slackChannelName: Swift.String? = nil,
        slackTeamId: Swift.String? = nil,
        snsTopicArns: [Swift.String]? = nil,
        userAuthorizationRequired: Swift.Bool? = nil
    )
    {
        self.configurationName = configurationName
        self.guardrailPolicyArns = guardrailPolicyArns
        self.iamRoleArn = iamRoleArn
        self.loggingLevel = loggingLevel
        self.slackChannelId = slackChannelId
        self.slackChannelName = slackChannelName
        self.slackTeamId = slackTeamId
        self.snsTopicArns = snsTopicArns
        self.userAuthorizationRequired = userAuthorizationRequired
    }
}

struct CreateSlackChannelConfigurationInputBody: Swift.Equatable {
    let slackTeamId: Swift.String?
    let slackChannelId: Swift.String?
    let slackChannelName: Swift.String?
    let snsTopicArns: [Swift.String]?
    let iamRoleArn: Swift.String?
    let configurationName: Swift.String?
    let loggingLevel: Swift.String?
    let guardrailPolicyArns: [Swift.String]?
    let userAuthorizationRequired: Swift.Bool?
}

extension CreateSlackChannelConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationName = "ConfigurationName"
        case guardrailPolicyArns = "GuardrailPolicyArns"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case slackChannelId = "SlackChannelId"
        case slackChannelName = "SlackChannelName"
        case slackTeamId = "SlackTeamId"
        case snsTopicArns = "SnsTopicArns"
        case userAuthorizationRequired = "UserAuthorizationRequired"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slackTeamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackTeamId)
        slackTeamId = slackTeamIdDecoded
        let slackChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackChannelId)
        slackChannelId = slackChannelIdDecoded
        let slackChannelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackChannelName)
        slackChannelName = slackChannelNameDecoded
        let snsTopicArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .snsTopicArns)
        var snsTopicArnsDecoded0:[Swift.String]? = nil
        if let snsTopicArnsContainer = snsTopicArnsContainer {
            snsTopicArnsDecoded0 = [Swift.String]()
            for string0 in snsTopicArnsContainer {
                if let string0 = string0 {
                    snsTopicArnsDecoded0?.append(string0)
                }
            }
        }
        snsTopicArns = snsTopicArnsDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let guardrailPolicyArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .guardrailPolicyArns)
        var guardrailPolicyArnsDecoded0:[Swift.String]? = nil
        if let guardrailPolicyArnsContainer = guardrailPolicyArnsContainer {
            guardrailPolicyArnsDecoded0 = [Swift.String]()
            for string0 in guardrailPolicyArnsContainer {
                if let string0 = string0 {
                    guardrailPolicyArnsDecoded0?.append(string0)
                }
            }
        }
        guardrailPolicyArns = guardrailPolicyArnsDecoded0
        let userAuthorizationRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userAuthorizationRequired)
        userAuthorizationRequired = userAuthorizationRequiredDecoded
    }
}

extension CreateSlackChannelConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSlackChannelConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelConfiguration = output.channelConfiguration
        } else {
            self.channelConfiguration = nil
        }
    }
}

public struct CreateSlackChannelConfigurationOutput: Swift.Equatable {
    /// The configuration for a Slack channel configured with AWS Chatbot.
    public var channelConfiguration: ChatbotClientTypes.SlackChannelConfiguration?

    public init(
        channelConfiguration: ChatbotClientTypes.SlackChannelConfiguration? = nil
    )
    {
        self.channelConfiguration = channelConfiguration
    }
}

struct CreateSlackChannelConfigurationOutputBody: Swift.Equatable {
    let channelConfiguration: ChatbotClientTypes.SlackChannelConfiguration?
}

extension CreateSlackChannelConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelConfiguration = "ChannelConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelConfigurationDecoded = try containerValues.decodeIfPresent(ChatbotClientTypes.SlackChannelConfiguration.self, forKey: .channelConfiguration)
        channelConfiguration = channelConfigurationDecoded
    }
}

enum CreateSlackChannelConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CreateSlackChannelConfigurationException": return try await CreateSlackChannelConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTeamsChannelConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTeamsChannelConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct CreateTeamsChannelConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CreateTeamsChannelConfigurationException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CreateTeamsChannelConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CreateTeamsChannelConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteChimeWebhookConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteChimeWebhookConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct DeleteChimeWebhookConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeleteChimeWebhookConfigurationException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DeleteChimeWebhookConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteChimeWebhookConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteChimeWebhookConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
    }
}

extension DeleteChimeWebhookConfigurationInput {

    static func urlPathProvider(_ value: DeleteChimeWebhookConfigurationInput) -> Swift.String? {
        return "/delete-chime-webhook-configuration"
    }
}

public struct DeleteChimeWebhookConfigurationInput: Swift.Equatable {
    /// The ARN of the ChimeWebhookConfiguration to delete.
    /// This member is required.
    public var chatConfigurationArn: Swift.String?

    public init(
        chatConfigurationArn: Swift.String? = nil
    )
    {
        self.chatConfigurationArn = chatConfigurationArn
    }
}

struct DeleteChimeWebhookConfigurationInputBody: Swift.Equatable {
    let chatConfigurationArn: Swift.String?
}

extension DeleteChimeWebhookConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
    }
}

extension DeleteChimeWebhookConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteChimeWebhookConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteChimeWebhookConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeleteChimeWebhookConfigurationException": return try await DeleteChimeWebhookConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMicrosoftTeamsChannelConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
    }
}

extension DeleteMicrosoftTeamsChannelConfigurationInput {

    static func urlPathProvider(_ value: DeleteMicrosoftTeamsChannelConfigurationInput) -> Swift.String? {
        return "/delete-ms-teams-channel-configuration"
    }
}

public struct DeleteMicrosoftTeamsChannelConfigurationInput: Swift.Equatable {
    /// The ARN of the MicrosoftTeamsChannelConfiguration to delete.
    /// This member is required.
    public var chatConfigurationArn: Swift.String?

    public init(
        chatConfigurationArn: Swift.String? = nil
    )
    {
        self.chatConfigurationArn = chatConfigurationArn
    }
}

struct DeleteMicrosoftTeamsChannelConfigurationInputBody: Swift.Equatable {
    let chatConfigurationArn: Swift.String?
}

extension DeleteMicrosoftTeamsChannelConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
    }
}

extension DeleteMicrosoftTeamsChannelConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMicrosoftTeamsChannelConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMicrosoftTeamsChannelConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeleteTeamsChannelConfigurationException": return try await DeleteTeamsChannelConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMicrosoftTeamsConfiguredTeamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case teamId = "TeamId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }
}

extension DeleteMicrosoftTeamsConfiguredTeamInput {

    static func urlPathProvider(_ value: DeleteMicrosoftTeamsConfiguredTeamInput) -> Swift.String? {
        return "/delete-ms-teams-configured-teams"
    }
}

public struct DeleteMicrosoftTeamsConfiguredTeamInput: Swift.Equatable {
    /// The ID of the Microsoft Team authorized with AWS Chatbot. To get the team ID, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console. Then you can copy and paste the team ID from the console. For more details, see steps 1-4 in Get started with Microsoft Teams in the AWS Chatbot Administrator Guide.
    /// This member is required.
    public var teamId: Swift.String?

    public init(
        teamId: Swift.String? = nil
    )
    {
        self.teamId = teamId
    }
}

struct DeleteMicrosoftTeamsConfiguredTeamInputBody: Swift.Equatable {
    let teamId: Swift.String?
}

extension DeleteMicrosoftTeamsConfiguredTeamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case teamId = "TeamId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
    }
}

extension DeleteMicrosoftTeamsConfiguredTeamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMicrosoftTeamsConfiguredTeamOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMicrosoftTeamsConfiguredTeamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeleteTeamsConfiguredTeamException": return try await DeleteTeamsConfiguredTeamException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMicrosoftTeamsUserIdentityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteMicrosoftTeamsUserIdentityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct DeleteMicrosoftTeamsUserIdentityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeleteMicrosoftTeamsUserIdentityException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DeleteMicrosoftTeamsUserIdentityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteMicrosoftTeamsUserIdentityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteMicrosoftTeamsUserIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DeleteMicrosoftTeamsUserIdentityInput {

    static func urlPathProvider(_ value: DeleteMicrosoftTeamsUserIdentityInput) -> Swift.String? {
        return "/delete-ms-teams-user-identity"
    }
}

public struct DeleteMicrosoftTeamsUserIdentityInput: Swift.Equatable {
    /// The ARN of the MicrosoftTeamsChannelConfiguration associated with the user identity to delete.
    /// This member is required.
    public var chatConfigurationArn: Swift.String?
    /// Id from Microsoft Teams for user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        chatConfigurationArn: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.chatConfigurationArn = chatConfigurationArn
        self.userId = userId
    }
}

struct DeleteMicrosoftTeamsUserIdentityInputBody: Swift.Equatable {
    let chatConfigurationArn: Swift.String?
    let userId: Swift.String?
}

extension DeleteMicrosoftTeamsUserIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DeleteMicrosoftTeamsUserIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMicrosoftTeamsUserIdentityOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMicrosoftTeamsUserIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeleteMicrosoftTeamsUserIdentityException": return try await DeleteMicrosoftTeamsUserIdentityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSlackChannelConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSlackChannelConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct DeleteSlackChannelConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeleteSlackChannelConfigurationException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DeleteSlackChannelConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteSlackChannelConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteSlackChannelConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
    }
}

extension DeleteSlackChannelConfigurationInput {

    static func urlPathProvider(_ value: DeleteSlackChannelConfigurationInput) -> Swift.String? {
        return "/delete-slack-channel-configuration"
    }
}

public struct DeleteSlackChannelConfigurationInput: Swift.Equatable {
    /// The ARN of the SlackChannelConfiguration to delete.
    /// This member is required.
    public var chatConfigurationArn: Swift.String?

    public init(
        chatConfigurationArn: Swift.String? = nil
    )
    {
        self.chatConfigurationArn = chatConfigurationArn
    }
}

struct DeleteSlackChannelConfigurationInputBody: Swift.Equatable {
    let chatConfigurationArn: Swift.String?
}

extension DeleteSlackChannelConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
    }
}

extension DeleteSlackChannelConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSlackChannelConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSlackChannelConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeleteSlackChannelConfigurationException": return try await DeleteSlackChannelConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSlackUserIdentityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSlackUserIdentityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct DeleteSlackUserIdentityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeleteSlackUserIdentityException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DeleteSlackUserIdentityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteSlackUserIdentityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteSlackUserIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case slackTeamId = "SlackTeamId"
        case slackUserId = "SlackUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
        if let slackTeamId = self.slackTeamId {
            try encodeContainer.encode(slackTeamId, forKey: .slackTeamId)
        }
        if let slackUserId = self.slackUserId {
            try encodeContainer.encode(slackUserId, forKey: .slackUserId)
        }
    }
}

extension DeleteSlackUserIdentityInput {

    static func urlPathProvider(_ value: DeleteSlackUserIdentityInput) -> Swift.String? {
        return "/delete-slack-user-identity"
    }
}

public struct DeleteSlackUserIdentityInput: Swift.Equatable {
    /// The ARN of the SlackChannelConfiguration associated with the user identity to delete.
    /// This member is required.
    public var chatConfigurationArn: Swift.String?
    /// The ID of the Slack workspace authorized with AWS Chatbot.
    /// This member is required.
    public var slackTeamId: Swift.String?
    /// The ID of the user in Slack.
    /// This member is required.
    public var slackUserId: Swift.String?

    public init(
        chatConfigurationArn: Swift.String? = nil,
        slackTeamId: Swift.String? = nil,
        slackUserId: Swift.String? = nil
    )
    {
        self.chatConfigurationArn = chatConfigurationArn
        self.slackTeamId = slackTeamId
        self.slackUserId = slackUserId
    }
}

struct DeleteSlackUserIdentityInputBody: Swift.Equatable {
    let chatConfigurationArn: Swift.String?
    let slackTeamId: Swift.String?
    let slackUserId: Swift.String?
}

extension DeleteSlackUserIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case slackTeamId = "SlackTeamId"
        case slackUserId = "SlackUserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
        let slackTeamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackTeamId)
        slackTeamId = slackTeamIdDecoded
        let slackUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackUserId)
        slackUserId = slackUserIdDecoded
    }
}

extension DeleteSlackUserIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSlackUserIdentityOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSlackUserIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeleteSlackUserIdentityException": return try await DeleteSlackUserIdentityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSlackWorkspaceAuthorizationFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSlackWorkspaceAuthorizationFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an issue deleting your Slack workspace.
public struct DeleteSlackWorkspaceAuthorizationFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeleteSlackWorkspaceAuthorizationFault" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DeleteSlackWorkspaceAuthorizationFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteSlackWorkspaceAuthorizationFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteSlackWorkspaceAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case slackTeamId = "SlackTeamId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let slackTeamId = self.slackTeamId {
            try encodeContainer.encode(slackTeamId, forKey: .slackTeamId)
        }
    }
}

extension DeleteSlackWorkspaceAuthorizationInput {

    static func urlPathProvider(_ value: DeleteSlackWorkspaceAuthorizationInput) -> Swift.String? {
        return "/delete-slack-workspace-authorization"
    }
}

public struct DeleteSlackWorkspaceAuthorizationInput: Swift.Equatable {
    /// The ID of the Slack workspace authorized with AWS Chatbot.
    /// This member is required.
    public var slackTeamId: Swift.String?

    public init(
        slackTeamId: Swift.String? = nil
    )
    {
        self.slackTeamId = slackTeamId
    }
}

struct DeleteSlackWorkspaceAuthorizationInputBody: Swift.Equatable {
    let slackTeamId: Swift.String?
}

extension DeleteSlackWorkspaceAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case slackTeamId = "SlackTeamId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slackTeamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackTeamId)
        slackTeamId = slackTeamIdDecoded
    }
}

extension DeleteSlackWorkspaceAuthorizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSlackWorkspaceAuthorizationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSlackWorkspaceAuthorizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeleteSlackWorkspaceAuthorizationFault": return try await DeleteSlackWorkspaceAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTeamsChannelConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteTeamsChannelConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct DeleteTeamsChannelConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeleteTeamsChannelConfigurationException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DeleteTeamsChannelConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteTeamsChannelConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteTeamsConfiguredTeamException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteTeamsConfiguredTeamExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct DeleteTeamsConfiguredTeamException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeleteTeamsConfiguredTeamException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DeleteTeamsConfiguredTeamExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteTeamsConfiguredTeamExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeChimeWebhookConfigurationsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeChimeWebhookConfigurationsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct DescribeChimeWebhookConfigurationsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DescribeChimeWebhookConfigurationsException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DescribeChimeWebhookConfigurationsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DescribeChimeWebhookConfigurationsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeChimeWebhookConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeChimeWebhookConfigurationsInput {

    static func urlPathProvider(_ value: DescribeChimeWebhookConfigurationsInput) -> Swift.String? {
        return "/describe-chime-webhook-configurations"
    }
}

public struct DescribeChimeWebhookConfigurationsInput: Swift.Equatable {
    /// An optional ARN of a ChimeWebhookConfiguration to describe.
    public var chatConfigurationArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init(
        chatConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.chatConfigurationArn = chatConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeChimeWebhookConfigurationsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let chatConfigurationArn: Swift.String?
}

extension DescribeChimeWebhookConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
    }
}

extension DescribeChimeWebhookConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeChimeWebhookConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.webhookConfigurations = output.webhookConfigurations
        } else {
            self.nextToken = nil
            self.webhookConfigurations = nil
        }
    }
}

public struct DescribeChimeWebhookConfigurationsOutput: Swift.Equatable {
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// A list of Chime webhooks associated with the account.
    public var webhookConfigurations: [ChatbotClientTypes.ChimeWebhookConfiguration]?

    public init(
        nextToken: Swift.String? = nil,
        webhookConfigurations: [ChatbotClientTypes.ChimeWebhookConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.webhookConfigurations = webhookConfigurations
    }
}

struct DescribeChimeWebhookConfigurationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let webhookConfigurations: [ChatbotClientTypes.ChimeWebhookConfiguration]?
}

extension DescribeChimeWebhookConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case webhookConfigurations = "WebhookConfigurations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let webhookConfigurationsContainer = try containerValues.decodeIfPresent([ChatbotClientTypes.ChimeWebhookConfiguration?].self, forKey: .webhookConfigurations)
        var webhookConfigurationsDecoded0:[ChatbotClientTypes.ChimeWebhookConfiguration]? = nil
        if let webhookConfigurationsContainer = webhookConfigurationsContainer {
            webhookConfigurationsDecoded0 = [ChatbotClientTypes.ChimeWebhookConfiguration]()
            for structure0 in webhookConfigurationsContainer {
                if let structure0 = structure0 {
                    webhookConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        webhookConfigurations = webhookConfigurationsDecoded0
    }
}

enum DescribeChimeWebhookConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DescribeChimeWebhookConfigurationsException": return try await DescribeChimeWebhookConfigurationsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSlackChannelConfigurationsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSlackChannelConfigurationsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct DescribeSlackChannelConfigurationsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DescribeSlackChannelConfigurationsException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DescribeSlackChannelConfigurationsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DescribeSlackChannelConfigurationsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeSlackChannelConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeSlackChannelConfigurationsInput {

    static func urlPathProvider(_ value: DescribeSlackChannelConfigurationsInput) -> Swift.String? {
        return "/describe-slack-channel-configurations"
    }
}

public struct DescribeSlackChannelConfigurationsInput: Swift.Equatable {
    /// An optional ARN of a SlackChannelConfiguration to describe.
    public var chatConfigurationArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init(
        chatConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.chatConfigurationArn = chatConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeSlackChannelConfigurationsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let chatConfigurationArn: Swift.String?
}

extension DescribeSlackChannelConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
    }
}

extension DescribeSlackChannelConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSlackChannelConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.slackChannelConfigurations = output.slackChannelConfigurations
        } else {
            self.nextToken = nil
            self.slackChannelConfigurations = nil
        }
    }
}

public struct DescribeSlackChannelConfigurationsOutput: Swift.Equatable {
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// A list of Slack channel configurations.
    public var slackChannelConfigurations: [ChatbotClientTypes.SlackChannelConfiguration]?

    public init(
        nextToken: Swift.String? = nil,
        slackChannelConfigurations: [ChatbotClientTypes.SlackChannelConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.slackChannelConfigurations = slackChannelConfigurations
    }
}

struct DescribeSlackChannelConfigurationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let slackChannelConfigurations: [ChatbotClientTypes.SlackChannelConfiguration]?
}

extension DescribeSlackChannelConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case slackChannelConfigurations = "SlackChannelConfigurations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let slackChannelConfigurationsContainer = try containerValues.decodeIfPresent([ChatbotClientTypes.SlackChannelConfiguration?].self, forKey: .slackChannelConfigurations)
        var slackChannelConfigurationsDecoded0:[ChatbotClientTypes.SlackChannelConfiguration]? = nil
        if let slackChannelConfigurationsContainer = slackChannelConfigurationsContainer {
            slackChannelConfigurationsDecoded0 = [ChatbotClientTypes.SlackChannelConfiguration]()
            for structure0 in slackChannelConfigurationsContainer {
                if let structure0 = structure0 {
                    slackChannelConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        slackChannelConfigurations = slackChannelConfigurationsDecoded0
    }
}

enum DescribeSlackChannelConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DescribeSlackChannelConfigurationsException": return try await DescribeSlackChannelConfigurationsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSlackUserIdentitiesException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSlackUserIdentitiesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct DescribeSlackUserIdentitiesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DescribeSlackUserIdentitiesException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DescribeSlackUserIdentitiesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DescribeSlackUserIdentitiesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeSlackUserIdentitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeSlackUserIdentitiesInput {

    static func urlPathProvider(_ value: DescribeSlackUserIdentitiesInput) -> Swift.String? {
        return "/describe-slack-user-identities"
    }
}

public struct DescribeSlackUserIdentitiesInput: Swift.Equatable {
    /// The ARN of the SlackChannelConfiguration associated with the user identities to describe.
    public var chatConfigurationArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init(
        chatConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.chatConfigurationArn = chatConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeSlackUserIdentitiesInputBody: Swift.Equatable {
    let chatConfigurationArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeSlackUserIdentitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeSlackUserIdentitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSlackUserIdentitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.slackUserIdentities = output.slackUserIdentities
        } else {
            self.nextToken = nil
            self.slackUserIdentities = nil
        }
    }
}

public struct DescribeSlackUserIdentitiesOutput: Swift.Equatable {
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// A list of Slack User Identities.
    public var slackUserIdentities: [ChatbotClientTypes.SlackUserIdentity]?

    public init(
        nextToken: Swift.String? = nil,
        slackUserIdentities: [ChatbotClientTypes.SlackUserIdentity]? = nil
    )
    {
        self.nextToken = nextToken
        self.slackUserIdentities = slackUserIdentities
    }
}

struct DescribeSlackUserIdentitiesOutputBody: Swift.Equatable {
    let slackUserIdentities: [ChatbotClientTypes.SlackUserIdentity]?
    let nextToken: Swift.String?
}

extension DescribeSlackUserIdentitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case slackUserIdentities = "SlackUserIdentities"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slackUserIdentitiesContainer = try containerValues.decodeIfPresent([ChatbotClientTypes.SlackUserIdentity?].self, forKey: .slackUserIdentities)
        var slackUserIdentitiesDecoded0:[ChatbotClientTypes.SlackUserIdentity]? = nil
        if let slackUserIdentitiesContainer = slackUserIdentitiesContainer {
            slackUserIdentitiesDecoded0 = [ChatbotClientTypes.SlackUserIdentity]()
            for structure0 in slackUserIdentitiesContainer {
                if let structure0 = structure0 {
                    slackUserIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        slackUserIdentities = slackUserIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeSlackUserIdentitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DescribeSlackUserIdentitiesException": return try await DescribeSlackUserIdentitiesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSlackWorkspacesException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSlackWorkspacesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct DescribeSlackWorkspacesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DescribeSlackWorkspacesException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DescribeSlackWorkspacesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DescribeSlackWorkspacesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeSlackWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeSlackWorkspacesInput {

    static func urlPathProvider(_ value: DescribeSlackWorkspacesInput) -> Swift.String? {
        return "/describe-slack-workspaces"
    }
}

public struct DescribeSlackWorkspacesInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeSlackWorkspacesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeSlackWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSlackWorkspacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSlackWorkspacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.slackWorkspaces = output.slackWorkspaces
        } else {
            self.nextToken = nil
            self.slackWorkspaces = nil
        }
    }
}

public struct DescribeSlackWorkspacesOutput: Swift.Equatable {
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// A list of Slack Workspaces registered with AWS Chatbot.
    public var slackWorkspaces: [ChatbotClientTypes.SlackWorkspace]?

    public init(
        nextToken: Swift.String? = nil,
        slackWorkspaces: [ChatbotClientTypes.SlackWorkspace]? = nil
    )
    {
        self.nextToken = nextToken
        self.slackWorkspaces = slackWorkspaces
    }
}

struct DescribeSlackWorkspacesOutputBody: Swift.Equatable {
    let slackWorkspaces: [ChatbotClientTypes.SlackWorkspace]?
    let nextToken: Swift.String?
}

extension DescribeSlackWorkspacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case slackWorkspaces = "SlackWorkspaces"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slackWorkspacesContainer = try containerValues.decodeIfPresent([ChatbotClientTypes.SlackWorkspace?].self, forKey: .slackWorkspaces)
        var slackWorkspacesDecoded0:[ChatbotClientTypes.SlackWorkspace]? = nil
        if let slackWorkspacesContainer = slackWorkspacesContainer {
            slackWorkspacesDecoded0 = [ChatbotClientTypes.SlackWorkspace]()
            for structure0 in slackWorkspacesContainer {
                if let structure0 = structure0 {
                    slackWorkspacesDecoded0?.append(structure0)
                }
            }
        }
        slackWorkspaces = slackWorkspacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeSlackWorkspacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DescribeSlackWorkspacesException": return try await DescribeSlackWorkspacesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAccountPreferencesException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountPreferencesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct GetAccountPreferencesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GetAccountPreferencesException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct GetAccountPreferencesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension GetAccountPreferencesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetAccountPreferencesInput {

    static func urlPathProvider(_ value: GetAccountPreferencesInput) -> Swift.String? {
        return "/get-account-preferences"
    }
}

public struct GetAccountPreferencesInput: Swift.Equatable {

    public init() { }
}

struct GetAccountPreferencesInputBody: Swift.Equatable {
}

extension GetAccountPreferencesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountPreferencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountPreferencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountPreferences = output.accountPreferences
        } else {
            self.accountPreferences = nil
        }
    }
}

public struct GetAccountPreferencesOutput: Swift.Equatable {
    /// Preferences which apply for AWS Chatbot usage in the calling AWS account.
    public var accountPreferences: ChatbotClientTypes.AccountPreferences?

    public init(
        accountPreferences: ChatbotClientTypes.AccountPreferences? = nil
    )
    {
        self.accountPreferences = accountPreferences
    }
}

struct GetAccountPreferencesOutputBody: Swift.Equatable {
    let accountPreferences: ChatbotClientTypes.AccountPreferences?
}

extension GetAccountPreferencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountPreferences = "AccountPreferences"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountPreferencesDecoded = try containerValues.decodeIfPresent(ChatbotClientTypes.AccountPreferences.self, forKey: .accountPreferences)
        accountPreferences = accountPreferencesDecoded
    }
}

enum GetAccountPreferencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "GetAccountPreferencesException": return try await GetAccountPreferencesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMicrosoftTeamsChannelConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
    }
}

extension GetMicrosoftTeamsChannelConfigurationInput {

    static func urlPathProvider(_ value: GetMicrosoftTeamsChannelConfigurationInput) -> Swift.String? {
        return "/get-ms-teams-channel-configuration"
    }
}

public struct GetMicrosoftTeamsChannelConfigurationInput: Swift.Equatable {
    /// The ARN of the MicrosoftTeamsChannelConfiguration to retrieve.
    /// This member is required.
    public var chatConfigurationArn: Swift.String?

    public init(
        chatConfigurationArn: Swift.String? = nil
    )
    {
        self.chatConfigurationArn = chatConfigurationArn
    }
}

struct GetMicrosoftTeamsChannelConfigurationInputBody: Swift.Equatable {
    let chatConfigurationArn: Swift.String?
}

extension GetMicrosoftTeamsChannelConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
    }
}

extension GetMicrosoftTeamsChannelConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMicrosoftTeamsChannelConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelConfiguration = output.channelConfiguration
        } else {
            self.channelConfiguration = nil
        }
    }
}

public struct GetMicrosoftTeamsChannelConfigurationOutput: Swift.Equatable {
    /// The configuration for a Microsoft Teams channel configured with AWS Chatbot.
    public var channelConfiguration: ChatbotClientTypes.TeamsChannelConfiguration?

    public init(
        channelConfiguration: ChatbotClientTypes.TeamsChannelConfiguration? = nil
    )
    {
        self.channelConfiguration = channelConfiguration
    }
}

struct GetMicrosoftTeamsChannelConfigurationOutputBody: Swift.Equatable {
    let channelConfiguration: ChatbotClientTypes.TeamsChannelConfiguration?
}

extension GetMicrosoftTeamsChannelConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelConfiguration = "ChannelConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelConfigurationDecoded = try containerValues.decodeIfPresent(ChatbotClientTypes.TeamsChannelConfiguration.self, forKey: .channelConfiguration)
        channelConfiguration = channelConfigurationDecoded
    }
}

enum GetMicrosoftTeamsChannelConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "GetTeamsChannelConfigurationException": return try await GetTeamsChannelConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTeamsChannelConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTeamsChannelConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct GetTeamsChannelConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GetTeamsChannelConfigurationException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct GetTeamsChannelConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension GetTeamsChannelConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request input doesn't meet the constraints that AWS Chatbot requires.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request input doesn't meet the constraints that AWS Chatbot requires.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded a service limit for AWS Chatbot.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListMicrosoftTeamsChannelConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case teamId = "TeamId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }
}

extension ListMicrosoftTeamsChannelConfigurationsInput {

    static func urlPathProvider(_ value: ListMicrosoftTeamsChannelConfigurationsInput) -> Swift.String? {
        return "/list-ms-teams-channel-configurations"
    }
}

public struct ListMicrosoftTeamsChannelConfigurationsInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The ID of the Microsoft Team authorized with AWS Chatbot. To get the team ID, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console. Then you can copy and paste the team ID from the console. For more details, see steps 1-4 in Get started with Microsoft Teams in the AWS Chatbot Administrator Guide.
    public var teamId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        teamId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.teamId = teamId
    }
}

struct ListMicrosoftTeamsChannelConfigurationsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let teamId: Swift.String?
}

extension ListMicrosoftTeamsChannelConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case teamId = "TeamId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
    }
}

extension ListMicrosoftTeamsChannelConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMicrosoftTeamsChannelConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.teamChannelConfigurations = output.teamChannelConfigurations
        } else {
            self.nextToken = nil
            self.teamChannelConfigurations = nil
        }
    }
}

public struct ListMicrosoftTeamsChannelConfigurationsOutput: Swift.Equatable {
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// A list of AWS Chatbot channel configurations for Microsoft Teams.
    public var teamChannelConfigurations: [ChatbotClientTypes.TeamsChannelConfiguration]?

    public init(
        nextToken: Swift.String? = nil,
        teamChannelConfigurations: [ChatbotClientTypes.TeamsChannelConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.teamChannelConfigurations = teamChannelConfigurations
    }
}

struct ListMicrosoftTeamsChannelConfigurationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let teamChannelConfigurations: [ChatbotClientTypes.TeamsChannelConfiguration]?
}

extension ListMicrosoftTeamsChannelConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case teamChannelConfigurations = "TeamChannelConfigurations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let teamChannelConfigurationsContainer = try containerValues.decodeIfPresent([ChatbotClientTypes.TeamsChannelConfiguration?].self, forKey: .teamChannelConfigurations)
        var teamChannelConfigurationsDecoded0:[ChatbotClientTypes.TeamsChannelConfiguration]? = nil
        if let teamChannelConfigurationsContainer = teamChannelConfigurationsContainer {
            teamChannelConfigurationsDecoded0 = [ChatbotClientTypes.TeamsChannelConfiguration]()
            for structure0 in teamChannelConfigurationsContainer {
                if let structure0 = structure0 {
                    teamChannelConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        teamChannelConfigurations = teamChannelConfigurationsDecoded0
    }
}

enum ListMicrosoftTeamsChannelConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ListTeamsChannelConfigurationsException": return try await ListTeamsChannelConfigurationsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMicrosoftTeamsConfiguredTeamsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMicrosoftTeamsConfiguredTeamsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct ListMicrosoftTeamsConfiguredTeamsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ListMicrosoftTeamsConfiguredTeamsException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ListMicrosoftTeamsConfiguredTeamsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ListMicrosoftTeamsConfiguredTeamsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListMicrosoftTeamsConfiguredTeamsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMicrosoftTeamsConfiguredTeamsInput {

    static func urlPathProvider(_ value: ListMicrosoftTeamsConfiguredTeamsInput) -> Swift.String? {
        return "/list-ms-teams-configured-teams"
    }
}

public struct ListMicrosoftTeamsConfiguredTeamsInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMicrosoftTeamsConfiguredTeamsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListMicrosoftTeamsConfiguredTeamsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMicrosoftTeamsConfiguredTeamsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMicrosoftTeamsConfiguredTeamsOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredTeams = output.configuredTeams
            self.nextToken = output.nextToken
        } else {
            self.configuredTeams = nil
            self.nextToken = nil
        }
    }
}

public struct ListMicrosoftTeamsConfiguredTeamsOutput: Swift.Equatable {
    /// A list of teams in Microsoft Teams that have been configured with AWS Chatbot.
    public var configuredTeams: [ChatbotClientTypes.ConfiguredTeam]?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init(
        configuredTeams: [ChatbotClientTypes.ConfiguredTeam]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configuredTeams = configuredTeams
        self.nextToken = nextToken
    }
}

struct ListMicrosoftTeamsConfiguredTeamsOutputBody: Swift.Equatable {
    let configuredTeams: [ChatbotClientTypes.ConfiguredTeam]?
    let nextToken: Swift.String?
}

extension ListMicrosoftTeamsConfiguredTeamsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredTeams = "ConfiguredTeams"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredTeamsContainer = try containerValues.decodeIfPresent([ChatbotClientTypes.ConfiguredTeam?].self, forKey: .configuredTeams)
        var configuredTeamsDecoded0:[ChatbotClientTypes.ConfiguredTeam]? = nil
        if let configuredTeamsContainer = configuredTeamsContainer {
            configuredTeamsDecoded0 = [ChatbotClientTypes.ConfiguredTeam]()
            for structure0 in configuredTeamsContainer {
                if let structure0 = structure0 {
                    configuredTeamsDecoded0?.append(structure0)
                }
            }
        }
        configuredTeams = configuredTeamsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMicrosoftTeamsConfiguredTeamsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ListMicrosoftTeamsConfiguredTeamsException": return try await ListMicrosoftTeamsConfiguredTeamsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMicrosoftTeamsUserIdentitiesException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMicrosoftTeamsUserIdentitiesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct ListMicrosoftTeamsUserIdentitiesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ListMicrosoftTeamsUserIdentitiesException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ListMicrosoftTeamsUserIdentitiesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ListMicrosoftTeamsUserIdentitiesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListMicrosoftTeamsUserIdentitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMicrosoftTeamsUserIdentitiesInput {

    static func urlPathProvider(_ value: ListMicrosoftTeamsUserIdentitiesInput) -> Swift.String? {
        return "/list-ms-teams-user-identities"
    }
}

public struct ListMicrosoftTeamsUserIdentitiesInput: Swift.Equatable {
    /// The ARN of the MicrosoftTeamsChannelConfiguration associated with the user identities to list.
    public var chatConfigurationArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init(
        chatConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.chatConfigurationArn = chatConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMicrosoftTeamsUserIdentitiesInputBody: Swift.Equatable {
    let chatConfigurationArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMicrosoftTeamsUserIdentitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMicrosoftTeamsUserIdentitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMicrosoftTeamsUserIdentitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.teamsUserIdentities = output.teamsUserIdentities
        } else {
            self.nextToken = nil
            self.teamsUserIdentities = nil
        }
    }
}

public struct ListMicrosoftTeamsUserIdentitiesOutput: Swift.Equatable {
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// User level permissions associated to a channel configuration.
    public var teamsUserIdentities: [ChatbotClientTypes.TeamsUserIdentity]?

    public init(
        nextToken: Swift.String? = nil,
        teamsUserIdentities: [ChatbotClientTypes.TeamsUserIdentity]? = nil
    )
    {
        self.nextToken = nextToken
        self.teamsUserIdentities = teamsUserIdentities
    }
}

struct ListMicrosoftTeamsUserIdentitiesOutputBody: Swift.Equatable {
    let teamsUserIdentities: [ChatbotClientTypes.TeamsUserIdentity]?
    let nextToken: Swift.String?
}

extension ListMicrosoftTeamsUserIdentitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case teamsUserIdentities = "TeamsUserIdentities"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamsUserIdentitiesContainer = try containerValues.decodeIfPresent([ChatbotClientTypes.TeamsUserIdentity?].self, forKey: .teamsUserIdentities)
        var teamsUserIdentitiesDecoded0:[ChatbotClientTypes.TeamsUserIdentity]? = nil
        if let teamsUserIdentitiesContainer = teamsUserIdentitiesContainer {
            teamsUserIdentitiesDecoded0 = [ChatbotClientTypes.TeamsUserIdentity]()
            for structure0 in teamsUserIdentitiesContainer {
                if let structure0 = structure0 {
                    teamsUserIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        teamsUserIdentities = teamsUserIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMicrosoftTeamsUserIdentitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ListMicrosoftTeamsUserIdentitiesException": return try await ListMicrosoftTeamsUserIdentitiesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTeamsChannelConfigurationsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTeamsChannelConfigurationsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct ListTeamsChannelConfigurationsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ListTeamsChannelConfigurationsException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ListTeamsChannelConfigurationsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ListTeamsChannelConfigurationsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We were not able to find the resource for your request.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChatbotClientTypes.SlackChannelConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case configurationName = "ConfigurationName"
        case guardrailPolicyArns = "GuardrailPolicyArns"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case slackChannelId = "SlackChannelId"
        case slackChannelName = "SlackChannelName"
        case slackTeamId = "SlackTeamId"
        case slackTeamName = "SlackTeamName"
        case snsTopicArns = "SnsTopicArns"
        case userAuthorizationRequired = "UserAuthorizationRequired"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
        if let configurationName = self.configurationName {
            try encodeContainer.encode(configurationName, forKey: .configurationName)
        }
        if let guardrailPolicyArns = guardrailPolicyArns {
            var guardrailPolicyArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .guardrailPolicyArns)
            for guardrailpolicyarn0 in guardrailPolicyArns {
                try guardrailPolicyArnsContainer.encode(guardrailpolicyarn0)
            }
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let loggingLevel = self.loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if let slackChannelId = self.slackChannelId {
            try encodeContainer.encode(slackChannelId, forKey: .slackChannelId)
        }
        if let slackChannelName = self.slackChannelName {
            try encodeContainer.encode(slackChannelName, forKey: .slackChannelName)
        }
        if let slackTeamId = self.slackTeamId {
            try encodeContainer.encode(slackTeamId, forKey: .slackTeamId)
        }
        if let slackTeamName = self.slackTeamName {
            try encodeContainer.encode(slackTeamName, forKey: .slackTeamName)
        }
        if let snsTopicArns = snsTopicArns {
            var snsTopicArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snsTopicArns)
            for arn0 in snsTopicArns {
                try snsTopicArnsContainer.encode(arn0)
            }
        }
        if let userAuthorizationRequired = self.userAuthorizationRequired {
            try encodeContainer.encode(userAuthorizationRequired, forKey: .userAuthorizationRequired)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slackTeamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackTeamName)
        slackTeamName = slackTeamNameDecoded
        let slackTeamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackTeamId)
        slackTeamId = slackTeamIdDecoded
        let slackChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackChannelId)
        slackChannelId = slackChannelIdDecoded
        let slackChannelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackChannelName)
        slackChannelName = slackChannelNameDecoded
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let snsTopicArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .snsTopicArns)
        var snsTopicArnsDecoded0:[Swift.String]? = nil
        if let snsTopicArnsContainer = snsTopicArnsContainer {
            snsTopicArnsDecoded0 = [Swift.String]()
            for string0 in snsTopicArnsContainer {
                if let string0 = string0 {
                    snsTopicArnsDecoded0?.append(string0)
                }
            }
        }
        snsTopicArns = snsTopicArnsDecoded0
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let guardrailPolicyArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .guardrailPolicyArns)
        var guardrailPolicyArnsDecoded0:[Swift.String]? = nil
        if let guardrailPolicyArnsContainer = guardrailPolicyArnsContainer {
            guardrailPolicyArnsDecoded0 = [Swift.String]()
            for string0 in guardrailPolicyArnsContainer {
                if let string0 = string0 {
                    guardrailPolicyArnsDecoded0?.append(string0)
                }
            }
        }
        guardrailPolicyArns = guardrailPolicyArnsDecoded0
        let userAuthorizationRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userAuthorizationRequired)
        userAuthorizationRequired = userAuthorizationRequiredDecoded
    }
}

extension ChatbotClientTypes {
    /// An AWS Chatbot configuration for Slack.
    public struct SlackChannelConfiguration: Swift.Equatable {
        /// The ARN of the SlackChannelConfiguration.
        /// This member is required.
        public var chatConfigurationArn: Swift.String?
        /// The name of the configuration.
        public var configurationName: Swift.String?
        /// The list of IAM policy ARNs that are applied as channel guardrails. The AWS managed 'AdministratorAccess' policy is applied by default if this is not set.
        public var guardrailPolicyArns: [Swift.String]?
        /// The ARN of the IAM role that defines the permissions for AWS Chatbot. This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see IAM Policies for AWS Chatbot.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// Logging levels include ERROR, INFO, or NONE.
        public var loggingLevel: Swift.String?
        /// The ID of the Slack channel. To get the ID, open Slack, right click on the channel name in the left pane, then choose Copy Link. The channel ID is the 9-character string at the end of the URL. For example, ABCBBLZZZ.
        /// This member is required.
        public var slackChannelId: Swift.String?
        /// The name of the Slack Channel.
        /// This member is required.
        public var slackChannelName: Swift.String?
        /// The ID of the Slack workspace authorized with AWS Chatbot.
        /// This member is required.
        public var slackTeamId: Swift.String?
        /// Name of the Slack Workspace.
        /// This member is required.
        public var slackTeamName: Swift.String?
        /// The ARNs of the SNS topics that deliver notifications to AWS Chatbot.
        /// This member is required.
        public var snsTopicArns: [Swift.String]?
        /// Enables use of a user role requirement in your chat configuration.
        public var userAuthorizationRequired: Swift.Bool?

        public init(
            chatConfigurationArn: Swift.String? = nil,
            configurationName: Swift.String? = nil,
            guardrailPolicyArns: [Swift.String]? = nil,
            iamRoleArn: Swift.String? = nil,
            loggingLevel: Swift.String? = nil,
            slackChannelId: Swift.String? = nil,
            slackChannelName: Swift.String? = nil,
            slackTeamId: Swift.String? = nil,
            slackTeamName: Swift.String? = nil,
            snsTopicArns: [Swift.String]? = nil,
            userAuthorizationRequired: Swift.Bool? = nil
        )
        {
            self.chatConfigurationArn = chatConfigurationArn
            self.configurationName = configurationName
            self.guardrailPolicyArns = guardrailPolicyArns
            self.iamRoleArn = iamRoleArn
            self.loggingLevel = loggingLevel
            self.slackChannelId = slackChannelId
            self.slackChannelName = slackChannelName
            self.slackTeamId = slackTeamId
            self.slackTeamName = slackTeamName
            self.snsTopicArns = snsTopicArns
            self.userAuthorizationRequired = userAuthorizationRequired
        }
    }

}

extension ChatbotClientTypes.SlackUserIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsUserIdentity = "AwsUserIdentity"
        case chatConfigurationArn = "ChatConfigurationArn"
        case iamRoleArn = "IamRoleArn"
        case slackTeamId = "SlackTeamId"
        case slackUserId = "SlackUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsUserIdentity = self.awsUserIdentity {
            try encodeContainer.encode(awsUserIdentity, forKey: .awsUserIdentity)
        }
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let slackTeamId = self.slackTeamId {
            try encodeContainer.encode(slackTeamId, forKey: .slackTeamId)
        }
        if let slackUserId = self.slackUserId {
            try encodeContainer.encode(slackUserId, forKey: .slackUserId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
        let slackTeamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackTeamId)
        slackTeamId = slackTeamIdDecoded
        let slackUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackUserId)
        slackUserId = slackUserIdDecoded
        let awsUserIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsUserIdentity)
        awsUserIdentity = awsUserIdentityDecoded
    }
}

extension ChatbotClientTypes {
    /// Identifes a User level permission for a channel configuration.
    public struct SlackUserIdentity: Swift.Equatable {
        /// The AWS user identity ARN used to associate a Slack User Identity with an IAM Role.
        public var awsUserIdentity: Swift.String?
        /// The ARN of the SlackChannelConfiguration associated with the user identity.
        /// This member is required.
        public var chatConfigurationArn: Swift.String?
        /// The ARN of the IAM role that defines the permissions for AWS Chatbot. This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see IAM Policies for AWS Chatbot.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// The ID of the Slack workspace authorized with AWS Chatbot.
        /// This member is required.
        public var slackTeamId: Swift.String?
        /// The ID of the user in Slack.
        /// This member is required.
        public var slackUserId: Swift.String?

        public init(
            awsUserIdentity: Swift.String? = nil,
            chatConfigurationArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            slackTeamId: Swift.String? = nil,
            slackUserId: Swift.String? = nil
        )
        {
            self.awsUserIdentity = awsUserIdentity
            self.chatConfigurationArn = chatConfigurationArn
            self.iamRoleArn = iamRoleArn
            self.slackTeamId = slackTeamId
            self.slackUserId = slackUserId
        }
    }

}

extension ChatbotClientTypes.SlackWorkspace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case slackTeamId = "SlackTeamId"
        case slackTeamName = "SlackTeamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let slackTeamId = self.slackTeamId {
            try encodeContainer.encode(slackTeamId, forKey: .slackTeamId)
        }
        if let slackTeamName = self.slackTeamName {
            try encodeContainer.encode(slackTeamName, forKey: .slackTeamName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slackTeamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackTeamId)
        slackTeamId = slackTeamIdDecoded
        let slackTeamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackTeamName)
        slackTeamName = slackTeamNameDecoded
    }
}

extension ChatbotClientTypes {
    /// A Slack Workspace.
    public struct SlackWorkspace: Swift.Equatable {
        /// The ID of the Slack workspace authorized with AWS Chatbot.
        /// This member is required.
        public var slackTeamId: Swift.String?
        /// Name of the Slack Workspace.
        /// This member is required.
        public var slackTeamName: Swift.String?

        public init(
            slackTeamId: Swift.String? = nil,
            slackTeamName: Swift.String? = nil
        )
        {
            self.slackTeamId = slackTeamId
            self.slackTeamName = slackTeamName
        }
    }

}

extension ChatbotClientTypes.TeamsChannelConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId = "ChannelId"
        case channelName = "ChannelName"
        case chatConfigurationArn = "ChatConfigurationArn"
        case configurationName = "ConfigurationName"
        case guardrailPolicyArns = "GuardrailPolicyArns"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case snsTopicArns = "SnsTopicArns"
        case teamId = "TeamId"
        case teamName = "TeamName"
        case tenantId = "TenantId"
        case userAuthorizationRequired = "UserAuthorizationRequired"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
        if let configurationName = self.configurationName {
            try encodeContainer.encode(configurationName, forKey: .configurationName)
        }
        if let guardrailPolicyArns = guardrailPolicyArns {
            var guardrailPolicyArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .guardrailPolicyArns)
            for guardrailpolicyarn0 in guardrailPolicyArns {
                try guardrailPolicyArnsContainer.encode(guardrailpolicyarn0)
            }
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let loggingLevel = self.loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if let snsTopicArns = snsTopicArns {
            var snsTopicArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snsTopicArns)
            for arn0 in snsTopicArns {
                try snsTopicArnsContainer.encode(arn0)
            }
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
        if let teamName = self.teamName {
            try encodeContainer.encode(teamName, forKey: .teamName)
        }
        if let tenantId = self.tenantId {
            try encodeContainer.encode(tenantId, forKey: .tenantId)
        }
        if let userAuthorizationRequired = self.userAuthorizationRequired {
            try encodeContainer.encode(userAuthorizationRequired, forKey: .userAuthorizationRequired)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let teamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamName)
        teamName = teamNameDecoded
        let tenantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenantId)
        tenantId = tenantIdDecoded
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let snsTopicArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .snsTopicArns)
        var snsTopicArnsDecoded0:[Swift.String]? = nil
        if let snsTopicArnsContainer = snsTopicArnsContainer {
            snsTopicArnsDecoded0 = [Swift.String]()
            for string0 in snsTopicArnsContainer {
                if let string0 = string0 {
                    snsTopicArnsDecoded0?.append(string0)
                }
            }
        }
        snsTopicArns = snsTopicArnsDecoded0
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let guardrailPolicyArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .guardrailPolicyArns)
        var guardrailPolicyArnsDecoded0:[Swift.String]? = nil
        if let guardrailPolicyArnsContainer = guardrailPolicyArnsContainer {
            guardrailPolicyArnsDecoded0 = [Swift.String]()
            for string0 in guardrailPolicyArnsContainer {
                if let string0 = string0 {
                    guardrailPolicyArnsDecoded0?.append(string0)
                }
            }
        }
        guardrailPolicyArns = guardrailPolicyArnsDecoded0
        let userAuthorizationRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userAuthorizationRequired)
        userAuthorizationRequired = userAuthorizationRequiredDecoded
    }
}

extension ChatbotClientTypes {
    /// An AWS Chatbot configuration for Microsoft Teams.
    public struct TeamsChannelConfiguration: Swift.Equatable {
        /// The ID of the Microsoft Teams channel.
        /// This member is required.
        public var channelId: Swift.String?
        /// The name of the Microsoft Teams channel.
        public var channelName: Swift.String?
        /// The ARN of the MicrosoftTeamsChannelConfiguration.
        /// This member is required.
        public var chatConfigurationArn: Swift.String?
        /// The name of the configuration.
        public var configurationName: Swift.String?
        /// The list of IAM policy ARNs that are applied as channel guardrails. The AWS managed 'AdministratorAccess' policy is applied by default if this is not set.
        public var guardrailPolicyArns: [Swift.String]?
        /// The ARN of the IAM role that defines the permissions for AWS Chatbot. This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see IAM Policies for AWS Chatbot.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// Logging levels include ERROR, INFO, or NONE.
        public var loggingLevel: Swift.String?
        /// The ARNs of the SNS topics that deliver notifications to AWS Chatbot.
        /// This member is required.
        public var snsTopicArns: [Swift.String]?
        /// The ID of the Microsoft Team authorized with AWS Chatbot. To get the team ID, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console. Then you can copy and paste the team ID from the console. For more details, see steps 1-4 in Get started with Microsoft Teams in the AWS Chatbot Administrator Guide.
        /// This member is required.
        public var teamId: Swift.String?
        /// The name of the Microsoft Teams Team.
        public var teamName: Swift.String?
        /// The ID of the Microsoft Teams tenant.
        /// This member is required.
        public var tenantId: Swift.String?
        /// Enables use of a user role requirement in your chat configuration.
        public var userAuthorizationRequired: Swift.Bool?

        public init(
            channelId: Swift.String? = nil,
            channelName: Swift.String? = nil,
            chatConfigurationArn: Swift.String? = nil,
            configurationName: Swift.String? = nil,
            guardrailPolicyArns: [Swift.String]? = nil,
            iamRoleArn: Swift.String? = nil,
            loggingLevel: Swift.String? = nil,
            snsTopicArns: [Swift.String]? = nil,
            teamId: Swift.String? = nil,
            teamName: Swift.String? = nil,
            tenantId: Swift.String? = nil,
            userAuthorizationRequired: Swift.Bool? = nil
        )
        {
            self.channelId = channelId
            self.channelName = channelName
            self.chatConfigurationArn = chatConfigurationArn
            self.configurationName = configurationName
            self.guardrailPolicyArns = guardrailPolicyArns
            self.iamRoleArn = iamRoleArn
            self.loggingLevel = loggingLevel
            self.snsTopicArns = snsTopicArns
            self.teamId = teamId
            self.teamName = teamName
            self.tenantId = tenantId
            self.userAuthorizationRequired = userAuthorizationRequired
        }
    }

}

extension ChatbotClientTypes.TeamsUserIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsUserIdentity = "AwsUserIdentity"
        case chatConfigurationArn = "ChatConfigurationArn"
        case iamRoleArn = "IamRoleArn"
        case teamId = "TeamId"
        case teamsChannelId = "TeamsChannelId"
        case teamsTenantId = "TeamsTenantId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsUserIdentity = self.awsUserIdentity {
            try encodeContainer.encode(awsUserIdentity, forKey: .awsUserIdentity)
        }
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
        if let teamsChannelId = self.teamsChannelId {
            try encodeContainer.encode(teamsChannelId, forKey: .teamsChannelId)
        }
        if let teamsTenantId = self.teamsTenantId {
            try encodeContainer.encode(teamsTenantId, forKey: .teamsTenantId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let awsUserIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsUserIdentity)
        awsUserIdentity = awsUserIdentityDecoded
        let teamsChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamsChannelId)
        teamsChannelId = teamsChannelIdDecoded
        let teamsTenantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamsTenantId)
        teamsTenantId = teamsTenantIdDecoded
    }
}

extension ChatbotClientTypes {
    /// Identifes a user level permission for a channel configuration.
    public struct TeamsUserIdentity: Swift.Equatable {
        /// The AWS user identity ARN used to associate a Microsoft Teams User Identity with an IAM Role.
        public var awsUserIdentity: Swift.String?
        /// The ARN of the MicrosoftTeamsChannelConfiguration associated with the user identity.
        /// This member is required.
        public var chatConfigurationArn: Swift.String?
        /// The ARN of the IAM role that defines the permissions for AWS Chatbot. This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see IAM Policies for AWS Chatbot.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// The ID of the Microsoft Team authorized with AWS Chatbot. To get the team ID, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console. Then you can copy and paste the team ID from the console. For more details, see steps 1-4 in Get started with Microsoft Teams in the AWS Chatbot Administrator Guide.
        /// This member is required.
        public var teamId: Swift.String?
        /// The ID of the Microsoft Teams channel.
        public var teamsChannelId: Swift.String?
        /// The ID of the Microsoft Teams tenant.
        public var teamsTenantId: Swift.String?
        /// Id from Microsoft Teams for user.
        public var userId: Swift.String?

        public init(
            awsUserIdentity: Swift.String? = nil,
            chatConfigurationArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            teamId: Swift.String? = nil,
            teamsChannelId: Swift.String? = nil,
            teamsTenantId: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.awsUserIdentity = awsUserIdentity
            self.chatConfigurationArn = chatConfigurationArn
            self.iamRoleArn = iamRoleArn
            self.teamId = teamId
            self.teamsChannelId = teamsChannelId
            self.teamsTenantId = teamsTenantId
            self.userId = userId
        }
    }

}

extension UpdateAccountPreferencesException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAccountPreferencesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct UpdateAccountPreferencesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UpdateAccountPreferencesException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UpdateAccountPreferencesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UpdateAccountPreferencesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateAccountPreferencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trainingDataCollectionEnabled = "TrainingDataCollectionEnabled"
        case userAuthorizationRequired = "UserAuthorizationRequired"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trainingDataCollectionEnabled = self.trainingDataCollectionEnabled {
            try encodeContainer.encode(trainingDataCollectionEnabled, forKey: .trainingDataCollectionEnabled)
        }
        if let userAuthorizationRequired = self.userAuthorizationRequired {
            try encodeContainer.encode(userAuthorizationRequired, forKey: .userAuthorizationRequired)
        }
    }
}

extension UpdateAccountPreferencesInput {

    static func urlPathProvider(_ value: UpdateAccountPreferencesInput) -> Swift.String? {
        return "/update-account-preferences"
    }
}

public struct UpdateAccountPreferencesInput: Swift.Equatable {
    /// Turns on training data collection. This helps improve the AWS Chatbot experience by allowing AWS Chatbot to store and use your customer information, such as AWS Chatbot configurations, notifications, user inputs, AWS Chatbot generated responses, and interaction data. This data helps us to continuously improve and develop Artificial Intelligence (AI) technologies. Your data is not shared with any third parties and is protected using sophisticated controls to prevent unauthorized access and misuse. AWS Chatbot does not store or use interactions in chat channels with Amazon Q for training AWS Chatbot’s AI technologies.
    public var trainingDataCollectionEnabled: Swift.Bool?
    /// Enables use of a user role requirement in your chat configuration.
    public var userAuthorizationRequired: Swift.Bool?

    public init(
        trainingDataCollectionEnabled: Swift.Bool? = nil,
        userAuthorizationRequired: Swift.Bool? = nil
    )
    {
        self.trainingDataCollectionEnabled = trainingDataCollectionEnabled
        self.userAuthorizationRequired = userAuthorizationRequired
    }
}

struct UpdateAccountPreferencesInputBody: Swift.Equatable {
    let userAuthorizationRequired: Swift.Bool?
    let trainingDataCollectionEnabled: Swift.Bool?
}

extension UpdateAccountPreferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trainingDataCollectionEnabled = "TrainingDataCollectionEnabled"
        case userAuthorizationRequired = "UserAuthorizationRequired"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAuthorizationRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userAuthorizationRequired)
        userAuthorizationRequired = userAuthorizationRequiredDecoded
        let trainingDataCollectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .trainingDataCollectionEnabled)
        trainingDataCollectionEnabled = trainingDataCollectionEnabledDecoded
    }
}

extension UpdateAccountPreferencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAccountPreferencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountPreferences = output.accountPreferences
        } else {
            self.accountPreferences = nil
        }
    }
}

public struct UpdateAccountPreferencesOutput: Swift.Equatable {
    /// Preferences which apply for AWS Chatbot usage in the calling AWS account.
    public var accountPreferences: ChatbotClientTypes.AccountPreferences?

    public init(
        accountPreferences: ChatbotClientTypes.AccountPreferences? = nil
    )
    {
        self.accountPreferences = accountPreferences
    }
}

struct UpdateAccountPreferencesOutputBody: Swift.Equatable {
    let accountPreferences: ChatbotClientTypes.AccountPreferences?
}

extension UpdateAccountPreferencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountPreferences = "AccountPreferences"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountPreferencesDecoded = try containerValues.decodeIfPresent(ChatbotClientTypes.AccountPreferences.self, forKey: .accountPreferences)
        accountPreferences = accountPreferencesDecoded
    }
}

enum UpdateAccountPreferencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UpdateAccountPreferencesException": return try await UpdateAccountPreferencesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateChimeWebhookConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateChimeWebhookConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct UpdateChimeWebhookConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UpdateChimeWebhookConfigurationException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UpdateChimeWebhookConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UpdateChimeWebhookConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateChimeWebhookConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case snsTopicArns = "SnsTopicArns"
        case webhookDescription = "WebhookDescription"
        case webhookUrl = "WebhookUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let loggingLevel = self.loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if let snsTopicArns = snsTopicArns {
            var snsTopicArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snsTopicArns)
            for arn0 in snsTopicArns {
                try snsTopicArnsContainer.encode(arn0)
            }
        }
        if let webhookDescription = self.webhookDescription {
            try encodeContainer.encode(webhookDescription, forKey: .webhookDescription)
        }
        if let webhookUrl = self.webhookUrl {
            try encodeContainer.encode(webhookUrl, forKey: .webhookUrl)
        }
    }
}

extension UpdateChimeWebhookConfigurationInput {

    static func urlPathProvider(_ value: UpdateChimeWebhookConfigurationInput) -> Swift.String? {
        return "/update-chime-webhook-configuration"
    }
}

public struct UpdateChimeWebhookConfigurationInput: Swift.Equatable {
    /// The ARN of the ChimeWebhookConfiguration to update.
    /// This member is required.
    public var chatConfigurationArn: Swift.String?
    /// The ARN of the IAM role that defines the permissions for AWS Chatbot. This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see IAM Policies for AWS Chatbot.
    public var iamRoleArn: Swift.String?
    /// Logging levels include ERROR, INFO, or NONE.
    public var loggingLevel: Swift.String?
    /// The ARNs of the SNS topics that deliver notifications to AWS Chatbot.
    public var snsTopicArns: [Swift.String]?
    /// Description of the webhook. Recommend using the convention RoomName/WebhookName. See Chime setup tutorial for more details: https://docs.aws.amazon.com/chatbot/latest/adminguide/chime-setup.html.
    public var webhookDescription: Swift.String?
    /// URL for the Chime webhook.
    public var webhookUrl: Swift.String?

    public init(
        chatConfigurationArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        loggingLevel: Swift.String? = nil,
        snsTopicArns: [Swift.String]? = nil,
        webhookDescription: Swift.String? = nil,
        webhookUrl: Swift.String? = nil
    )
    {
        self.chatConfigurationArn = chatConfigurationArn
        self.iamRoleArn = iamRoleArn
        self.loggingLevel = loggingLevel
        self.snsTopicArns = snsTopicArns
        self.webhookDescription = webhookDescription
        self.webhookUrl = webhookUrl
    }
}

struct UpdateChimeWebhookConfigurationInputBody: Swift.Equatable {
    let chatConfigurationArn: Swift.String?
    let webhookDescription: Swift.String?
    let webhookUrl: Swift.String?
    let snsTopicArns: [Swift.String]?
    let iamRoleArn: Swift.String?
    let loggingLevel: Swift.String?
}

extension UpdateChimeWebhookConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case snsTopicArns = "SnsTopicArns"
        case webhookDescription = "WebhookDescription"
        case webhookUrl = "WebhookUrl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
        let webhookDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webhookDescription)
        webhookDescription = webhookDescriptionDecoded
        let webhookUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webhookUrl)
        webhookUrl = webhookUrlDecoded
        let snsTopicArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .snsTopicArns)
        var snsTopicArnsDecoded0:[Swift.String]? = nil
        if let snsTopicArnsContainer = snsTopicArnsContainer {
            snsTopicArnsDecoded0 = [Swift.String]()
            for string0 in snsTopicArnsContainer {
                if let string0 = string0 {
                    snsTopicArnsDecoded0?.append(string0)
                }
            }
        }
        snsTopicArns = snsTopicArnsDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
    }
}

extension UpdateChimeWebhookConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateChimeWebhookConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.webhookConfiguration = output.webhookConfiguration
        } else {
            self.webhookConfiguration = nil
        }
    }
}

public struct UpdateChimeWebhookConfigurationOutput: Swift.Equatable {
    /// Chime webhook configuration.
    public var webhookConfiguration: ChatbotClientTypes.ChimeWebhookConfiguration?

    public init(
        webhookConfiguration: ChatbotClientTypes.ChimeWebhookConfiguration? = nil
    )
    {
        self.webhookConfiguration = webhookConfiguration
    }
}

struct UpdateChimeWebhookConfigurationOutputBody: Swift.Equatable {
    let webhookConfiguration: ChatbotClientTypes.ChimeWebhookConfiguration?
}

extension UpdateChimeWebhookConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webhookConfiguration = "WebhookConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookConfigurationDecoded = try containerValues.decodeIfPresent(ChatbotClientTypes.ChimeWebhookConfiguration.self, forKey: .webhookConfiguration)
        webhookConfiguration = webhookConfigurationDecoded
    }
}

enum UpdateChimeWebhookConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UpdateChimeWebhookConfigurationException": return try await UpdateChimeWebhookConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMicrosoftTeamsChannelConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId = "ChannelId"
        case channelName = "ChannelName"
        case chatConfigurationArn = "ChatConfigurationArn"
        case guardrailPolicyArns = "GuardrailPolicyArns"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case snsTopicArns = "SnsTopicArns"
        case userAuthorizationRequired = "UserAuthorizationRequired"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
        if let guardrailPolicyArns = guardrailPolicyArns {
            var guardrailPolicyArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .guardrailPolicyArns)
            for guardrailpolicyarn0 in guardrailPolicyArns {
                try guardrailPolicyArnsContainer.encode(guardrailpolicyarn0)
            }
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let loggingLevel = self.loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if let snsTopicArns = snsTopicArns {
            var snsTopicArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snsTopicArns)
            for arn0 in snsTopicArns {
                try snsTopicArnsContainer.encode(arn0)
            }
        }
        if let userAuthorizationRequired = self.userAuthorizationRequired {
            try encodeContainer.encode(userAuthorizationRequired, forKey: .userAuthorizationRequired)
        }
    }
}

extension UpdateMicrosoftTeamsChannelConfigurationInput {

    static func urlPathProvider(_ value: UpdateMicrosoftTeamsChannelConfigurationInput) -> Swift.String? {
        return "/update-ms-teams-channel-configuration"
    }
}

public struct UpdateMicrosoftTeamsChannelConfigurationInput: Swift.Equatable {
    /// The ID of the Microsoft Teams channel.
    /// This member is required.
    public var channelId: Swift.String?
    /// The name of the Microsoft Teams channel.
    public var channelName: Swift.String?
    /// The ARN of the MicrosoftTeamsChannelConfiguration to update.
    /// This member is required.
    public var chatConfigurationArn: Swift.String?
    /// The list of IAM policy ARNs that are applied as channel guardrails. The AWS managed 'AdministratorAccess' policy is applied by default if this is not set.
    public var guardrailPolicyArns: [Swift.String]?
    /// The ARN of the IAM role that defines the permissions for AWS Chatbot. This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see IAM Policies for AWS Chatbot.
    public var iamRoleArn: Swift.String?
    /// Logging levels include ERROR, INFO, or NONE.
    public var loggingLevel: Swift.String?
    /// The ARNs of the SNS topics that deliver notifications to AWS Chatbot.
    public var snsTopicArns: [Swift.String]?
    /// Enables use of a user role requirement in your chat configuration.
    public var userAuthorizationRequired: Swift.Bool?

    public init(
        channelId: Swift.String? = nil,
        channelName: Swift.String? = nil,
        chatConfigurationArn: Swift.String? = nil,
        guardrailPolicyArns: [Swift.String]? = nil,
        iamRoleArn: Swift.String? = nil,
        loggingLevel: Swift.String? = nil,
        snsTopicArns: [Swift.String]? = nil,
        userAuthorizationRequired: Swift.Bool? = nil
    )
    {
        self.channelId = channelId
        self.channelName = channelName
        self.chatConfigurationArn = chatConfigurationArn
        self.guardrailPolicyArns = guardrailPolicyArns
        self.iamRoleArn = iamRoleArn
        self.loggingLevel = loggingLevel
        self.snsTopicArns = snsTopicArns
        self.userAuthorizationRequired = userAuthorizationRequired
    }
}

struct UpdateMicrosoftTeamsChannelConfigurationInputBody: Swift.Equatable {
    let chatConfigurationArn: Swift.String?
    let channelId: Swift.String?
    let channelName: Swift.String?
    let snsTopicArns: [Swift.String]?
    let iamRoleArn: Swift.String?
    let loggingLevel: Swift.String?
    let guardrailPolicyArns: [Swift.String]?
    let userAuthorizationRequired: Swift.Bool?
}

extension UpdateMicrosoftTeamsChannelConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId = "ChannelId"
        case channelName = "ChannelName"
        case chatConfigurationArn = "ChatConfigurationArn"
        case guardrailPolicyArns = "GuardrailPolicyArns"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case snsTopicArns = "SnsTopicArns"
        case userAuthorizationRequired = "UserAuthorizationRequired"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let snsTopicArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .snsTopicArns)
        var snsTopicArnsDecoded0:[Swift.String]? = nil
        if let snsTopicArnsContainer = snsTopicArnsContainer {
            snsTopicArnsDecoded0 = [Swift.String]()
            for string0 in snsTopicArnsContainer {
                if let string0 = string0 {
                    snsTopicArnsDecoded0?.append(string0)
                }
            }
        }
        snsTopicArns = snsTopicArnsDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let guardrailPolicyArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .guardrailPolicyArns)
        var guardrailPolicyArnsDecoded0:[Swift.String]? = nil
        if let guardrailPolicyArnsContainer = guardrailPolicyArnsContainer {
            guardrailPolicyArnsDecoded0 = [Swift.String]()
            for string0 in guardrailPolicyArnsContainer {
                if let string0 = string0 {
                    guardrailPolicyArnsDecoded0?.append(string0)
                }
            }
        }
        guardrailPolicyArns = guardrailPolicyArnsDecoded0
        let userAuthorizationRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userAuthorizationRequired)
        userAuthorizationRequired = userAuthorizationRequiredDecoded
    }
}

extension UpdateMicrosoftTeamsChannelConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMicrosoftTeamsChannelConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelConfiguration = output.channelConfiguration
        } else {
            self.channelConfiguration = nil
        }
    }
}

public struct UpdateMicrosoftTeamsChannelConfigurationOutput: Swift.Equatable {
    /// The configuration for a Microsoft Teams channel configured with AWS Chatbot.
    public var channelConfiguration: ChatbotClientTypes.TeamsChannelConfiguration?

    public init(
        channelConfiguration: ChatbotClientTypes.TeamsChannelConfiguration? = nil
    )
    {
        self.channelConfiguration = channelConfiguration
    }
}

struct UpdateMicrosoftTeamsChannelConfigurationOutputBody: Swift.Equatable {
    let channelConfiguration: ChatbotClientTypes.TeamsChannelConfiguration?
}

extension UpdateMicrosoftTeamsChannelConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelConfiguration = "ChannelConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelConfigurationDecoded = try containerValues.decodeIfPresent(ChatbotClientTypes.TeamsChannelConfiguration.self, forKey: .channelConfiguration)
        channelConfiguration = channelConfigurationDecoded
    }
}

enum UpdateMicrosoftTeamsChannelConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UpdateTeamsChannelConfigurationException": return try await UpdateTeamsChannelConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSlackChannelConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSlackChannelConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct UpdateSlackChannelConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UpdateSlackChannelConfigurationException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UpdateSlackChannelConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UpdateSlackChannelConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateSlackChannelConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case guardrailPolicyArns = "GuardrailPolicyArns"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case slackChannelId = "SlackChannelId"
        case slackChannelName = "SlackChannelName"
        case snsTopicArns = "SnsTopicArns"
        case userAuthorizationRequired = "UserAuthorizationRequired"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatConfigurationArn = self.chatConfigurationArn {
            try encodeContainer.encode(chatConfigurationArn, forKey: .chatConfigurationArn)
        }
        if let guardrailPolicyArns = guardrailPolicyArns {
            var guardrailPolicyArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .guardrailPolicyArns)
            for guardrailpolicyarn0 in guardrailPolicyArns {
                try guardrailPolicyArnsContainer.encode(guardrailpolicyarn0)
            }
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let loggingLevel = self.loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if let slackChannelId = self.slackChannelId {
            try encodeContainer.encode(slackChannelId, forKey: .slackChannelId)
        }
        if let slackChannelName = self.slackChannelName {
            try encodeContainer.encode(slackChannelName, forKey: .slackChannelName)
        }
        if let snsTopicArns = snsTopicArns {
            var snsTopicArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snsTopicArns)
            for arn0 in snsTopicArns {
                try snsTopicArnsContainer.encode(arn0)
            }
        }
        if let userAuthorizationRequired = self.userAuthorizationRequired {
            try encodeContainer.encode(userAuthorizationRequired, forKey: .userAuthorizationRequired)
        }
    }
}

extension UpdateSlackChannelConfigurationInput {

    static func urlPathProvider(_ value: UpdateSlackChannelConfigurationInput) -> Swift.String? {
        return "/update-slack-channel-configuration"
    }
}

public struct UpdateSlackChannelConfigurationInput: Swift.Equatable {
    /// The ARN of the SlackChannelConfiguration to update.
    /// This member is required.
    public var chatConfigurationArn: Swift.String?
    /// The list of IAM policy ARNs that are applied as channel guardrails. The AWS managed 'AdministratorAccess' policy is applied by default if this is not set.
    public var guardrailPolicyArns: [Swift.String]?
    /// The ARN of the IAM role that defines the permissions for AWS Chatbot. This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see IAM Policies for AWS Chatbot.
    public var iamRoleArn: Swift.String?
    /// Logging levels include ERROR, INFO, or NONE.
    public var loggingLevel: Swift.String?
    /// The ID of the Slack channel. To get the ID, open Slack, right click on the channel name in the left pane, then choose Copy Link. The channel ID is the 9-character string at the end of the URL. For example, ABCBBLZZZ.
    /// This member is required.
    public var slackChannelId: Swift.String?
    /// The name of the Slack Channel.
    public var slackChannelName: Swift.String?
    /// The ARNs of the SNS topics that deliver notifications to AWS Chatbot.
    public var snsTopicArns: [Swift.String]?
    /// Enables use of a user role requirement in your chat configuration.
    public var userAuthorizationRequired: Swift.Bool?

    public init(
        chatConfigurationArn: Swift.String? = nil,
        guardrailPolicyArns: [Swift.String]? = nil,
        iamRoleArn: Swift.String? = nil,
        loggingLevel: Swift.String? = nil,
        slackChannelId: Swift.String? = nil,
        slackChannelName: Swift.String? = nil,
        snsTopicArns: [Swift.String]? = nil,
        userAuthorizationRequired: Swift.Bool? = nil
    )
    {
        self.chatConfigurationArn = chatConfigurationArn
        self.guardrailPolicyArns = guardrailPolicyArns
        self.iamRoleArn = iamRoleArn
        self.loggingLevel = loggingLevel
        self.slackChannelId = slackChannelId
        self.slackChannelName = slackChannelName
        self.snsTopicArns = snsTopicArns
        self.userAuthorizationRequired = userAuthorizationRequired
    }
}

struct UpdateSlackChannelConfigurationInputBody: Swift.Equatable {
    let chatConfigurationArn: Swift.String?
    let slackChannelId: Swift.String?
    let slackChannelName: Swift.String?
    let snsTopicArns: [Swift.String]?
    let iamRoleArn: Swift.String?
    let loggingLevel: Swift.String?
    let guardrailPolicyArns: [Swift.String]?
    let userAuthorizationRequired: Swift.Bool?
}

extension UpdateSlackChannelConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatConfigurationArn = "ChatConfigurationArn"
        case guardrailPolicyArns = "GuardrailPolicyArns"
        case iamRoleArn = "IamRoleArn"
        case loggingLevel = "LoggingLevel"
        case slackChannelId = "SlackChannelId"
        case slackChannelName = "SlackChannelName"
        case snsTopicArns = "SnsTopicArns"
        case userAuthorizationRequired = "UserAuthorizationRequired"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chatConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chatConfigurationArn)
        chatConfigurationArn = chatConfigurationArnDecoded
        let slackChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackChannelId)
        slackChannelId = slackChannelIdDecoded
        let slackChannelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slackChannelName)
        slackChannelName = slackChannelNameDecoded
        let snsTopicArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .snsTopicArns)
        var snsTopicArnsDecoded0:[Swift.String]? = nil
        if let snsTopicArnsContainer = snsTopicArnsContainer {
            snsTopicArnsDecoded0 = [Swift.String]()
            for string0 in snsTopicArnsContainer {
                if let string0 = string0 {
                    snsTopicArnsDecoded0?.append(string0)
                }
            }
        }
        snsTopicArns = snsTopicArnsDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let guardrailPolicyArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .guardrailPolicyArns)
        var guardrailPolicyArnsDecoded0:[Swift.String]? = nil
        if let guardrailPolicyArnsContainer = guardrailPolicyArnsContainer {
            guardrailPolicyArnsDecoded0 = [Swift.String]()
            for string0 in guardrailPolicyArnsContainer {
                if let string0 = string0 {
                    guardrailPolicyArnsDecoded0?.append(string0)
                }
            }
        }
        guardrailPolicyArns = guardrailPolicyArnsDecoded0
        let userAuthorizationRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userAuthorizationRequired)
        userAuthorizationRequired = userAuthorizationRequiredDecoded
    }
}

extension UpdateSlackChannelConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSlackChannelConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelConfiguration = output.channelConfiguration
        } else {
            self.channelConfiguration = nil
        }
    }
}

public struct UpdateSlackChannelConfigurationOutput: Swift.Equatable {
    /// The configuration for a Slack channel configured with AWS Chatbot.
    public var channelConfiguration: ChatbotClientTypes.SlackChannelConfiguration?

    public init(
        channelConfiguration: ChatbotClientTypes.SlackChannelConfiguration? = nil
    )
    {
        self.channelConfiguration = channelConfiguration
    }
}

struct UpdateSlackChannelConfigurationOutputBody: Swift.Equatable {
    let channelConfiguration: ChatbotClientTypes.SlackChannelConfiguration?
}

extension UpdateSlackChannelConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelConfiguration = "ChannelConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelConfigurationDecoded = try containerValues.decodeIfPresent(ChatbotClientTypes.SlackChannelConfiguration.self, forKey: .channelConfiguration)
        channelConfiguration = channelConfigurationDecoded
    }
}

enum UpdateSlackChannelConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UpdateSlackChannelConfigurationException": return try await UpdateSlackChannelConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTeamsChannelConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTeamsChannelConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct UpdateTeamsChannelConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UpdateTeamsChannelConfigurationException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UpdateTeamsChannelConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UpdateTeamsChannelConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
