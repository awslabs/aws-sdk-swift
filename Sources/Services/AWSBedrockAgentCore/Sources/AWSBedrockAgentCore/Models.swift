//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyEventStreams.DefaultMessageDecoder
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ByteStream
import enum Smithy.ClientError
import enum SmithyEventStreamsAPI.MessageType
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
import struct SmithyEventStreams.DefaultMessageDecoderStream
import struct SmithyEventStreamsAPI.Message
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter
import typealias SmithyEventStreamsAPI.UnmarshalClosure

/// The exception that occurs when you do not have sufficient permissions to perform an action. Verify that your IAM policy includes the necessary permissions for the operation you are trying to perform.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains summary information about an actor in an AgentCore Memory resource.
    public struct ActorSummary: Swift.Sendable {
        /// The unique identifier of the actor.
        /// This member is required.
        public var actorId: Swift.String?

        public init(
            actorId: Swift.String? = nil
        ) {
            self.actorId = actorId
        }
    }
}

/// The exception that occurs when the service encounters an unexpected internal error. This is a temporary condition that will resolve itself with retries. We recommend implementing exponential backoff retry logic in your application.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The exception that occurs when the specified resource does not exist. This can happen when using an invalid identifier or when trying to access a resource that has been deleted.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The exception that occurs when there is an error in the runtime client. This can happen due to network issues, invalid configuration, or other client-side problems. Check the error message for specific details about the error.
public struct RuntimeClientError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RuntimeClientError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The exception that occurs when the request would cause a service quota to be exceeded. Review your service quotas and either reduce your request rate or request a quota increase.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The exception that occurs when the request was denied due to request throttling. This happens when you exceed the allowed request rate for an operation. Reduce the frequency of requests or implement exponential backoff retry logic in your application.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockAgentCoreClientTypes {

    /// Stores information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message describing why this field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

extension BedrockAgentCoreClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case idempotentParameterMismatchException
        case resourceConflict
        case rootEventInOtherSession
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .idempotentParameterMismatchException,
                .resourceConflict,
                .rootEventInOtherSession
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CannotParse"
            case .fieldValidationFailed: return "FieldValidationFailed"
            case .idempotentParameterMismatchException: return "IdempotentParameterMismatchException"
            case .resourceConflict: return "ResourceConflict"
            case .rootEventInOtherSession: return "EventInOtherSession"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The exception that occurs when the input fails to satisfy the constraints specified by the service. Check the error message for details about which input parameter is invalid and correct your request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var fieldList: [BedrockAgentCoreClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// This member is required.
        public internal(set) var reason: BedrockAgentCoreClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [BedrockAgentCoreClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: BedrockAgentCoreClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct GetAgentCardInput: Swift.Sendable {
    /// The ARN of the AgentCore Runtime agent for which you want to get the A2A agent card.
    /// This member is required.
    public var agentRuntimeArn: Swift.String?
    /// Optional qualifier to specify an agent alias, such as prodcode> or dev. If you don't provide a value, the DEFAULT alias is used.
    public var qualifier: Swift.String?
    /// The session ID that the AgentCore Runtime agent is using.
    public var runtimeSessionId: Swift.String?

    public init(
        agentRuntimeArn: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        runtimeSessionId: Swift.String? = nil
    ) {
        self.agentRuntimeArn = agentRuntimeArn
        self.qualifier = qualifier
        self.runtimeSessionId = runtimeSessionId
    }
}

public struct GetAgentCardOutput: Swift.Sendable {
    /// An agent card document that contains metadata and capabilities for an AgentCore Runtime agent.
    /// This member is required.
    public var agentCard: Smithy.Document?
    /// The ID of the session associated with the AgentCore Runtime agent.
    public var runtimeSessionId: Swift.String?
    /// The status code of the request.
    public var statusCode: Swift.Int?

    public init(
        agentCard: Smithy.Document? = nil,
        runtimeSessionId: Swift.String? = nil,
        statusCode: Swift.Int? = nil
    ) {
        self.agentCard = agentCard
        self.runtimeSessionId = runtimeSessionId
        self.statusCode = statusCode
    }
}

public struct InvokeAgentRuntimeInput: Swift.Sendable {
    /// The desired MIME type for the response from the agent runtime. This tells the agent runtime what format to use for the response data. Common values include application/json for JSON data.
    public var accept: Swift.String?
    /// The identifier of the Amazon Web Services account for the agent runtime resource.
    public var accountId: Swift.String?
    /// The Amazon Web Services Resource Name (ARN) of the agent runtime to invoke. The ARN uniquely identifies the agent runtime resource in Amazon Bedrock AgentCore.
    /// This member is required.
    public var agentRuntimeArn: Swift.String?
    /// Additional context information for distributed tracing.
    public var baggage: Swift.String?
    /// The MIME type of the input data in the payload. This tells the agent runtime how to interpret the payload data. Common values include application/json for JSON data.
    public var contentType: Swift.String?
    /// The version of the MCP protocol being used.
    public var mcpProtocolVersion: Swift.String?
    /// The identifier of the MCP session.
    public var mcpSessionId: Swift.String?
    /// The input data to send to the agent runtime. The format of this data depends on the specific agent configuration and must match the specified content type. For most agents, this is a JSON object containing the user's request.
    /// This member is required.
    public var payload: Foundation.Data?
    /// The qualifier to use for the agent runtime. This can be a version number or an endpoint name that points to a specific version. If not specified, Amazon Bedrock AgentCore uses the default version of the agent runtime.
    public var qualifier: Swift.String?
    /// The identifier of the runtime session.
    public var runtimeSessionId: Swift.String?
    /// The identifier of the runtime user.
    public var runtimeUserId: Swift.String?
    /// The trace identifier for request tracking.
    public var traceId: Swift.String?
    /// The parent trace information for distributed tracing.
    public var traceParent: Swift.String?
    /// The trace state information for distributed tracing.
    public var traceState: Swift.String?

    public init(
        accept: Swift.String? = nil,
        accountId: Swift.String? = nil,
        agentRuntimeArn: Swift.String? = nil,
        baggage: Swift.String? = nil,
        contentType: Swift.String? = nil,
        mcpProtocolVersion: Swift.String? = nil,
        mcpSessionId: Swift.String? = nil,
        payload: Foundation.Data? = nil,
        qualifier: Swift.String? = nil,
        runtimeSessionId: Swift.String? = nil,
        runtimeUserId: Swift.String? = nil,
        traceId: Swift.String? = nil,
        traceParent: Swift.String? = nil,
        traceState: Swift.String? = nil
    ) {
        self.accept = accept
        self.accountId = accountId
        self.agentRuntimeArn = agentRuntimeArn
        self.baggage = baggage
        self.contentType = contentType
        self.mcpProtocolVersion = mcpProtocolVersion
        self.mcpSessionId = mcpSessionId
        self.payload = payload
        self.qualifier = qualifier
        self.runtimeSessionId = runtimeSessionId
        self.runtimeUserId = runtimeUserId
        self.traceId = traceId
        self.traceParent = traceParent
        self.traceState = traceState
    }
}

extension InvokeAgentRuntimeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeAgentRuntimeInput(accept: \(Swift.String(describing: accept)), accountId: \(Swift.String(describing: accountId)), agentRuntimeArn: \(Swift.String(describing: agentRuntimeArn)), baggage: \(Swift.String(describing: baggage)), contentType: \(Swift.String(describing: contentType)), mcpProtocolVersion: \(Swift.String(describing: mcpProtocolVersion)), mcpSessionId: \(Swift.String(describing: mcpSessionId)), qualifier: \(Swift.String(describing: qualifier)), runtimeSessionId: \(Swift.String(describing: runtimeSessionId)), runtimeUserId: \(Swift.String(describing: runtimeUserId)), traceId: \(Swift.String(describing: traceId)), traceParent: \(Swift.String(describing: traceParent)), traceState: \(Swift.String(describing: traceState)), payload: \"CONTENT_REDACTED\")"}
}

public struct InvokeAgentRuntimeOutput: Swift.Sendable {
    /// Additional context information for distributed tracing.
    public var baggage: Swift.String?
    /// The MIME type of the response data. This indicates how to interpret the response data. Common values include application/json for JSON data.
    /// This member is required.
    public var contentType: Swift.String?
    /// The version of the MCP protocol being used.
    public var mcpProtocolVersion: Swift.String?
    /// The identifier of the MCP session.
    public var mcpSessionId: Swift.String?
    /// The response data from the agent runtime. The format of this data depends on the specific agent configuration and the requested accept type. For most agents, this is a JSON object containing the agent's response to the user's request.
    public var response: Smithy.ByteStream?
    /// The identifier of the runtime session.
    public var runtimeSessionId: Swift.String?
    /// The HTTP status code of the response. A status code of 200 indicates a successful operation. Other status codes indicate various error conditions.
    public var statusCode: Swift.Int?
    /// The trace identifier for request tracking.
    public var traceId: Swift.String?
    /// The parent trace information for distributed tracing.
    public var traceParent: Swift.String?
    /// The trace state information for distributed tracing.
    public var traceState: Swift.String?

    public init(
        baggage: Swift.String? = nil,
        contentType: Swift.String? = nil,
        mcpProtocolVersion: Swift.String? = nil,
        mcpSessionId: Swift.String? = nil,
        response: Smithy.ByteStream? = Smithy.ByteStream.data(Foundation.Data(base64Encoded: "")),
        runtimeSessionId: Swift.String? = nil,
        statusCode: Swift.Int? = nil,
        traceId: Swift.String? = nil,
        traceParent: Swift.String? = nil,
        traceState: Swift.String? = nil
    ) {
        self.baggage = baggage
        self.contentType = contentType
        self.mcpProtocolVersion = mcpProtocolVersion
        self.mcpSessionId = mcpSessionId
        self.response = response
        self.runtimeSessionId = runtimeSessionId
        self.statusCode = statusCode
        self.traceId = traceId
        self.traceParent = traceParent
        self.traceState = traceState
    }
}

extension InvokeAgentRuntimeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeAgentRuntimeOutput(baggage: \(Swift.String(describing: baggage)), contentType: \(Swift.String(describing: contentType)), mcpProtocolVersion: \(Swift.String(describing: mcpProtocolVersion)), mcpSessionId: \(Swift.String(describing: mcpSessionId)), runtimeSessionId: \(Swift.String(describing: runtimeSessionId)), statusCode: \(Swift.String(describing: statusCode)), traceId: \(Swift.String(describing: traceId)), traceParent: \(Swift.String(describing: traceParent)), traceState: \(Swift.String(describing: traceState)), response: \"CONTENT_REDACTED\")"}
}

/// The exception that occurs when the request conflicts with the current state of the resource. This can happen when trying to modify a resource that is currently being modified by another request, or when trying to create a resource that already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown when the JWT bearer token is invalid or not found for OAuth bearer token based access
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct StopRuntimeSessionInput: Swift.Sendable {
    /// The ARN of the agent that contains the session that you want to stop.
    /// This member is required.
    public var agentRuntimeArn: Swift.String?
    /// Idempotent token used to identify the request. If you use the same token with multiple requests, the same response is returned. Use ClientToken to prevent the same request from being processed more than once.
    public var clientToken: Swift.String?
    /// Optional qualifier to specify an agent alias, such as prodcode> or dev. If you don't provide a value, the DEFAULT alias is used.
    public var qualifier: Swift.String?
    /// The ID of the session that you want to stop.
    /// This member is required.
    public var runtimeSessionId: Swift.String?

    public init(
        agentRuntimeArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        runtimeSessionId: Swift.String? = nil
    ) {
        self.agentRuntimeArn = agentRuntimeArn
        self.clientToken = clientToken
        self.qualifier = qualifier
        self.runtimeSessionId = runtimeSessionId
    }
}

public struct StopRuntimeSessionOutput: Swift.Sendable {
    /// The ID of the session that you requested to stop.
    public var runtimeSessionId: Swift.String?
    /// The status code of the request to stop the session.
    public var statusCode: Swift.Int?

    public init(
        runtimeSessionId: Swift.String? = nil,
        statusCode: Swift.Int? = nil
    ) {
        self.runtimeSessionId = runtimeSessionId
        self.statusCode = statusCode
    }
}

public struct SaveBrowserSessionProfileInput: Swift.Sendable {
    /// The unique identifier of the browser associated with the session from which to save the profile.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock AgentCore ignores the request, but does not return an error.
    public var clientToken: Swift.String?
    /// The unique identifier for the browser profile. This identifier is used to reference the profile when starting new browser sessions. The identifier must follow the pattern of an alphanumeric name (up to 48 characters) followed by a hyphen and a 10-character alphanumeric suffix.
    /// This member is required.
    public var profileIdentifier: Swift.String?
    /// The unique identifier of the browser session from which to save the profile. The session must be active when saving the profile.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The trace identifier for request tracking.
    public var traceId: Swift.String?
    /// The parent trace information for distributed tracing.
    public var traceParent: Swift.String?

    public init(
        browserIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        profileIdentifier: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        traceId: Swift.String? = nil,
        traceParent: Swift.String? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.clientToken = clientToken
        self.profileIdentifier = profileIdentifier
        self.sessionId = sessionId
        self.traceId = traceId
        self.traceParent = traceParent
    }
}

public struct SaveBrowserSessionProfileOutput: Swift.Sendable {
    /// The unique identifier of the browser associated with the session from which the profile was saved.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// The timestamp when the browser profile was last updated. This value is in ISO 8601 format.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The unique identifier of the saved browser profile.
    /// This member is required.
    public var profileIdentifier: Swift.String?
    /// The unique identifier of the browser session from which the profile was saved.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        browserIdentifier: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        profileIdentifier: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.lastUpdatedAt = lastUpdatedAt
        self.profileIdentifier = profileIdentifier
        self.sessionId = sessionId
    }
}

public struct GetBrowserSessionInput: Swift.Sendable {
    /// The unique identifier of the browser associated with the session.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// The unique identifier of the browser session to retrieve.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        browserIdentifier: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.sessionId = sessionId
    }
}

extension BedrockAgentCoreClientTypes {

    /// The Amazon S3 location configuration of a resource.
    public struct S3Location: Swift.Sendable {
        /// The name of the Amazon S3 bucket where the resource is stored.
        /// This member is required.
        public var bucket: Swift.String?
        /// The name of the Amazon S3 prefix/key where the resource is stored.
        /// This member is required.
        public var `prefix`: Swift.String?
        /// The name of the Amazon S3 version ID where the resource is stored (Optional).
        public var versionId: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil,
            versionId: Swift.String? = nil
        ) {
            self.bucket = bucket
            self.`prefix` = `prefix`
            self.versionId = versionId
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The location of the browser extension.
    public enum ResourceLocation: Swift.Sendable {
        /// The Amazon S3 location of the resource. Use this when the resource is stored in an Amazon S3 bucket.
        case s3(BedrockAgentCoreClientTypes.S3Location)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    /// Browser extension configuration.
    public struct BrowserExtension: Swift.Sendable {
        /// The location where the browser extension files are stored. This specifies the source from which the extension will be loaded and installed.
        /// This member is required.
        public var location: BedrockAgentCoreClientTypes.ResourceLocation?

        public init(
            location: BedrockAgentCoreClientTypes.ResourceLocation? = nil
        ) {
            self.location = location
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The configuration for a browser profile in Amazon Bedrock AgentCore. A browser profile contains persistent browser data such as cookies and local storage that can be saved from one browser session and reused in subsequent sessions. Browser profiles enable continuity for tasks that require authentication, maintain user preferences, or depend on previously stored browser state.
    public struct BrowserProfileConfiguration: Swift.Sendable {
        /// The unique identifier of the browser profile. This identifier is used to reference the profile when starting new browser sessions or saving session data to the profile.
        /// This member is required.
        public var profileIdentifier: Swift.String?

        public init(
            profileIdentifier: Swift.String? = nil
        ) {
            self.profileIdentifier = profileIdentifier
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Configuration for domains that should bypass all proxies and connect directly to the internet. These bypass rules take precedence over all proxy routing rules.
    public struct ProxyBypass: Swift.Sendable {
        /// Array of domain patterns that should bypass the proxy. Supports .amazonaws.com for subdomain matching or amazonaws.com for exact domain matching. Requests to these domains connect directly without using any proxy. Maximum 253 characters per pattern.
        public var domainPatterns: [Swift.String]?

        public init(
            domainPatterns: [Swift.String]? = nil
        ) {
            self.domainPatterns = domainPatterns
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Configuration for HTTP Basic Authentication using credentials stored in Amazon Web Services Secrets Manager. The secret must contain a JSON object with username and password string fields. Username allows alphanumeric characters and @._+=- symbols (pattern: ^[a-zA-Z0-9@._+=\-]+$). Password allows alphanumeric characters and @._+=-!#$%&* symbols (pattern: ^[a-zA-Z0-9@._+=\-!#$%&*]+$). Both fields have a maximum length of 256 characters.
    public struct BasicAuth: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret containing proxy credentials. The secret must be a JSON object with username and password string fields that meet validation requirements. The caller must have secretsmanager:GetSecretValue permission for this ARN. Example secret format: {"username": "proxy_user", "password": "secure_password"}
        /// This member is required.
        public var secretArn: Swift.String?

        public init(
            secretArn: Swift.String? = nil
        ) {
            self.secretArn = secretArn
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Union type representing different proxy authentication methods. Currently supports HTTP Basic Authentication (username and password).
    public enum ProxyCredentials: Swift.Sendable {
        /// HTTP Basic Authentication credentials (username and password) stored in Amazon Web Services Secrets Manager.
        case basicauth(BedrockAgentCoreClientTypes.BasicAuth)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    /// Configuration for a customer-managed external proxy server. Includes server location, optional domain-based routing patterns, and authentication credentials.
    public struct ExternalProxy: Swift.Sendable {
        /// Optional authentication credentials for the proxy server. If omitted, the proxy is accessed without authentication (useful for IP-allowlisted proxies).
        public var credentials: BedrockAgentCoreClientTypes.ProxyCredentials?
        /// Optional array of domain patterns that should route through this specific proxy. Supports .example.com for subdomain matching (matches any subdomain of example.com) or example.com for exact domain matching. If omitted, this proxy acts as a catch-all for domains not matched by other proxies. Maximum 100 patterns per proxy, each up to 253 characters.
        public var domainPatterns: [Swift.String]?
        /// The port number of the proxy server. Valid range: 1-65535.
        /// This member is required.
        public var port: Swift.Int?
        /// The hostname of the proxy server. Must be a valid DNS hostname (maximum 253 characters).
        /// This member is required.
        public var server: Swift.String?

        public init(
            credentials: BedrockAgentCoreClientTypes.ProxyCredentials? = nil,
            domainPatterns: [Swift.String]? = nil,
            port: Swift.Int? = nil,
            server: Swift.String? = nil
        ) {
            self.credentials = credentials
            self.domainPatterns = domainPatterns
            self.port = port
            self.server = server
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Union type representing different proxy configurations. Currently supports external customer-managed proxies.
    public enum Proxy: Swift.Sendable {
        /// Configuration for an external customer-managed proxy server.
        case externalproxy(BedrockAgentCoreClientTypes.ExternalProxy)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    /// Configuration for routing browser traffic through customer-managed proxy servers. Supports 1-5 proxy servers for domain-based routing and proxy bypass rules.
    public struct ProxyConfiguration: Swift.Sendable {
        /// Optional configuration for domains that should bypass all proxies and connect directly to their destination, like the internet. Takes precedence over all proxy routing rules.
        public var bypass: BedrockAgentCoreClientTypes.ProxyBypass?
        /// An array of 1-5 proxy server configurations for domain-based routing. Each proxy can specify which domains it handles via domainPatterns, enabling flexible routing of different traffic through different proxies based on destination domain.
        /// This member is required.
        public var proxies: [BedrockAgentCoreClientTypes.Proxy]?

        public init(
            bypass: BedrockAgentCoreClientTypes.ProxyBypass? = nil,
            proxies: [BedrockAgentCoreClientTypes.Proxy]? = nil
        ) {
            self.bypass = bypass
            self.proxies = proxies
        }
    }
}

extension BedrockAgentCoreClientTypes {

    public enum BrowserSessionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ready
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [BrowserSessionStatus] {
            return [
                .ready,
                .terminated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ready: return "READY"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    public enum AutomationStreamStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationStreamStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The configuration for a stream that enables programmatic control of a browser session in Amazon Bedrock AgentCore. This stream provides a bidirectional communication channel for sending commands to the browser and receiving responses, allowing agents to automate web interactions such as navigation, form filling, and element clicking.
    public struct AutomationStream: Swift.Sendable {
        /// The endpoint URL for the automation stream. This URL is used to establish a WebSocket connection to the stream for sending commands and receiving responses.
        /// This member is required.
        public var streamEndpoint: Swift.String?
        /// The current status of the automation stream. This indicates whether the stream is available for use. Possible values include ACTIVE, CONNECTING, and DISCONNECTED.
        /// This member is required.
        public var streamStatus: BedrockAgentCoreClientTypes.AutomationStreamStatus?

        public init(
            streamEndpoint: Swift.String? = nil,
            streamStatus: BedrockAgentCoreClientTypes.AutomationStreamStatus? = nil
        ) {
            self.streamEndpoint = streamEndpoint
            self.streamStatus = streamStatus
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The configuration for a stream that provides a visual representation of a browser session in Amazon Bedrock AgentCore. This stream enables agents to observe the current state of the browser, including rendered web pages, visual elements, and the results of interactions.
    public struct LiveViewStream: Swift.Sendable {
        /// The endpoint URL for the live view stream. This URL is used to establish a connection to receive visual updates from the browser session.
        public var streamEndpoint: Swift.String?

        public init(
            streamEndpoint: Swift.String? = nil
        ) {
            self.streamEndpoint = streamEndpoint
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The collection of streams associated with a browser session in Amazon Bedrock AgentCore. These streams provide different ways to interact with and observe the browser session, including programmatic control and visual representation of the browser content.
    public struct BrowserSessionStream: Swift.Sendable {
        /// The stream that enables programmatic control of the browser. This stream allows agents to perform actions such as navigating to URLs, clicking elements, and filling forms.
        /// This member is required.
        public var automationStream: BedrockAgentCoreClientTypes.AutomationStream?
        /// The stream that provides a visual representation of the browser content. This stream allows agents to observe the current state of the browser, including rendered web pages and visual elements.
        public var liveViewStream: BedrockAgentCoreClientTypes.LiveViewStream?

        public init(
            automationStream: BedrockAgentCoreClientTypes.AutomationStream? = nil,
            liveViewStream: BedrockAgentCoreClientTypes.LiveViewStream? = nil
        ) {
            self.automationStream = automationStream
            self.liveViewStream = liveViewStream
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The configuration that defines the dimensions of a browser viewport in a browser session. The viewport determines the visible area of web content and affects how web pages are rendered and displayed. Proper viewport configuration ensures that web content is displayed correctly for the agent's browsing tasks.
    public struct ViewPort: Swift.Sendable {
        /// The height of the viewport in pixels. This value determines the vertical dimension of the visible area. Valid values range from 600 to 1080 pixels.
        /// This member is required.
        public var height: Swift.Int?
        /// The width of the viewport in pixels. This value determines the horizontal dimension of the visible area. Valid values range from 800 to 1920 pixels.
        /// This member is required.
        public var width: Swift.Int?

        public init(
            height: Swift.Int? = nil,
            width: Swift.Int? = nil
        ) {
            self.height = height
            self.width = width
        }
    }
}

public struct GetBrowserSessionOutput: Swift.Sendable {
    /// The identifier of the browser.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// The time at which the browser session was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The list of browser extensions that are configured in the browser session.
    public var extensions: [BedrockAgentCoreClientTypes.BrowserExtension]?
    /// The time at which the browser session was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the browser session.
    public var name: Swift.String?
    /// The browser profile configuration associated with this session. Contains the profile identifier that links to persistent browser data such as cookies and local storage.
    public var profileConfiguration: BedrockAgentCoreClientTypes.BrowserProfileConfiguration?
    /// The active proxy configuration for this browser session. This field is only present if proxy configuration was provided when the session was started using StartBrowserSession. The configuration includes proxy servers, domain bypass rules and the proxy authentication credentials.
    public var proxyConfiguration: BedrockAgentCoreClientTypes.ProxyConfiguration?
    /// The identifier of the browser session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The artifact containing the session replay information.
    public var sessionReplayArtifact: Swift.String?
    /// The timeout period for the browser session in seconds.
    public var sessionTimeoutSeconds: Swift.Int?
    /// The current status of the browser session. Possible values include ACTIVE, STOPPING, and STOPPED.
    public var status: BedrockAgentCoreClientTypes.BrowserSessionStatus?
    /// The streams associated with this browser session. These include the automation stream and live view stream.
    public var streams: BedrockAgentCoreClientTypes.BrowserSessionStream?
    /// The configuration that defines the dimensions of a browser viewport in a browser session. The viewport determines the visible area of web content and affects how web pages are rendered and displayed. Proper viewport configuration ensures that web content is displayed correctly for the agent's browsing tasks.
    public var viewPort: BedrockAgentCoreClientTypes.ViewPort?

    public init(
        browserIdentifier: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        extensions: [BedrockAgentCoreClientTypes.BrowserExtension]? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        profileConfiguration: BedrockAgentCoreClientTypes.BrowserProfileConfiguration? = nil,
        proxyConfiguration: BedrockAgentCoreClientTypes.ProxyConfiguration? = nil,
        sessionId: Swift.String? = nil,
        sessionReplayArtifact: Swift.String? = nil,
        sessionTimeoutSeconds: Swift.Int? = nil,
        status: BedrockAgentCoreClientTypes.BrowserSessionStatus? = nil,
        streams: BedrockAgentCoreClientTypes.BrowserSessionStream? = nil,
        viewPort: BedrockAgentCoreClientTypes.ViewPort? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.createdAt = createdAt
        self.extensions = extensions
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.profileConfiguration = profileConfiguration
        self.proxyConfiguration = proxyConfiguration
        self.sessionId = sessionId
        self.sessionReplayArtifact = sessionReplayArtifact
        self.sessionTimeoutSeconds = sessionTimeoutSeconds
        self.status = status
        self.streams = streams
        self.viewPort = viewPort
    }
}

public struct ListBrowserSessionsInput: Swift.Sendable {
    /// The unique identifier of the browser to list sessions for. If specified, only sessions for this browser are returned. If not specified, sessions for all browsers are returned.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// The maximum number of results to return in a single call. The default value is 10. Valid values range from 1 to 100. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. If not specified, Amazon Bedrock AgentCore returns the first page of results.
    public var nextToken: Swift.String?
    /// The status of the browser sessions to list. Valid values include ACTIVE, STOPPING, and STOPPED. If not specified, sessions with any status are returned.
    public var status: BedrockAgentCoreClientTypes.BrowserSessionStatus?

    public init(
        browserIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: BedrockAgentCoreClientTypes.BrowserSessionStatus? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension BedrockAgentCoreClientTypes {

    /// A condensed representation of a browser session in Amazon Bedrock AgentCore. This structure contains key information about a browser session, including identifiers, status, and timestamps, without the full details of the session configuration and streams.
    public struct BrowserSessionSummary: Swift.Sendable {
        /// The unique identifier of the browser associated with the session. This identifier specifies which browser environment is used for the session.
        /// This member is required.
        public var browserIdentifier: Swift.String?
        /// The timestamp when the browser session was created. This value is in ISO 8601 format.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The timestamp when the browser session was last updated. This value is in ISO 8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the browser session. This name helps identify and manage the session.
        public var name: Swift.String?
        /// The unique identifier of the browser session. This identifier is used in operations that interact with the session.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The current status of the browser session. Possible values include ACTIVE, STOPPING, and STOPPED.
        /// This member is required.
        public var status: BedrockAgentCoreClientTypes.BrowserSessionStatus?

        public init(
            browserIdentifier: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            status: BedrockAgentCoreClientTypes.BrowserSessionStatus? = nil
        ) {
            self.browserIdentifier = browserIdentifier
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.sessionId = sessionId
            self.status = status
        }
    }
}

public struct ListBrowserSessionsOutput: Swift.Sendable {
    /// The list of browser sessions that match the specified criteria.
    /// This member is required.
    public var items: [BedrockAgentCoreClientTypes.BrowserSessionSummary]?
    /// The token to use in a subsequent ListBrowserSessions request to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [BedrockAgentCoreClientTypes.BrowserSessionSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct StartBrowserSessionInput: Swift.Sendable {
    /// The unique identifier of the browser to use for this session. This identifier specifies which browser environment to initialize for the session.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock AgentCore ignores the request, but does not return an error. This parameter helps prevent the creation of duplicate sessions if there are temporary network issues.
    public var clientToken: Swift.String?
    /// A list of browser extensions to load into the browser session.
    public var extensions: [BedrockAgentCoreClientTypes.BrowserExtension]?
    /// The name of the browser session. This name helps you identify and manage the session. The name does not need to be unique.
    public var name: Swift.String?
    /// The browser profile configuration to use for this session. A browser profile contains persistent data such as cookies and local storage that can be reused across multiple browser sessions. If specified, the session initializes with the profile's stored data, enabling continuity for tasks that require authentication or personalized settings.
    public var profileConfiguration: BedrockAgentCoreClientTypes.BrowserProfileConfiguration?
    /// Optional proxy configuration for routing browser traffic through customer-specified proxy servers. When provided, enables HTTP Basic authentication via Amazon Web Services Secrets Manager and domain-based routing rules. Requires secretsmanager:GetSecretValue IAM permission for the specified secret ARNs.
    public var proxyConfiguration: BedrockAgentCoreClientTypes.ProxyConfiguration?
    /// The time in seconds after which the session automatically terminates if there is no activity. The default value is 3600 seconds (1 hour). The minimum allowed value is 60 seconds, and the maximum allowed value is 28800 seconds (8 hours).
    public var sessionTimeoutSeconds: Swift.Int?
    /// The trace identifier for request tracking.
    public var traceId: Swift.String?
    /// The parent trace information for distributed tracing.
    public var traceParent: Swift.String?
    /// The dimensions of the browser viewport for this session. This determines the visible area of the web content and affects how web pages are rendered. If not specified, Amazon Bedrock AgentCore uses a default viewport size.
    public var viewPort: BedrockAgentCoreClientTypes.ViewPort?

    public init(
        browserIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        extensions: [BedrockAgentCoreClientTypes.BrowserExtension]? = nil,
        name: Swift.String? = nil,
        profileConfiguration: BedrockAgentCoreClientTypes.BrowserProfileConfiguration? = nil,
        proxyConfiguration: BedrockAgentCoreClientTypes.ProxyConfiguration? = nil,
        sessionTimeoutSeconds: Swift.Int? = nil,
        traceId: Swift.String? = nil,
        traceParent: Swift.String? = nil,
        viewPort: BedrockAgentCoreClientTypes.ViewPort? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.clientToken = clientToken
        self.extensions = extensions
        self.name = name
        self.profileConfiguration = profileConfiguration
        self.proxyConfiguration = proxyConfiguration
        self.sessionTimeoutSeconds = sessionTimeoutSeconds
        self.traceId = traceId
        self.traceParent = traceParent
        self.viewPort = viewPort
    }
}

public struct StartBrowserSessionOutput: Swift.Sendable {
    /// The identifier of the browser.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// The timestamp when the browser session was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The unique identifier of the created browser session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The streams associated with this browser session. These include the automation stream and live view stream.
    public var streams: BedrockAgentCoreClientTypes.BrowserSessionStream?

    public init(
        browserIdentifier: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        sessionId: Swift.String? = nil,
        streams: BedrockAgentCoreClientTypes.BrowserSessionStream? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.createdAt = createdAt
        self.sessionId = sessionId
        self.streams = streams
    }
}

public struct StopBrowserSessionInput: Swift.Sendable {
    /// The unique identifier of the browser associated with the session.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock AgentCore ignores the request, but does not return an error.
    public var clientToken: Swift.String?
    /// The unique identifier of the browser session to stop.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The trace identifier for request tracking.
    public var traceId: Swift.String?
    /// The parent trace information for distributed tracing.
    public var traceParent: Swift.String?

    public init(
        browserIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        traceId: Swift.String? = nil,
        traceParent: Swift.String? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.traceId = traceId
        self.traceParent = traceParent
    }
}

public struct StopBrowserSessionOutput: Swift.Sendable {
    /// The identifier of the browser.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// The time at which the browser session was last updated.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The identifier of the browser session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        browserIdentifier: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.lastUpdatedAt = lastUpdatedAt
        self.sessionId = sessionId
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains information about an update to an automation stream.
    public struct AutomationStreamUpdate: Swift.Sendable {
        /// The status of the automation stream.
        public var streamStatus: BedrockAgentCoreClientTypes.AutomationStreamStatus?

        public init(
            streamStatus: BedrockAgentCoreClientTypes.AutomationStreamStatus? = nil
        ) {
            self.streamStatus = streamStatus
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains information about an update to a stream.
    public enum StreamUpdate: Swift.Sendable {
        /// The update to an automation stream.
        case automationstreamupdate(BedrockAgentCoreClientTypes.AutomationStreamUpdate)
        case sdkUnknown(Swift.String)
    }
}

public struct UpdateBrowserStreamInput: Swift.Sendable {
    /// The identifier of the browser.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
    public var clientToken: Swift.String?
    /// The identifier of the browser session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The update to apply to the browser stream.
    /// This member is required.
    public var streamUpdate: BedrockAgentCoreClientTypes.StreamUpdate?

    public init(
        browserIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        streamUpdate: BedrockAgentCoreClientTypes.StreamUpdate? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.streamUpdate = streamUpdate
    }
}

public struct UpdateBrowserStreamOutput: Swift.Sendable {
    /// The identifier of the browser.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// The identifier of the browser session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The collection of streams associated with a browser session in Amazon Bedrock AgentCore. These streams provide different ways to interact with and observe the browser session, including programmatic control and visual representation of the browser content.
    /// This member is required.
    public var streams: BedrockAgentCoreClientTypes.BrowserSessionStream?
    /// The time at which the browser stream was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        browserIdentifier: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        streams: BedrockAgentCoreClientTypes.BrowserSessionStream? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.sessionId = sessionId
        self.streams = streams
        self.updatedAt = updatedAt
    }
}

public struct GetCodeInterpreterSessionInput: Swift.Sendable {
    /// The unique identifier of the code interpreter associated with the session.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The unique identifier of the code interpreter session to retrieve.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        codeInterpreterIdentifier: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.sessionId = sessionId
    }
}

extension BedrockAgentCoreClientTypes {

    public enum CodeInterpreterSessionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ready
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeInterpreterSessionStatus] {
            return [
                .ready,
                .terminated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ready: return "READY"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetCodeInterpreterSessionOutput: Swift.Sendable {
    /// The identifier of the code interpreter.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The time at which the code interpreter session was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The name of the code interpreter session.
    public var name: Swift.String?
    /// The identifier of the code interpreter session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The timeout period for the code interpreter session in seconds.
    public var sessionTimeoutSeconds: Swift.Int?
    /// The current status of the code interpreter session. Possible values include ACTIVE, STOPPING, and STOPPED.
    public var status: BedrockAgentCoreClientTypes.CodeInterpreterSessionStatus?

    public init(
        codeInterpreterIdentifier: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionTimeoutSeconds: Swift.Int? = nil,
        status: BedrockAgentCoreClientTypes.CodeInterpreterSessionStatus? = nil
    ) {
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.createdAt = createdAt
        self.name = name
        self.sessionId = sessionId
        self.sessionTimeoutSeconds = sessionTimeoutSeconds
        self.status = status
    }
}

public struct ListCodeInterpreterSessionsInput: Swift.Sendable {
    /// The unique identifier of the code interpreter to list sessions for. If specified, only sessions for this code interpreter are returned. If not specified, sessions for all code interpreters are returned.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The maximum number of results to return in a single call. The default value is 10. Valid values range from 1 to 100. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. If not specified, Amazon Bedrock AgentCore returns the first page of results.
    public var nextToken: Swift.String?
    /// The status of the code interpreter sessions to list. Valid values include ACTIVE, STOPPING, and STOPPED. If not specified, sessions with any status are returned.
    public var status: BedrockAgentCoreClientTypes.CodeInterpreterSessionStatus?

    public init(
        codeInterpreterIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: BedrockAgentCoreClientTypes.CodeInterpreterSessionStatus? = nil
    ) {
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension BedrockAgentCoreClientTypes {

    /// A condensed representation of a code interpreter session in Amazon Bedrock AgentCore. This structure contains key information about a code interpreter session, including identifiers, status, and timestamps, without the full details of the session configuration.
    public struct CodeInterpreterSessionSummary: Swift.Sendable {
        /// The unique identifier of the code interpreter associated with the session. This identifier specifies which code interpreter environment is used for the session.
        /// This member is required.
        public var codeInterpreterIdentifier: Swift.String?
        /// The timestamp when the code interpreter session was created. This value is in ISO 8601 format.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The timestamp when the code interpreter session was last updated. This value is in ISO 8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the code interpreter session. This name helps identify and manage the session.
        public var name: Swift.String?
        /// The unique identifier of the code interpreter session. This identifier is used in operations that interact with the session.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The current status of the code interpreter session. Possible values include ACTIVE, STOPPING, and STOPPED.
        /// This member is required.
        public var status: BedrockAgentCoreClientTypes.CodeInterpreterSessionStatus?

        public init(
            codeInterpreterIdentifier: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            status: BedrockAgentCoreClientTypes.CodeInterpreterSessionStatus? = nil
        ) {
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.sessionId = sessionId
            self.status = status
        }
    }
}

public struct ListCodeInterpreterSessionsOutput: Swift.Sendable {
    /// The list of code interpreter sessions that match the specified criteria.
    /// This member is required.
    public var items: [BedrockAgentCoreClientTypes.CodeInterpreterSessionSummary]?
    /// The token to use in a subsequent ListCodeInterpreterSessions request to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [BedrockAgentCoreClientTypes.CodeInterpreterSessionSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct StartCodeInterpreterSessionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock AgentCore ignores the request, but does not return an error. This parameter helps prevent the creation of duplicate sessions if there are temporary network issues.
    public var clientToken: Swift.String?
    /// The unique identifier of the code interpreter to use for this session. This identifier specifies which code interpreter environment to initialize for the session.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The name of the code interpreter session. This name helps you identify and manage the session. The name does not need to be unique.
    public var name: Swift.String?
    /// The time in seconds after which the session automatically terminates if there is no activity. The default value is 900 seconds (15 minutes). The minimum allowed value is 60 seconds, and the maximum allowed value is 28800 seconds (8 hours).
    public var sessionTimeoutSeconds: Swift.Int?
    /// The trace identifier for request tracking.
    public var traceId: Swift.String?
    /// The parent trace information for distributed tracing.
    public var traceParent: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        codeInterpreterIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        sessionTimeoutSeconds: Swift.Int? = nil,
        traceId: Swift.String? = nil,
        traceParent: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.name = name
        self.sessionTimeoutSeconds = sessionTimeoutSeconds
        self.traceId = traceId
        self.traceParent = traceParent
    }
}

public struct StartCodeInterpreterSessionOutput: Swift.Sendable {
    /// The identifier of the code interpreter.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The time at which the code interpreter session was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The unique identifier of the created code interpreter session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        codeInterpreterIdentifier: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.createdAt = createdAt
        self.sessionId = sessionId
    }
}

public struct StopCodeInterpreterSessionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock AgentCore ignores the request, but does not return an error.
    public var clientToken: Swift.String?
    /// The unique identifier of the code interpreter associated with the session.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The unique identifier of the code interpreter session to stop.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The trace identifier for request tracking.
    public var traceId: Swift.String?
    /// The parent trace information for distributed tracing.
    public var traceParent: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        codeInterpreterIdentifier: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        traceId: Swift.String? = nil,
        traceParent: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.sessionId = sessionId
        self.traceId = traceId
        self.traceParent = traceParent
    }
}

public struct StopCodeInterpreterSessionOutput: Swift.Sendable {
    /// The identifier of the code interpreter.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The timestamp when the code interpreter session was last updated.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The identifier of the code interpreter session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        codeInterpreterIdentifier: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.lastUpdatedAt = lastUpdatedAt
        self.sessionId = sessionId
    }
}

extension BedrockAgentCoreClientTypes {

    /// The OAuth2.0 token or user ID that was used to generate the workload access token used for initiating the user authorization flow to retrieve OAuth2.0 tokens.
    public enum UserIdentifier: Swift.Sendable {
        /// The OAuth2.0 token issued by the users identity provider
        case usertoken(Swift.String)
        /// The ID of the user for whom you have retrieved a workload access token for
        case userid(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

public struct CompleteResourceTokenAuthInput: Swift.Sendable {
    /// Unique identifier for the user's authentication session for retrieving OAuth2 tokens. This ID tracks the authorization flow state across multiple requests and responses during the OAuth2 authentication process.
    /// This member is required.
    public var sessionUri: Swift.String?
    /// The OAuth2.0 token or user ID that was used to generate the workload access token used for initiating the user authorization flow to retrieve OAuth2.0 tokens.
    /// This member is required.
    public var userIdentifier: BedrockAgentCoreClientTypes.UserIdentifier?

    public init(
        sessionUri: Swift.String? = nil,
        userIdentifier: BedrockAgentCoreClientTypes.UserIdentifier? = nil
    ) {
        self.sessionUri = sessionUri
        self.userIdentifier = userIdentifier
    }
}

public struct CompleteResourceTokenAuthOutput: Swift.Sendable {

    public init() { }
}

/// An exception thrown when attempting to create a resource with an identifier that already exists.
public struct DuplicateIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateIdException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockAgentCoreClientTypes {

    /// The input data structure containing agent session spans in OpenTelemetry format. Supports traces from frameworks like Strands (AgentCore Runtime) and LangGraph with OpenInference instrumentation for comprehensive evaluation.
    public enum EvaluationInput: Swift.Sendable {
        /// The collection of spans representing agent execution traces within a session. Each span contains detailed information about tool calls, model interactions, and other agent activities that can be evaluated for quality and performance.
        case sessionspans([Smithy.Document])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    /// The specification of which trace or span IDs to evaluate within the provided input data. Allows precise targeting of evaluation at different levels: tool calls, traces, or sessions.
    public enum EvaluationTarget: Swift.Sendable {
        /// The list of specific span IDs to evaluate within the provided traces. Used to target evaluation at individual tool calls or specific operations within the agent's execution flow.
        case spanids([Swift.String])
        /// The list of trace IDs to evaluate, representing complete request-response interactions. Used to evaluate entire conversation turns or specific agent interactions within a session.
        case traceids([Swift.String])
        case sdkUnknown(Swift.String)
    }
}

public struct EvaluateInput: Swift.Sendable {
    /// The input data containing agent session spans to be evaluated. Includes a list of spans in OpenTelemetry format from supported frameworks like Strands (AgentCore Runtime) or LangGraph with OpenInference instrumentation.
    /// This member is required.
    public var evaluationInput: BedrockAgentCoreClientTypes.EvaluationInput?
    /// The specific trace or span IDs to evaluate within the provided input. Allows targeting evaluation at different levels: individual tool calls, single request-response interactions (traces), or entire conversation sessions.
    public var evaluationTarget: BedrockAgentCoreClientTypes.EvaluationTarget?
    /// The unique identifier of the evaluator to use for scoring. Can be a built-in evaluator (e.g., Builtin.Helpfulness, Builtin.Correctness) or a custom evaluator ARN created through the control plane API.
    /// This member is required.
    public var evaluatorId: Swift.String?

    public init(
        evaluationInput: BedrockAgentCoreClientTypes.EvaluationInput? = nil,
        evaluationTarget: BedrockAgentCoreClientTypes.EvaluationTarget? = nil,
        evaluatorId: Swift.String? = nil
    ) {
        self.evaluationInput = evaluationInput
        self.evaluationTarget = evaluationTarget
        self.evaluatorId = evaluatorId
    }
}

extension BedrockAgentCoreClientTypes {

    /// The contextual information that uniquely identifies a span within the distributed tracing system. Contains session, trace, and span identifiers used to correlate evaluation results with specific agent execution points.
    public struct SpanContext: Swift.Sendable {
        /// The unique identifier of the session containing this span. Sessions represent complete conversation flows and are detected using configurable SessionTimeoutMinutes (default 15 minutes).
        /// This member is required.
        public var sessionId: Swift.String?
        /// The unique identifier of the specific span being referenced. Spans represent individual operations like tool calls, model invocations, or other discrete actions within the agent's execution.
        public var spanId: Swift.String?
        /// The unique identifier of the trace containing this span. Traces represent individual request-response interactions within a session and group related spans together.
        public var traceId: Swift.String?

        public init(
            sessionId: Swift.String? = nil,
            spanId: Swift.String? = nil,
            traceId: Swift.String? = nil
        ) {
            self.sessionId = sessionId
            self.spanId = spanId
            self.traceId = traceId
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The contextual information associated with an evaluation, including span context details that identify the specific traces and sessions being evaluated within the agent's execution flow.
    public enum Context: Swift.Sendable {
        /// The span context information that uniquely identifies the trace and span being evaluated, including session ID, trace ID, and span ID for precise targeting within the agent's execution flow.
        case spancontext(BedrockAgentCoreClientTypes.SpanContext)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    /// The token consumption statistics for language model operations during evaluation. Provides detailed breakdown of input, output, and total tokens used for cost tracking and performance monitoring.
    public struct TokenUsage: Swift.Sendable {
        /// The number of tokens consumed for input processing during the evaluation. Includes tokens from the evaluation prompt, agent traces, and any additional context provided to the evaluator model.
        public var inputTokens: Swift.Int?
        /// The number of tokens generated by the evaluator model in its response. Includes tokens for the score, explanation, and any additional output produced during the evaluation process.
        public var outputTokens: Swift.Int?
        /// The total number of tokens consumed during the evaluation, calculated as the sum of input and output tokens. Used for cost calculation and rate limiting within the service limits.
        public var totalTokens: Swift.Int?

        public init(
            inputTokens: Swift.Int? = nil,
            outputTokens: Swift.Int? = nil,
            totalTokens: Swift.Int? = nil
        ) {
            self.inputTokens = inputTokens
            self.outputTokens = outputTokens
            self.totalTokens = totalTokens
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The comprehensive result of an evaluation containing the score, explanation, evaluator metadata, and execution details. Provides both quantitative ratings and qualitative insights about agent performance.
    public struct EvaluationResultContent: Swift.Sendable {
        /// The contextual information associated with this evaluation result, including span context details that identify the specific traces and sessions that were evaluated.
        /// This member is required.
        public var context: BedrockAgentCoreClientTypes.Context?
        /// The error code indicating the type of failure that occurred during evaluation. Used to programmatically identify and handle different categories of evaluation errors.
        public var errorCode: Swift.String?
        /// The error message describing what went wrong if the evaluation failed. Provides detailed information about evaluation failures to help diagnose and resolve issues with evaluator configuration or input data.
        public var errorMessage: Swift.String?
        /// The Amazon Resource Name (ARN) of the evaluator used to generate this result. For custom evaluators, this is the full ARN; for built-in evaluators, this follows the pattern Builtin.{EvaluatorName}.
        /// This member is required.
        public var evaluatorArn: Swift.String?
        /// The unique identifier of the evaluator that produced this result. This matches the evaluatorId provided in the evaluation request and can be used to identify which evaluator generated specific results.
        /// This member is required.
        public var evaluatorId: Swift.String?
        /// The human-readable name of the evaluator used for this evaluation. For built-in evaluators, this is the descriptive name (e.g., "Helpfulness", "Correctness"); for custom evaluators, this is the user-defined name.
        /// This member is required.
        public var evaluatorName: Swift.String?
        /// The detailed explanation provided by the evaluator describing the reasoning behind the assigned score. This qualitative feedback helps understand why specific ratings were given and provides actionable insights for improvement.
        public var explanation: Swift.String?
        /// The categorical label assigned by the evaluator when using a categorical rating scale. This provides a human-readable description of the evaluation result (e.g., "Excellent", "Good", "Poor") corresponding to the numerical value. For numerical scales, this field is optional and provides a natural language explanation of what the value means (e.g., value 0.5 = "Somewhat Helpful").
        public var label: Swift.String?
        /// The token consumption statistics for this evaluation, including input tokens, output tokens, and total tokens used by the underlying language model during the evaluation process.
        public var tokenUsage: BedrockAgentCoreClientTypes.TokenUsage?
        /// The numerical score assigned by the evaluator according to its configured rating scale. For numerical scales, this is a decimal value within the defined range. This field is not allowed for categorical scales.
        public var value: Swift.Double?

        public init(
            context: BedrockAgentCoreClientTypes.Context? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            evaluatorArn: Swift.String? = nil,
            evaluatorId: Swift.String? = nil,
            evaluatorName: Swift.String? = nil,
            explanation: Swift.String? = nil,
            label: Swift.String? = nil,
            tokenUsage: BedrockAgentCoreClientTypes.TokenUsage? = nil,
            value: Swift.Double? = nil
        ) {
            self.context = context
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.evaluatorArn = evaluatorArn
            self.evaluatorId = evaluatorId
            self.evaluatorName = evaluatorName
            self.explanation = explanation
            self.label = label
            self.tokenUsage = tokenUsage
            self.value = value
        }
    }
}

extension BedrockAgentCoreClientTypes.EvaluationResultContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluationResultContent(context: \(Swift.String(describing: context)), errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), evaluatorArn: \(Swift.String(describing: evaluatorArn)), evaluatorId: \(Swift.String(describing: evaluatorId)), evaluatorName: \(Swift.String(describing: evaluatorName)), label: \(Swift.String(describing: label)), tokenUsage: \(Swift.String(describing: tokenUsage)), value: \(Swift.String(describing: value)), explanation: \"CONTENT_REDACTED\")"}
}

public struct EvaluateOutput: Swift.Sendable {
    /// The detailed evaluation results containing scores, explanations, and metadata. Includes the evaluator information, numerical or categorical ratings based on the evaluator's rating scale, and token usage statistics for the evaluation process.
    /// This member is required.
    public var evaluationResults: [BedrockAgentCoreClientTypes.EvaluationResultContent]?

    public init(
        evaluationResults: [BedrockAgentCoreClientTypes.EvaluationResultContent]? = nil
    ) {
        self.evaluationResults = evaluationResults
    }
}

public struct GetResourceApiKeyInput: Swift.Sendable {
    /// The credential provider name for the resource from which you are retrieving the API key.
    /// This member is required.
    public var resourceCredentialProviderName: Swift.String?
    /// The identity token of the workload from which you want to retrieve the API key.
    /// This member is required.
    public var workloadIdentityToken: Swift.String?

    public init(
        resourceCredentialProviderName: Swift.String? = nil,
        workloadIdentityToken: Swift.String? = nil
    ) {
        self.resourceCredentialProviderName = resourceCredentialProviderName
        self.workloadIdentityToken = workloadIdentityToken
    }
}

extension GetResourceApiKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceApiKeyInput(resourceCredentialProviderName: \(Swift.String(describing: resourceCredentialProviderName)), workloadIdentityToken: \"CONTENT_REDACTED\")"}
}

public struct GetResourceApiKeyOutput: Swift.Sendable {
    /// The API key associated with the resource requested.
    /// This member is required.
    public var apiKey: Swift.String?

    public init(
        apiKey: Swift.String? = nil
    ) {
        self.apiKey = apiKey
    }
}

extension GetResourceApiKeyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceApiKeyOutput(apiKey: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreClientTypes {

    public enum Oauth2FlowType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case m2m
        case userFederation
        case sdkUnknown(Swift.String)

        public static var allCases: [Oauth2FlowType] {
            return [
                .m2m,
                .userFederation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .m2m: return "M2M"
            case .userFederation: return "USER_FEDERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetResourceOauth2TokenInput: Swift.Sendable {
    /// A map of custom parameters to include in the authorization request to the resource credential provider. These parameters are in addition to the standard OAuth 2.0 flow parameters, and will not override them.
    public var customParameters: [Swift.String: Swift.String]?
    /// An opaque string that will be sent back to the callback URL provided in resourceOauth2ReturnUrl. This state should be used to protect the callback URL of your application against CSRF attacks by ensuring the response corresponds to the original request.
    public var customState: Swift.String?
    /// Indicates whether to always initiate a new three-legged OAuth (3LO) flow, regardless of any existing session.
    public var forceAuthentication: Swift.Bool?
    /// The type of flow to be performed.
    /// This member is required.
    public var oauth2Flow: BedrockAgentCoreClientTypes.Oauth2FlowType?
    /// The name of the resource's credential provider.
    /// This member is required.
    public var resourceCredentialProviderName: Swift.String?
    /// The callback URL to redirect to after the OAuth 2.0 token retrieval is complete. This URL must be one of the provided URLs configured for the workload identity.
    public var resourceOauth2ReturnUrl: Swift.String?
    /// The OAuth scopes being requested.
    /// This member is required.
    public var scopes: [Swift.String]?
    /// Unique identifier for the user's authentication session for retrieving OAuth2 tokens. This ID tracks the authorization flow state across multiple requests and responses during the OAuth2 authentication process.
    public var sessionUri: Swift.String?
    /// The identity token of the workload from which you want to retrieve the OAuth2 token.
    /// This member is required.
    public var workloadIdentityToken: Swift.String?

    public init(
        customParameters: [Swift.String: Swift.String]? = nil,
        customState: Swift.String? = nil,
        forceAuthentication: Swift.Bool? = nil,
        oauth2Flow: BedrockAgentCoreClientTypes.Oauth2FlowType? = nil,
        resourceCredentialProviderName: Swift.String? = nil,
        resourceOauth2ReturnUrl: Swift.String? = nil,
        scopes: [Swift.String]? = nil,
        sessionUri: Swift.String? = nil,
        workloadIdentityToken: Swift.String? = nil
    ) {
        self.customParameters = customParameters
        self.customState = customState
        self.forceAuthentication = forceAuthentication
        self.oauth2Flow = oauth2Flow
        self.resourceCredentialProviderName = resourceCredentialProviderName
        self.resourceOauth2ReturnUrl = resourceOauth2ReturnUrl
        self.scopes = scopes
        self.sessionUri = sessionUri
        self.workloadIdentityToken = workloadIdentityToken
    }
}

extension GetResourceOauth2TokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceOauth2TokenInput(forceAuthentication: \(Swift.String(describing: forceAuthentication)), oauth2Flow: \(Swift.String(describing: oauth2Flow)), resourceCredentialProviderName: \(Swift.String(describing: resourceCredentialProviderName)), resourceOauth2ReturnUrl: \(Swift.String(describing: resourceOauth2ReturnUrl)), scopes: \(Swift.String(describing: scopes)), sessionUri: \(Swift.String(describing: sessionUri)), customParameters: [keys: \(Swift.String(describing: customParameters?.keys)), values: \"CONTENT_REDACTED\"], customState: \"CONTENT_REDACTED\", workloadIdentityToken: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreClientTypes {

    public enum SessionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionStatus] {
            return [
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetResourceOauth2TokenOutput: Swift.Sendable {
    /// The OAuth 2.0 access token to use.
    public var accessToken: Swift.String?
    /// The URL to initiate the authorization process, provided when the access token requires user authorization.
    public var authorizationUrl: Swift.String?
    /// Status indicating whether the user's authorization session is in progress or has failed. This helps determine the next steps in the OAuth2 authentication flow.
    public var sessionStatus: BedrockAgentCoreClientTypes.SessionStatus?
    /// Unique identifier for the user's authorization session for retrieving OAuth2 tokens. This matches the sessionId from the request and can be used to track the session state.
    public var sessionUri: Swift.String?

    public init(
        accessToken: Swift.String? = nil,
        authorizationUrl: Swift.String? = nil,
        sessionStatus: BedrockAgentCoreClientTypes.SessionStatus? = nil,
        sessionUri: Swift.String? = nil
    ) {
        self.accessToken = accessToken
        self.authorizationUrl = authorizationUrl
        self.sessionStatus = sessionStatus
        self.sessionUri = sessionUri
    }
}

extension GetResourceOauth2TokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceOauth2TokenOutput(sessionStatus: \(Swift.String(describing: sessionStatus)), sessionUri: \(Swift.String(describing: sessionUri)), accessToken: \"CONTENT_REDACTED\", authorizationUrl: \"CONTENT_REDACTED\")"}
}

public struct GetWorkloadAccessTokenInput: Swift.Sendable {
    /// The unique identifier for the registered workload.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        workloadName: Swift.String? = nil
    ) {
        self.workloadName = workloadName
    }
}

public struct GetWorkloadAccessTokenOutput: Swift.Sendable {
    /// An opaque token representing the identity of both the workload and the user.
    /// This member is required.
    public var workloadAccessToken: Swift.String?

    public init(
        workloadAccessToken: Swift.String? = nil
    ) {
        self.workloadAccessToken = workloadAccessToken
    }
}

extension GetWorkloadAccessTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkloadAccessTokenOutput(workloadAccessToken: \"CONTENT_REDACTED\")"}
}

public struct GetWorkloadAccessTokenForJWTInput: Swift.Sendable {
    /// The OAuth 2.0 token issued by the user's identity provider.
    /// This member is required.
    public var userToken: Swift.String?
    /// The unique identifier for the registered workload.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        userToken: Swift.String? = nil,
        workloadName: Swift.String? = nil
    ) {
        self.userToken = userToken
        self.workloadName = workloadName
    }
}

extension GetWorkloadAccessTokenForJWTInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkloadAccessTokenForJWTInput(workloadName: \(Swift.String(describing: workloadName)), userToken: \"CONTENT_REDACTED\")"}
}

public struct GetWorkloadAccessTokenForJWTOutput: Swift.Sendable {
    /// An opaque token representing the identity of both the workload and the user.
    /// This member is required.
    public var workloadAccessToken: Swift.String?

    public init(
        workloadAccessToken: Swift.String? = nil
    ) {
        self.workloadAccessToken = workloadAccessToken
    }
}

extension GetWorkloadAccessTokenForJWTOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkloadAccessTokenForJWTOutput(workloadAccessToken: \"CONTENT_REDACTED\")"}
}

public struct GetWorkloadAccessTokenForUserIdInput: Swift.Sendable {
    /// The ID of the user for whom you are retrieving the access token.
    /// This member is required.
    public var userId: Swift.String?
    /// The name of the workload from which you want to retrieve the access token.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        userId: Swift.String? = nil,
        workloadName: Swift.String? = nil
    ) {
        self.userId = userId
        self.workloadName = workloadName
    }
}

public struct GetWorkloadAccessTokenForUserIdOutput: Swift.Sendable {
    /// The access token for the specified workload.
    /// This member is required.
    public var workloadAccessToken: Swift.String?

    public init(
        workloadAccessToken: Swift.String? = nil
    ) {
        self.workloadAccessToken = workloadAccessToken
    }
}

extension GetWorkloadAccessTokenForUserIdOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkloadAccessTokenForUserIdOutput(workloadAccessToken: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreClientTypes {

    /// A block of input content.
    public struct InputContentBlock: Swift.Sendable {
        /// The binary input content.
        public var blob: Foundation.Data?
        /// The path to the input content.
        /// This member is required.
        public var path: Swift.String?
        /// The text input content.
        public var text: Swift.String?

        public init(
            blob: Foundation.Data? = nil,
            path: Swift.String? = nil,
            text: Swift.String? = nil
        ) {
            self.blob = blob
            self.path = path
            self.text = text
        }
    }
}

extension BedrockAgentCoreClientTypes.InputContentBlock: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputContentBlock(path: \(Swift.String(describing: path)), text: \(Swift.String(describing: text)), blob: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreClientTypes {

    public enum ProgrammingLanguage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case javascript
        case python
        case typescript
        case sdkUnknown(Swift.String)

        public static var allCases: [ProgrammingLanguage] {
            return [
                .javascript,
                .python,
                .typescript
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .javascript: return "javascript"
            case .python: return "python"
            case .typescript: return "typescript"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The collection of arguments that specify the operation to perform and its parameters when invoking a tool in Amazon Bedrock AgentCore. Different tools require different arguments, and this structure provides a flexible way to pass the appropriate arguments to each tool type.
    public struct ToolArguments: Swift.Sendable {
        /// Whether to clear the context for the tool.
        public var clearContext: Swift.Bool?
        /// The code to execute in a code interpreter session. This is the source code in the specified programming language that will be executed by the code interpreter.
        public var code: Swift.String?
        /// The command to execute with the tool.
        public var command: Swift.String?
        /// The content for the tool operation.
        public var content: [BedrockAgentCoreClientTypes.InputContentBlock]?
        /// The directory path for the tool operation.
        public var directoryPath: Swift.String?
        /// The programming language of the code to execute. This tells the code interpreter which language runtime to use for execution. Common values include 'python', 'javascript', and 'r'.
        public var language: BedrockAgentCoreClientTypes.ProgrammingLanguage?
        /// The path for the tool operation.
        public var path: Swift.String?
        /// The paths for the tool operation.
        public var paths: [Swift.String]?
        /// The identifier of the task for the tool operation.
        public var taskId: Swift.String?

        public init(
            clearContext: Swift.Bool? = nil,
            code: Swift.String? = nil,
            command: Swift.String? = nil,
            content: [BedrockAgentCoreClientTypes.InputContentBlock]? = nil,
            directoryPath: Swift.String? = nil,
            language: BedrockAgentCoreClientTypes.ProgrammingLanguage? = nil,
            path: Swift.String? = nil,
            paths: [Swift.String]? = nil,
            taskId: Swift.String? = nil
        ) {
            self.clearContext = clearContext
            self.code = code
            self.command = command
            self.content = content
            self.directoryPath = directoryPath
            self.language = language
            self.path = path
            self.paths = paths
            self.taskId = taskId
        }
    }
}

extension BedrockAgentCoreClientTypes {

    public enum ToolName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case executeCode
        case executeCommand
        case getTask
        case listFiles
        case readFiles
        case removeFiles
        case startCommandExecution
        case stopTask
        case writeFiles
        case sdkUnknown(Swift.String)

        public static var allCases: [ToolName] {
            return [
                .executeCode,
                .executeCommand,
                .getTask,
                .listFiles,
                .readFiles,
                .removeFiles,
                .startCommandExecution,
                .stopTask,
                .writeFiles
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .executeCode: return "executeCode"
            case .executeCommand: return "executeCommand"
            case .getTask: return "getTask"
            case .listFiles: return "listFiles"
            case .readFiles: return "readFiles"
            case .removeFiles: return "removeFiles"
            case .startCommandExecution: return "startCommandExecution"
            case .stopTask: return "stopTask"
            case .writeFiles: return "writeFiles"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct InvokeCodeInterpreterInput: Swift.Sendable {
    /// The arguments for the code interpreter. This includes the code to execute and any additional parameters such as the programming language, whether to clear the execution context, and other execution options. The structure of this parameter depends on the specific code interpreter being used.
    public var arguments: BedrockAgentCoreClientTypes.ToolArguments?
    /// The unique identifier of the code interpreter associated with the session. This must match the identifier used when creating the session with StartCodeInterpreterSession.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The name of the code interpreter to invoke.
    /// This member is required.
    public var name: BedrockAgentCoreClientTypes.ToolName?
    /// The unique identifier of the code interpreter session to use. This must be an active session created with StartCodeInterpreterSession. If the session has expired or been stopped, the request will fail.
    public var sessionId: Swift.String?
    /// The trace identifier for request tracking.
    public var traceId: Swift.String?
    /// The parent trace information for distributed tracing.
    public var traceParent: Swift.String?

    public init(
        arguments: BedrockAgentCoreClientTypes.ToolArguments? = nil,
        codeInterpreterIdentifier: Swift.String? = nil,
        name: BedrockAgentCoreClientTypes.ToolName? = nil,
        sessionId: Swift.String? = nil,
        traceId: Swift.String? = nil,
        traceParent: Swift.String? = nil
    ) {
        self.arguments = arguments
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.name = name
        self.sessionId = sessionId
        self.traceId = traceId
        self.traceParent = traceParent
    }
}

extension BedrockAgentCoreClientTypes {

    public enum ResourceContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blob
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceContentType] {
            return [
                .blob,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blob: return "blob"
            case .text: return "text"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains information about resource content.
    public struct ResourceContent: Swift.Sendable {
        /// The binary resource content.
        public var blob: Foundation.Data?
        /// The MIME type of the resource content.
        public var mimeType: Swift.String?
        /// The text resource content.
        public var text: Swift.String?
        /// The type of resource content.
        /// This member is required.
        public var type: BedrockAgentCoreClientTypes.ResourceContentType?
        /// The URI of the resource content.
        public var uri: Swift.String?

        public init(
            blob: Foundation.Data? = nil,
            mimeType: Swift.String? = nil,
            text: Swift.String? = nil,
            type: BedrockAgentCoreClientTypes.ResourceContentType? = nil,
            uri: Swift.String? = nil
        ) {
            self.blob = blob
            self.mimeType = mimeType
            self.text = text
            self.type = type
            self.uri = uri
        }
    }
}

extension BedrockAgentCoreClientTypes {

    public enum ContentBlockType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case embeddedResource
        case image
        case resourceLink
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentBlockType] {
            return [
                .embeddedResource,
                .image,
                .resourceLink,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .embeddedResource: return "resource"
            case .image: return "image"
            case .resourceLink: return "resource_link"
            case .text: return "text"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// A block of content in a response.
    public struct ContentBlock: Swift.Sendable {
        /// The binary data content of the block.
        public var data: Foundation.Data?
        /// The description of the content block.
        public var description: Swift.String?
        /// The MIME type of the content.
        public var mimeType: Swift.String?
        /// The name of the content block.
        public var name: Swift.String?
        /// The resource associated with the content block.
        public var resource: BedrockAgentCoreClientTypes.ResourceContent?
        /// The size of the content in bytes.
        public var size: Swift.Int?
        /// The text content of the block.
        public var text: Swift.String?
        /// The type of content in the block.
        /// This member is required.
        public var type: BedrockAgentCoreClientTypes.ContentBlockType?
        /// The URI of the content.
        public var uri: Swift.String?

        public init(
            data: Foundation.Data? = nil,
            description: Swift.String? = nil,
            mimeType: Swift.String? = nil,
            name: Swift.String? = nil,
            resource: BedrockAgentCoreClientTypes.ResourceContent? = nil,
            size: Swift.Int? = nil,
            text: Swift.String? = nil,
            type: BedrockAgentCoreClientTypes.ContentBlockType? = nil,
            uri: Swift.String? = nil
        ) {
            self.data = data
            self.description = description
            self.mimeType = mimeType
            self.name = name
            self.resource = resource
            self.size = size
            self.text = text
            self.type = type
            self.uri = uri
        }
    }
}

extension BedrockAgentCoreClientTypes {

    public enum TaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case submitted
        case working
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .submitted,
                .working
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "canceled"
            case .completed: return "completed"
            case .failed: return "failed"
            case .submitted: return "submitted"
            case .working: return "working"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains structured content from a tool result.
    public struct ToolResultStructuredContent: Swift.Sendable {
        /// The execution time of the tool operation in milliseconds.
        public var executionTime: Swift.Double?
        /// The exit code from the tool execution.
        public var exitCode: Swift.Int?
        /// The standard error output from the tool execution.
        public var stderr: Swift.String?
        /// The standard output from the tool execution.
        public var stdout: Swift.String?
        /// The identifier of the task that produced the result.
        public var taskId: Swift.String?
        /// The status of the task that produced the result.
        public var taskStatus: BedrockAgentCoreClientTypes.TaskStatus?

        public init(
            executionTime: Swift.Double? = nil,
            exitCode: Swift.Int? = nil,
            stderr: Swift.String? = nil,
            stdout: Swift.String? = nil,
            taskId: Swift.String? = nil,
            taskStatus: BedrockAgentCoreClientTypes.TaskStatus? = nil
        ) {
            self.executionTime = executionTime
            self.exitCode = exitCode
            self.stderr = stderr
            self.stdout = stdout
            self.taskId = taskId
            self.taskStatus = taskStatus
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The output produced by executing code in a code interpreter session in Amazon Bedrock AgentCore. This structure contains the results of code execution, including textual output, structured data, and error information. Agents use these results to generate responses that incorporate computation, data analysis, and visualization.
    public struct CodeInterpreterResult: Swift.Sendable {
        /// The textual content of the execution result. This includes standard output from the code execution, such as print statements, console output, and text representations of results.
        /// This member is required.
        public var content: [BedrockAgentCoreClientTypes.ContentBlock]?
        /// Indicates whether the result represents an error. If true, the content contains error messages or exception information. If false, the content contains successful execution results.
        public var isError: Swift.Bool?
        /// The structured content of the execution result. This includes additional metadata about the execution, such as execution time, memory usage, and structured representations of output data. The format depends on the specific code interpreter and execution context.
        public var structuredContent: BedrockAgentCoreClientTypes.ToolResultStructuredContent?

        public init(
            content: [BedrockAgentCoreClientTypes.ContentBlock]? = nil,
            isError: Swift.Bool? = nil,
            structuredContent: BedrockAgentCoreClientTypes.ToolResultStructuredContent? = nil
        ) {
            self.content = content
            self.isError = isError
            self.structuredContent = structuredContent
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains output from a code interpreter stream.
    public enum CodeInterpreterStreamOutput: Swift.Sendable {
        /// The output produced by executing code in a code interpreter session in Amazon Bedrock AgentCore. This structure contains the results of code execution, including textual output, structured data, and error information. Agents use these results to generate responses that incorporate computation, data analysis, and visualization.
        case result(BedrockAgentCoreClientTypes.CodeInterpreterResult)
        case sdkUnknown(Swift.String)
    }
}

public struct InvokeCodeInterpreterOutput: Swift.Sendable {
    /// The identifier of the code interpreter session.
    public var sessionId: Swift.String?
    /// The stream containing the results of the code execution. This includes output, errors, and execution status.
    /// This member is required.
    public var stream: AsyncThrowingStream<BedrockAgentCoreClientTypes.CodeInterpreterStreamOutput, Swift.Error>?

    public init(
        sessionId: Swift.String? = nil,
        stream: AsyncThrowingStream<BedrockAgentCoreClientTypes.CodeInterpreterStreamOutput, Swift.Error>? = nil
    ) {
        self.sessionId = sessionId
        self.stream = stream
    }
}

/// The service encountered an internal error. Try your request again later.
public struct ServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling. Reduce the frequency of requests and try again.
public struct ThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains the content of a memory record.
    public enum MemoryContent: Swift.Sendable {
        /// The text content of the memory record.
        case text(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    /// Input structure to create a new memory record.
    public struct MemoryRecordCreateInput: Swift.Sendable {
        /// The content to be stored within the memory record.
        /// This member is required.
        public var content: BedrockAgentCoreClientTypes.MemoryContent?
        /// The ID of the memory strategy that defines how this memory record is grouped.
        public var memoryStrategyId: Swift.String?
        /// A list of namespace identifiers that categorize or group the memory record.
        /// This member is required.
        public var namespaces: [Swift.String]?
        /// A client-provided identifier for tracking this specific record creation request.
        /// This member is required.
        public var requestIdentifier: Swift.String?
        /// Time at which the memory record was created.
        /// This member is required.
        public var timestamp: Foundation.Date?

        public init(
            content: BedrockAgentCoreClientTypes.MemoryContent? = nil,
            memoryStrategyId: Swift.String? = nil,
            namespaces: [Swift.String]? = nil,
            requestIdentifier: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        ) {
            self.content = content
            self.memoryStrategyId = memoryStrategyId
            self.namespaces = namespaces
            self.requestIdentifier = requestIdentifier
            self.timestamp = timestamp
        }
    }
}

public struct BatchCreateMemoryRecordsInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure idempotent processing of the batch request.
    public var clientToken: Swift.String?
    /// The unique ID of the memory resource where records will be created.
    /// This member is required.
    public var memoryId: Swift.String?
    /// A list of memory record creation inputs to be processed in the batch operation.
    /// This member is required.
    public var records: [BedrockAgentCoreClientTypes.MemoryRecordCreateInput]?

    public init(
        clientToken: Swift.String? = nil,
        memoryId: Swift.String? = nil,
        records: [BedrockAgentCoreClientTypes.MemoryRecordCreateInput]? = nil
    ) {
        self.clientToken = clientToken
        self.memoryId = memoryId
        self.records = records
    }
}

extension BedrockAgentCoreClientTypes {

    public enum MemoryRecordStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [MemoryRecordStatus] {
            return [
                .failed,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Output information returned after processing a memory record operation.
    public struct MemoryRecordOutput: Swift.Sendable {
        /// The error code returned when the memory record operation fails.
        public var errorCode: Swift.Int?
        /// A human-readable error message describing why the memory record operation failed.
        public var errorMessage: Swift.String?
        /// The unique ID associated to the memory record.
        /// This member is required.
        public var memoryRecordId: Swift.String?
        /// The client-provided identifier that was used to track this record operation.
        public var requestIdentifier: Swift.String?
        /// The status of the memory record operation (e.g., SUCCEEDED, FAILED).
        /// This member is required.
        public var status: BedrockAgentCoreClientTypes.MemoryRecordStatus?

        public init(
            errorCode: Swift.Int? = nil,
            errorMessage: Swift.String? = nil,
            memoryRecordId: Swift.String? = nil,
            requestIdentifier: Swift.String? = nil,
            status: BedrockAgentCoreClientTypes.MemoryRecordStatus? = nil
        ) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memoryRecordId = memoryRecordId
            self.requestIdentifier = requestIdentifier
            self.status = status
        }
    }
}

public struct BatchCreateMemoryRecordsOutput: Swift.Sendable {
    /// A list of memory records that failed to be created, including error details for each failure.
    /// This member is required.
    public var failedRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]?
    /// A list of memory records that were successfully created during the batch operation.
    /// This member is required.
    public var successfulRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]?

    public init(
        failedRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]? = nil,
        successfulRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]? = nil
    ) {
        self.failedRecords = failedRecords
        self.successfulRecords = successfulRecords
    }
}

extension BedrockAgentCoreClientTypes {

    /// Input structure to delete an existing memory record.
    public struct MemoryRecordDeleteInput: Swift.Sendable {
        /// The unique ID of the memory record to be deleted.
        /// This member is required.
        public var memoryRecordId: Swift.String?

        public init(
            memoryRecordId: Swift.String? = nil
        ) {
            self.memoryRecordId = memoryRecordId
        }
    }
}

public struct BatchDeleteMemoryRecordsInput: Swift.Sendable {
    /// The unique ID of the memory resource where records will be deleted.
    /// This member is required.
    public var memoryId: Swift.String?
    /// A list of memory record deletion inputs to be processed in the batch operation.
    /// This member is required.
    public var records: [BedrockAgentCoreClientTypes.MemoryRecordDeleteInput]?

    public init(
        memoryId: Swift.String? = nil,
        records: [BedrockAgentCoreClientTypes.MemoryRecordDeleteInput]? = nil
    ) {
        self.memoryId = memoryId
        self.records = records
    }
}

public struct BatchDeleteMemoryRecordsOutput: Swift.Sendable {
    /// A list of memory records that failed to be deleted, including error details for each failure.
    /// This member is required.
    public var failedRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]?
    /// A list of memory records that were successfully deleted during the batch operation.
    /// This member is required.
    public var successfulRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]?

    public init(
        failedRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]? = nil,
        successfulRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]? = nil
    ) {
        self.failedRecords = failedRecords
        self.successfulRecords = successfulRecords
    }
}

extension BedrockAgentCoreClientTypes {

    /// Input structure to update an existing memory record.
    public struct MemoryRecordUpdateInput: Swift.Sendable {
        /// The content to be stored within the memory record.
        public var content: BedrockAgentCoreClientTypes.MemoryContent?
        /// The unique ID of the memory record to be updated.
        /// This member is required.
        public var memoryRecordId: Swift.String?
        /// The updated ID of the memory strategy that defines how this memory record is grouped.
        public var memoryStrategyId: Swift.String?
        /// The updated list of namespace identifiers for categorizing the memory record.
        public var namespaces: [Swift.String]?
        /// Time at which the memory record was updated
        /// This member is required.
        public var timestamp: Foundation.Date?

        public init(
            content: BedrockAgentCoreClientTypes.MemoryContent? = nil,
            memoryRecordId: Swift.String? = nil,
            memoryStrategyId: Swift.String? = nil,
            namespaces: [Swift.String]? = nil,
            timestamp: Foundation.Date? = nil
        ) {
            self.content = content
            self.memoryRecordId = memoryRecordId
            self.memoryStrategyId = memoryStrategyId
            self.namespaces = namespaces
            self.timestamp = timestamp
        }
    }
}

public struct BatchUpdateMemoryRecordsInput: Swift.Sendable {
    /// The unique ID of the memory resource where records will be updated.
    /// This member is required.
    public var memoryId: Swift.String?
    /// A list of memory record update inputs to be processed in the batch operation.
    /// This member is required.
    public var records: [BedrockAgentCoreClientTypes.MemoryRecordUpdateInput]?

    public init(
        memoryId: Swift.String? = nil,
        records: [BedrockAgentCoreClientTypes.MemoryRecordUpdateInput]? = nil
    ) {
        self.memoryId = memoryId
        self.records = records
    }
}

public struct BatchUpdateMemoryRecordsOutput: Swift.Sendable {
    /// A list of memory records that failed to be updated, including error details for each failure.
    /// This member is required.
    public var failedRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]?
    /// A list of memory records that were successfully updated during the batch operation.
    /// This member is required.
    public var successfulRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]?

    public init(
        failedRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]? = nil,
        successfulRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]? = nil
    ) {
        self.failedRecords = failedRecords
        self.successfulRecords = successfulRecords
    }
}

/// The input fails to satisfy the constraints specified by AgentCore. Check your input values and try again.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The exception that occurs when there is a retryable conflict performing an operation. This is a temporary condition that may resolve itself with retries. We recommend implementing exponential backoff retry logic in your application.
public struct RetryableConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RetryableConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains information about a branch in an AgentCore Memory resource. Branches allow for organizing events into different conversation threads or paths.
    public struct Branch: Swift.Sendable {
        /// The name of the branch.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the root event for this branch.
        public var rootEventId: Swift.String?

        public init(
            name: Swift.String? = nil,
            rootEventId: Swift.String? = nil
        ) {
            self.name = name
            self.rootEventId = rootEventId
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Value associated with the eventMetadata key.
    public enum MetadataValue: Swift.Sendable {
        /// Value associated with the eventMetadata key.
        case stringvalue(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains the content of a memory item.
    public enum Content: Swift.Sendable {
        /// The text content of the memory item.
        case text(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    public enum Role: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assistant
        case other
        case tool
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [Role] {
            return [
                .assistant,
                .other,
                .tool,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assistant: return "ASSISTANT"
            case .other: return "OTHER"
            case .tool: return "TOOL"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains conversational content for an event payload.
    public struct Conversational: Swift.Sendable {
        /// The content of the conversation message.
        /// This member is required.
        public var content: BedrockAgentCoreClientTypes.Content?
        /// The role of the participant in the conversation (for example, "user" or "assistant").
        /// This member is required.
        public var role: BedrockAgentCoreClientTypes.Role?

        public init(
            content: BedrockAgentCoreClientTypes.Content? = nil,
            role: BedrockAgentCoreClientTypes.Role? = nil
        ) {
            self.content = content
            self.role = role
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains the payload content for an event.
    public enum PayloadType: Swift.Sendable {
        /// The conversational content of the payload.
        case conversational(BedrockAgentCoreClientTypes.Conversational)
        /// The binary content of the payload.
        case blob(Smithy.Document)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateEventInput: Swift.Sendable {
    /// The identifier of the actor associated with this event. An actor represents an entity that participates in sessions and generates events.
    /// This member is required.
    public var actorId: Swift.String?
    /// The branch information for this event. Branches allow for organizing events into different conversation threads or paths.
    public var branch: BedrockAgentCoreClientTypes.Branch?
    /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, AgentCore ignores the request, but does not return an error.
    public var clientToken: Swift.String?
    /// The timestamp when the event occurred. If not specified, the current time is used.
    /// This member is required.
    public var eventTimestamp: Foundation.Date?
    /// The identifier of the AgentCore Memory resource in which to create the event.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The key-value metadata to attach to the event.
    public var metadata: [Swift.String: BedrockAgentCoreClientTypes.MetadataValue]?
    /// The content payload of the event. This can include conversational data or binary content.
    /// This member is required.
    public var payload: [BedrockAgentCoreClientTypes.PayloadType]?
    /// The identifier of the session in which this event occurs. A session represents a sequence of related events.
    public var sessionId: Swift.String?

    public init(
        actorId: Swift.String? = nil,
        branch: BedrockAgentCoreClientTypes.Branch? = nil,
        clientToken: Swift.String? = nil,
        eventTimestamp: Foundation.Date? = nil,
        memoryId: Swift.String? = nil,
        metadata: [Swift.String: BedrockAgentCoreClientTypes.MetadataValue]? = nil,
        payload: [BedrockAgentCoreClientTypes.PayloadType]? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.actorId = actorId
        self.branch = branch
        self.clientToken = clientToken
        self.eventTimestamp = eventTimestamp
        self.memoryId = memoryId
        self.metadata = metadata
        self.payload = payload
        self.sessionId = sessionId
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains information about an event in an AgentCore Memory resource.
    public struct Event: Swift.Sendable {
        /// The identifier of the actor associated with the event.
        /// This member is required.
        public var actorId: Swift.String?
        /// The branch information for the event.
        public var branch: BedrockAgentCoreClientTypes.Branch?
        /// The unique identifier of the event.
        /// This member is required.
        public var eventId: Swift.String?
        /// The timestamp when the event occurred.
        /// This member is required.
        public var eventTimestamp: Foundation.Date?
        /// The identifier of the AgentCore Memory resource containing the event.
        /// This member is required.
        public var memoryId: Swift.String?
        /// Metadata associated with an event.
        public var metadata: [Swift.String: BedrockAgentCoreClientTypes.MetadataValue]?
        /// The content payload of the event.
        /// This member is required.
        public var payload: [BedrockAgentCoreClientTypes.PayloadType]?
        /// The identifier of the session containing the event.
        /// This member is required.
        public var sessionId: Swift.String?

        public init(
            actorId: Swift.String? = nil,
            branch: BedrockAgentCoreClientTypes.Branch? = nil,
            eventId: Swift.String? = nil,
            eventTimestamp: Foundation.Date? = nil,
            memoryId: Swift.String? = nil,
            metadata: [Swift.String: BedrockAgentCoreClientTypes.MetadataValue]? = nil,
            payload: [BedrockAgentCoreClientTypes.PayloadType]? = nil,
            sessionId: Swift.String? = nil
        ) {
            self.actorId = actorId
            self.branch = branch
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.memoryId = memoryId
            self.metadata = metadata
            self.payload = payload
            self.sessionId = sessionId
        }
    }
}

public struct CreateEventOutput: Swift.Sendable {
    /// The event that was created.
    /// This member is required.
    public var event: BedrockAgentCoreClientTypes.Event?

    public init(
        event: BedrockAgentCoreClientTypes.Event? = nil
    ) {
        self.event = event
    }
}

public struct DeleteEventInput: Swift.Sendable {
    /// The identifier of the actor associated with the event to delete.
    /// This member is required.
    public var actorId: Swift.String?
    /// The identifier of the event to delete.
    /// This member is required.
    public var eventId: Swift.String?
    /// The identifier of the AgentCore Memory resource from which to delete the event.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The identifier of the session containing the event to delete.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        actorId: Swift.String? = nil,
        eventId: Swift.String? = nil,
        memoryId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.actorId = actorId
        self.eventId = eventId
        self.memoryId = memoryId
        self.sessionId = sessionId
    }
}

public struct DeleteEventOutput: Swift.Sendable {
    /// The identifier of the event that was deleted.
    /// This member is required.
    public var eventId: Swift.String?

    public init(
        eventId: Swift.String? = nil
    ) {
        self.eventId = eventId
    }
}

public struct DeleteMemoryRecordInput: Swift.Sendable {
    /// The identifier of the AgentCore Memory resource from which to delete the memory record.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The identifier of the memory record to delete.
    /// This member is required.
    public var memoryRecordId: Swift.String?

    public init(
        memoryId: Swift.String? = nil,
        memoryRecordId: Swift.String? = nil
    ) {
        self.memoryId = memoryId
        self.memoryRecordId = memoryRecordId
    }
}

public struct DeleteMemoryRecordOutput: Swift.Sendable {
    /// The identifier of the memory record that was deleted.
    /// This member is required.
    public var memoryRecordId: Swift.String?

    public init(
        memoryRecordId: Swift.String? = nil
    ) {
        self.memoryRecordId = memoryRecordId
    }
}

public struct GetEventInput: Swift.Sendable {
    /// The identifier of the actor associated with the event.
    /// This member is required.
    public var actorId: Swift.String?
    /// The identifier of the event to retrieve.
    /// This member is required.
    public var eventId: Swift.String?
    /// The identifier of the AgentCore Memory resource containing the event.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The identifier of the session containing the event.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        actorId: Swift.String? = nil,
        eventId: Swift.String? = nil,
        memoryId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.actorId = actorId
        self.eventId = eventId
        self.memoryId = memoryId
        self.sessionId = sessionId
    }
}

public struct GetEventOutput: Swift.Sendable {
    /// The requested event information.
    /// This member is required.
    public var event: BedrockAgentCoreClientTypes.Event?

    public init(
        event: BedrockAgentCoreClientTypes.Event? = nil
    ) {
        self.event = event
    }
}

public struct GetMemoryRecordInput: Swift.Sendable {
    /// The identifier of the AgentCore Memory resource containing the memory record.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The identifier of the memory record to retrieve.
    /// This member is required.
    public var memoryRecordId: Swift.String?

    public init(
        memoryId: Swift.String? = nil,
        memoryRecordId: Swift.String? = nil
    ) {
        self.memoryId = memoryId
        self.memoryRecordId = memoryRecordId
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains information about a memory record in an AgentCore Memory resource.
    public struct MemoryRecord: Swift.Sendable {
        /// The content of the memory record.
        /// This member is required.
        public var content: BedrockAgentCoreClientTypes.MemoryContent?
        /// The timestamp when the memory record was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the memory record.
        /// This member is required.
        public var memoryRecordId: Swift.String?
        /// The identifier of the memory strategy associated with this record.
        /// This member is required.
        public var memoryStrategyId: Swift.String?
        /// A map of metadata key-value pairs associated with a memory record.
        public var metadata: [Swift.String: BedrockAgentCoreClientTypes.MetadataValue]?
        /// The namespaces associated with this memory record. Namespaces help organize and categorize memory records.
        /// This member is required.
        public var namespaces: [Swift.String]?

        public init(
            content: BedrockAgentCoreClientTypes.MemoryContent? = nil,
            createdAt: Foundation.Date? = nil,
            memoryRecordId: Swift.String? = nil,
            memoryStrategyId: Swift.String? = nil,
            metadata: [Swift.String: BedrockAgentCoreClientTypes.MetadataValue]? = nil,
            namespaces: [Swift.String]? = nil
        ) {
            self.content = content
            self.createdAt = createdAt
            self.memoryRecordId = memoryRecordId
            self.memoryStrategyId = memoryStrategyId
            self.metadata = metadata
            self.namespaces = namespaces
        }
    }
}

public struct GetMemoryRecordOutput: Swift.Sendable {
    /// The requested memory record.
    /// This member is required.
    public var memoryRecord: BedrockAgentCoreClientTypes.MemoryRecord?

    public init(
        memoryRecord: BedrockAgentCoreClientTypes.MemoryRecord? = nil
    ) {
        self.memoryRecord = memoryRecord
    }
}

public struct ListActorsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. The default value is 20.
    public var maxResults: Swift.Int?
    /// The identifier of the AgentCore Memory resource for which to list actors.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        memoryId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.memoryId = memoryId
        self.nextToken = nextToken
    }
}

public struct ListActorsOutput: Swift.Sendable {
    /// The list of actor summaries.
    /// This member is required.
    public var actorSummaries: [BedrockAgentCoreClientTypes.ActorSummary]?
    /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        actorSummaries: [BedrockAgentCoreClientTypes.ActorSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.actorSummaries = actorSummaries
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains filter criteria for branches when listing events.
    public struct BranchFilter: Swift.Sendable {
        /// Specifies whether to include parent branches in the results. Set to true to include parent branches, or false to exclude them.
        public var includeParentBranches: Swift.Bool?
        /// The name of the branch to filter by.
        /// This member is required.
        public var name: Swift.String?

        public init(
            includeParentBranches: Swift.Bool? = true,
            name: Swift.String? = nil
        ) {
            self.includeParentBranches = includeParentBranches
            self.name = name
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Left expression of the event metadata filter.
    public enum LeftExpression: Swift.Sendable {
        /// Key associated with the metadata in an event.
        case metadatakey(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    public enum OperatorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equalsTo
        case exists
        case notExists
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatorType] {
            return [
                .equalsTo,
                .exists,
                .notExists
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equalsTo: return "EQUALS_TO"
            case .exists: return "EXISTS"
            case .notExists: return "NOT_EXISTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Right expression of the eventMetadatafilter.
    public enum RightExpression: Swift.Sendable {
        /// Value associated with the key in eventMetadata.
        case metadatavalue(BedrockAgentCoreClientTypes.MetadataValue)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    /// Filter expression for retrieving events based on metadata associated with an event.
    public struct EventMetadataFilterExpression: Swift.Sendable {
        /// Left operand of the event metadata filter expression.
        /// This member is required.
        public var `left`: BedrockAgentCoreClientTypes.LeftExpression?
        /// Operator applied to the event metadata filter expression.
        /// This member is required.
        public var `operator`: BedrockAgentCoreClientTypes.OperatorType?
        /// Right operand of the event metadata filter expression.
        public var `right`: BedrockAgentCoreClientTypes.RightExpression?

        public init(
            `left`: BedrockAgentCoreClientTypes.LeftExpression? = nil,
            `operator`: BedrockAgentCoreClientTypes.OperatorType? = nil,
            `right`: BedrockAgentCoreClientTypes.RightExpression? = nil
        ) {
            self.`left` = `left`
            self.`operator` = `operator`
            self.`right` = `right`
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains filter criteria for listing events.
    public struct FilterInput: Swift.Sendable {
        /// The branch filter criteria to apply when listing events.
        public var branch: BedrockAgentCoreClientTypes.BranchFilter?
        /// Event metadata filter criteria to apply when retrieving events.
        public var eventMetadata: [BedrockAgentCoreClientTypes.EventMetadataFilterExpression]?

        public init(
            branch: BedrockAgentCoreClientTypes.BranchFilter? = nil,
            eventMetadata: [BedrockAgentCoreClientTypes.EventMetadataFilterExpression]? = nil
        ) {
            self.branch = branch
            self.eventMetadata = eventMetadata
        }
    }
}

public struct ListEventsInput: Swift.Sendable {
    /// The identifier of the actor for which to list events.
    /// This member is required.
    public var actorId: Swift.String?
    /// Filter criteria to apply when listing events.
    public var filter: BedrockAgentCoreClientTypes.FilterInput?
    /// Specifies whether to include event payloads in the response. Set to true to include payloads, or false to exclude them.
    public var includePayloads: Swift.Bool?
    /// The maximum number of results to return in a single call. The default value is 20.
    public var maxResults: Swift.Int?
    /// The identifier of the AgentCore Memory resource for which to list events.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the session for which to list events.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        actorId: Swift.String? = nil,
        filter: BedrockAgentCoreClientTypes.FilterInput? = nil,
        includePayloads: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        memoryId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.actorId = actorId
        self.filter = filter
        self.includePayloads = includePayloads
        self.maxResults = maxResults
        self.memoryId = memoryId
        self.nextToken = nextToken
        self.sessionId = sessionId
    }
}

public struct ListEventsOutput: Swift.Sendable {
    /// The list of events that match the specified criteria.
    /// This member is required.
    public var events: [BedrockAgentCoreClientTypes.Event]?
    /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        events: [BedrockAgentCoreClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.events = events
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreClientTypes {

    public enum ExtractionJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ExtractionJobStatus] {
            return [
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Filters for querying memory extraction jobs based on various criteria.
    public struct ExtractionJobFilterInput: Swift.Sendable {
        /// The identifier of the actor. If specified, only extraction jobs with this actor ID are returned.
        public var actorId: Swift.String?
        /// The unique identifier of the session. If specified, only extraction jobs with this session ID are returned.
        public var sessionId: Swift.String?
        /// The status of the extraction job. If specified, only extraction jobs with this status are returned.
        public var status: BedrockAgentCoreClientTypes.ExtractionJobStatus?
        /// The memory strategy identifier to filter extraction jobs by. If specified, only extraction jobs with this strategy ID are returned.
        public var strategyId: Swift.String?

        public init(
            actorId: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            status: BedrockAgentCoreClientTypes.ExtractionJobStatus? = nil,
            strategyId: Swift.String? = nil
        ) {
            self.actorId = actorId
            self.sessionId = sessionId
            self.status = status
            self.strategyId = strategyId
        }
    }
}

public struct ListMemoryExtractionJobsInput: Swift.Sendable {
    /// Filter criteria to apply when listing extraction jobs.
    public var filter: BedrockAgentCoreClientTypes.ExtractionJobFilterInput?
    /// The maximum number of results to return in a single call. The default value is 20.
    public var maxResults: Swift.Int?
    /// The unique identifier of the memory to list extraction jobs for.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        filter: BedrockAgentCoreClientTypes.ExtractionJobFilterInput? = nil,
        maxResults: Swift.Int? = nil,
        memoryId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filter = filter
        self.maxResults = maxResults
        self.memoryId = memoryId
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreClientTypes {

    /// Metadata information associated with this message.
    public struct MessageMetadata: Swift.Sendable {
        /// The identifier of the event associated with this message.
        /// This member is required.
        public var eventId: Swift.String?
        /// The position of this message within that events ordered list of messages.
        /// This member is required.
        public var messageIndex: Swift.Int?

        public init(
            eventId: Swift.String? = nil,
            messageIndex: Swift.Int? = nil
        ) {
            self.eventId = eventId
            self.messageIndex = messageIndex
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The list of messages that compose this extraction job.
    public enum ExtractionJobMessages: Swift.Sendable {
        /// The list of messages that compose this extraction job.
        case messageslist([BedrockAgentCoreClientTypes.MessageMetadata])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    /// Metadata information associated with this extraction job.
    public struct ExtractionJobMetadata: Swift.Sendable {
        /// The identifier of the actor for this extraction job.
        public var actorId: Swift.String?
        /// The cause of failure, if the job did not complete successfully.
        public var failureReason: Swift.String?
        /// The unique identifier for the extraction job.
        /// This member is required.
        public var jobID: Swift.String?
        /// The messages associated with the extraction job.
        /// This member is required.
        public var messages: BedrockAgentCoreClientTypes.ExtractionJobMessages?
        /// The identifier of the session for this extraction job.
        public var sessionId: Swift.String?
        /// The current status of the extraction job.
        public var status: BedrockAgentCoreClientTypes.ExtractionJobStatus?
        /// The identifier of the memory strategy for this extraction job.
        public var strategyId: Swift.String?

        public init(
            actorId: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            jobID: Swift.String? = nil,
            messages: BedrockAgentCoreClientTypes.ExtractionJobMessages? = nil,
            sessionId: Swift.String? = nil,
            status: BedrockAgentCoreClientTypes.ExtractionJobStatus? = nil,
            strategyId: Swift.String? = nil
        ) {
            self.actorId = actorId
            self.failureReason = failureReason
            self.jobID = jobID
            self.messages = messages
            self.sessionId = sessionId
            self.status = status
            self.strategyId = strategyId
        }
    }
}

public struct ListMemoryExtractionJobsOutput: Swift.Sendable {
    /// List of extraction job metadata matching the specified criteria.
    /// This member is required.
    public var jobs: [BedrockAgentCoreClientTypes.ExtractionJobMetadata]?
    /// Token to retrieve the next page of results, if available.
    public var nextToken: Swift.String?

    public init(
        jobs: [BedrockAgentCoreClientTypes.ExtractionJobMetadata]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

public struct ListMemoryRecordsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. The default value is 20.
    public var maxResults: Swift.Int?
    /// The identifier of the AgentCore Memory resource for which to list memory records.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The memory strategy identifier to filter memory records by. If specified, only memory records with this strategy ID are returned.
    public var memoryStrategyId: Swift.String?
    /// The namespace prefix to filter memory records by. Returns all memory records in namespaces that start with the provided prefix.
    /// This member is required.
    public var namespace: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        memoryId: Swift.String? = nil,
        memoryStrategyId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.memoryId = memoryId
        self.memoryStrategyId = memoryStrategyId
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains summary information about a memory record.
    public struct MemoryRecordSummary: Swift.Sendable {
        /// The content of the memory record.
        /// This member is required.
        public var content: BedrockAgentCoreClientTypes.MemoryContent?
        /// The timestamp when the memory record was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the memory record.
        /// This member is required.
        public var memoryRecordId: Swift.String?
        /// The identifier of the memory strategy associated with this record.
        /// This member is required.
        public var memoryStrategyId: Swift.String?
        /// A map of metadata key-value pairs associated with a memory record.
        public var metadata: [Swift.String: BedrockAgentCoreClientTypes.MetadataValue]?
        /// The namespaces associated with this memory record.
        /// This member is required.
        public var namespaces: [Swift.String]?
        /// The relevance score of the memory record when returned as part of a search result. Higher values indicate greater relevance to the search query.
        public var score: Swift.Double?

        public init(
            content: BedrockAgentCoreClientTypes.MemoryContent? = nil,
            createdAt: Foundation.Date? = nil,
            memoryRecordId: Swift.String? = nil,
            memoryStrategyId: Swift.String? = nil,
            metadata: [Swift.String: BedrockAgentCoreClientTypes.MetadataValue]? = nil,
            namespaces: [Swift.String]? = nil,
            score: Swift.Double? = nil
        ) {
            self.content = content
            self.createdAt = createdAt
            self.memoryRecordId = memoryRecordId
            self.memoryStrategyId = memoryStrategyId
            self.metadata = metadata
            self.namespaces = namespaces
            self.score = score
        }
    }
}

public struct ListMemoryRecordsOutput: Swift.Sendable {
    /// The list of memory record summaries that match the specified criteria.
    /// This member is required.
    public var memoryRecordSummaries: [BedrockAgentCoreClientTypes.MemoryRecordSummary]?
    /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        memoryRecordSummaries: [BedrockAgentCoreClientTypes.MemoryRecordSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.memoryRecordSummaries = memoryRecordSummaries
        self.nextToken = nextToken
    }
}

public struct ListSessionsInput: Swift.Sendable {
    /// The identifier of the actor for which to list sessions.
    /// This member is required.
    public var actorId: Swift.String?
    /// The maximum number of results to return in a single call. The default value is 20.
    public var maxResults: Swift.Int?
    /// The identifier of the AgentCore Memory resource for which to list sessions.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        actorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        memoryId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.actorId = actorId
        self.maxResults = maxResults
        self.memoryId = memoryId
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains summary information about a session in an AgentCore Memory resource.
    public struct SessionSummary: Swift.Sendable {
        /// The identifier of the actor associated with the session.
        /// This member is required.
        public var actorId: Swift.String?
        /// The timestamp when the session was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the session.
        /// This member is required.
        public var sessionId: Swift.String?

        public init(
            actorId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            sessionId: Swift.String? = nil
        ) {
            self.actorId = actorId
            self.createdAt = createdAt
            self.sessionId = sessionId
        }
    }
}

public struct ListSessionsOutput: Swift.Sendable {
    /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of session summaries that match the specified criteria.
    /// This member is required.
    public var sessionSummaries: [BedrockAgentCoreClientTypes.SessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessionSummaries: [BedrockAgentCoreClientTypes.SessionSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.sessionSummaries = sessionSummaries
    }
}

extension BedrockAgentCoreClientTypes {

    /// Filters to apply to metadata associated with a memory. Specify the metadata key and value in the left and right fields and use the operator field to define the relationship to match.
    public struct MemoryMetadataFilterExpression: Swift.Sendable {
        /// Left expression of the event metadata filter.
        /// This member is required.
        public var `left`: BedrockAgentCoreClientTypes.LeftExpression?
        /// The relationship between the metadata key and value to match when applying the metadata filter.
        /// This member is required.
        public var `operator`: BedrockAgentCoreClientTypes.OperatorType?
        /// Right expression of the eventMetadatafilter.
        public var `right`: BedrockAgentCoreClientTypes.RightExpression?

        public init(
            `left`: BedrockAgentCoreClientTypes.LeftExpression? = nil,
            `operator`: BedrockAgentCoreClientTypes.OperatorType? = nil,
            `right`: BedrockAgentCoreClientTypes.RightExpression? = nil
        ) {
            self.`left` = `left`
            self.`operator` = `operator`
            self.`right` = `right`
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains search criteria for retrieving memory records.
    public struct SearchCriteria: Swift.Sendable {
        /// The memory strategy identifier to filter memory records by.
        public var memoryStrategyId: Swift.String?
        /// Filters to apply to metadata associated with a memory.
        public var metadataFilters: [BedrockAgentCoreClientTypes.MemoryMetadataFilterExpression]?
        /// The search query to use for finding relevant memory records.
        /// This member is required.
        public var searchQuery: Swift.String?
        /// The maximum number of top-scoring memory records to return. This value is used for semantic search ranking.
        public var topk: Swift.Int?

        public init(
            memoryStrategyId: Swift.String? = nil,
            metadataFilters: [BedrockAgentCoreClientTypes.MemoryMetadataFilterExpression]? = nil,
            searchQuery: Swift.String? = nil,
            topk: Swift.Int? = 10
        ) {
            self.memoryStrategyId = memoryStrategyId
            self.metadataFilters = metadataFilters
            self.searchQuery = searchQuery
            self.topk = topk
        }
    }
}

extension BedrockAgentCoreClientTypes.SearchCriteria: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchCriteria(memoryStrategyId: \(Swift.String(describing: memoryStrategyId)), metadataFilters: \(Swift.String(describing: metadataFilters)), topk: \(Swift.String(describing: topk)), searchQuery: \"CONTENT_REDACTED\")"}
}

public struct RetrieveMemoryRecordsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. The default value is 20.
    public var maxResults: Swift.Int?
    /// The identifier of the AgentCore Memory resource from which to retrieve memory records.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The namespace prefix to filter memory records by. Searches for memory records in namespaces that start with the provided prefix.
    /// This member is required.
    public var namespace: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to use for finding relevant memory records. This includes the search query, memory strategy ID, and other search parameters.
    /// This member is required.
    public var searchCriteria: BedrockAgentCoreClientTypes.SearchCriteria?

    public init(
        maxResults: Swift.Int? = nil,
        memoryId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: BedrockAgentCoreClientTypes.SearchCriteria? = nil
    ) {
        self.maxResults = maxResults
        self.memoryId = memoryId
        self.namespace = namespace
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
    }
}

public struct RetrieveMemoryRecordsOutput: Swift.Sendable {
    /// The list of memory record summaries that match the search criteria, ordered by relevance.
    /// This member is required.
    public var memoryRecordSummaries: [BedrockAgentCoreClientTypes.MemoryRecordSummary]?
    /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        memoryRecordSummaries: [BedrockAgentCoreClientTypes.MemoryRecordSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.memoryRecordSummaries = memoryRecordSummaries
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreClientTypes {

    /// Represents the metadata of a memory extraction job such as the message identifiers that compose this job.
    public struct ExtractionJob: Swift.Sendable {
        /// The unique identifier of the extraction job.
        /// This member is required.
        public var jobId: Swift.String?

        public init(
            jobId: Swift.String? = nil
        ) {
            self.jobId = jobId
        }
    }
}

public struct StartMemoryExtractionJobInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure idempotent processing of the request.
    public var clientToken: Swift.String?
    /// Extraction job to start in this operation.
    /// This member is required.
    public var extractionJob: BedrockAgentCoreClientTypes.ExtractionJob?
    /// The unique identifier of the memory for which to start extraction jobs.
    /// This member is required.
    public var memoryId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        extractionJob: BedrockAgentCoreClientTypes.ExtractionJob? = nil,
        memoryId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.extractionJob = extractionJob
        self.memoryId = memoryId
    }
}

public struct StartMemoryExtractionJobOutput: Swift.Sendable {
    /// Extraction Job ID that was attempted to start.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    ) {
        self.jobId = jobId
    }
}

extension BatchCreateMemoryRecordsInput {

    static func urlPathProvider(_ value: BatchCreateMemoryRecordsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/memoryRecords/batchCreate"
    }
}

extension BatchDeleteMemoryRecordsInput {

    static func urlPathProvider(_ value: BatchDeleteMemoryRecordsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/memoryRecords/batchDelete"
    }
}

extension BatchUpdateMemoryRecordsInput {

    static func urlPathProvider(_ value: BatchUpdateMemoryRecordsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/memoryRecords/batchUpdate"
    }
}

extension CompleteResourceTokenAuthInput {

    static func urlPathProvider(_ value: CompleteResourceTokenAuthInput) -> Swift.String? {
        return "/identities/CompleteResourceTokenAuth"
    }
}

extension CreateEventInput {

    static func urlPathProvider(_ value: CreateEventInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/events"
    }
}

extension DeleteEventInput {

    static func urlPathProvider(_ value: DeleteEventInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        guard let actorId = value.actorId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        guard let eventId = value.eventId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/actor/\(actorId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/events/\(eventId.urlPercentEncoding())"
    }
}

extension DeleteMemoryRecordInput {

    static func urlPathProvider(_ value: DeleteMemoryRecordInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        guard let memoryRecordId = value.memoryRecordId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/memoryRecords/\(memoryRecordId.urlPercentEncoding())"
    }
}

extension EvaluateInput {

    static func urlPathProvider(_ value: EvaluateInput) -> Swift.String? {
        guard let evaluatorId = value.evaluatorId else {
            return nil
        }
        return "/evaluations/evaluate/\(evaluatorId.urlPercentEncoding())"
    }
}

extension GetAgentCardInput {

    static func urlPathProvider(_ value: GetAgentCardInput) -> Swift.String? {
        guard let agentRuntimeArn = value.agentRuntimeArn else {
            return nil
        }
        return "/runtimes/\(agentRuntimeArn.urlPercentEncoding())/invocations/.well-known/agent-card.json"
    }
}

extension GetAgentCardInput {

    static func headerProvider(_ value: GetAgentCardInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let runtimeSessionId = value.runtimeSessionId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id", value: Swift.String(runtimeSessionId)))
        }
        return items
    }
}

extension GetAgentCardInput {

    static func queryItemProvider(_ value: GetAgentCardInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetBrowserSessionInput {

    static func urlPathProvider(_ value: GetBrowserSessionInput) -> Swift.String? {
        guard let browserIdentifier = value.browserIdentifier else {
            return nil
        }
        return "/browsers/\(browserIdentifier.urlPercentEncoding())/sessions/get"
    }
}

extension GetBrowserSessionInput {

    static func queryItemProvider(_ value: GetBrowserSessionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let sessionId = value.sessionId else {
            let message = "Creating a URL Query Item failed. sessionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
        items.append(sessionIdQueryItem)
        return items
    }
}

extension GetCodeInterpreterSessionInput {

    static func urlPathProvider(_ value: GetCodeInterpreterSessionInput) -> Swift.String? {
        guard let codeInterpreterIdentifier = value.codeInterpreterIdentifier else {
            return nil
        }
        return "/code-interpreters/\(codeInterpreterIdentifier.urlPercentEncoding())/sessions/get"
    }
}

extension GetCodeInterpreterSessionInput {

    static func queryItemProvider(_ value: GetCodeInterpreterSessionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let sessionId = value.sessionId else {
            let message = "Creating a URL Query Item failed. sessionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
        items.append(sessionIdQueryItem)
        return items
    }
}

extension GetEventInput {

    static func urlPathProvider(_ value: GetEventInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        guard let actorId = value.actorId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        guard let eventId = value.eventId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/actor/\(actorId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/events/\(eventId.urlPercentEncoding())"
    }
}

extension GetMemoryRecordInput {

    static func urlPathProvider(_ value: GetMemoryRecordInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        guard let memoryRecordId = value.memoryRecordId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/memoryRecord/\(memoryRecordId.urlPercentEncoding())"
    }
}

extension GetResourceApiKeyInput {

    static func urlPathProvider(_ value: GetResourceApiKeyInput) -> Swift.String? {
        return "/identities/api-key"
    }
}

extension GetResourceOauth2TokenInput {

    static func urlPathProvider(_ value: GetResourceOauth2TokenInput) -> Swift.String? {
        return "/identities/oauth2/token"
    }
}

extension GetWorkloadAccessTokenInput {

    static func urlPathProvider(_ value: GetWorkloadAccessTokenInput) -> Swift.String? {
        return "/identities/GetWorkloadAccessToken"
    }
}

extension GetWorkloadAccessTokenForJWTInput {

    static func urlPathProvider(_ value: GetWorkloadAccessTokenForJWTInput) -> Swift.String? {
        return "/identities/GetWorkloadAccessTokenForJWT"
    }
}

extension GetWorkloadAccessTokenForUserIdInput {

    static func urlPathProvider(_ value: GetWorkloadAccessTokenForUserIdInput) -> Swift.String? {
        return "/identities/GetWorkloadAccessTokenForUserId"
    }
}

extension InvokeAgentRuntimeInput {

    static func urlPathProvider(_ value: InvokeAgentRuntimeInput) -> Swift.String? {
        guard let agentRuntimeArn = value.agentRuntimeArn else {
            return nil
        }
        return "/runtimes/\(agentRuntimeArn.urlPercentEncoding())/invocations"
    }
}

extension InvokeAgentRuntimeInput {

    static func headerProvider(_ value: InvokeAgentRuntimeInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let accept = value.accept {
            items.add(SmithyHTTPAPI.Header(name: "Accept", value: Swift.String(accept)))
        }
        if let baggage = value.baggage {
            items.add(SmithyHTTPAPI.Header(name: "baggage", value: Swift.String(baggage)))
        }
        if let contentType = value.contentType {
            items.add(SmithyHTTPAPI.Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let mcpProtocolVersion = value.mcpProtocolVersion {
            items.add(SmithyHTTPAPI.Header(name: "Mcp-Protocol-Version", value: Swift.String(mcpProtocolVersion)))
        }
        if let mcpSessionId = value.mcpSessionId {
            items.add(SmithyHTTPAPI.Header(name: "Mcp-Session-Id", value: Swift.String(mcpSessionId)))
        }
        if let runtimeSessionId = value.runtimeSessionId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id", value: Swift.String(runtimeSessionId)))
        }
        if let runtimeUserId = value.runtimeUserId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-AgentCore-Runtime-User-Id", value: Swift.String(runtimeUserId)))
        }
        if let traceId = value.traceId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Trace-Id", value: Swift.String(traceId)))
        }
        if let traceParent = value.traceParent {
            items.add(SmithyHTTPAPI.Header(name: "traceparent", value: Swift.String(traceParent)))
        }
        if let traceState = value.traceState {
            items.add(SmithyHTTPAPI.Header(name: "tracestate", value: Swift.String(traceState)))
        }
        return items
    }
}

extension InvokeAgentRuntimeInput {

    static func queryItemProvider(_ value: InvokeAgentRuntimeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let accountId = value.accountId {
            let accountIdQueryItem = Smithy.URIQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
            items.append(accountIdQueryItem)
        }
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension InvokeCodeInterpreterInput {

    static func urlPathProvider(_ value: InvokeCodeInterpreterInput) -> Swift.String? {
        guard let codeInterpreterIdentifier = value.codeInterpreterIdentifier else {
            return nil
        }
        return "/code-interpreters/\(codeInterpreterIdentifier.urlPercentEncoding())/tools/invoke"
    }
}

extension InvokeCodeInterpreterInput {

    static func headerProvider(_ value: InvokeCodeInterpreterInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let sessionId = value.sessionId {
            items.add(SmithyHTTPAPI.Header(name: "x-amzn-code-interpreter-session-id", value: Swift.String(sessionId)))
        }
        if let traceId = value.traceId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Trace-Id", value: Swift.String(traceId)))
        }
        if let traceParent = value.traceParent {
            items.add(SmithyHTTPAPI.Header(name: "traceparent", value: Swift.String(traceParent)))
        }
        return items
    }
}

extension ListActorsInput {

    static func urlPathProvider(_ value: ListActorsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/actors"
    }
}

extension ListBrowserSessionsInput {

    static func urlPathProvider(_ value: ListBrowserSessionsInput) -> Swift.String? {
        guard let browserIdentifier = value.browserIdentifier else {
            return nil
        }
        return "/browsers/\(browserIdentifier.urlPercentEncoding())/sessions/list"
    }
}

extension ListCodeInterpreterSessionsInput {

    static func urlPathProvider(_ value: ListCodeInterpreterSessionsInput) -> Swift.String? {
        guard let codeInterpreterIdentifier = value.codeInterpreterIdentifier else {
            return nil
        }
        return "/code-interpreters/\(codeInterpreterIdentifier.urlPercentEncoding())/sessions/list"
    }
}

extension ListEventsInput {

    static func urlPathProvider(_ value: ListEventsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        guard let actorId = value.actorId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/actor/\(actorId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

extension ListMemoryExtractionJobsInput {

    static func urlPathProvider(_ value: ListMemoryExtractionJobsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/extractionJobs"
    }
}

extension ListMemoryRecordsInput {

    static func urlPathProvider(_ value: ListMemoryRecordsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/memoryRecords"
    }
}

extension ListSessionsInput {

    static func urlPathProvider(_ value: ListSessionsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        guard let actorId = value.actorId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/actor/\(actorId.urlPercentEncoding())/sessions"
    }
}

extension RetrieveMemoryRecordsInput {

    static func urlPathProvider(_ value: RetrieveMemoryRecordsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/retrieve"
    }
}

extension SaveBrowserSessionProfileInput {

    static func urlPathProvider(_ value: SaveBrowserSessionProfileInput) -> Swift.String? {
        guard let profileIdentifier = value.profileIdentifier else {
            return nil
        }
        return "/browser-profiles/\(profileIdentifier.urlPercentEncoding())/save"
    }
}

extension SaveBrowserSessionProfileInput {

    static func headerProvider(_ value: SaveBrowserSessionProfileInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let traceId = value.traceId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Trace-Id", value: Swift.String(traceId)))
        }
        if let traceParent = value.traceParent {
            items.add(SmithyHTTPAPI.Header(name: "traceparent", value: Swift.String(traceParent)))
        }
        return items
    }
}

extension StartBrowserSessionInput {

    static func urlPathProvider(_ value: StartBrowserSessionInput) -> Swift.String? {
        guard let browserIdentifier = value.browserIdentifier else {
            return nil
        }
        return "/browsers/\(browserIdentifier.urlPercentEncoding())/sessions/start"
    }
}

extension StartBrowserSessionInput {

    static func headerProvider(_ value: StartBrowserSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let traceId = value.traceId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Trace-Id", value: Swift.String(traceId)))
        }
        if let traceParent = value.traceParent {
            items.add(SmithyHTTPAPI.Header(name: "traceparent", value: Swift.String(traceParent)))
        }
        return items
    }
}

extension StartCodeInterpreterSessionInput {

    static func urlPathProvider(_ value: StartCodeInterpreterSessionInput) -> Swift.String? {
        guard let codeInterpreterIdentifier = value.codeInterpreterIdentifier else {
            return nil
        }
        return "/code-interpreters/\(codeInterpreterIdentifier.urlPercentEncoding())/sessions/start"
    }
}

extension StartCodeInterpreterSessionInput {

    static func headerProvider(_ value: StartCodeInterpreterSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let traceId = value.traceId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Trace-Id", value: Swift.String(traceId)))
        }
        if let traceParent = value.traceParent {
            items.add(SmithyHTTPAPI.Header(name: "traceparent", value: Swift.String(traceParent)))
        }
        return items
    }
}

extension StartMemoryExtractionJobInput {

    static func urlPathProvider(_ value: StartMemoryExtractionJobInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/extractionJobs/start"
    }
}

extension StopBrowserSessionInput {

    static func urlPathProvider(_ value: StopBrowserSessionInput) -> Swift.String? {
        guard let browserIdentifier = value.browserIdentifier else {
            return nil
        }
        return "/browsers/\(browserIdentifier.urlPercentEncoding())/sessions/stop"
    }
}

extension StopBrowserSessionInput {

    static func headerProvider(_ value: StopBrowserSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let traceId = value.traceId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Trace-Id", value: Swift.String(traceId)))
        }
        if let traceParent = value.traceParent {
            items.add(SmithyHTTPAPI.Header(name: "traceparent", value: Swift.String(traceParent)))
        }
        return items
    }
}

extension StopBrowserSessionInput {

    static func queryItemProvider(_ value: StopBrowserSessionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let sessionId = value.sessionId else {
            let message = "Creating a URL Query Item failed. sessionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
        items.append(sessionIdQueryItem)
        return items
    }
}

extension StopCodeInterpreterSessionInput {

    static func urlPathProvider(_ value: StopCodeInterpreterSessionInput) -> Swift.String? {
        guard let codeInterpreterIdentifier = value.codeInterpreterIdentifier else {
            return nil
        }
        return "/code-interpreters/\(codeInterpreterIdentifier.urlPercentEncoding())/sessions/stop"
    }
}

extension StopCodeInterpreterSessionInput {

    static func headerProvider(_ value: StopCodeInterpreterSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let traceId = value.traceId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Trace-Id", value: Swift.String(traceId)))
        }
        if let traceParent = value.traceParent {
            items.add(SmithyHTTPAPI.Header(name: "traceparent", value: Swift.String(traceParent)))
        }
        return items
    }
}

extension StopCodeInterpreterSessionInput {

    static func queryItemProvider(_ value: StopCodeInterpreterSessionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let sessionId = value.sessionId else {
            let message = "Creating a URL Query Item failed. sessionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
        items.append(sessionIdQueryItem)
        return items
    }
}

extension StopRuntimeSessionInput {

    static func urlPathProvider(_ value: StopRuntimeSessionInput) -> Swift.String? {
        guard let agentRuntimeArn = value.agentRuntimeArn else {
            return nil
        }
        return "/runtimes/\(agentRuntimeArn.urlPercentEncoding())/stopruntimesession"
    }
}

extension StopRuntimeSessionInput {

    static func headerProvider(_ value: StopRuntimeSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let runtimeSessionId = value.runtimeSessionId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id", value: Swift.String(runtimeSessionId)))
        }
        return items
    }
}

extension StopRuntimeSessionInput {

    static func queryItemProvider(_ value: StopRuntimeSessionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension UpdateBrowserStreamInput {

    static func urlPathProvider(_ value: UpdateBrowserStreamInput) -> Swift.String? {
        guard let browserIdentifier = value.browserIdentifier else {
            return nil
        }
        return "/browsers/\(browserIdentifier.urlPercentEncoding())/sessions/streams/update"
    }
}

extension UpdateBrowserStreamInput {

    static func queryItemProvider(_ value: UpdateBrowserStreamInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let sessionId = value.sessionId else {
            let message = "Creating a URL Query Item failed. sessionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
        items.append(sessionIdQueryItem)
        return items
    }
}

extension BatchCreateMemoryRecordsInput {

    static func write(value: BatchCreateMemoryRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["records"].writeList(value.records, memberWritingClosure: BedrockAgentCoreClientTypes.MemoryRecordCreateInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDeleteMemoryRecordsInput {

    static func write(value: BatchDeleteMemoryRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["records"].writeList(value.records, memberWritingClosure: BedrockAgentCoreClientTypes.MemoryRecordDeleteInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdateMemoryRecordsInput {

    static func write(value: BatchUpdateMemoryRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["records"].writeList(value.records, memberWritingClosure: BedrockAgentCoreClientTypes.MemoryRecordUpdateInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CompleteResourceTokenAuthInput {

    static func write(value: CompleteResourceTokenAuthInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sessionUri"].write(value.sessionUri)
        try writer["userIdentifier"].write(value.userIdentifier, with: BedrockAgentCoreClientTypes.UserIdentifier.write(value:to:))
    }
}

extension CreateEventInput {

    static func write(value: CreateEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actorId"].write(value.actorId)
        try writer["branch"].write(value.branch, with: BedrockAgentCoreClientTypes.Branch.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["eventTimestamp"].writeTimestamp(value.eventTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["metadata"].writeMap(value.metadata, valueWritingClosure: BedrockAgentCoreClientTypes.MetadataValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["payload"].writeList(value.payload, memberWritingClosure: BedrockAgentCoreClientTypes.PayloadType.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sessionId"].write(value.sessionId)
    }
}

extension EvaluateInput {

    static func write(value: EvaluateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["evaluationInput"].write(value.evaluationInput, with: BedrockAgentCoreClientTypes.EvaluationInput.write(value:to:))
        try writer["evaluationTarget"].write(value.evaluationTarget, with: BedrockAgentCoreClientTypes.EvaluationTarget.write(value:to:))
    }
}

extension GetResourceApiKeyInput {

    static func write(value: GetResourceApiKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceCredentialProviderName"].write(value.resourceCredentialProviderName)
        try writer["workloadIdentityToken"].write(value.workloadIdentityToken)
    }
}

extension GetResourceOauth2TokenInput {

    static func write(value: GetResourceOauth2TokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customParameters"].writeMap(value.customParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["customState"].write(value.customState)
        try writer["forceAuthentication"].write(value.forceAuthentication)
        try writer["oauth2Flow"].write(value.oauth2Flow)
        try writer["resourceCredentialProviderName"].write(value.resourceCredentialProviderName)
        try writer["resourceOauth2ReturnUrl"].write(value.resourceOauth2ReturnUrl)
        try writer["scopes"].writeList(value.scopes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sessionUri"].write(value.sessionUri)
        try writer["workloadIdentityToken"].write(value.workloadIdentityToken)
    }
}

extension GetWorkloadAccessTokenInput {

    static func write(value: GetWorkloadAccessTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["workloadName"].write(value.workloadName)
    }
}

extension GetWorkloadAccessTokenForJWTInput {

    static func write(value: GetWorkloadAccessTokenForJWTInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userToken"].write(value.userToken)
        try writer["workloadName"].write(value.workloadName)
    }
}

extension GetWorkloadAccessTokenForUserIdInput {

    static func write(value: GetWorkloadAccessTokenForUserIdInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userId"].write(value.userId)
        try writer["workloadName"].write(value.workloadName)
    }
}

extension InvokeAgentRuntimeInput {

    static func write(value: InvokeAgentRuntimeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["payload"].write(value.payload)
    }
}

extension InvokeCodeInterpreterInput {

    static func write(value: InvokeCodeInterpreterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arguments"].write(value.arguments, with: BedrockAgentCoreClientTypes.ToolArguments.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension ListActorsInput {

    static func write(value: ListActorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListBrowserSessionsInput {

    static func write(value: ListBrowserSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["status"].write(value.status)
    }
}

extension ListCodeInterpreterSessionsInput {

    static func write(value: ListCodeInterpreterSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["status"].write(value.status)
    }
}

extension ListEventsInput {

    static func write(value: ListEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: BedrockAgentCoreClientTypes.FilterInput.write(value:to:))
        try writer["includePayloads"].write(value.includePayloads)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListMemoryExtractionJobsInput {

    static func write(value: ListMemoryExtractionJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: BedrockAgentCoreClientTypes.ExtractionJobFilterInput.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListMemoryRecordsInput {

    static func write(value: ListMemoryRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["memoryStrategyId"].write(value.memoryStrategyId)
        try writer["namespace"].write(value.namespace)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListSessionsInput {

    static func write(value: ListSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension RetrieveMemoryRecordsInput {

    static func write(value: RetrieveMemoryRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["namespace"].write(value.namespace)
        try writer["nextToken"].write(value.nextToken)
        try writer["searchCriteria"].write(value.searchCriteria, with: BedrockAgentCoreClientTypes.SearchCriteria.write(value:to:))
    }
}

extension SaveBrowserSessionProfileInput {

    static func write(value: SaveBrowserSessionProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["browserIdentifier"].write(value.browserIdentifier)
        try writer["clientToken"].write(value.clientToken)
        try writer["sessionId"].write(value.sessionId)
    }
}

extension StartBrowserSessionInput {

    static func write(value: StartBrowserSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["extensions"].writeList(value.extensions, memberWritingClosure: BedrockAgentCoreClientTypes.BrowserExtension.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["profileConfiguration"].write(value.profileConfiguration, with: BedrockAgentCoreClientTypes.BrowserProfileConfiguration.write(value:to:))
        try writer["proxyConfiguration"].write(value.proxyConfiguration, with: BedrockAgentCoreClientTypes.ProxyConfiguration.write(value:to:))
        try writer["sessionTimeoutSeconds"].write(value.sessionTimeoutSeconds)
        try writer["viewPort"].write(value.viewPort, with: BedrockAgentCoreClientTypes.ViewPort.write(value:to:))
    }
}

extension StartCodeInterpreterSessionInput {

    static func write(value: StartCodeInterpreterSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["name"].write(value.name)
        try writer["sessionTimeoutSeconds"].write(value.sessionTimeoutSeconds)
    }
}

extension StartMemoryExtractionJobInput {

    static func write(value: StartMemoryExtractionJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["extractionJob"].write(value.extractionJob, with: BedrockAgentCoreClientTypes.ExtractionJob.write(value:to:))
    }
}

extension StopBrowserSessionInput {

    static func write(value: StopBrowserSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension StopCodeInterpreterSessionInput {

    static func write(value: StopCodeInterpreterSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension StopRuntimeSessionInput {

    static func write(value: StopRuntimeSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension UpdateBrowserStreamInput {

    static func write(value: UpdateBrowserStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["streamUpdate"].write(value.streamUpdate, with: BedrockAgentCoreClientTypes.StreamUpdate.write(value:to:))
    }
}

extension BatchCreateMemoryRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateMemoryRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateMemoryRecordsOutput()
        value.failedRecords = try reader["failedRecords"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.successfulRecords = try reader["successfulRecords"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchDeleteMemoryRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteMemoryRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteMemoryRecordsOutput()
        value.failedRecords = try reader["failedRecords"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.successfulRecords = try reader["successfulRecords"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchUpdateMemoryRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateMemoryRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateMemoryRecordsOutput()
        value.failedRecords = try reader["failedRecords"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.successfulRecords = try reader["successfulRecords"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CompleteResourceTokenAuthOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CompleteResourceTokenAuthOutput {
        return CompleteResourceTokenAuthOutput()
    }
}

extension CreateEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventOutput()
        value.event = try reader["event"].readIfPresent(with: BedrockAgentCoreClientTypes.Event.read(from:))
        return value
    }
}

extension DeleteEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEventOutput()
        value.eventId = try reader["eventId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteMemoryRecordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMemoryRecordOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteMemoryRecordOutput()
        value.memoryRecordId = try reader["memoryRecordId"].readIfPresent() ?? ""
        return value
    }
}

extension EvaluateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EvaluateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EvaluateOutput()
        value.evaluationResults = try reader["evaluationResults"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.EvaluationResultContent.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetAgentCardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAgentCardOutput {
        var value = GetAgentCardOutput()
        if let runtimeSessionIdHeaderValue = httpResponse.headers.value(for: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id") {
            value.runtimeSessionId = runtimeSessionIdHeaderValue
        }
        if let data = try await httpResponse.body.readData() {
            value.agentCard = try Smithy.Document.make(from: data)
        }
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension GetBrowserSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBrowserSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBrowserSessionOutput()
        value.browserIdentifier = try reader["browserIdentifier"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.extensions = try reader["extensions"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.BrowserExtension.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.profileConfiguration = try reader["profileConfiguration"].readIfPresent(with: BedrockAgentCoreClientTypes.BrowserProfileConfiguration.read(from:))
        value.proxyConfiguration = try reader["proxyConfiguration"].readIfPresent(with: BedrockAgentCoreClientTypes.ProxyConfiguration.read(from:))
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.sessionReplayArtifact = try reader["sessionReplayArtifact"].readIfPresent()
        value.sessionTimeoutSeconds = try reader["sessionTimeoutSeconds"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.streams = try reader["streams"].readIfPresent(with: BedrockAgentCoreClientTypes.BrowserSessionStream.read(from:))
        value.viewPort = try reader["viewPort"].readIfPresent(with: BedrockAgentCoreClientTypes.ViewPort.read(from:))
        return value
    }
}

extension GetCodeInterpreterSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCodeInterpreterSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCodeInterpreterSessionOutput()
        value.codeInterpreterIdentifier = try reader["codeInterpreterIdentifier"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.sessionTimeoutSeconds = try reader["sessionTimeoutSeconds"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventOutput()
        value.event = try reader["event"].readIfPresent(with: BedrockAgentCoreClientTypes.Event.read(from:))
        return value
    }
}

extension GetMemoryRecordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMemoryRecordOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMemoryRecordOutput()
        value.memoryRecord = try reader["memoryRecord"].readIfPresent(with: BedrockAgentCoreClientTypes.MemoryRecord.read(from:))
        return value
    }
}

extension GetResourceApiKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceApiKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceApiKeyOutput()
        value.apiKey = try reader["apiKey"].readIfPresent() ?? ""
        return value
    }
}

extension GetResourceOauth2TokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceOauth2TokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceOauth2TokenOutput()
        value.accessToken = try reader["accessToken"].readIfPresent()
        value.authorizationUrl = try reader["authorizationUrl"].readIfPresent()
        value.sessionStatus = try reader["sessionStatus"].readIfPresent()
        value.sessionUri = try reader["sessionUri"].readIfPresent()
        return value
    }
}

extension GetWorkloadAccessTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkloadAccessTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkloadAccessTokenOutput()
        value.workloadAccessToken = try reader["workloadAccessToken"].readIfPresent() ?? ""
        return value
    }
}

extension GetWorkloadAccessTokenForJWTOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkloadAccessTokenForJWTOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkloadAccessTokenForJWTOutput()
        value.workloadAccessToken = try reader["workloadAccessToken"].readIfPresent() ?? ""
        return value
    }
}

extension GetWorkloadAccessTokenForUserIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkloadAccessTokenForUserIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkloadAccessTokenForUserIdOutput()
        value.workloadAccessToken = try reader["workloadAccessToken"].readIfPresent() ?? ""
        return value
    }
}

extension InvokeAgentRuntimeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeAgentRuntimeOutput {
        var value = InvokeAgentRuntimeOutput()
        if let baggageHeaderValue = httpResponse.headers.value(for: "baggage") {
            value.baggage = baggageHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        if let mcpProtocolVersionHeaderValue = httpResponse.headers.value(for: "Mcp-Protocol-Version") {
            value.mcpProtocolVersion = mcpProtocolVersionHeaderValue
        }
        if let mcpSessionIdHeaderValue = httpResponse.headers.value(for: "Mcp-Session-Id") {
            value.mcpSessionId = mcpSessionIdHeaderValue
        }
        if let runtimeSessionIdHeaderValue = httpResponse.headers.value(for: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id") {
            value.runtimeSessionId = runtimeSessionIdHeaderValue
        }
        if let traceIdHeaderValue = httpResponse.headers.value(for: "X-Amzn-Trace-Id") {
            value.traceId = traceIdHeaderValue
        }
        if let traceParentHeaderValue = httpResponse.headers.value(for: "traceparent") {
            value.traceParent = traceParentHeaderValue
        }
        if let traceStateHeaderValue = httpResponse.headers.value(for: "tracestate") {
            value.traceState = traceStateHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.response = .data(data)
        case .stream(let stream):
            value.response = .stream(stream)
        case .noStream:
            value.response = nil
        }
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension InvokeCodeInterpreterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeCodeInterpreterOutput {
        var value = InvokeCodeInterpreterOutput()
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amzn-code-interpreter-session-id") {
            value.sessionId = sessionIdHeaderValue
        }
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: BedrockAgentCoreClientTypes.CodeInterpreterStreamOutput.unmarshal)
            value.stream = decoderStream.toAsyncStream()
        }
        return value
    }
}

extension ListActorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListActorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListActorsOutput()
        value.actorSummaries = try reader["actorSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.ActorSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBrowserSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBrowserSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBrowserSessionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.BrowserSessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCodeInterpreterSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCodeInterpreterSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCodeInterpreterSessionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.CodeInterpreterSessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventsOutput()
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.Event.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMemoryExtractionJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMemoryExtractionJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMemoryExtractionJobsOutput()
        value.jobs = try reader["jobs"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.ExtractionJobMetadata.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMemoryRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMemoryRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMemoryRecordsOutput()
        value.memoryRecordSummaries = try reader["memoryRecordSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSessionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sessionSummaries = try reader["sessionSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.SessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension RetrieveMemoryRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RetrieveMemoryRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RetrieveMemoryRecordsOutput()
        value.memoryRecordSummaries = try reader["memoryRecordSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension SaveBrowserSessionProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SaveBrowserSessionProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SaveBrowserSessionProfileOutput()
        value.browserIdentifier = try reader["browserIdentifier"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.profileIdentifier = try reader["profileIdentifier"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension StartBrowserSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartBrowserSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartBrowserSessionOutput()
        value.browserIdentifier = try reader["browserIdentifier"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.streams = try reader["streams"].readIfPresent(with: BedrockAgentCoreClientTypes.BrowserSessionStream.read(from:))
        return value
    }
}

extension StartCodeInterpreterSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartCodeInterpreterSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartCodeInterpreterSessionOutput()
        value.codeInterpreterIdentifier = try reader["codeInterpreterIdentifier"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension StartMemoryExtractionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMemoryExtractionJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMemoryExtractionJobOutput()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        return value
    }
}

extension StopBrowserSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopBrowserSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopBrowserSessionOutput()
        value.browserIdentifier = try reader["browserIdentifier"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension StopCodeInterpreterSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopCodeInterpreterSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopCodeInterpreterSessionOutput()
        value.codeInterpreterIdentifier = try reader["codeInterpreterIdentifier"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension StopRuntimeSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopRuntimeSessionOutput {
        var value = StopRuntimeSessionOutput()
        if let runtimeSessionIdHeaderValue = httpResponse.headers.value(for: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id") {
            value.runtimeSessionId = runtimeSessionIdHeaderValue
        }
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateBrowserStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBrowserStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBrowserStreamOutput()
        value.browserIdentifier = try reader["browserIdentifier"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.streams = try reader["streams"].readIfPresent(with: BedrockAgentCoreClientTypes.BrowserSessionStream.read(from:))
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

enum BatchCreateMemoryRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteMemoryRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateMemoryRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CompleteResourceTokenAuthOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMemoryRecordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EvaluateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DuplicateIdException": return try DuplicateIdException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAgentCardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RuntimeClientError": return try RuntimeClientError.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBrowserSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCodeInterpreterSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMemoryRecordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceApiKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceOauth2TokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkloadAccessTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkloadAccessTokenForJWTOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkloadAccessTokenForUserIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeAgentRuntimeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RuntimeClientError": return try RuntimeClientError.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeCodeInterpreterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListActorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBrowserSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCodeInterpreterSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMemoryExtractionJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMemoryRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RetrieveMemoryRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SaveBrowserSessionProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartBrowserSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartCodeInterpreterSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMemoryExtractionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopBrowserSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopCodeInterpreterSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopRuntimeSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RuntimeClientError": return try RuntimeClientError.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBrowserStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceException {
        let reader = baseError.errorBodyReader
        var value = ServiceException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottledException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottledException {
        let reader = baseError.errorBodyReader
        var value = ThrottledException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInputException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidInputException {
        let reader = baseError.errorBodyReader
        var value = InvalidInputException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RetryableConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RetryableConflictException {
        let reader = baseError.errorBodyReader
        var value = RetryableConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateIdException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DuplicateIdException {
        let reader = baseError.errorBodyReader
        var value = DuplicateIdException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RuntimeClientError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RuntimeClientError {
        let reader = baseError.errorBodyReader
        var value = RuntimeClientError()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BedrockAgentCoreClientTypes.CodeInterpreterStreamOutput {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<BedrockAgentCoreClientTypes.CodeInterpreterStreamOutput> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "result":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentCoreClientTypes.CodeInterpreterResult.read(from:))
                    return .result(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    case "accessDeniedException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: AccessDeniedException.read(from:))
                        return value
                    case "conflictException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ConflictException.read(from:))
                        return value
                    case "internalServerException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: InternalServerException.read(from:))
                        return value
                    case "resourceNotFoundException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ResourceNotFoundException.read(from:))
                        return value
                    case "serviceQuotaExceededException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ServiceQuotaExceededException.read(from:))
                        return value
                    case "throttlingException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ThrottlingException.read(from:))
                        return value
                    case "validationException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ValidationException.read(from:))
                        return value
                    default:
                        let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension BedrockAgentCoreClientTypes.MemoryRecordOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.MemoryRecordOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.MemoryRecordOutput()
        value.memoryRecordId = try reader["memoryRecordId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.requestIdentifier = try reader["requestIdentifier"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.Event {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.Event {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.Event()
        value.memoryId = try reader["memoryId"].readIfPresent() ?? ""
        value.actorId = try reader["actorId"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.eventId = try reader["eventId"].readIfPresent() ?? ""
        value.eventTimestamp = try reader["eventTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.payload = try reader["payload"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.PayloadType.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.branch = try reader["branch"].readIfPresent(with: BedrockAgentCoreClientTypes.Branch.read(from:))
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: BedrockAgentCoreClientTypes.MetadataValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockAgentCoreClientTypes.MetadataValue {

    static func write(value: BedrockAgentCoreClientTypes.MetadataValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .stringvalue(stringvalue):
                try writer["stringValue"].write(stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.MetadataValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "stringValue":
                return .stringvalue(try reader["stringValue"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreClientTypes.Branch {

    static func write(value: BedrockAgentCoreClientTypes.Branch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["rootEventId"].write(value.rootEventId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.Branch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.Branch()
        value.rootEventId = try reader["rootEventId"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreClientTypes.PayloadType {

    static func write(value: BedrockAgentCoreClientTypes.PayloadType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .blob(blob):
                try writer["blob"].write(blob)
            case let .conversational(conversational):
                try writer["conversational"].write(conversational, with: BedrockAgentCoreClientTypes.Conversational.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.PayloadType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "conversational":
                return .conversational(try reader["conversational"].read(with: BedrockAgentCoreClientTypes.Conversational.read(from:)))
            case "blob":
                return .blob(try reader["blob"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreClientTypes.Conversational {

    static func write(value: BedrockAgentCoreClientTypes.Conversational?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content, with: BedrockAgentCoreClientTypes.Content.write(value:to:))
        try writer["role"].write(value.role)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.Conversational {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.Conversational()
        value.content = try reader["content"].readIfPresent(with: BedrockAgentCoreClientTypes.Content.read(from:))
        value.role = try reader["role"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockAgentCoreClientTypes.Content {

    static func write(value: BedrockAgentCoreClientTypes.Content?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.Content {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreClientTypes.EvaluationResultContent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.EvaluationResultContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.EvaluationResultContent()
        value.evaluatorArn = try reader["evaluatorArn"].readIfPresent() ?? ""
        value.evaluatorId = try reader["evaluatorId"].readIfPresent() ?? ""
        value.evaluatorName = try reader["evaluatorName"].readIfPresent() ?? ""
        value.explanation = try reader["explanation"].readIfPresent()
        value.context = try reader["context"].readIfPresent(with: BedrockAgentCoreClientTypes.Context.read(from:))
        value.value = try reader["value"].readIfPresent()
        value.label = try reader["label"].readIfPresent()
        value.tokenUsage = try reader["tokenUsage"].readIfPresent(with: BedrockAgentCoreClientTypes.TokenUsage.read(from:))
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.TokenUsage {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.TokenUsage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.TokenUsage()
        value.inputTokens = try reader["inputTokens"].readIfPresent()
        value.outputTokens = try reader["outputTokens"].readIfPresent()
        value.totalTokens = try reader["totalTokens"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.Context {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.Context {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "spanContext":
                return .spancontext(try reader["spanContext"].read(with: BedrockAgentCoreClientTypes.SpanContext.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreClientTypes.SpanContext {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.SpanContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.SpanContext()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.traceId = try reader["traceId"].readIfPresent()
        value.spanId = try reader["spanId"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.ViewPort {

    static func write(value: BedrockAgentCoreClientTypes.ViewPort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["height"].write(value.height)
        try writer["width"].write(value.width)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ViewPort {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ViewPort()
        value.width = try reader["width"].readIfPresent() ?? 0
        value.height = try reader["height"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockAgentCoreClientTypes.BrowserExtension {

    static func write(value: BedrockAgentCoreClientTypes.BrowserExtension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["location"].write(value.location, with: BedrockAgentCoreClientTypes.ResourceLocation.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.BrowserExtension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.BrowserExtension()
        value.location = try reader["location"].readIfPresent(with: BedrockAgentCoreClientTypes.ResourceLocation.read(from:))
        return value
    }
}

extension BedrockAgentCoreClientTypes.ResourceLocation {

    static func write(value: BedrockAgentCoreClientTypes.ResourceLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3(s3):
                try writer["s3"].write(s3, with: BedrockAgentCoreClientTypes.S3Location.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ResourceLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3":
                return .s3(try reader["s3"].read(with: BedrockAgentCoreClientTypes.S3Location.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreClientTypes.S3Location {

    static func write(value: BedrockAgentCoreClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["prefix"].write(value.`prefix`)
        try writer["versionId"].write(value.versionId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.S3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.S3Location()
        value.bucket = try reader["bucket"].readIfPresent() ?? ""
        value.`prefix` = try reader["prefix"].readIfPresent() ?? ""
        value.versionId = try reader["versionId"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.BrowserProfileConfiguration {

    static func write(value: BedrockAgentCoreClientTypes.BrowserProfileConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["profileIdentifier"].write(value.profileIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.BrowserProfileConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.BrowserProfileConfiguration()
        value.profileIdentifier = try reader["profileIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreClientTypes.BrowserSessionStream {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.BrowserSessionStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.BrowserSessionStream()
        value.automationStream = try reader["automationStream"].readIfPresent(with: BedrockAgentCoreClientTypes.AutomationStream.read(from:))
        value.liveViewStream = try reader["liveViewStream"].readIfPresent(with: BedrockAgentCoreClientTypes.LiveViewStream.read(from:))
        return value
    }
}

extension BedrockAgentCoreClientTypes.LiveViewStream {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.LiveViewStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.LiveViewStream()
        value.streamEndpoint = try reader["streamEndpoint"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.AutomationStream {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.AutomationStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.AutomationStream()
        value.streamEndpoint = try reader["streamEndpoint"].readIfPresent() ?? ""
        value.streamStatus = try reader["streamStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockAgentCoreClientTypes.ProxyConfiguration {

    static func write(value: BedrockAgentCoreClientTypes.ProxyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bypass"].write(value.bypass, with: BedrockAgentCoreClientTypes.ProxyBypass.write(value:to:))
        try writer["proxies"].writeList(value.proxies, memberWritingClosure: BedrockAgentCoreClientTypes.Proxy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ProxyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ProxyConfiguration()
        value.proxies = try reader["proxies"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.Proxy.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.bypass = try reader["bypass"].readIfPresent(with: BedrockAgentCoreClientTypes.ProxyBypass.read(from:))
        return value
    }
}

extension BedrockAgentCoreClientTypes.ProxyBypass {

    static func write(value: BedrockAgentCoreClientTypes.ProxyBypass?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainPatterns"].writeList(value.domainPatterns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ProxyBypass {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ProxyBypass()
        value.domainPatterns = try reader["domainPatterns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentCoreClientTypes.Proxy {

    static func write(value: BedrockAgentCoreClientTypes.Proxy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .externalproxy(externalproxy):
                try writer["externalProxy"].write(externalproxy, with: BedrockAgentCoreClientTypes.ExternalProxy.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.Proxy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "externalProxy":
                return .externalproxy(try reader["externalProxy"].read(with: BedrockAgentCoreClientTypes.ExternalProxy.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreClientTypes.ExternalProxy {

    static func write(value: BedrockAgentCoreClientTypes.ExternalProxy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credentials"].write(value.credentials, with: BedrockAgentCoreClientTypes.ProxyCredentials.write(value:to:))
        try writer["domainPatterns"].writeList(value.domainPatterns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["port"].write(value.port)
        try writer["server"].write(value.server)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ExternalProxy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ExternalProxy()
        value.server = try reader["server"].readIfPresent() ?? ""
        value.port = try reader["port"].readIfPresent() ?? 0
        value.domainPatterns = try reader["domainPatterns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.credentials = try reader["credentials"].readIfPresent(with: BedrockAgentCoreClientTypes.ProxyCredentials.read(from:))
        return value
    }
}

extension BedrockAgentCoreClientTypes.ProxyCredentials {

    static func write(value: BedrockAgentCoreClientTypes.ProxyCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .basicauth(basicauth):
                try writer["basicAuth"].write(basicauth, with: BedrockAgentCoreClientTypes.BasicAuth.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ProxyCredentials {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "basicAuth":
                return .basicauth(try reader["basicAuth"].read(with: BedrockAgentCoreClientTypes.BasicAuth.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreClientTypes.BasicAuth {

    static func write(value: BedrockAgentCoreClientTypes.BasicAuth?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["secretArn"].write(value.secretArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.BasicAuth {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.BasicAuth()
        value.secretArn = try reader["secretArn"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreClientTypes.MemoryRecord {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.MemoryRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.MemoryRecord()
        value.memoryRecordId = try reader["memoryRecordId"].readIfPresent() ?? ""
        value.content = try reader["content"].readIfPresent(with: BedrockAgentCoreClientTypes.MemoryContent.read(from:))
        value.memoryStrategyId = try reader["memoryStrategyId"].readIfPresent() ?? ""
        value.namespaces = try reader["namespaces"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: BedrockAgentCoreClientTypes.MetadataValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockAgentCoreClientTypes.MemoryContent {

    static func write(value: BedrockAgentCoreClientTypes.MemoryContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.MemoryContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ValidationException {

    static func read(from reader: SmithyJSON.Reader) throws -> ValidationException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentCoreClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension ThrottlingException {

    static func read(from reader: SmithyJSON.Reader) throws -> ThrottlingException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ServiceQuotaExceededException {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotaExceededException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ResourceNotFoundException {

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceNotFoundException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension InternalServerException {

    static func read(from reader: SmithyJSON.Reader) throws -> InternalServerException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ConflictException {

    static func read(from reader: SmithyJSON.Reader) throws -> ConflictException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension AccessDeniedException {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessDeniedException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.CodeInterpreterResult {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.CodeInterpreterResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.CodeInterpreterResult()
        value.content = try reader["content"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.ContentBlock.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.structuredContent = try reader["structuredContent"].readIfPresent(with: BedrockAgentCoreClientTypes.ToolResultStructuredContent.read(from:))
        value.isError = try reader["isError"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.ToolResultStructuredContent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ToolResultStructuredContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ToolResultStructuredContent()
        value.taskId = try reader["taskId"].readIfPresent()
        value.taskStatus = try reader["taskStatus"].readIfPresent()
        value.stdout = try reader["stdout"].readIfPresent()
        value.stderr = try reader["stderr"].readIfPresent()
        value.exitCode = try reader["exitCode"].readIfPresent()
        value.executionTime = try reader["executionTime"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.ContentBlock {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ContentBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ContentBlock()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.text = try reader["text"].readIfPresent()
        value.data = try reader["data"].readIfPresent()
        value.mimeType = try reader["mimeType"].readIfPresent()
        value.uri = try reader["uri"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.size = try reader["size"].readIfPresent()
        value.resource = try reader["resource"].readIfPresent(with: BedrockAgentCoreClientTypes.ResourceContent.read(from:))
        return value
    }
}

extension BedrockAgentCoreClientTypes.ResourceContent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ResourceContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ResourceContent()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.uri = try reader["uri"].readIfPresent()
        value.mimeType = try reader["mimeType"].readIfPresent()
        value.text = try reader["text"].readIfPresent()
        value.blob = try reader["blob"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.ActorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ActorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ActorSummary()
        value.actorId = try reader["actorId"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreClientTypes.BrowserSessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.BrowserSessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.BrowserSessionSummary()
        value.browserIdentifier = try reader["browserIdentifier"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockAgentCoreClientTypes.CodeInterpreterSessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.CodeInterpreterSessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.CodeInterpreterSessionSummary()
        value.codeInterpreterIdentifier = try reader["codeInterpreterIdentifier"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockAgentCoreClientTypes.ExtractionJobMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ExtractionJobMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ExtractionJobMetadata()
        value.jobID = try reader["jobID"].readIfPresent() ?? ""
        value.messages = try reader["messages"].readIfPresent(with: BedrockAgentCoreClientTypes.ExtractionJobMessages.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.strategyId = try reader["strategyId"].readIfPresent()
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.actorId = try reader["actorId"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.ExtractionJobMessages {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ExtractionJobMessages {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "messagesList":
                return .messageslist(try reader["messagesList"].readList(memberReadingClosure: BedrockAgentCoreClientTypes.MessageMetadata.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreClientTypes.MessageMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.MessageMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.MessageMetadata()
        value.eventId = try reader["eventId"].readIfPresent() ?? ""
        value.messageIndex = try reader["messageIndex"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockAgentCoreClientTypes.MemoryRecordSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.MemoryRecordSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.MemoryRecordSummary()
        value.memoryRecordId = try reader["memoryRecordId"].readIfPresent() ?? ""
        value.content = try reader["content"].readIfPresent(with: BedrockAgentCoreClientTypes.MemoryContent.read(from:))
        value.memoryStrategyId = try reader["memoryStrategyId"].readIfPresent() ?? ""
        value.namespaces = try reader["namespaces"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.score = try reader["score"].readIfPresent()
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: BedrockAgentCoreClientTypes.MetadataValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockAgentCoreClientTypes.SessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.SessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.SessionSummary()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.actorId = try reader["actorId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentCoreClientTypes.MemoryRecordCreateInput {

    static func write(value: BedrockAgentCoreClientTypes.MemoryRecordCreateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content, with: BedrockAgentCoreClientTypes.MemoryContent.write(value:to:))
        try writer["memoryStrategyId"].write(value.memoryStrategyId)
        try writer["namespaces"].writeList(value.namespaces, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["requestIdentifier"].write(value.requestIdentifier)
        try writer["timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension BedrockAgentCoreClientTypes.MemoryRecordDeleteInput {

    static func write(value: BedrockAgentCoreClientTypes.MemoryRecordDeleteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["memoryRecordId"].write(value.memoryRecordId)
    }
}

extension BedrockAgentCoreClientTypes.MemoryRecordUpdateInput {

    static func write(value: BedrockAgentCoreClientTypes.MemoryRecordUpdateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content, with: BedrockAgentCoreClientTypes.MemoryContent.write(value:to:))
        try writer["memoryRecordId"].write(value.memoryRecordId)
        try writer["memoryStrategyId"].write(value.memoryStrategyId)
        try writer["namespaces"].writeList(value.namespaces, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension BedrockAgentCoreClientTypes.UserIdentifier {

    static func write(value: BedrockAgentCoreClientTypes.UserIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .userid(userid):
                try writer["userId"].write(userid)
            case let .usertoken(usertoken):
                try writer["userToken"].write(usertoken)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreClientTypes.EvaluationInput {

    static func write(value: BedrockAgentCoreClientTypes.EvaluationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .sessionspans(sessionspans):
                try writer["sessionSpans"].writeList(sessionspans, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreClientTypes.EvaluationTarget {

    static func write(value: BedrockAgentCoreClientTypes.EvaluationTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .spanids(spanids):
                try writer["spanIds"].writeList(spanids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .traceids(traceids):
                try writer["traceIds"].writeList(traceids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreClientTypes.ToolArguments {

    static func write(value: BedrockAgentCoreClientTypes.ToolArguments?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clearContext"].write(value.clearContext)
        try writer["code"].write(value.code)
        try writer["command"].write(value.command)
        try writer["content"].writeList(value.content, memberWritingClosure: BedrockAgentCoreClientTypes.InputContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["directoryPath"].write(value.directoryPath)
        try writer["language"].write(value.language)
        try writer["path"].write(value.path)
        try writer["paths"].writeList(value.paths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["taskId"].write(value.taskId)
    }
}

extension BedrockAgentCoreClientTypes.InputContentBlock {

    static func write(value: BedrockAgentCoreClientTypes.InputContentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blob"].write(value.blob)
        try writer["path"].write(value.path)
        try writer["text"].write(value.text)
    }
}

extension BedrockAgentCoreClientTypes.FilterInput {

    static func write(value: BedrockAgentCoreClientTypes.FilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["branch"].write(value.branch, with: BedrockAgentCoreClientTypes.BranchFilter.write(value:to:))
        try writer["eventMetadata"].writeList(value.eventMetadata, memberWritingClosure: BedrockAgentCoreClientTypes.EventMetadataFilterExpression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockAgentCoreClientTypes.EventMetadataFilterExpression {

    static func write(value: BedrockAgentCoreClientTypes.EventMetadataFilterExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["left"].write(value.`left`, with: BedrockAgentCoreClientTypes.LeftExpression.write(value:to:))
        try writer["operator"].write(value.`operator`)
        try writer["right"].write(value.`right`, with: BedrockAgentCoreClientTypes.RightExpression.write(value:to:))
    }
}

extension BedrockAgentCoreClientTypes.RightExpression {

    static func write(value: BedrockAgentCoreClientTypes.RightExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .metadatavalue(metadatavalue):
                try writer["metadataValue"].write(metadatavalue, with: BedrockAgentCoreClientTypes.MetadataValue.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreClientTypes.LeftExpression {

    static func write(value: BedrockAgentCoreClientTypes.LeftExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .metadatakey(metadatakey):
                try writer["metadataKey"].write(metadatakey)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreClientTypes.BranchFilter {

    static func write(value: BedrockAgentCoreClientTypes.BranchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeParentBranches"].write(value.includeParentBranches)
        try writer["name"].write(value.name)
    }
}

extension BedrockAgentCoreClientTypes.ExtractionJobFilterInput {

    static func write(value: BedrockAgentCoreClientTypes.ExtractionJobFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actorId"].write(value.actorId)
        try writer["sessionId"].write(value.sessionId)
        try writer["status"].write(value.status)
        try writer["strategyId"].write(value.strategyId)
    }
}

extension BedrockAgentCoreClientTypes.SearchCriteria {

    static func write(value: BedrockAgentCoreClientTypes.SearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["memoryStrategyId"].write(value.memoryStrategyId)
        try writer["metadataFilters"].writeList(value.metadataFilters, memberWritingClosure: BedrockAgentCoreClientTypes.MemoryMetadataFilterExpression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["searchQuery"].write(value.searchQuery)
        try writer["topK"].write(value.topk)
    }
}

extension BedrockAgentCoreClientTypes.MemoryMetadataFilterExpression {

    static func write(value: BedrockAgentCoreClientTypes.MemoryMetadataFilterExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["left"].write(value.`left`, with: BedrockAgentCoreClientTypes.LeftExpression.write(value:to:))
        try writer["operator"].write(value.`operator`)
        try writer["right"].write(value.`right`, with: BedrockAgentCoreClientTypes.RightExpression.write(value:to:))
    }
}

extension BedrockAgentCoreClientTypes.ExtractionJob {

    static func write(value: BedrockAgentCoreClientTypes.ExtractionJob?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobId"].write(value.jobId)
    }
}

extension BedrockAgentCoreClientTypes.StreamUpdate {

    static func write(value: BedrockAgentCoreClientTypes.StreamUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .automationstreamupdate(automationstreamupdate):
                try writer["automationStreamUpdate"].write(automationstreamupdate, with: BedrockAgentCoreClientTypes.AutomationStreamUpdate.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreClientTypes.AutomationStreamUpdate {

    static func write(value: BedrockAgentCoreClientTypes.AutomationStreamUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["streamStatus"].write(value.streamStatus)
    }
}

public enum BedrockAgentCoreClientTypes {}
