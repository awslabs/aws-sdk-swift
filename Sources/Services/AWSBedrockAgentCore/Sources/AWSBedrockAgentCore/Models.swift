//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyEventStreams.DefaultMessageDecoder
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ByteStream
import enum Smithy.ClientError
import enum SmithyEventStreamsAPI.MessageType
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
import struct SmithyEventStreams.DefaultMessageDecoderStream
import struct SmithyEventStreamsAPI.Message
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter
import typealias SmithyEventStreamsAPI.UnmarshalClosure

/// The exception that occurs when you do not have sufficient permissions to perform an action. Verify that your IAM policy includes the necessary permissions for the operation you are trying to perform.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains summary information about an actor in an AgentCore Memory resource.
    public struct ActorSummary: Swift.Sendable {
        /// The unique identifier of the actor.
        /// This member is required.
        public var actorId: Swift.String?

        public init(
            actorId: Swift.String? = nil
        ) {
            self.actorId = actorId
        }
    }
}

/// The exception that occurs when the service encounters an unexpected internal error. This is a temporary condition that will resolve itself with retries. We recommend implementing exponential backoff retry logic in your application.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The exception that occurs when the specified resource does not exist. This can happen when using an invalid identifier or when trying to access a resource that has been deleted.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The exception that occurs when there is an error in the runtime client. This can happen due to network issues, invalid configuration, or other client-side problems. Check the error message for specific details about the error.
public struct RuntimeClientError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RuntimeClientError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The exception that occurs when the request would cause a service quota to be exceeded. Review your service quotas and either reduce your request rate or request a quota increase.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The exception that occurs when the request was denied due to request throttling. This happens when you exceed the allowed request rate for an operation. Reduce the frequency of requests or implement exponential backoff retry logic in your application.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockAgentCoreClientTypes {

    /// Stores information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message describing why this field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

extension BedrockAgentCoreClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case idempotentParameterMismatchException
        case resourceConflict
        case rootEventInOtherSession
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .idempotentParameterMismatchException,
                .resourceConflict,
                .rootEventInOtherSession
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CannotParse"
            case .fieldValidationFailed: return "FieldValidationFailed"
            case .idempotentParameterMismatchException: return "IdempotentParameterMismatchException"
            case .resourceConflict: return "ResourceConflict"
            case .rootEventInOtherSession: return "EventInOtherSession"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The exception that occurs when the input fails to satisfy the constraints specified by the service. Check the error message for details about which input parameter is invalid and correct your request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var fieldList: [BedrockAgentCoreClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// This member is required.
        public internal(set) var reason: BedrockAgentCoreClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [BedrockAgentCoreClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: BedrockAgentCoreClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct GetAgentCardInput: Swift.Sendable {
    /// The ARN of the AgentCore Runtime agent for which you want to get the A2A agent card.
    /// This member is required.
    public var agentRuntimeArn: Swift.String?
    /// Optional qualifier to specify an agent alias, such as prodcode> or dev. If you don't provide a value, the DEFAULT alias is used.
    public var qualifier: Swift.String?
    /// The session ID that the AgentCore Runtime agent is using.
    public var runtimeSessionId: Swift.String?

    public init(
        agentRuntimeArn: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        runtimeSessionId: Swift.String? = nil
    ) {
        self.agentRuntimeArn = agentRuntimeArn
        self.qualifier = qualifier
        self.runtimeSessionId = runtimeSessionId
    }
}

public struct GetAgentCardOutput: Swift.Sendable {
    /// An agent card document that contains metadata and capabilities for an AgentCore Runtime agent.
    /// This member is required.
    public var agentCard: Smithy.Document?
    /// The ID of the session associated with the AgentCore Runtime agent.
    public var runtimeSessionId: Swift.String?
    /// The status code of the request.
    public var statusCode: Swift.Int?

    public init(
        agentCard: Smithy.Document? = nil,
        runtimeSessionId: Swift.String? = nil,
        statusCode: Swift.Int? = nil
    ) {
        self.agentCard = agentCard
        self.runtimeSessionId = runtimeSessionId
        self.statusCode = statusCode
    }
}

public struct InvokeAgentRuntimeInput: Swift.Sendable {
    /// The desired MIME type for the response from the agent runtime. This tells the agent runtime what format to use for the response data. Common values include application/json for JSON data.
    public var accept: Swift.String?
    /// The Amazon Web Services Resource Name (ARN) of the agent runtime to invoke. The ARN uniquely identifies the agent runtime resource in Amazon Bedrock.
    /// This member is required.
    public var agentRuntimeArn: Swift.String?
    /// Additional context information for distributed tracing.
    public var baggage: Swift.String?
    /// The MIME type of the input data in the payload. This tells the agent runtime how to interpret the payload data. Common values include application/json for JSON data.
    public var contentType: Swift.String?
    /// The version of the MCP protocol being used.
    public var mcpProtocolVersion: Swift.String?
    /// The identifier of the MCP session.
    public var mcpSessionId: Swift.String?
    /// The input data to send to the agent runtime. The format of this data depends on the specific agent configuration and must match the specified content type. For most agents, this is a JSON object containing the user's request.
    /// This member is required.
    public var payload: Foundation.Data?
    /// The qualifier to use for the agent runtime. This can be a version number or an endpoint name that points to a specific version. If not specified, Amazon Bedrock uses the default version of the agent runtime.
    public var qualifier: Swift.String?
    /// The identifier of the runtime session.
    public var runtimeSessionId: Swift.String?
    /// The identifier of the runtime user.
    public var runtimeUserId: Swift.String?
    /// The trace identifier for request tracking.
    public var traceId: Swift.String?
    /// The parent trace information for distributed tracing.
    public var traceParent: Swift.String?
    /// The trace state information for distributed tracing.
    public var traceState: Swift.String?

    public init(
        accept: Swift.String? = nil,
        agentRuntimeArn: Swift.String? = nil,
        baggage: Swift.String? = nil,
        contentType: Swift.String? = nil,
        mcpProtocolVersion: Swift.String? = nil,
        mcpSessionId: Swift.String? = nil,
        payload: Foundation.Data? = nil,
        qualifier: Swift.String? = nil,
        runtimeSessionId: Swift.String? = nil,
        runtimeUserId: Swift.String? = nil,
        traceId: Swift.String? = nil,
        traceParent: Swift.String? = nil,
        traceState: Swift.String? = nil
    ) {
        self.accept = accept
        self.agentRuntimeArn = agentRuntimeArn
        self.baggage = baggage
        self.contentType = contentType
        self.mcpProtocolVersion = mcpProtocolVersion
        self.mcpSessionId = mcpSessionId
        self.payload = payload
        self.qualifier = qualifier
        self.runtimeSessionId = runtimeSessionId
        self.runtimeUserId = runtimeUserId
        self.traceId = traceId
        self.traceParent = traceParent
        self.traceState = traceState
    }
}

extension InvokeAgentRuntimeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeAgentRuntimeInput(accept: \(Swift.String(describing: accept)), agentRuntimeArn: \(Swift.String(describing: agentRuntimeArn)), baggage: \(Swift.String(describing: baggage)), contentType: \(Swift.String(describing: contentType)), mcpProtocolVersion: \(Swift.String(describing: mcpProtocolVersion)), mcpSessionId: \(Swift.String(describing: mcpSessionId)), qualifier: \(Swift.String(describing: qualifier)), runtimeSessionId: \(Swift.String(describing: runtimeSessionId)), runtimeUserId: \(Swift.String(describing: runtimeUserId)), traceId: \(Swift.String(describing: traceId)), traceParent: \(Swift.String(describing: traceParent)), traceState: \(Swift.String(describing: traceState)), payload: \"CONTENT_REDACTED\")"}
}

public struct InvokeAgentRuntimeOutput: Swift.Sendable {
    /// Additional context information for distributed tracing.
    public var baggage: Swift.String?
    /// The MIME type of the response data. This indicates how to interpret the response data. Common values include application/json for JSON data.
    /// This member is required.
    public var contentType: Swift.String?
    /// The version of the MCP protocol being used.
    public var mcpProtocolVersion: Swift.String?
    /// The identifier of the MCP session.
    public var mcpSessionId: Swift.String?
    /// The response data from the agent runtime. The format of this data depends on the specific agent configuration and the requested accept type. For most agents, this is a JSON object containing the agent's response to the user's request.
    public var response: Smithy.ByteStream?
    /// The identifier of the runtime session.
    public var runtimeSessionId: Swift.String?
    /// The HTTP status code of the response. A status code of 200 indicates a successful operation. Other status codes indicate various error conditions.
    public var statusCode: Swift.Int?
    /// The trace identifier for request tracking.
    public var traceId: Swift.String?
    /// The parent trace information for distributed tracing.
    public var traceParent: Swift.String?
    /// The trace state information for distributed tracing.
    public var traceState: Swift.String?

    public init(
        baggage: Swift.String? = nil,
        contentType: Swift.String? = nil,
        mcpProtocolVersion: Swift.String? = nil,
        mcpSessionId: Swift.String? = nil,
        response: Smithy.ByteStream? = Smithy.ByteStream.data(Foundation.Data(base64Encoded: "")),
        runtimeSessionId: Swift.String? = nil,
        statusCode: Swift.Int? = nil,
        traceId: Swift.String? = nil,
        traceParent: Swift.String? = nil,
        traceState: Swift.String? = nil
    ) {
        self.baggage = baggage
        self.contentType = contentType
        self.mcpProtocolVersion = mcpProtocolVersion
        self.mcpSessionId = mcpSessionId
        self.response = response
        self.runtimeSessionId = runtimeSessionId
        self.statusCode = statusCode
        self.traceId = traceId
        self.traceParent = traceParent
        self.traceState = traceState
    }
}

extension InvokeAgentRuntimeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeAgentRuntimeOutput(baggage: \(Swift.String(describing: baggage)), contentType: \(Swift.String(describing: contentType)), mcpProtocolVersion: \(Swift.String(describing: mcpProtocolVersion)), mcpSessionId: \(Swift.String(describing: mcpSessionId)), runtimeSessionId: \(Swift.String(describing: runtimeSessionId)), statusCode: \(Swift.String(describing: statusCode)), traceId: \(Swift.String(describing: traceId)), traceParent: \(Swift.String(describing: traceParent)), traceState: \(Swift.String(describing: traceState)), response: \"CONTENT_REDACTED\")"}
}

/// The exception that occurs when the request conflicts with the current state of the resource. This can happen when trying to modify a resource that is currently being modified by another request, or when trying to create a resource that already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown when the JWT bearer token is invalid or not found for OAuth bearer token based access
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct StopRuntimeSessionInput: Swift.Sendable {
    /// The ARN of the agent that contains the session that you want to stop.
    /// This member is required.
    public var agentRuntimeArn: Swift.String?
    /// Idempotent token used to identify the request. If you use the same token with multiple requests, the same response is returned. Use ClientToken to prevent the same request from being processed more than once.
    public var clientToken: Swift.String?
    /// Optional qualifier to specify an agent alias, such as prodcode> or dev. If you don't provide a value, the DEFAULT alias is used.
    public var qualifier: Swift.String?
    /// The ID of the session that you want to stop.
    /// This member is required.
    public var runtimeSessionId: Swift.String?

    public init(
        agentRuntimeArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        runtimeSessionId: Swift.String? = nil
    ) {
        self.agentRuntimeArn = agentRuntimeArn
        self.clientToken = clientToken
        self.qualifier = qualifier
        self.runtimeSessionId = runtimeSessionId
    }
}

public struct StopRuntimeSessionOutput: Swift.Sendable {
    /// The ID of the session that you requested to stop.
    public var runtimeSessionId: Swift.String?
    /// The status code of the request to stop the session.
    public var statusCode: Swift.Int?

    public init(
        runtimeSessionId: Swift.String? = nil,
        statusCode: Swift.Int? = nil
    ) {
        self.runtimeSessionId = runtimeSessionId
        self.statusCode = statusCode
    }
}

public struct GetBrowserSessionInput: Swift.Sendable {
    /// The unique identifier of the browser associated with the session.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// The unique identifier of the browser session to retrieve.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        browserIdentifier: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.sessionId = sessionId
    }
}

extension BedrockAgentCoreClientTypes {

    public enum BrowserSessionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ready
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [BrowserSessionStatus] {
            return [
                .ready,
                .terminated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ready: return "READY"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    public enum AutomationStreamStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationStreamStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The configuration for a stream that enables programmatic control of a browser session in Amazon Bedrock. This stream provides a bidirectional communication channel for sending commands to the browser and receiving responses, allowing agents to automate web interactions such as navigation, form filling, and element clicking.
    public struct AutomationStream: Swift.Sendable {
        /// The endpoint URL for the automation stream. This URL is used to establish a WebSocket connection to the stream for sending commands and receiving responses.
        /// This member is required.
        public var streamEndpoint: Swift.String?
        /// The current status of the automation stream. This indicates whether the stream is available for use. Possible values include ACTIVE, CONNECTING, and DISCONNECTED.
        /// This member is required.
        public var streamStatus: BedrockAgentCoreClientTypes.AutomationStreamStatus?

        public init(
            streamEndpoint: Swift.String? = nil,
            streamStatus: BedrockAgentCoreClientTypes.AutomationStreamStatus? = nil
        ) {
            self.streamEndpoint = streamEndpoint
            self.streamStatus = streamStatus
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The configuration for a stream that provides a visual representation of a browser session in Amazon Bedrock. This stream enables agents to observe the current state of the browser, including rendered web pages, visual elements, and the results of interactions.
    public struct LiveViewStream: Swift.Sendable {
        /// The endpoint URL for the live view stream. This URL is used to establish a connection to receive visual updates from the browser session.
        public var streamEndpoint: Swift.String?

        public init(
            streamEndpoint: Swift.String? = nil
        ) {
            self.streamEndpoint = streamEndpoint
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The collection of streams associated with a browser session in Amazon Bedrock. These streams provide different ways to interact with and observe the browser session, including programmatic control and visual representation of the browser content.
    public struct BrowserSessionStream: Swift.Sendable {
        /// The stream that enables programmatic control of the browser. This stream allows agents to perform actions such as navigating to URLs, clicking elements, and filling forms.
        /// This member is required.
        public var automationStream: BedrockAgentCoreClientTypes.AutomationStream?
        /// The stream that provides a visual representation of the browser content. This stream allows agents to observe the current state of the browser, including rendered web pages and visual elements.
        public var liveViewStream: BedrockAgentCoreClientTypes.LiveViewStream?

        public init(
            automationStream: BedrockAgentCoreClientTypes.AutomationStream? = nil,
            liveViewStream: BedrockAgentCoreClientTypes.LiveViewStream? = nil
        ) {
            self.automationStream = automationStream
            self.liveViewStream = liveViewStream
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The configuration that defines the dimensions of a browser viewport in a browser session. The viewport determines the visible area of web content and affects how web pages are rendered and displayed. Proper viewport configuration ensures that web content is displayed correctly for the agent's browsing tasks.
    public struct ViewPort: Swift.Sendable {
        /// The height of the viewport in pixels. This value determines the vertical dimension of the visible area. Valid values range from 600 to 1080 pixels.
        /// This member is required.
        public var height: Swift.Int?
        /// The width of the viewport in pixels. This value determines the horizontal dimension of the visible area. Valid values range from 800 to 1920 pixels.
        /// This member is required.
        public var width: Swift.Int?

        public init(
            height: Swift.Int? = nil,
            width: Swift.Int? = nil
        ) {
            self.height = height
            self.width = width
        }
    }
}

public struct GetBrowserSessionOutput: Swift.Sendable {
    /// The identifier of the browser.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// The time at which the browser session was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The time at which the browser session was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the browser session.
    public var name: Swift.String?
    /// The identifier of the browser session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The artifact containing the session replay information.
    public var sessionReplayArtifact: Swift.String?
    /// The timeout period for the browser session in seconds.
    public var sessionTimeoutSeconds: Swift.Int?
    /// The current status of the browser session. Possible values include ACTIVE, STOPPING, and STOPPED.
    public var status: BedrockAgentCoreClientTypes.BrowserSessionStatus?
    /// The streams associated with this browser session. These include the automation stream and live view stream.
    public var streams: BedrockAgentCoreClientTypes.BrowserSessionStream?
    /// The configuration that defines the dimensions of a browser viewport in a browser session. The viewport determines the visible area of web content and affects how web pages are rendered and displayed. Proper viewport configuration ensures that web content is displayed correctly for the agent's browsing tasks.
    public var viewPort: BedrockAgentCoreClientTypes.ViewPort?

    public init(
        browserIdentifier: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionReplayArtifact: Swift.String? = nil,
        sessionTimeoutSeconds: Swift.Int? = nil,
        status: BedrockAgentCoreClientTypes.BrowserSessionStatus? = nil,
        streams: BedrockAgentCoreClientTypes.BrowserSessionStream? = nil,
        viewPort: BedrockAgentCoreClientTypes.ViewPort? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.sessionId = sessionId
        self.sessionReplayArtifact = sessionReplayArtifact
        self.sessionTimeoutSeconds = sessionTimeoutSeconds
        self.status = status
        self.streams = streams
        self.viewPort = viewPort
    }
}

public struct ListBrowserSessionsInput: Swift.Sendable {
    /// The unique identifier of the browser to list sessions for. If specified, only sessions for this browser are returned. If not specified, sessions for all browsers are returned.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// The maximum number of results to return in a single call. The default value is 10. Valid values range from 1 to 100. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. If not specified, Amazon Bedrock returns the first page of results.
    public var nextToken: Swift.String?
    /// The status of the browser sessions to list. Valid values include ACTIVE, STOPPING, and STOPPED. If not specified, sessions with any status are returned.
    public var status: BedrockAgentCoreClientTypes.BrowserSessionStatus?

    public init(
        browserIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: BedrockAgentCoreClientTypes.BrowserSessionStatus? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension BedrockAgentCoreClientTypes {

    /// A condensed representation of a browser session in Amazon Bedrock. This structure contains key information about a browser session, including identifiers, status, and timestamps, without the full details of the session configuration and streams.
    public struct BrowserSessionSummary: Swift.Sendable {
        /// The unique identifier of the browser associated with the session. This identifier specifies which browser environment is used for the session.
        /// This member is required.
        public var browserIdentifier: Swift.String?
        /// The timestamp when the browser session was created. This value is in ISO 8601 format.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The timestamp when the browser session was last updated. This value is in ISO 8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the browser session. This name helps identify and manage the session.
        public var name: Swift.String?
        /// The unique identifier of the browser session. This identifier is used in operations that interact with the session.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The current status of the browser session. Possible values include ACTIVE, STOPPING, and STOPPED.
        /// This member is required.
        public var status: BedrockAgentCoreClientTypes.BrowserSessionStatus?

        public init(
            browserIdentifier: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            status: BedrockAgentCoreClientTypes.BrowserSessionStatus? = nil
        ) {
            self.browserIdentifier = browserIdentifier
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.sessionId = sessionId
            self.status = status
        }
    }
}

public struct ListBrowserSessionsOutput: Swift.Sendable {
    /// The list of browser sessions that match the specified criteria.
    /// This member is required.
    public var items: [BedrockAgentCoreClientTypes.BrowserSessionSummary]?
    /// The token to use in a subsequent ListBrowserSessions request to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [BedrockAgentCoreClientTypes.BrowserSessionSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct StartBrowserSessionInput: Swift.Sendable {
    /// The unique identifier of the browser to use for this session. This identifier specifies which browser environment to initialize for the session.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. This parameter helps prevent the creation of duplicate sessions if there are temporary network issues.
    public var clientToken: Swift.String?
    /// The name of the browser session. This name helps you identify and manage the session. The name does not need to be unique.
    public var name: Swift.String?
    /// The time in seconds after which the session automatically terminates if there is no activity. The default value is 3600 seconds (1 hour). The minimum allowed value is 60 seconds, and the maximum allowed value is 28800 seconds (8 hours).
    public var sessionTimeoutSeconds: Swift.Int?
    /// The dimensions of the browser viewport for this session. This determines the visible area of the web content and affects how web pages are rendered. If not specified, Amazon Bedrock uses a default viewport size.
    public var viewPort: BedrockAgentCoreClientTypes.ViewPort?

    public init(
        browserIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        sessionTimeoutSeconds: Swift.Int? = nil,
        viewPort: BedrockAgentCoreClientTypes.ViewPort? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.clientToken = clientToken
        self.name = name
        self.sessionTimeoutSeconds = sessionTimeoutSeconds
        self.viewPort = viewPort
    }
}

public struct StartBrowserSessionOutput: Swift.Sendable {
    /// The identifier of the browser.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// The timestamp when the browser session was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The unique identifier of the created browser session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The streams associated with this browser session. These include the automation stream and live view stream.
    public var streams: BedrockAgentCoreClientTypes.BrowserSessionStream?

    public init(
        browserIdentifier: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        sessionId: Swift.String? = nil,
        streams: BedrockAgentCoreClientTypes.BrowserSessionStream? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.createdAt = createdAt
        self.sessionId = sessionId
        self.streams = streams
    }
}

public struct StopBrowserSessionInput: Swift.Sendable {
    /// The unique identifier of the browser associated with the session.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
    public var clientToken: Swift.String?
    /// The unique identifier of the browser session to stop.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        browserIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.clientToken = clientToken
        self.sessionId = sessionId
    }
}

public struct StopBrowserSessionOutput: Swift.Sendable {
    /// The identifier of the browser.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// The time at which the browser session was last updated.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The identifier of the browser session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        browserIdentifier: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.lastUpdatedAt = lastUpdatedAt
        self.sessionId = sessionId
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains information about an update to an automation stream.
    public struct AutomationStreamUpdate: Swift.Sendable {
        /// The status of the automation stream.
        public var streamStatus: BedrockAgentCoreClientTypes.AutomationStreamStatus?

        public init(
            streamStatus: BedrockAgentCoreClientTypes.AutomationStreamStatus? = nil
        ) {
            self.streamStatus = streamStatus
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains information about an update to a stream.
    public enum StreamUpdate: Swift.Sendable {
        /// The update to an automation stream.
        case automationstreamupdate(BedrockAgentCoreClientTypes.AutomationStreamUpdate)
        case sdkUnknown(Swift.String)
    }
}

public struct UpdateBrowserStreamInput: Swift.Sendable {
    /// The identifier of the browser.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
    public var clientToken: Swift.String?
    /// The identifier of the browser session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The update to apply to the browser stream.
    /// This member is required.
    public var streamUpdate: BedrockAgentCoreClientTypes.StreamUpdate?

    public init(
        browserIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        streamUpdate: BedrockAgentCoreClientTypes.StreamUpdate? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.streamUpdate = streamUpdate
    }
}

public struct UpdateBrowserStreamOutput: Swift.Sendable {
    /// The identifier of the browser.
    /// This member is required.
    public var browserIdentifier: Swift.String?
    /// The identifier of the browser session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The collection of streams associated with a browser session in Amazon Bedrock. These streams provide different ways to interact with and observe the browser session, including programmatic control and visual representation of the browser content.
    /// This member is required.
    public var streams: BedrockAgentCoreClientTypes.BrowserSessionStream?
    /// The time at which the browser stream was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        browserIdentifier: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        streams: BedrockAgentCoreClientTypes.BrowserSessionStream? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.browserIdentifier = browserIdentifier
        self.sessionId = sessionId
        self.streams = streams
        self.updatedAt = updatedAt
    }
}

public struct GetCodeInterpreterSessionInput: Swift.Sendable {
    /// The unique identifier of the code interpreter associated with the session.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The unique identifier of the code interpreter session to retrieve.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        codeInterpreterIdentifier: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.sessionId = sessionId
    }
}

extension BedrockAgentCoreClientTypes {

    public enum CodeInterpreterSessionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ready
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeInterpreterSessionStatus] {
            return [
                .ready,
                .terminated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ready: return "READY"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetCodeInterpreterSessionOutput: Swift.Sendable {
    /// The identifier of the code interpreter.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The time at which the code interpreter session was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The name of the code interpreter session.
    public var name: Swift.String?
    /// The identifier of the code interpreter session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The timeout period for the code interpreter session in seconds.
    public var sessionTimeoutSeconds: Swift.Int?
    /// The current status of the code interpreter session. Possible values include ACTIVE, STOPPING, and STOPPED.
    public var status: BedrockAgentCoreClientTypes.CodeInterpreterSessionStatus?

    public init(
        codeInterpreterIdentifier: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionTimeoutSeconds: Swift.Int? = nil,
        status: BedrockAgentCoreClientTypes.CodeInterpreterSessionStatus? = nil
    ) {
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.createdAt = createdAt
        self.name = name
        self.sessionId = sessionId
        self.sessionTimeoutSeconds = sessionTimeoutSeconds
        self.status = status
    }
}

public struct ListCodeInterpreterSessionsInput: Swift.Sendable {
    /// The unique identifier of the code interpreter to list sessions for. If specified, only sessions for this code interpreter are returned. If not specified, sessions for all code interpreters are returned.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The maximum number of results to return in a single call. The default value is 10. Valid values range from 1 to 100. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. If not specified, Amazon Bedrock returns the first page of results.
    public var nextToken: Swift.String?
    /// The status of the code interpreter sessions to list. Valid values include ACTIVE, STOPPING, and STOPPED. If not specified, sessions with any status are returned.
    public var status: BedrockAgentCoreClientTypes.CodeInterpreterSessionStatus?

    public init(
        codeInterpreterIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: BedrockAgentCoreClientTypes.CodeInterpreterSessionStatus? = nil
    ) {
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension BedrockAgentCoreClientTypes {

    /// A condensed representation of a code interpreter session in Amazon Bedrock. This structure contains key information about a code interpreter session, including identifiers, status, and timestamps, without the full details of the session configuration.
    public struct CodeInterpreterSessionSummary: Swift.Sendable {
        /// The unique identifier of the code interpreter associated with the session. This identifier specifies which code interpreter environment is used for the session.
        /// This member is required.
        public var codeInterpreterIdentifier: Swift.String?
        /// The timestamp when the code interpreter session was created. This value is in ISO 8601 format.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The timestamp when the code interpreter session was last updated. This value is in ISO 8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the code interpreter session. This name helps identify and manage the session.
        public var name: Swift.String?
        /// The unique identifier of the code interpreter session. This identifier is used in operations that interact with the session.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The current status of the code interpreter session. Possible values include ACTIVE, STOPPING, and STOPPED.
        /// This member is required.
        public var status: BedrockAgentCoreClientTypes.CodeInterpreterSessionStatus?

        public init(
            codeInterpreterIdentifier: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            status: BedrockAgentCoreClientTypes.CodeInterpreterSessionStatus? = nil
        ) {
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.sessionId = sessionId
            self.status = status
        }
    }
}

public struct ListCodeInterpreterSessionsOutput: Swift.Sendable {
    /// The list of code interpreter sessions that match the specified criteria.
    /// This member is required.
    public var items: [BedrockAgentCoreClientTypes.CodeInterpreterSessionSummary]?
    /// The token to use in a subsequent ListCodeInterpreterSessions request to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [BedrockAgentCoreClientTypes.CodeInterpreterSessionSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct StartCodeInterpreterSessionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. This parameter helps prevent the creation of duplicate sessions if there are temporary network issues.
    public var clientToken: Swift.String?
    /// The unique identifier of the code interpreter to use for this session. This identifier specifies which code interpreter environment to initialize for the session.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The name of the code interpreter session. This name helps you identify and manage the session. The name does not need to be unique.
    public var name: Swift.String?
    /// The time in seconds after which the session automatically terminates if there is no activity. The default value is 900 seconds (15 minutes). The minimum allowed value is 60 seconds, and the maximum allowed value is 28800 seconds (8 hours).
    public var sessionTimeoutSeconds: Swift.Int?

    public init(
        clientToken: Swift.String? = nil,
        codeInterpreterIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        sessionTimeoutSeconds: Swift.Int? = nil
    ) {
        self.clientToken = clientToken
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.name = name
        self.sessionTimeoutSeconds = sessionTimeoutSeconds
    }
}

public struct StartCodeInterpreterSessionOutput: Swift.Sendable {
    /// The identifier of the code interpreter.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The time at which the code interpreter session was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The unique identifier of the created code interpreter session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        codeInterpreterIdentifier: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.createdAt = createdAt
        self.sessionId = sessionId
    }
}

public struct StopCodeInterpreterSessionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
    public var clientToken: Swift.String?
    /// The unique identifier of the code interpreter associated with the session.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The unique identifier of the code interpreter session to stop.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        codeInterpreterIdentifier: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.sessionId = sessionId
    }
}

public struct StopCodeInterpreterSessionOutput: Swift.Sendable {
    /// The identifier of the code interpreter.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The timestamp when the code interpreter session was last updated.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The identifier of the code interpreter session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        codeInterpreterIdentifier: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.lastUpdatedAt = lastUpdatedAt
        self.sessionId = sessionId
    }
}

public struct GetResourceApiKeyInput: Swift.Sendable {
    /// The credential provider name for the resource from which you are retrieving the API key.
    /// This member is required.
    public var resourceCredentialProviderName: Swift.String?
    /// The identity token of the workload from which you want to retrieve the API key.
    /// This member is required.
    public var workloadIdentityToken: Swift.String?

    public init(
        resourceCredentialProviderName: Swift.String? = nil,
        workloadIdentityToken: Swift.String? = nil
    ) {
        self.resourceCredentialProviderName = resourceCredentialProviderName
        self.workloadIdentityToken = workloadIdentityToken
    }
}

extension GetResourceApiKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceApiKeyInput(resourceCredentialProviderName: \(Swift.String(describing: resourceCredentialProviderName)), workloadIdentityToken: \"CONTENT_REDACTED\")"}
}

public struct GetResourceApiKeyOutput: Swift.Sendable {
    /// The API key associated with the resource requested.
    /// This member is required.
    public var apiKey: Swift.String?

    public init(
        apiKey: Swift.String? = nil
    ) {
        self.apiKey = apiKey
    }
}

extension GetResourceApiKeyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceApiKeyOutput(apiKey: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreClientTypes {

    public enum Oauth2FlowType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case m2m
        case userFederation
        case sdkUnknown(Swift.String)

        public static var allCases: [Oauth2FlowType] {
            return [
                .m2m,
                .userFederation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .m2m: return "M2M"
            case .userFederation: return "USER_FEDERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetResourceOauth2TokenInput: Swift.Sendable {
    /// A map of custom parameters to include in the authorization request to the resource credential provider. These parameters are in addition to the standard OAuth 2.0 flow parameters, and will not override them.
    public var customParameters: [Swift.String: Swift.String]?
    /// Indicates whether to always initiate a new three-legged OAuth (3LO) flow, regardless of any existing session.
    public var forceAuthentication: Swift.Bool?
    /// The type of flow to be performed.
    /// This member is required.
    public var oauth2Flow: BedrockAgentCoreClientTypes.Oauth2FlowType?
    /// The name of the resource's credential provider.
    /// This member is required.
    public var resourceCredentialProviderName: Swift.String?
    /// The callback URL to redirect to after the OAuth 2.0 token retrieval is complete. This URL must be one of the provided URLs configured for the workload identity.
    public var resourceOauth2ReturnUrl: Swift.String?
    /// The OAuth scopes being requested.
    /// This member is required.
    public var scopes: [Swift.String]?
    /// The identity token of the workload from which you want to retrieve the OAuth2 token.
    /// This member is required.
    public var workloadIdentityToken: Swift.String?

    public init(
        customParameters: [Swift.String: Swift.String]? = nil,
        forceAuthentication: Swift.Bool? = nil,
        oauth2Flow: BedrockAgentCoreClientTypes.Oauth2FlowType? = nil,
        resourceCredentialProviderName: Swift.String? = nil,
        resourceOauth2ReturnUrl: Swift.String? = nil,
        scopes: [Swift.String]? = nil,
        workloadIdentityToken: Swift.String? = nil
    ) {
        self.customParameters = customParameters
        self.forceAuthentication = forceAuthentication
        self.oauth2Flow = oauth2Flow
        self.resourceCredentialProviderName = resourceCredentialProviderName
        self.resourceOauth2ReturnUrl = resourceOauth2ReturnUrl
        self.scopes = scopes
        self.workloadIdentityToken = workloadIdentityToken
    }
}

extension GetResourceOauth2TokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceOauth2TokenInput(forceAuthentication: \(Swift.String(describing: forceAuthentication)), oauth2Flow: \(Swift.String(describing: oauth2Flow)), resourceCredentialProviderName: \(Swift.String(describing: resourceCredentialProviderName)), resourceOauth2ReturnUrl: \(Swift.String(describing: resourceOauth2ReturnUrl)), scopes: \(Swift.String(describing: scopes)), customParameters: [keys: \(Swift.String(describing: customParameters?.keys)), values: \"CONTENT_REDACTED\"], workloadIdentityToken: \"CONTENT_REDACTED\")"}
}

public struct GetResourceOauth2TokenOutput: Swift.Sendable {
    /// The OAuth 2.0 access token to use.
    public var accessToken: Swift.String?
    /// The URL to initiate the authorization process, provided when the access token requires user authorization.
    public var authorizationUrl: Swift.String?

    public init(
        accessToken: Swift.String? = nil,
        authorizationUrl: Swift.String? = nil
    ) {
        self.accessToken = accessToken
        self.authorizationUrl = authorizationUrl
    }
}

extension GetResourceOauth2TokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceOauth2TokenOutput(authorizationUrl: \(Swift.String(describing: authorizationUrl)), accessToken: \"CONTENT_REDACTED\")"}
}

public struct GetWorkloadAccessTokenInput: Swift.Sendable {
    /// The unique identifier for the registered workload.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        workloadName: Swift.String? = nil
    ) {
        self.workloadName = workloadName
    }
}

public struct GetWorkloadAccessTokenOutput: Swift.Sendable {
    /// An opaque token representing the identity of both the workload and the user.
    /// This member is required.
    public var workloadAccessToken: Swift.String?

    public init(
        workloadAccessToken: Swift.String? = nil
    ) {
        self.workloadAccessToken = workloadAccessToken
    }
}

extension GetWorkloadAccessTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkloadAccessTokenOutput(workloadAccessToken: \"CONTENT_REDACTED\")"}
}

public struct GetWorkloadAccessTokenForJWTInput: Swift.Sendable {
    /// The OAuth 2.0 token issued by the user's identity provider.
    /// This member is required.
    public var userToken: Swift.String?
    /// The unique identifier for the registered workload.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        userToken: Swift.String? = nil,
        workloadName: Swift.String? = nil
    ) {
        self.userToken = userToken
        self.workloadName = workloadName
    }
}

extension GetWorkloadAccessTokenForJWTInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkloadAccessTokenForJWTInput(workloadName: \(Swift.String(describing: workloadName)), userToken: \"CONTENT_REDACTED\")"}
}

public struct GetWorkloadAccessTokenForJWTOutput: Swift.Sendable {
    /// An opaque token representing the identity of both the workload and the user.
    /// This member is required.
    public var workloadAccessToken: Swift.String?

    public init(
        workloadAccessToken: Swift.String? = nil
    ) {
        self.workloadAccessToken = workloadAccessToken
    }
}

extension GetWorkloadAccessTokenForJWTOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkloadAccessTokenForJWTOutput(workloadAccessToken: \"CONTENT_REDACTED\")"}
}

public struct GetWorkloadAccessTokenForUserIdInput: Swift.Sendable {
    /// The ID of the user for whom you are retrieving the access token.
    /// This member is required.
    public var userId: Swift.String?
    /// The name of the workload from which you want to retrieve the access token.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        userId: Swift.String? = nil,
        workloadName: Swift.String? = nil
    ) {
        self.userId = userId
        self.workloadName = workloadName
    }
}

public struct GetWorkloadAccessTokenForUserIdOutput: Swift.Sendable {
    /// The access token for the specified workload.
    /// This member is required.
    public var workloadAccessToken: Swift.String?

    public init(
        workloadAccessToken: Swift.String? = nil
    ) {
        self.workloadAccessToken = workloadAccessToken
    }
}

extension GetWorkloadAccessTokenForUserIdOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkloadAccessTokenForUserIdOutput(workloadAccessToken: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreClientTypes {

    /// A block of input content.
    public struct InputContentBlock: Swift.Sendable {
        /// The binary input content.
        public var blob: Foundation.Data?
        /// The path to the input content.
        /// This member is required.
        public var path: Swift.String?
        /// The text input content.
        public var text: Swift.String?

        public init(
            blob: Foundation.Data? = nil,
            path: Swift.String? = nil,
            text: Swift.String? = nil
        ) {
            self.blob = blob
            self.path = path
            self.text = text
        }
    }
}

extension BedrockAgentCoreClientTypes.InputContentBlock: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputContentBlock(path: \(Swift.String(describing: path)), text: \(Swift.String(describing: text)), blob: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentCoreClientTypes {

    public enum ProgrammingLanguage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case javascript
        case python
        case typescript
        case sdkUnknown(Swift.String)

        public static var allCases: [ProgrammingLanguage] {
            return [
                .javascript,
                .python,
                .typescript
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .javascript: return "javascript"
            case .python: return "python"
            case .typescript: return "typescript"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The collection of arguments that specify the operation to perform and its parameters when invoking a tool in Amazon Bedrock. Different tools require different arguments, and this structure provides a flexible way to pass the appropriate arguments to each tool type.
    public struct ToolArguments: Swift.Sendable {
        /// Whether to clear the context for the tool.
        public var clearContext: Swift.Bool?
        /// The code to execute in a code interpreter session. This is the source code in the specified programming language that will be executed by the code interpreter.
        public var code: Swift.String?
        /// The command to execute with the tool.
        public var command: Swift.String?
        /// The content for the tool operation.
        public var content: [BedrockAgentCoreClientTypes.InputContentBlock]?
        /// The directory path for the tool operation.
        public var directoryPath: Swift.String?
        /// The programming language of the code to execute. This tells the code interpreter which language runtime to use for execution. Common values include 'python', 'javascript', and 'r'.
        public var language: BedrockAgentCoreClientTypes.ProgrammingLanguage?
        /// The path for the tool operation.
        public var path: Swift.String?
        /// The paths for the tool operation.
        public var paths: [Swift.String]?
        /// The identifier of the task for the tool operation.
        public var taskId: Swift.String?

        public init(
            clearContext: Swift.Bool? = nil,
            code: Swift.String? = nil,
            command: Swift.String? = nil,
            content: [BedrockAgentCoreClientTypes.InputContentBlock]? = nil,
            directoryPath: Swift.String? = nil,
            language: BedrockAgentCoreClientTypes.ProgrammingLanguage? = nil,
            path: Swift.String? = nil,
            paths: [Swift.String]? = nil,
            taskId: Swift.String? = nil
        ) {
            self.clearContext = clearContext
            self.code = code
            self.command = command
            self.content = content
            self.directoryPath = directoryPath
            self.language = language
            self.path = path
            self.paths = paths
            self.taskId = taskId
        }
    }
}

extension BedrockAgentCoreClientTypes {

    public enum ToolName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case executeCode
        case executeCommand
        case getTask
        case listFiles
        case readFiles
        case removeFiles
        case startCommandExecution
        case stopTask
        case writeFiles
        case sdkUnknown(Swift.String)

        public static var allCases: [ToolName] {
            return [
                .executeCode,
                .executeCommand,
                .getTask,
                .listFiles,
                .readFiles,
                .removeFiles,
                .startCommandExecution,
                .stopTask,
                .writeFiles
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .executeCode: return "executeCode"
            case .executeCommand: return "executeCommand"
            case .getTask: return "getTask"
            case .listFiles: return "listFiles"
            case .readFiles: return "readFiles"
            case .removeFiles: return "removeFiles"
            case .startCommandExecution: return "startCommandExecution"
            case .stopTask: return "stopTask"
            case .writeFiles: return "writeFiles"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct InvokeCodeInterpreterInput: Swift.Sendable {
    /// The arguments for the code interpreter. This includes the code to execute and any additional parameters such as the programming language, whether to clear the execution context, and other execution options. The structure of this parameter depends on the specific code interpreter being used.
    public var arguments: BedrockAgentCoreClientTypes.ToolArguments?
    /// The unique identifier of the code interpreter associated with the session. This must match the identifier used when creating the session with StartCodeInterpreterSession.
    /// This member is required.
    public var codeInterpreterIdentifier: Swift.String?
    /// The name of the code interpreter to invoke.
    /// This member is required.
    public var name: BedrockAgentCoreClientTypes.ToolName?
    /// The unique identifier of the code interpreter session to use. This must be an active session created with StartCodeInterpreterSession. If the session has expired or been stopped, the request will fail.
    public var sessionId: Swift.String?

    public init(
        arguments: BedrockAgentCoreClientTypes.ToolArguments? = nil,
        codeInterpreterIdentifier: Swift.String? = nil,
        name: BedrockAgentCoreClientTypes.ToolName? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.arguments = arguments
        self.codeInterpreterIdentifier = codeInterpreterIdentifier
        self.name = name
        self.sessionId = sessionId
    }
}

extension BedrockAgentCoreClientTypes {

    public enum ResourceContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blob
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceContentType] {
            return [
                .blob,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blob: return "blob"
            case .text: return "text"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains information about resource content.
    public struct ResourceContent: Swift.Sendable {
        /// The binary resource content.
        public var blob: Foundation.Data?
        /// The MIME type of the resource content.
        public var mimeType: Swift.String?
        /// The text resource content.
        public var text: Swift.String?
        /// The type of resource content.
        /// This member is required.
        public var type: BedrockAgentCoreClientTypes.ResourceContentType?
        /// The URI of the resource content.
        public var uri: Swift.String?

        public init(
            blob: Foundation.Data? = nil,
            mimeType: Swift.String? = nil,
            text: Swift.String? = nil,
            type: BedrockAgentCoreClientTypes.ResourceContentType? = nil,
            uri: Swift.String? = nil
        ) {
            self.blob = blob
            self.mimeType = mimeType
            self.text = text
            self.type = type
            self.uri = uri
        }
    }
}

extension BedrockAgentCoreClientTypes {

    public enum ContentBlockType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case embeddedResource
        case image
        case resourceLink
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentBlockType] {
            return [
                .embeddedResource,
                .image,
                .resourceLink,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .embeddedResource: return "resource"
            case .image: return "image"
            case .resourceLink: return "resource_link"
            case .text: return "text"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// A block of content in a response.
    public struct ContentBlock: Swift.Sendable {
        /// The binary data content of the block.
        public var data: Foundation.Data?
        /// The description of the content block.
        public var description: Swift.String?
        /// The MIME type of the content.
        public var mimeType: Swift.String?
        /// The name of the content block.
        public var name: Swift.String?
        /// The resource associated with the content block.
        public var resource: BedrockAgentCoreClientTypes.ResourceContent?
        /// The size of the content in bytes.
        public var size: Swift.Int?
        /// The text content of the block.
        public var text: Swift.String?
        /// The type of content in the block.
        /// This member is required.
        public var type: BedrockAgentCoreClientTypes.ContentBlockType?
        /// The URI of the content.
        public var uri: Swift.String?

        public init(
            data: Foundation.Data? = nil,
            description: Swift.String? = nil,
            mimeType: Swift.String? = nil,
            name: Swift.String? = nil,
            resource: BedrockAgentCoreClientTypes.ResourceContent? = nil,
            size: Swift.Int? = nil,
            text: Swift.String? = nil,
            type: BedrockAgentCoreClientTypes.ContentBlockType? = nil,
            uri: Swift.String? = nil
        ) {
            self.data = data
            self.description = description
            self.mimeType = mimeType
            self.name = name
            self.resource = resource
            self.size = size
            self.text = text
            self.type = type
            self.uri = uri
        }
    }
}

extension BedrockAgentCoreClientTypes {

    public enum TaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case submitted
        case working
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .submitted,
                .working
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "canceled"
            case .completed: return "completed"
            case .failed: return "failed"
            case .submitted: return "submitted"
            case .working: return "working"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains structured content from a tool result.
    public struct ToolResultStructuredContent: Swift.Sendable {
        /// The execution time of the tool operation in milliseconds.
        public var executionTime: Swift.Double?
        /// The exit code from the tool execution.
        public var exitCode: Swift.Int?
        /// The standard error output from the tool execution.
        public var stderr: Swift.String?
        /// The standard output from the tool execution.
        public var stdout: Swift.String?
        /// The identifier of the task that produced the result.
        public var taskId: Swift.String?
        /// The status of the task that produced the result.
        public var taskStatus: BedrockAgentCoreClientTypes.TaskStatus?

        public init(
            executionTime: Swift.Double? = nil,
            exitCode: Swift.Int? = nil,
            stderr: Swift.String? = nil,
            stdout: Swift.String? = nil,
            taskId: Swift.String? = nil,
            taskStatus: BedrockAgentCoreClientTypes.TaskStatus? = nil
        ) {
            self.executionTime = executionTime
            self.exitCode = exitCode
            self.stderr = stderr
            self.stdout = stdout
            self.taskId = taskId
            self.taskStatus = taskStatus
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// The output produced by executing code in a code interpreter session in Amazon Bedrock. This structure contains the results of code execution, including textual output, structured data, and error information. Agents use these results to generate responses that incorporate computation, data analysis, and visualization.
    public struct CodeInterpreterResult: Swift.Sendable {
        /// The textual content of the execution result. This includes standard output from the code execution, such as print statements, console output, and text representations of results.
        /// This member is required.
        public var content: [BedrockAgentCoreClientTypes.ContentBlock]?
        /// Indicates whether the result represents an error. If true, the content contains error messages or exception information. If false, the content contains successful execution results.
        public var isError: Swift.Bool?
        /// The structured content of the execution result. This includes additional metadata about the execution, such as execution time, memory usage, and structured representations of output data. The format depends on the specific code interpreter and execution context.
        public var structuredContent: BedrockAgentCoreClientTypes.ToolResultStructuredContent?

        public init(
            content: [BedrockAgentCoreClientTypes.ContentBlock]? = nil,
            isError: Swift.Bool? = nil,
            structuredContent: BedrockAgentCoreClientTypes.ToolResultStructuredContent? = nil
        ) {
            self.content = content
            self.isError = isError
            self.structuredContent = structuredContent
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains output from a code interpreter stream.
    public enum CodeInterpreterStreamOutput: Swift.Sendable {
        /// The output produced by executing code in a code interpreter session in Amazon Bedrock. This structure contains the results of code execution, including textual output, structured data, and error information. Agents use these results to generate responses that incorporate computation, data analysis, and visualization.
        case result(BedrockAgentCoreClientTypes.CodeInterpreterResult)
        case sdkUnknown(Swift.String)
    }
}

public struct InvokeCodeInterpreterOutput: Swift.Sendable {
    /// The identifier of the code interpreter session.
    public var sessionId: Swift.String?
    /// The stream containing the results of the code execution. This includes output, errors, and execution status.
    /// This member is required.
    public var stream: AsyncThrowingStream<BedrockAgentCoreClientTypes.CodeInterpreterStreamOutput, Swift.Error>?

    public init(
        sessionId: Swift.String? = nil,
        stream: AsyncThrowingStream<BedrockAgentCoreClientTypes.CodeInterpreterStreamOutput, Swift.Error>? = nil
    ) {
        self.sessionId = sessionId
        self.stream = stream
    }
}

/// The service encountered an internal error. Try your request again later.
public struct ServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling. Reduce the frequency of requests and try again.
public struct ThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains the content of a memory record.
    public enum MemoryContent: Swift.Sendable {
        /// The text content of the memory record.
        case text(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    /// Input structure to create a new memory record.
    public struct MemoryRecordCreateInput: Swift.Sendable {
        /// The content to be stored within the memory record.
        /// This member is required.
        public var content: BedrockAgentCoreClientTypes.MemoryContent?
        /// The ID of the memory strategy that defines how this memory record is grouped.
        public var memoryStrategyId: Swift.String?
        /// A list of namespace identifiers that categorize or group the memory record.
        /// This member is required.
        public var namespaces: [Swift.String]?
        /// A client-provided identifier for tracking this specific record creation request.
        /// This member is required.
        public var requestIdentifier: Swift.String?
        /// Time at which the memory record was created.
        /// This member is required.
        public var timestamp: Foundation.Date?

        public init(
            content: BedrockAgentCoreClientTypes.MemoryContent? = nil,
            memoryStrategyId: Swift.String? = nil,
            namespaces: [Swift.String]? = nil,
            requestIdentifier: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        ) {
            self.content = content
            self.memoryStrategyId = memoryStrategyId
            self.namespaces = namespaces
            self.requestIdentifier = requestIdentifier
            self.timestamp = timestamp
        }
    }
}

public struct BatchCreateMemoryRecordsInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure idempotent processing of the batch request.
    public var clientToken: Swift.String?
    /// The unique ID of the memory resource where records will be created.
    /// This member is required.
    public var memoryId: Swift.String?
    /// A list of memory record creation inputs to be processed in the batch operation.
    /// This member is required.
    public var records: [BedrockAgentCoreClientTypes.MemoryRecordCreateInput]?

    public init(
        clientToken: Swift.String? = nil,
        memoryId: Swift.String? = nil,
        records: [BedrockAgentCoreClientTypes.MemoryRecordCreateInput]? = nil
    ) {
        self.clientToken = clientToken
        self.memoryId = memoryId
        self.records = records
    }
}

extension BedrockAgentCoreClientTypes {

    public enum MemoryRecordStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [MemoryRecordStatus] {
            return [
                .failed,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Output information returned after processing a memory record operation.
    public struct MemoryRecordOutput: Swift.Sendable {
        /// The error code returned when the memory record operation fails.
        public var errorCode: Swift.Int?
        /// A human-readable error message describing why the memory record operation failed.
        public var errorMessage: Swift.String?
        /// The unique ID associated to the memory record.
        /// This member is required.
        public var memoryRecordId: Swift.String?
        /// The client-provided identifier that was used to track this record operation.
        public var requestIdentifier: Swift.String?
        /// The status of the memory record operation (e.g., SUCCEEDED, FAILED).
        /// This member is required.
        public var status: BedrockAgentCoreClientTypes.MemoryRecordStatus?

        public init(
            errorCode: Swift.Int? = nil,
            errorMessage: Swift.String? = nil,
            memoryRecordId: Swift.String? = nil,
            requestIdentifier: Swift.String? = nil,
            status: BedrockAgentCoreClientTypes.MemoryRecordStatus? = nil
        ) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memoryRecordId = memoryRecordId
            self.requestIdentifier = requestIdentifier
            self.status = status
        }
    }
}

public struct BatchCreateMemoryRecordsOutput: Swift.Sendable {
    /// A list of memory records that failed to be created, including error details for each failure.
    /// This member is required.
    public var failedRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]?
    /// A list of memory records that were successfully created during the batch operation.
    /// This member is required.
    public var successfulRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]?

    public init(
        failedRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]? = nil,
        successfulRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]? = nil
    ) {
        self.failedRecords = failedRecords
        self.successfulRecords = successfulRecords
    }
}

extension BedrockAgentCoreClientTypes {

    /// Input structure to delete an existing memory record.
    public struct MemoryRecordDeleteInput: Swift.Sendable {
        /// The unique ID of the memory record to be deleted.
        /// This member is required.
        public var memoryRecordId: Swift.String?

        public init(
            memoryRecordId: Swift.String? = nil
        ) {
            self.memoryRecordId = memoryRecordId
        }
    }
}

public struct BatchDeleteMemoryRecordsInput: Swift.Sendable {
    /// The unique ID of the memory resource where records will be deleted.
    /// This member is required.
    public var memoryId: Swift.String?
    /// A list of memory record deletion inputs to be processed in the batch operation.
    /// This member is required.
    public var records: [BedrockAgentCoreClientTypes.MemoryRecordDeleteInput]?

    public init(
        memoryId: Swift.String? = nil,
        records: [BedrockAgentCoreClientTypes.MemoryRecordDeleteInput]? = nil
    ) {
        self.memoryId = memoryId
        self.records = records
    }
}

public struct BatchDeleteMemoryRecordsOutput: Swift.Sendable {
    /// A list of memory records that failed to be deleted, including error details for each failure.
    /// This member is required.
    public var failedRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]?
    /// A list of memory records that were successfully deleted during the batch operation.
    /// This member is required.
    public var successfulRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]?

    public init(
        failedRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]? = nil,
        successfulRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]? = nil
    ) {
        self.failedRecords = failedRecords
        self.successfulRecords = successfulRecords
    }
}

extension BedrockAgentCoreClientTypes {

    /// Input structure to update an existing memory record.
    public struct MemoryRecordUpdateInput: Swift.Sendable {
        /// The content to be stored within the memory record.
        public var content: BedrockAgentCoreClientTypes.MemoryContent?
        /// The unique ID of the memory record to be updated.
        /// This member is required.
        public var memoryRecordId: Swift.String?
        /// The updated ID of the memory strategy that defines how this memory record is grouped.
        public var memoryStrategyId: Swift.String?
        /// The updated list of namespace identifiers for categorizing the memory record.
        public var namespaces: [Swift.String]?
        /// Time at which the memory record was updated
        /// This member is required.
        public var timestamp: Foundation.Date?

        public init(
            content: BedrockAgentCoreClientTypes.MemoryContent? = nil,
            memoryRecordId: Swift.String? = nil,
            memoryStrategyId: Swift.String? = nil,
            namespaces: [Swift.String]? = nil,
            timestamp: Foundation.Date? = nil
        ) {
            self.content = content
            self.memoryRecordId = memoryRecordId
            self.memoryStrategyId = memoryStrategyId
            self.namespaces = namespaces
            self.timestamp = timestamp
        }
    }
}

public struct BatchUpdateMemoryRecordsInput: Swift.Sendable {
    /// The unique ID of the memory resource where records will be updated.
    /// This member is required.
    public var memoryId: Swift.String?
    /// A list of memory record update inputs to be processed in the batch operation.
    /// This member is required.
    public var records: [BedrockAgentCoreClientTypes.MemoryRecordUpdateInput]?

    public init(
        memoryId: Swift.String? = nil,
        records: [BedrockAgentCoreClientTypes.MemoryRecordUpdateInput]? = nil
    ) {
        self.memoryId = memoryId
        self.records = records
    }
}

public struct BatchUpdateMemoryRecordsOutput: Swift.Sendable {
    /// A list of memory records that failed to be updated, including error details for each failure.
    /// This member is required.
    public var failedRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]?
    /// A list of memory records that were successfully updated during the batch operation.
    /// This member is required.
    public var successfulRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]?

    public init(
        failedRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]? = nil,
        successfulRecords: [BedrockAgentCoreClientTypes.MemoryRecordOutput]? = nil
    ) {
        self.failedRecords = failedRecords
        self.successfulRecords = successfulRecords
    }
}

/// The input fails to satisfy the constraints specified by AgentCore. Check your input values and try again.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains information about a branch in an AgentCore Memory resource. Branches allow for organizing events into different conversation threads or paths.
    public struct Branch: Swift.Sendable {
        /// The name of the branch.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the root event for this branch.
        public var rootEventId: Swift.String?

        public init(
            name: Swift.String? = nil,
            rootEventId: Swift.String? = nil
        ) {
            self.name = name
            self.rootEventId = rootEventId
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Value associated with the eventMetadata key.
    public enum MetadataValue: Swift.Sendable {
        /// Value associated with the eventMetadata key.
        case stringvalue(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains the content of a memory item.
    public enum Content: Swift.Sendable {
        /// The text content of the memory item.
        case text(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    public enum Role: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assistant
        case other
        case tool
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [Role] {
            return [
                .assistant,
                .other,
                .tool,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assistant: return "ASSISTANT"
            case .other: return "OTHER"
            case .tool: return "TOOL"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains conversational content for an event payload.
    public struct Conversational: Swift.Sendable {
        /// The content of the conversation message.
        /// This member is required.
        public var content: BedrockAgentCoreClientTypes.Content?
        /// The role of the participant in the conversation (for example, "user" or "assistant").
        /// This member is required.
        public var role: BedrockAgentCoreClientTypes.Role?

        public init(
            content: BedrockAgentCoreClientTypes.Content? = nil,
            role: BedrockAgentCoreClientTypes.Role? = nil
        ) {
            self.content = content
            self.role = role
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains the payload content for an event.
    public enum PayloadType: Swift.Sendable {
        /// The conversational content of the payload.
        case conversational(BedrockAgentCoreClientTypes.Conversational)
        /// The binary content of the payload.
        case blob(Smithy.Document)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateEventInput: Swift.Sendable {
    /// The identifier of the actor associated with this event. An actor represents an entity that participates in sessions and generates events.
    /// This member is required.
    public var actorId: Swift.String?
    /// The branch information for this event. Branches allow for organizing events into different conversation threads or paths.
    public var branch: BedrockAgentCoreClientTypes.Branch?
    /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, AgentCore ignores the request, but does not return an error.
    public var clientToken: Swift.String?
    /// The timestamp when the event occurred. If not specified, the current time is used.
    /// This member is required.
    public var eventTimestamp: Foundation.Date?
    /// The identifier of the AgentCore Memory resource in which to create the event.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The key-value metadata to attach to the event.
    public var metadata: [Swift.String: BedrockAgentCoreClientTypes.MetadataValue]?
    /// The content payload of the event. This can include conversational data or binary content.
    /// This member is required.
    public var payload: [BedrockAgentCoreClientTypes.PayloadType]?
    /// The identifier of the session in which this event occurs. A session represents a sequence of related events.
    public var sessionId: Swift.String?

    public init(
        actorId: Swift.String? = nil,
        branch: BedrockAgentCoreClientTypes.Branch? = nil,
        clientToken: Swift.String? = nil,
        eventTimestamp: Foundation.Date? = nil,
        memoryId: Swift.String? = nil,
        metadata: [Swift.String: BedrockAgentCoreClientTypes.MetadataValue]? = nil,
        payload: [BedrockAgentCoreClientTypes.PayloadType]? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.actorId = actorId
        self.branch = branch
        self.clientToken = clientToken
        self.eventTimestamp = eventTimestamp
        self.memoryId = memoryId
        self.metadata = metadata
        self.payload = payload
        self.sessionId = sessionId
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains information about an event in an AgentCore Memory resource.
    public struct Event: Swift.Sendable {
        /// The identifier of the actor associated with the event.
        /// This member is required.
        public var actorId: Swift.String?
        /// The branch information for the event.
        public var branch: BedrockAgentCoreClientTypes.Branch?
        /// The unique identifier of the event.
        /// This member is required.
        public var eventId: Swift.String?
        /// The timestamp when the event occurred.
        /// This member is required.
        public var eventTimestamp: Foundation.Date?
        /// The identifier of the AgentCore Memory resource containing the event.
        /// This member is required.
        public var memoryId: Swift.String?
        /// Metadata associated with an event.
        public var metadata: [Swift.String: BedrockAgentCoreClientTypes.MetadataValue]?
        /// The content payload of the event.
        /// This member is required.
        public var payload: [BedrockAgentCoreClientTypes.PayloadType]?
        /// The identifier of the session containing the event.
        /// This member is required.
        public var sessionId: Swift.String?

        public init(
            actorId: Swift.String? = nil,
            branch: BedrockAgentCoreClientTypes.Branch? = nil,
            eventId: Swift.String? = nil,
            eventTimestamp: Foundation.Date? = nil,
            memoryId: Swift.String? = nil,
            metadata: [Swift.String: BedrockAgentCoreClientTypes.MetadataValue]? = nil,
            payload: [BedrockAgentCoreClientTypes.PayloadType]? = nil,
            sessionId: Swift.String? = nil
        ) {
            self.actorId = actorId
            self.branch = branch
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.memoryId = memoryId
            self.metadata = metadata
            self.payload = payload
            self.sessionId = sessionId
        }
    }
}

public struct CreateEventOutput: Swift.Sendable {
    /// The event that was created.
    /// This member is required.
    public var event: BedrockAgentCoreClientTypes.Event?

    public init(
        event: BedrockAgentCoreClientTypes.Event? = nil
    ) {
        self.event = event
    }
}

public struct DeleteEventInput: Swift.Sendable {
    /// The identifier of the actor associated with the event to delete.
    /// This member is required.
    public var actorId: Swift.String?
    /// The identifier of the event to delete.
    /// This member is required.
    public var eventId: Swift.String?
    /// The identifier of the AgentCore Memory resource from which to delete the event.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The identifier of the session containing the event to delete.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        actorId: Swift.String? = nil,
        eventId: Swift.String? = nil,
        memoryId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.actorId = actorId
        self.eventId = eventId
        self.memoryId = memoryId
        self.sessionId = sessionId
    }
}

public struct DeleteEventOutput: Swift.Sendable {
    /// The identifier of the event that was deleted.
    /// This member is required.
    public var eventId: Swift.String?

    public init(
        eventId: Swift.String? = nil
    ) {
        self.eventId = eventId
    }
}

public struct DeleteMemoryRecordInput: Swift.Sendable {
    /// The identifier of the AgentCore Memory resource from which to delete the memory record.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The identifier of the memory record to delete.
    /// This member is required.
    public var memoryRecordId: Swift.String?

    public init(
        memoryId: Swift.String? = nil,
        memoryRecordId: Swift.String? = nil
    ) {
        self.memoryId = memoryId
        self.memoryRecordId = memoryRecordId
    }
}

public struct DeleteMemoryRecordOutput: Swift.Sendable {
    /// The identifier of the memory record that was deleted.
    /// This member is required.
    public var memoryRecordId: Swift.String?

    public init(
        memoryRecordId: Swift.String? = nil
    ) {
        self.memoryRecordId = memoryRecordId
    }
}

public struct GetEventInput: Swift.Sendable {
    /// The identifier of the actor associated with the event.
    /// This member is required.
    public var actorId: Swift.String?
    /// The identifier of the event to retrieve.
    /// This member is required.
    public var eventId: Swift.String?
    /// The identifier of the AgentCore Memory resource containing the event.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The identifier of the session containing the event.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        actorId: Swift.String? = nil,
        eventId: Swift.String? = nil,
        memoryId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.actorId = actorId
        self.eventId = eventId
        self.memoryId = memoryId
        self.sessionId = sessionId
    }
}

public struct GetEventOutput: Swift.Sendable {
    /// The requested event information.
    /// This member is required.
    public var event: BedrockAgentCoreClientTypes.Event?

    public init(
        event: BedrockAgentCoreClientTypes.Event? = nil
    ) {
        self.event = event
    }
}

public struct GetMemoryRecordInput: Swift.Sendable {
    /// The identifier of the AgentCore Memory resource containing the memory record.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The identifier of the memory record to retrieve.
    /// This member is required.
    public var memoryRecordId: Swift.String?

    public init(
        memoryId: Swift.String? = nil,
        memoryRecordId: Swift.String? = nil
    ) {
        self.memoryId = memoryId
        self.memoryRecordId = memoryRecordId
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains information about a memory record in an AgentCore Memory resource.
    public struct MemoryRecord: Swift.Sendable {
        /// The content of the memory record.
        /// This member is required.
        public var content: BedrockAgentCoreClientTypes.MemoryContent?
        /// The timestamp when the memory record was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the memory record.
        /// This member is required.
        public var memoryRecordId: Swift.String?
        /// The identifier of the memory strategy associated with this record.
        /// This member is required.
        public var memoryStrategyId: Swift.String?
        /// The namespaces associated with this memory record. Namespaces help organize and categorize memory records.
        /// This member is required.
        public var namespaces: [Swift.String]?

        public init(
            content: BedrockAgentCoreClientTypes.MemoryContent? = nil,
            createdAt: Foundation.Date? = nil,
            memoryRecordId: Swift.String? = nil,
            memoryStrategyId: Swift.String? = nil,
            namespaces: [Swift.String]? = nil
        ) {
            self.content = content
            self.createdAt = createdAt
            self.memoryRecordId = memoryRecordId
            self.memoryStrategyId = memoryStrategyId
            self.namespaces = namespaces
        }
    }
}

public struct GetMemoryRecordOutput: Swift.Sendable {
    /// The requested memory record.
    /// This member is required.
    public var memoryRecord: BedrockAgentCoreClientTypes.MemoryRecord?

    public init(
        memoryRecord: BedrockAgentCoreClientTypes.MemoryRecord? = nil
    ) {
        self.memoryRecord = memoryRecord
    }
}

public struct ListActorsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    public var maxResults: Swift.Int?
    /// The identifier of the AgentCore Memory resource for which to list actors.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        memoryId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.memoryId = memoryId
        self.nextToken = nextToken
    }
}

public struct ListActorsOutput: Swift.Sendable {
    /// The list of actor summaries.
    /// This member is required.
    public var actorSummaries: [BedrockAgentCoreClientTypes.ActorSummary]?
    /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        actorSummaries: [BedrockAgentCoreClientTypes.ActorSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.actorSummaries = actorSummaries
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains filter criteria for branches when listing events.
    public struct BranchFilter: Swift.Sendable {
        /// Specifies whether to include parent branches in the results. Set to true to include parent branches, or false to exclude them.
        public var includeParentBranches: Swift.Bool?
        /// The name of the branch to filter by.
        /// This member is required.
        public var name: Swift.String?

        public init(
            includeParentBranches: Swift.Bool? = true,
            name: Swift.String? = nil
        ) {
            self.includeParentBranches = includeParentBranches
            self.name = name
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Left expression of the event metadata filter.
    public enum LeftExpression: Swift.Sendable {
        /// Key associated with the metadata in an event.
        case metadatakey(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    public enum OperatorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equalsTo
        case exists
        case notExists
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatorType] {
            return [
                .equalsTo,
                .exists,
                .notExists
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equalsTo: return "EQUALS_TO"
            case .exists: return "EXISTS"
            case .notExists: return "NOT_EXISTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Right expression of the eventMetadatafilter.
    public enum RightExpression: Swift.Sendable {
        /// Value associated with the key in eventMetadata.
        case metadatavalue(BedrockAgentCoreClientTypes.MetadataValue)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentCoreClientTypes {

    /// Filter expression for retrieving events based on metadata associated with an event.
    public struct EventMetadataFilterExpression: Swift.Sendable {
        /// Left operand of the event metadata filter expression.
        /// This member is required.
        public var `left`: BedrockAgentCoreClientTypes.LeftExpression?
        /// Operator applied to the event metadata filter expression.
        /// This member is required.
        public var `operator`: BedrockAgentCoreClientTypes.OperatorType?
        /// Right operand of the event metadata filter expression.
        public var `right`: BedrockAgentCoreClientTypes.RightExpression?

        public init(
            `left`: BedrockAgentCoreClientTypes.LeftExpression? = nil,
            `operator`: BedrockAgentCoreClientTypes.OperatorType? = nil,
            `right`: BedrockAgentCoreClientTypes.RightExpression? = nil
        ) {
            self.`left` = `left`
            self.`operator` = `operator`
            self.`right` = `right`
        }
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains filter criteria for listing events.
    public struct FilterInput: Swift.Sendable {
        /// The branch filter criteria to apply when listing events.
        public var branch: BedrockAgentCoreClientTypes.BranchFilter?
        /// Event metadata filter criteria to apply when retrieving events.
        public var eventMetadata: [BedrockAgentCoreClientTypes.EventMetadataFilterExpression]?

        public init(
            branch: BedrockAgentCoreClientTypes.BranchFilter? = nil,
            eventMetadata: [BedrockAgentCoreClientTypes.EventMetadataFilterExpression]? = nil
        ) {
            self.branch = branch
            self.eventMetadata = eventMetadata
        }
    }
}

public struct ListEventsInput: Swift.Sendable {
    /// The identifier of the actor for which to list events. If specified, only events from this actor are returned.
    /// This member is required.
    public var actorId: Swift.String?
    /// Filter criteria to apply when listing events.
    public var filter: BedrockAgentCoreClientTypes.FilterInput?
    /// Specifies whether to include event payloads in the response. Set to true to include payloads, or false to exclude them.
    public var includePayloads: Swift.Bool?
    /// The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    public var maxResults: Swift.Int?
    /// The identifier of the AgentCore Memory resource for which to list events.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the session for which to list events. If specified, only events from this session are returned.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        actorId: Swift.String? = nil,
        filter: BedrockAgentCoreClientTypes.FilterInput? = nil,
        includePayloads: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        memoryId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.actorId = actorId
        self.filter = filter
        self.includePayloads = includePayloads
        self.maxResults = maxResults
        self.memoryId = memoryId
        self.nextToken = nextToken
        self.sessionId = sessionId
    }
}

public struct ListEventsOutput: Swift.Sendable {
    /// The list of events that match the specified criteria.
    /// This member is required.
    public var events: [BedrockAgentCoreClientTypes.Event]?
    /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        events: [BedrockAgentCoreClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.events = events
        self.nextToken = nextToken
    }
}

public struct ListMemoryRecordsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    public var maxResults: Swift.Int?
    /// The identifier of the AgentCore Memory resource for which to list memory records.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The memory strategy identifier to filter memory records by. If specified, only memory records with this strategy ID are returned.
    public var memoryStrategyId: Swift.String?
    /// The namespace to filter memory records by. If specified, only memory records in this namespace are returned.
    /// This member is required.
    public var namespace: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        memoryId: Swift.String? = nil,
        memoryStrategyId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.memoryId = memoryId
        self.memoryStrategyId = memoryStrategyId
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains summary information about a memory record.
    public struct MemoryRecordSummary: Swift.Sendable {
        /// The content of the memory record.
        /// This member is required.
        public var content: BedrockAgentCoreClientTypes.MemoryContent?
        /// The timestamp when the memory record was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the memory record.
        /// This member is required.
        public var memoryRecordId: Swift.String?
        /// The identifier of the memory strategy associated with this record.
        /// This member is required.
        public var memoryStrategyId: Swift.String?
        /// The namespaces associated with this memory record.
        /// This member is required.
        public var namespaces: [Swift.String]?
        /// The relevance score of the memory record when returned as part of a search result. Higher values indicate greater relevance to the search query.
        public var score: Swift.Double?

        public init(
            content: BedrockAgentCoreClientTypes.MemoryContent? = nil,
            createdAt: Foundation.Date? = nil,
            memoryRecordId: Swift.String? = nil,
            memoryStrategyId: Swift.String? = nil,
            namespaces: [Swift.String]? = nil,
            score: Swift.Double? = nil
        ) {
            self.content = content
            self.createdAt = createdAt
            self.memoryRecordId = memoryRecordId
            self.memoryStrategyId = memoryStrategyId
            self.namespaces = namespaces
            self.score = score
        }
    }
}

public struct ListMemoryRecordsOutput: Swift.Sendable {
    /// The list of memory record summaries that match the specified criteria.
    /// This member is required.
    public var memoryRecordSummaries: [BedrockAgentCoreClientTypes.MemoryRecordSummary]?
    /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        memoryRecordSummaries: [BedrockAgentCoreClientTypes.MemoryRecordSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.memoryRecordSummaries = memoryRecordSummaries
        self.nextToken = nextToken
    }
}

public struct ListSessionsInput: Swift.Sendable {
    /// The identifier of the actor for which to list sessions. If specified, only sessions involving this actor are returned.
    /// This member is required.
    public var actorId: Swift.String?
    /// The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    public var maxResults: Swift.Int?
    /// The identifier of the AgentCore Memory resource for which to list sessions.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        actorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        memoryId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.actorId = actorId
        self.maxResults = maxResults
        self.memoryId = memoryId
        self.nextToken = nextToken
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains summary information about a session in an AgentCore Memory resource.
    public struct SessionSummary: Swift.Sendable {
        /// The identifier of the actor associated with the session.
        /// This member is required.
        public var actorId: Swift.String?
        /// The timestamp when the session was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the session.
        /// This member is required.
        public var sessionId: Swift.String?

        public init(
            actorId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            sessionId: Swift.String? = nil
        ) {
            self.actorId = actorId
            self.createdAt = createdAt
            self.sessionId = sessionId
        }
    }
}

public struct ListSessionsOutput: Swift.Sendable {
    /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of session summaries that match the specified criteria.
    /// This member is required.
    public var sessionSummaries: [BedrockAgentCoreClientTypes.SessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessionSummaries: [BedrockAgentCoreClientTypes.SessionSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.sessionSummaries = sessionSummaries
    }
}

extension BedrockAgentCoreClientTypes {

    /// Contains search criteria for retrieving memory records.
    public struct SearchCriteria: Swift.Sendable {
        /// The memory strategy identifier to filter memory records by.
        public var memoryStrategyId: Swift.String?
        /// The search query to use for finding relevant memory records.
        /// This member is required.
        public var searchQuery: Swift.String?
        /// The maximum number of top-scoring memory records to return. This value is used for semantic search ranking.
        public var topk: Swift.Int?

        public init(
            memoryStrategyId: Swift.String? = nil,
            searchQuery: Swift.String? = nil,
            topk: Swift.Int? = 10
        ) {
            self.memoryStrategyId = memoryStrategyId
            self.searchQuery = searchQuery
            self.topk = topk
        }
    }
}

extension BedrockAgentCoreClientTypes.SearchCriteria: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchCriteria(memoryStrategyId: \(Swift.String(describing: memoryStrategyId)), topk: \(Swift.String(describing: topk)), searchQuery: \"CONTENT_REDACTED\")"}
}

public struct RetrieveMemoryRecordsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    public var maxResults: Swift.Int?
    /// The identifier of the AgentCore Memory resource from which to retrieve memory records.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The namespace to filter memory records by. If specified, only memory records in this namespace are searched.
    /// This member is required.
    public var namespace: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search criteria to use for finding relevant memory records. This includes the search query, memory strategy ID, and other search parameters.
    /// This member is required.
    public var searchCriteria: BedrockAgentCoreClientTypes.SearchCriteria?

    public init(
        maxResults: Swift.Int? = nil,
        memoryId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: BedrockAgentCoreClientTypes.SearchCriteria? = nil
    ) {
        self.maxResults = maxResults
        self.memoryId = memoryId
        self.namespace = namespace
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
    }
}

public struct RetrieveMemoryRecordsOutput: Swift.Sendable {
    /// The list of memory record summaries that match the search criteria, ordered by relevance.
    /// This member is required.
    public var memoryRecordSummaries: [BedrockAgentCoreClientTypes.MemoryRecordSummary]?
    /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        memoryRecordSummaries: [BedrockAgentCoreClientTypes.MemoryRecordSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.memoryRecordSummaries = memoryRecordSummaries
        self.nextToken = nextToken
    }
}

extension BatchCreateMemoryRecordsInput {

    static func urlPathProvider(_ value: BatchCreateMemoryRecordsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/memoryRecords/batchCreate"
    }
}

extension BatchDeleteMemoryRecordsInput {

    static func urlPathProvider(_ value: BatchDeleteMemoryRecordsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/memoryRecords/batchDelete"
    }
}

extension BatchUpdateMemoryRecordsInput {

    static func urlPathProvider(_ value: BatchUpdateMemoryRecordsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/memoryRecords/batchUpdate"
    }
}

extension CreateEventInput {

    static func urlPathProvider(_ value: CreateEventInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/events"
    }
}

extension DeleteEventInput {

    static func urlPathProvider(_ value: DeleteEventInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        guard let actorId = value.actorId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        guard let eventId = value.eventId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/actor/\(actorId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/events/\(eventId.urlPercentEncoding())"
    }
}

extension DeleteMemoryRecordInput {

    static func urlPathProvider(_ value: DeleteMemoryRecordInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        guard let memoryRecordId = value.memoryRecordId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/memoryRecords/\(memoryRecordId.urlPercentEncoding())"
    }
}

extension GetAgentCardInput {

    static func urlPathProvider(_ value: GetAgentCardInput) -> Swift.String? {
        guard let agentRuntimeArn = value.agentRuntimeArn else {
            return nil
        }
        return "/runtimes/\(agentRuntimeArn.urlPercentEncoding())/invocations/.well-known/agent-card.json"
    }
}

extension GetAgentCardInput {

    static func headerProvider(_ value: GetAgentCardInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let runtimeSessionId = value.runtimeSessionId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id", value: Swift.String(runtimeSessionId)))
        }
        return items
    }
}

extension GetAgentCardInput {

    static func queryItemProvider(_ value: GetAgentCardInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetBrowserSessionInput {

    static func urlPathProvider(_ value: GetBrowserSessionInput) -> Swift.String? {
        guard let browserIdentifier = value.browserIdentifier else {
            return nil
        }
        return "/browsers/\(browserIdentifier.urlPercentEncoding())/sessions/get"
    }
}

extension GetBrowserSessionInput {

    static func queryItemProvider(_ value: GetBrowserSessionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let sessionId = value.sessionId else {
            let message = "Creating a URL Query Item failed. sessionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
        items.append(sessionIdQueryItem)
        return items
    }
}

extension GetCodeInterpreterSessionInput {

    static func urlPathProvider(_ value: GetCodeInterpreterSessionInput) -> Swift.String? {
        guard let codeInterpreterIdentifier = value.codeInterpreterIdentifier else {
            return nil
        }
        return "/code-interpreters/\(codeInterpreterIdentifier.urlPercentEncoding())/sessions/get"
    }
}

extension GetCodeInterpreterSessionInput {

    static func queryItemProvider(_ value: GetCodeInterpreterSessionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let sessionId = value.sessionId else {
            let message = "Creating a URL Query Item failed. sessionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
        items.append(sessionIdQueryItem)
        return items
    }
}

extension GetEventInput {

    static func urlPathProvider(_ value: GetEventInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        guard let actorId = value.actorId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        guard let eventId = value.eventId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/actor/\(actorId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/events/\(eventId.urlPercentEncoding())"
    }
}

extension GetMemoryRecordInput {

    static func urlPathProvider(_ value: GetMemoryRecordInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        guard let memoryRecordId = value.memoryRecordId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/memoryRecord/\(memoryRecordId.urlPercentEncoding())"
    }
}

extension GetResourceApiKeyInput {

    static func urlPathProvider(_ value: GetResourceApiKeyInput) -> Swift.String? {
        return "/identities/api-key"
    }
}

extension GetResourceOauth2TokenInput {

    static func urlPathProvider(_ value: GetResourceOauth2TokenInput) -> Swift.String? {
        return "/identities/oauth2/token"
    }
}

extension GetWorkloadAccessTokenInput {

    static func urlPathProvider(_ value: GetWorkloadAccessTokenInput) -> Swift.String? {
        return "/identities/GetWorkloadAccessToken"
    }
}

extension GetWorkloadAccessTokenForJWTInput {

    static func urlPathProvider(_ value: GetWorkloadAccessTokenForJWTInput) -> Swift.String? {
        return "/identities/GetWorkloadAccessTokenForJWT"
    }
}

extension GetWorkloadAccessTokenForUserIdInput {

    static func urlPathProvider(_ value: GetWorkloadAccessTokenForUserIdInput) -> Swift.String? {
        return "/identities/GetWorkloadAccessTokenForUserId"
    }
}

extension InvokeAgentRuntimeInput {

    static func urlPathProvider(_ value: InvokeAgentRuntimeInput) -> Swift.String? {
        guard let agentRuntimeArn = value.agentRuntimeArn else {
            return nil
        }
        return "/runtimes/\(agentRuntimeArn.urlPercentEncoding())/invocations"
    }
}

extension InvokeAgentRuntimeInput {

    static func headerProvider(_ value: InvokeAgentRuntimeInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let accept = value.accept {
            items.add(SmithyHTTPAPI.Header(name: "Accept", value: Swift.String(accept)))
        }
        if let baggage = value.baggage {
            items.add(SmithyHTTPAPI.Header(name: "baggage", value: Swift.String(baggage)))
        }
        if let contentType = value.contentType {
            items.add(SmithyHTTPAPI.Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let mcpProtocolVersion = value.mcpProtocolVersion {
            items.add(SmithyHTTPAPI.Header(name: "Mcp-Protocol-Version", value: Swift.String(mcpProtocolVersion)))
        }
        if let mcpSessionId = value.mcpSessionId {
            items.add(SmithyHTTPAPI.Header(name: "Mcp-Session-Id", value: Swift.String(mcpSessionId)))
        }
        if let runtimeSessionId = value.runtimeSessionId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id", value: Swift.String(runtimeSessionId)))
        }
        if let runtimeUserId = value.runtimeUserId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-AgentCore-Runtime-User-Id", value: Swift.String(runtimeUserId)))
        }
        if let traceId = value.traceId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Trace-Id", value: Swift.String(traceId)))
        }
        if let traceParent = value.traceParent {
            items.add(SmithyHTTPAPI.Header(name: "traceparent", value: Swift.String(traceParent)))
        }
        if let traceState = value.traceState {
            items.add(SmithyHTTPAPI.Header(name: "tracestate", value: Swift.String(traceState)))
        }
        return items
    }
}

extension InvokeAgentRuntimeInput {

    static func queryItemProvider(_ value: InvokeAgentRuntimeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension InvokeCodeInterpreterInput {

    static func urlPathProvider(_ value: InvokeCodeInterpreterInput) -> Swift.String? {
        guard let codeInterpreterIdentifier = value.codeInterpreterIdentifier else {
            return nil
        }
        return "/code-interpreters/\(codeInterpreterIdentifier.urlPercentEncoding())/tools/invoke"
    }
}

extension InvokeCodeInterpreterInput {

    static func headerProvider(_ value: InvokeCodeInterpreterInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let sessionId = value.sessionId {
            items.add(SmithyHTTPAPI.Header(name: "x-amzn-code-interpreter-session-id", value: Swift.String(sessionId)))
        }
        return items
    }
}

extension ListActorsInput {

    static func urlPathProvider(_ value: ListActorsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/actors"
    }
}

extension ListBrowserSessionsInput {

    static func urlPathProvider(_ value: ListBrowserSessionsInput) -> Swift.String? {
        guard let browserIdentifier = value.browserIdentifier else {
            return nil
        }
        return "/browsers/\(browserIdentifier.urlPercentEncoding())/sessions/list"
    }
}

extension ListCodeInterpreterSessionsInput {

    static func urlPathProvider(_ value: ListCodeInterpreterSessionsInput) -> Swift.String? {
        guard let codeInterpreterIdentifier = value.codeInterpreterIdentifier else {
            return nil
        }
        return "/code-interpreters/\(codeInterpreterIdentifier.urlPercentEncoding())/sessions/list"
    }
}

extension ListEventsInput {

    static func urlPathProvider(_ value: ListEventsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        guard let actorId = value.actorId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/actor/\(actorId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

extension ListMemoryRecordsInput {

    static func urlPathProvider(_ value: ListMemoryRecordsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/memoryRecords"
    }
}

extension ListSessionsInput {

    static func urlPathProvider(_ value: ListSessionsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        guard let actorId = value.actorId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/actor/\(actorId.urlPercentEncoding())/sessions"
    }
}

extension RetrieveMemoryRecordsInput {

    static func urlPathProvider(_ value: RetrieveMemoryRecordsInput) -> Swift.String? {
        guard let memoryId = value.memoryId else {
            return nil
        }
        return "/memories/\(memoryId.urlPercentEncoding())/retrieve"
    }
}

extension StartBrowserSessionInput {

    static func urlPathProvider(_ value: StartBrowserSessionInput) -> Swift.String? {
        guard let browserIdentifier = value.browserIdentifier else {
            return nil
        }
        return "/browsers/\(browserIdentifier.urlPercentEncoding())/sessions/start"
    }
}

extension StartCodeInterpreterSessionInput {

    static func urlPathProvider(_ value: StartCodeInterpreterSessionInput) -> Swift.String? {
        guard let codeInterpreterIdentifier = value.codeInterpreterIdentifier else {
            return nil
        }
        return "/code-interpreters/\(codeInterpreterIdentifier.urlPercentEncoding())/sessions/start"
    }
}

extension StopBrowserSessionInput {

    static func urlPathProvider(_ value: StopBrowserSessionInput) -> Swift.String? {
        guard let browserIdentifier = value.browserIdentifier else {
            return nil
        }
        return "/browsers/\(browserIdentifier.urlPercentEncoding())/sessions/stop"
    }
}

extension StopBrowserSessionInput {

    static func queryItemProvider(_ value: StopBrowserSessionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let sessionId = value.sessionId else {
            let message = "Creating a URL Query Item failed. sessionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
        items.append(sessionIdQueryItem)
        return items
    }
}

extension StopCodeInterpreterSessionInput {

    static func urlPathProvider(_ value: StopCodeInterpreterSessionInput) -> Swift.String? {
        guard let codeInterpreterIdentifier = value.codeInterpreterIdentifier else {
            return nil
        }
        return "/code-interpreters/\(codeInterpreterIdentifier.urlPercentEncoding())/sessions/stop"
    }
}

extension StopCodeInterpreterSessionInput {

    static func queryItemProvider(_ value: StopCodeInterpreterSessionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let sessionId = value.sessionId else {
            let message = "Creating a URL Query Item failed. sessionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
        items.append(sessionIdQueryItem)
        return items
    }
}

extension StopRuntimeSessionInput {

    static func urlPathProvider(_ value: StopRuntimeSessionInput) -> Swift.String? {
        guard let agentRuntimeArn = value.agentRuntimeArn else {
            return nil
        }
        return "/runtimes/\(agentRuntimeArn.urlPercentEncoding())/stopruntimesession"
    }
}

extension StopRuntimeSessionInput {

    static func headerProvider(_ value: StopRuntimeSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let runtimeSessionId = value.runtimeSessionId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id", value: Swift.String(runtimeSessionId)))
        }
        return items
    }
}

extension StopRuntimeSessionInput {

    static func queryItemProvider(_ value: StopRuntimeSessionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension UpdateBrowserStreamInput {

    static func urlPathProvider(_ value: UpdateBrowserStreamInput) -> Swift.String? {
        guard let browserIdentifier = value.browserIdentifier else {
            return nil
        }
        return "/browsers/\(browserIdentifier.urlPercentEncoding())/sessions/streams/update"
    }
}

extension UpdateBrowserStreamInput {

    static func queryItemProvider(_ value: UpdateBrowserStreamInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let sessionId = value.sessionId else {
            let message = "Creating a URL Query Item failed. sessionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
        items.append(sessionIdQueryItem)
        return items
    }
}

extension BatchCreateMemoryRecordsInput {

    static func write(value: BatchCreateMemoryRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["records"].writeList(value.records, memberWritingClosure: BedrockAgentCoreClientTypes.MemoryRecordCreateInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDeleteMemoryRecordsInput {

    static func write(value: BatchDeleteMemoryRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["records"].writeList(value.records, memberWritingClosure: BedrockAgentCoreClientTypes.MemoryRecordDeleteInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdateMemoryRecordsInput {

    static func write(value: BatchUpdateMemoryRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["records"].writeList(value.records, memberWritingClosure: BedrockAgentCoreClientTypes.MemoryRecordUpdateInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateEventInput {

    static func write(value: CreateEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actorId"].write(value.actorId)
        try writer["branch"].write(value.branch, with: BedrockAgentCoreClientTypes.Branch.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["eventTimestamp"].writeTimestamp(value.eventTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["metadata"].writeMap(value.metadata, valueWritingClosure: BedrockAgentCoreClientTypes.MetadataValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["payload"].writeList(value.payload, memberWritingClosure: BedrockAgentCoreClientTypes.PayloadType.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sessionId"].write(value.sessionId)
    }
}

extension GetResourceApiKeyInput {

    static func write(value: GetResourceApiKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceCredentialProviderName"].write(value.resourceCredentialProviderName)
        try writer["workloadIdentityToken"].write(value.workloadIdentityToken)
    }
}

extension GetResourceOauth2TokenInput {

    static func write(value: GetResourceOauth2TokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customParameters"].writeMap(value.customParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["forceAuthentication"].write(value.forceAuthentication)
        try writer["oauth2Flow"].write(value.oauth2Flow)
        try writer["resourceCredentialProviderName"].write(value.resourceCredentialProviderName)
        try writer["resourceOauth2ReturnUrl"].write(value.resourceOauth2ReturnUrl)
        try writer["scopes"].writeList(value.scopes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workloadIdentityToken"].write(value.workloadIdentityToken)
    }
}

extension GetWorkloadAccessTokenInput {

    static func write(value: GetWorkloadAccessTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["workloadName"].write(value.workloadName)
    }
}

extension GetWorkloadAccessTokenForJWTInput {

    static func write(value: GetWorkloadAccessTokenForJWTInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userToken"].write(value.userToken)
        try writer["workloadName"].write(value.workloadName)
    }
}

extension GetWorkloadAccessTokenForUserIdInput {

    static func write(value: GetWorkloadAccessTokenForUserIdInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userId"].write(value.userId)
        try writer["workloadName"].write(value.workloadName)
    }
}

extension InvokeAgentRuntimeInput {

    static func write(value: InvokeAgentRuntimeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["payload"].write(value.payload)
    }
}

extension InvokeCodeInterpreterInput {

    static func write(value: InvokeCodeInterpreterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arguments"].write(value.arguments, with: BedrockAgentCoreClientTypes.ToolArguments.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension ListActorsInput {

    static func write(value: ListActorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListBrowserSessionsInput {

    static func write(value: ListBrowserSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["status"].write(value.status)
    }
}

extension ListCodeInterpreterSessionsInput {

    static func write(value: ListCodeInterpreterSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["status"].write(value.status)
    }
}

extension ListEventsInput {

    static func write(value: ListEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: BedrockAgentCoreClientTypes.FilterInput.write(value:to:))
        try writer["includePayloads"].write(value.includePayloads)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListMemoryRecordsInput {

    static func write(value: ListMemoryRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["memoryStrategyId"].write(value.memoryStrategyId)
        try writer["namespace"].write(value.namespace)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListSessionsInput {

    static func write(value: ListSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension RetrieveMemoryRecordsInput {

    static func write(value: RetrieveMemoryRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["namespace"].write(value.namespace)
        try writer["nextToken"].write(value.nextToken)
        try writer["searchCriteria"].write(value.searchCriteria, with: BedrockAgentCoreClientTypes.SearchCriteria.write(value:to:))
    }
}

extension StartBrowserSessionInput {

    static func write(value: StartBrowserSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["name"].write(value.name)
        try writer["sessionTimeoutSeconds"].write(value.sessionTimeoutSeconds)
        try writer["viewPort"].write(value.viewPort, with: BedrockAgentCoreClientTypes.ViewPort.write(value:to:))
    }
}

extension StartCodeInterpreterSessionInput {

    static func write(value: StartCodeInterpreterSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["name"].write(value.name)
        try writer["sessionTimeoutSeconds"].write(value.sessionTimeoutSeconds)
    }
}

extension StopBrowserSessionInput {

    static func write(value: StopBrowserSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension StopCodeInterpreterSessionInput {

    static func write(value: StopCodeInterpreterSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension StopRuntimeSessionInput {

    static func write(value: StopRuntimeSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension UpdateBrowserStreamInput {

    static func write(value: UpdateBrowserStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["streamUpdate"].write(value.streamUpdate, with: BedrockAgentCoreClientTypes.StreamUpdate.write(value:to:))
    }
}

extension BatchCreateMemoryRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateMemoryRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateMemoryRecordsOutput()
        value.failedRecords = try reader["failedRecords"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.successfulRecords = try reader["successfulRecords"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchDeleteMemoryRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteMemoryRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteMemoryRecordsOutput()
        value.failedRecords = try reader["failedRecords"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.successfulRecords = try reader["successfulRecords"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchUpdateMemoryRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateMemoryRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateMemoryRecordsOutput()
        value.failedRecords = try reader["failedRecords"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.successfulRecords = try reader["successfulRecords"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CreateEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventOutput()
        value.event = try reader["event"].readIfPresent(with: BedrockAgentCoreClientTypes.Event.read(from:))
        return value
    }
}

extension DeleteEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEventOutput()
        value.eventId = try reader["eventId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteMemoryRecordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMemoryRecordOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteMemoryRecordOutput()
        value.memoryRecordId = try reader["memoryRecordId"].readIfPresent() ?? ""
        return value
    }
}

extension GetAgentCardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAgentCardOutput {
        var value = GetAgentCardOutput()
        if let runtimeSessionIdHeaderValue = httpResponse.headers.value(for: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id") {
            value.runtimeSessionId = runtimeSessionIdHeaderValue
        }
        if let data = try await httpResponse.body.readData() {
            value.agentCard = try Smithy.Document.make(from: data)
        }
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension GetBrowserSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBrowserSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBrowserSessionOutput()
        value.browserIdentifier = try reader["browserIdentifier"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.sessionReplayArtifact = try reader["sessionReplayArtifact"].readIfPresent()
        value.sessionTimeoutSeconds = try reader["sessionTimeoutSeconds"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.streams = try reader["streams"].readIfPresent(with: BedrockAgentCoreClientTypes.BrowserSessionStream.read(from:))
        value.viewPort = try reader["viewPort"].readIfPresent(with: BedrockAgentCoreClientTypes.ViewPort.read(from:))
        return value
    }
}

extension GetCodeInterpreterSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCodeInterpreterSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCodeInterpreterSessionOutput()
        value.codeInterpreterIdentifier = try reader["codeInterpreterIdentifier"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.sessionTimeoutSeconds = try reader["sessionTimeoutSeconds"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventOutput()
        value.event = try reader["event"].readIfPresent(with: BedrockAgentCoreClientTypes.Event.read(from:))
        return value
    }
}

extension GetMemoryRecordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMemoryRecordOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMemoryRecordOutput()
        value.memoryRecord = try reader["memoryRecord"].readIfPresent(with: BedrockAgentCoreClientTypes.MemoryRecord.read(from:))
        return value
    }
}

extension GetResourceApiKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceApiKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceApiKeyOutput()
        value.apiKey = try reader["apiKey"].readIfPresent() ?? ""
        return value
    }
}

extension GetResourceOauth2TokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceOauth2TokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceOauth2TokenOutput()
        value.accessToken = try reader["accessToken"].readIfPresent()
        value.authorizationUrl = try reader["authorizationUrl"].readIfPresent()
        return value
    }
}

extension GetWorkloadAccessTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkloadAccessTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkloadAccessTokenOutput()
        value.workloadAccessToken = try reader["workloadAccessToken"].readIfPresent() ?? ""
        return value
    }
}

extension GetWorkloadAccessTokenForJWTOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkloadAccessTokenForJWTOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkloadAccessTokenForJWTOutput()
        value.workloadAccessToken = try reader["workloadAccessToken"].readIfPresent() ?? ""
        return value
    }
}

extension GetWorkloadAccessTokenForUserIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkloadAccessTokenForUserIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkloadAccessTokenForUserIdOutput()
        value.workloadAccessToken = try reader["workloadAccessToken"].readIfPresent() ?? ""
        return value
    }
}

extension InvokeAgentRuntimeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeAgentRuntimeOutput {
        var value = InvokeAgentRuntimeOutput()
        if let baggageHeaderValue = httpResponse.headers.value(for: "baggage") {
            value.baggage = baggageHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        if let mcpProtocolVersionHeaderValue = httpResponse.headers.value(for: "Mcp-Protocol-Version") {
            value.mcpProtocolVersion = mcpProtocolVersionHeaderValue
        }
        if let mcpSessionIdHeaderValue = httpResponse.headers.value(for: "Mcp-Session-Id") {
            value.mcpSessionId = mcpSessionIdHeaderValue
        }
        if let runtimeSessionIdHeaderValue = httpResponse.headers.value(for: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id") {
            value.runtimeSessionId = runtimeSessionIdHeaderValue
        }
        if let traceIdHeaderValue = httpResponse.headers.value(for: "X-Amzn-Trace-Id") {
            value.traceId = traceIdHeaderValue
        }
        if let traceParentHeaderValue = httpResponse.headers.value(for: "traceparent") {
            value.traceParent = traceParentHeaderValue
        }
        if let traceStateHeaderValue = httpResponse.headers.value(for: "tracestate") {
            value.traceState = traceStateHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.response = .data(data)
        case .stream(let stream):
            value.response = .stream(stream)
        case .noStream:
            value.response = nil
        }
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension InvokeCodeInterpreterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeCodeInterpreterOutput {
        var value = InvokeCodeInterpreterOutput()
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amzn-code-interpreter-session-id") {
            value.sessionId = sessionIdHeaderValue
        }
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: BedrockAgentCoreClientTypes.CodeInterpreterStreamOutput.unmarshal)
            value.stream = decoderStream.toAsyncStream()
        }
        return value
    }
}

extension ListActorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListActorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListActorsOutput()
        value.actorSummaries = try reader["actorSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.ActorSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBrowserSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBrowserSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBrowserSessionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.BrowserSessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCodeInterpreterSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCodeInterpreterSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCodeInterpreterSessionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.CodeInterpreterSessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventsOutput()
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.Event.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMemoryRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMemoryRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMemoryRecordsOutput()
        value.memoryRecordSummaries = try reader["memoryRecordSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSessionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sessionSummaries = try reader["sessionSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.SessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension RetrieveMemoryRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RetrieveMemoryRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RetrieveMemoryRecordsOutput()
        value.memoryRecordSummaries = try reader["memoryRecordSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.MemoryRecordSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension StartBrowserSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartBrowserSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartBrowserSessionOutput()
        value.browserIdentifier = try reader["browserIdentifier"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.streams = try reader["streams"].readIfPresent(with: BedrockAgentCoreClientTypes.BrowserSessionStream.read(from:))
        return value
    }
}

extension StartCodeInterpreterSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartCodeInterpreterSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartCodeInterpreterSessionOutput()
        value.codeInterpreterIdentifier = try reader["codeInterpreterIdentifier"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension StopBrowserSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopBrowserSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopBrowserSessionOutput()
        value.browserIdentifier = try reader["browserIdentifier"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension StopCodeInterpreterSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopCodeInterpreterSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopCodeInterpreterSessionOutput()
        value.codeInterpreterIdentifier = try reader["codeInterpreterIdentifier"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension StopRuntimeSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopRuntimeSessionOutput {
        var value = StopRuntimeSessionOutput()
        if let runtimeSessionIdHeaderValue = httpResponse.headers.value(for: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id") {
            value.runtimeSessionId = runtimeSessionIdHeaderValue
        }
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateBrowserStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBrowserStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBrowserStreamOutput()
        value.browserIdentifier = try reader["browserIdentifier"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.streams = try reader["streams"].readIfPresent(with: BedrockAgentCoreClientTypes.BrowserSessionStream.read(from:))
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

enum BatchCreateMemoryRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteMemoryRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateMemoryRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMemoryRecordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAgentCardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RuntimeClientError": return try RuntimeClientError.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBrowserSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCodeInterpreterSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMemoryRecordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceApiKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceOauth2TokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkloadAccessTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkloadAccessTokenForJWTOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkloadAccessTokenForUserIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeAgentRuntimeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RuntimeClientError": return try RuntimeClientError.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeCodeInterpreterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListActorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBrowserSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCodeInterpreterSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMemoryRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RetrieveMemoryRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartBrowserSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartCodeInterpreterSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopBrowserSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopCodeInterpreterSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopRuntimeSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RuntimeClientError": return try RuntimeClientError.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBrowserStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceException {
        let reader = baseError.errorBodyReader
        var value = ServiceException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottledException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottledException {
        let reader = baseError.errorBodyReader
        var value = ThrottledException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInputException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidInputException {
        let reader = baseError.errorBodyReader
        var value = InvalidInputException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RuntimeClientError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RuntimeClientError {
        let reader = baseError.errorBodyReader
        var value = RuntimeClientError()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BedrockAgentCoreClientTypes.CodeInterpreterStreamOutput {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<BedrockAgentCoreClientTypes.CodeInterpreterStreamOutput> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "result":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentCoreClientTypes.CodeInterpreterResult.read(from:))
                    return .result(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    case "accessDeniedException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: AccessDeniedException.read(from:))
                        return value
                    case "conflictException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ConflictException.read(from:))
                        return value
                    case "internalServerException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: InternalServerException.read(from:))
                        return value
                    case "resourceNotFoundException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ResourceNotFoundException.read(from:))
                        return value
                    case "serviceQuotaExceededException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ServiceQuotaExceededException.read(from:))
                        return value
                    case "throttlingException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ThrottlingException.read(from:))
                        return value
                    case "validationException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ValidationException.read(from:))
                        return value
                    default:
                        let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension BedrockAgentCoreClientTypes.MemoryRecordOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.MemoryRecordOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.MemoryRecordOutput()
        value.memoryRecordId = try reader["memoryRecordId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.requestIdentifier = try reader["requestIdentifier"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.Event {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.Event {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.Event()
        value.memoryId = try reader["memoryId"].readIfPresent() ?? ""
        value.actorId = try reader["actorId"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.eventId = try reader["eventId"].readIfPresent() ?? ""
        value.eventTimestamp = try reader["eventTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.payload = try reader["payload"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.PayloadType.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.branch = try reader["branch"].readIfPresent(with: BedrockAgentCoreClientTypes.Branch.read(from:))
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: BedrockAgentCoreClientTypes.MetadataValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockAgentCoreClientTypes.MetadataValue {

    static func write(value: BedrockAgentCoreClientTypes.MetadataValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .stringvalue(stringvalue):
                try writer["stringValue"].write(stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.MetadataValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "stringValue":
                return .stringvalue(try reader["stringValue"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreClientTypes.Branch {

    static func write(value: BedrockAgentCoreClientTypes.Branch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["rootEventId"].write(value.rootEventId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.Branch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.Branch()
        value.rootEventId = try reader["rootEventId"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreClientTypes.PayloadType {

    static func write(value: BedrockAgentCoreClientTypes.PayloadType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .blob(blob):
                try writer["blob"].write(blob)
            case let .conversational(conversational):
                try writer["conversational"].write(conversational, with: BedrockAgentCoreClientTypes.Conversational.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.PayloadType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "conversational":
                return .conversational(try reader["conversational"].read(with: BedrockAgentCoreClientTypes.Conversational.read(from:)))
            case "blob":
                return .blob(try reader["blob"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreClientTypes.Conversational {

    static func write(value: BedrockAgentCoreClientTypes.Conversational?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content, with: BedrockAgentCoreClientTypes.Content.write(value:to:))
        try writer["role"].write(value.role)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.Conversational {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.Conversational()
        value.content = try reader["content"].readIfPresent(with: BedrockAgentCoreClientTypes.Content.read(from:))
        value.role = try reader["role"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockAgentCoreClientTypes.Content {

    static func write(value: BedrockAgentCoreClientTypes.Content?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.Content {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentCoreClientTypes.ViewPort {

    static func write(value: BedrockAgentCoreClientTypes.ViewPort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["height"].write(value.height)
        try writer["width"].write(value.width)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ViewPort {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ViewPort()
        value.width = try reader["width"].readIfPresent() ?? 0
        value.height = try reader["height"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockAgentCoreClientTypes.BrowserSessionStream {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.BrowserSessionStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.BrowserSessionStream()
        value.automationStream = try reader["automationStream"].readIfPresent(with: BedrockAgentCoreClientTypes.AutomationStream.read(from:))
        value.liveViewStream = try reader["liveViewStream"].readIfPresent(with: BedrockAgentCoreClientTypes.LiveViewStream.read(from:))
        return value
    }
}

extension BedrockAgentCoreClientTypes.LiveViewStream {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.LiveViewStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.LiveViewStream()
        value.streamEndpoint = try reader["streamEndpoint"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.AutomationStream {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.AutomationStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.AutomationStream()
        value.streamEndpoint = try reader["streamEndpoint"].readIfPresent() ?? ""
        value.streamStatus = try reader["streamStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockAgentCoreClientTypes.MemoryRecord {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.MemoryRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.MemoryRecord()
        value.memoryRecordId = try reader["memoryRecordId"].readIfPresent() ?? ""
        value.content = try reader["content"].readIfPresent(with: BedrockAgentCoreClientTypes.MemoryContent.read(from:))
        value.memoryStrategyId = try reader["memoryStrategyId"].readIfPresent() ?? ""
        value.namespaces = try reader["namespaces"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentCoreClientTypes.MemoryContent {

    static func write(value: BedrockAgentCoreClientTypes.MemoryContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.MemoryContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ValidationException {

    static func read(from reader: SmithyJSON.Reader) throws -> ValidationException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentCoreClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension ThrottlingException {

    static func read(from reader: SmithyJSON.Reader) throws -> ThrottlingException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ServiceQuotaExceededException {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotaExceededException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ResourceNotFoundException {

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceNotFoundException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension InternalServerException {

    static func read(from reader: SmithyJSON.Reader) throws -> InternalServerException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ConflictException {

    static func read(from reader: SmithyJSON.Reader) throws -> ConflictException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension AccessDeniedException {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessDeniedException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.CodeInterpreterResult {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.CodeInterpreterResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.CodeInterpreterResult()
        value.content = try reader["content"].readListIfPresent(memberReadingClosure: BedrockAgentCoreClientTypes.ContentBlock.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.structuredContent = try reader["structuredContent"].readIfPresent(with: BedrockAgentCoreClientTypes.ToolResultStructuredContent.read(from:))
        value.isError = try reader["isError"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.ToolResultStructuredContent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ToolResultStructuredContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ToolResultStructuredContent()
        value.taskId = try reader["taskId"].readIfPresent()
        value.taskStatus = try reader["taskStatus"].readIfPresent()
        value.stdout = try reader["stdout"].readIfPresent()
        value.stderr = try reader["stderr"].readIfPresent()
        value.exitCode = try reader["exitCode"].readIfPresent()
        value.executionTime = try reader["executionTime"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.ContentBlock {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ContentBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ContentBlock()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.text = try reader["text"].readIfPresent()
        value.data = try reader["data"].readIfPresent()
        value.mimeType = try reader["mimeType"].readIfPresent()
        value.uri = try reader["uri"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.size = try reader["size"].readIfPresent()
        value.resource = try reader["resource"].readIfPresent(with: BedrockAgentCoreClientTypes.ResourceContent.read(from:))
        return value
    }
}

extension BedrockAgentCoreClientTypes.ResourceContent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ResourceContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ResourceContent()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.uri = try reader["uri"].readIfPresent()
        value.mimeType = try reader["mimeType"].readIfPresent()
        value.text = try reader["text"].readIfPresent()
        value.blob = try reader["blob"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.ActorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.ActorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.ActorSummary()
        value.actorId = try reader["actorId"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentCoreClientTypes.BrowserSessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.BrowserSessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.BrowserSessionSummary()
        value.browserIdentifier = try reader["browserIdentifier"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockAgentCoreClientTypes.CodeInterpreterSessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.CodeInterpreterSessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.CodeInterpreterSessionSummary()
        value.codeInterpreterIdentifier = try reader["codeInterpreterIdentifier"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockAgentCoreClientTypes.MemoryRecordSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.MemoryRecordSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.MemoryRecordSummary()
        value.memoryRecordId = try reader["memoryRecordId"].readIfPresent() ?? ""
        value.content = try reader["content"].readIfPresent(with: BedrockAgentCoreClientTypes.MemoryContent.read(from:))
        value.memoryStrategyId = try reader["memoryStrategyId"].readIfPresent() ?? ""
        value.namespaces = try reader["namespaces"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.score = try reader["score"].readIfPresent()
        return value
    }
}

extension BedrockAgentCoreClientTypes.SessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentCoreClientTypes.SessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentCoreClientTypes.SessionSummary()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.actorId = try reader["actorId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentCoreClientTypes.MemoryRecordCreateInput {

    static func write(value: BedrockAgentCoreClientTypes.MemoryRecordCreateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content, with: BedrockAgentCoreClientTypes.MemoryContent.write(value:to:))
        try writer["memoryStrategyId"].write(value.memoryStrategyId)
        try writer["namespaces"].writeList(value.namespaces, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["requestIdentifier"].write(value.requestIdentifier)
        try writer["timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension BedrockAgentCoreClientTypes.MemoryRecordDeleteInput {

    static func write(value: BedrockAgentCoreClientTypes.MemoryRecordDeleteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["memoryRecordId"].write(value.memoryRecordId)
    }
}

extension BedrockAgentCoreClientTypes.MemoryRecordUpdateInput {

    static func write(value: BedrockAgentCoreClientTypes.MemoryRecordUpdateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content, with: BedrockAgentCoreClientTypes.MemoryContent.write(value:to:))
        try writer["memoryRecordId"].write(value.memoryRecordId)
        try writer["memoryStrategyId"].write(value.memoryStrategyId)
        try writer["namespaces"].writeList(value.namespaces, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension BedrockAgentCoreClientTypes.ToolArguments {

    static func write(value: BedrockAgentCoreClientTypes.ToolArguments?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clearContext"].write(value.clearContext)
        try writer["code"].write(value.code)
        try writer["command"].write(value.command)
        try writer["content"].writeList(value.content, memberWritingClosure: BedrockAgentCoreClientTypes.InputContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["directoryPath"].write(value.directoryPath)
        try writer["language"].write(value.language)
        try writer["path"].write(value.path)
        try writer["paths"].writeList(value.paths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["taskId"].write(value.taskId)
    }
}

extension BedrockAgentCoreClientTypes.InputContentBlock {

    static func write(value: BedrockAgentCoreClientTypes.InputContentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blob"].write(value.blob)
        try writer["path"].write(value.path)
        try writer["text"].write(value.text)
    }
}

extension BedrockAgentCoreClientTypes.FilterInput {

    static func write(value: BedrockAgentCoreClientTypes.FilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["branch"].write(value.branch, with: BedrockAgentCoreClientTypes.BranchFilter.write(value:to:))
        try writer["eventMetadata"].writeList(value.eventMetadata, memberWritingClosure: BedrockAgentCoreClientTypes.EventMetadataFilterExpression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockAgentCoreClientTypes.EventMetadataFilterExpression {

    static func write(value: BedrockAgentCoreClientTypes.EventMetadataFilterExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["left"].write(value.`left`, with: BedrockAgentCoreClientTypes.LeftExpression.write(value:to:))
        try writer["operator"].write(value.`operator`)
        try writer["right"].write(value.`right`, with: BedrockAgentCoreClientTypes.RightExpression.write(value:to:))
    }
}

extension BedrockAgentCoreClientTypes.RightExpression {

    static func write(value: BedrockAgentCoreClientTypes.RightExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .metadatavalue(metadatavalue):
                try writer["metadataValue"].write(metadatavalue, with: BedrockAgentCoreClientTypes.MetadataValue.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreClientTypes.LeftExpression {

    static func write(value: BedrockAgentCoreClientTypes.LeftExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .metadatakey(metadatakey):
                try writer["metadataKey"].write(metadatakey)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreClientTypes.BranchFilter {

    static func write(value: BedrockAgentCoreClientTypes.BranchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeParentBranches"].write(value.includeParentBranches)
        try writer["name"].write(value.name)
    }
}

extension BedrockAgentCoreClientTypes.SearchCriteria {

    static func write(value: BedrockAgentCoreClientTypes.SearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["memoryStrategyId"].write(value.memoryStrategyId)
        try writer["searchQuery"].write(value.searchQuery)
        try writer["topK"].write(value.topk)
    }
}

extension BedrockAgentCoreClientTypes.StreamUpdate {

    static func write(value: BedrockAgentCoreClientTypes.StreamUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .automationstreamupdate(automationstreamupdate):
                try writer["automationStreamUpdate"].write(automationstreamupdate, with: BedrockAgentCoreClientTypes.AutomationStreamUpdate.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentCoreClientTypes.AutomationStreamUpdate {

    static func write(value: BedrockAgentCoreClientTypes.AutomationStreamUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["streamStatus"].write(value.streamStatus)
    }
}

public enum BedrockAgentCoreClientTypes {}
