// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access is denied. Your account is not authorized to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes {
    public enum AuthorizationStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsAuth
        case smartv1
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationStrategy] {
            return [
                .awsAuth,
                .smartv1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsAuth: return "AWS_AUTH"
            case .smartv1: return "SMART_ON_FHIR_V1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizationStrategy(rawValue: rawValue) ?? AuthorizationStrategy.sdkUnknown(rawValue)
        }
    }
}

extension HealthLakeClientTypes {
    public enum CmkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aoCmk
        case cmCmk
        case sdkUnknown(Swift.String)

        public static var allCases: [CmkType] {
            return [
                .aoCmk,
                .cmCmk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aoCmk: return "AWS_OWNED_KMS_KEY"
            case .cmCmk: return "CUSTOMER_MANAGED_KMS_KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CmkType(rawValue: rawValue) ?? CmkType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The data store is in a transition state and the user requested action can not be performed.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateFHIRDatastoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case datastoreName = "DatastoreName"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case identityProviderConfiguration = "IdentityProviderConfiguration"
        case preloadDataConfig = "PreloadDataConfig"
        case sseConfiguration = "SseConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let datastoreName = self.datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreTypeVersion = self.datastoreTypeVersion {
            try encodeContainer.encode(datastoreTypeVersion.rawValue, forKey: .datastoreTypeVersion)
        }
        if let identityProviderConfiguration = self.identityProviderConfiguration {
            try encodeContainer.encode(identityProviderConfiguration, forKey: .identityProviderConfiguration)
        }
        if let preloadDataConfig = self.preloadDataConfig {
            try encodeContainer.encode(preloadDataConfig, forKey: .preloadDataConfig)
        }
        if let sseConfiguration = self.sseConfiguration {
            try encodeContainer.encode(sseConfiguration, forKey: .sseConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateFHIRDatastoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFHIRDatastoreInput: Swift.Equatable {
    /// Optional user provided token used for ensuring idempotency.
    public var clientToken: Swift.String?
    /// The user generated name for the data store.
    public var datastoreName: Swift.String?
    /// The FHIR version of the data store. The only supported version is R4.
    /// This member is required.
    public var datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
    /// The configuration of the identity provider that you want to use for your data store.
    public var identityProviderConfiguration: HealthLakeClientTypes.IdentityProviderConfiguration?
    /// Optional parameter to preload data upon creation of the data store. Currently, the only supported preloaded data is synthetic data generated from Synthea.
    public var preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?
    /// The server-side encryption key configuration for a customer provided encryption key specified for creating a data store.
    public var sseConfiguration: HealthLakeClientTypes.SseConfiguration?
    /// Resource tags that are applied to a data store when it is created.
    public var tags: [HealthLakeClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        datastoreName: Swift.String? = nil,
        datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion? = nil,
        identityProviderConfiguration: HealthLakeClientTypes.IdentityProviderConfiguration? = nil,
        preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig? = nil,
        sseConfiguration: HealthLakeClientTypes.SseConfiguration? = nil,
        tags: [HealthLakeClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.datastoreName = datastoreName
        self.datastoreTypeVersion = datastoreTypeVersion
        self.identityProviderConfiguration = identityProviderConfiguration
        self.preloadDataConfig = preloadDataConfig
        self.sseConfiguration = sseConfiguration
        self.tags = tags
    }
}

struct CreateFHIRDatastoreInputBody: Swift.Equatable {
    let datastoreName: Swift.String?
    let datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
    let sseConfiguration: HealthLakeClientTypes.SseConfiguration?
    let preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?
    let clientToken: Swift.String?
    let tags: [HealthLakeClientTypes.Tag]?
    let identityProviderConfiguration: HealthLakeClientTypes.IdentityProviderConfiguration?
}

extension CreateFHIRDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case datastoreName = "DatastoreName"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case identityProviderConfiguration = "IdentityProviderConfiguration"
        case preloadDataConfig = "PreloadDataConfig"
        case sseConfiguration = "SseConfiguration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreTypeVersionDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.FHIRVersion.self, forKey: .datastoreTypeVersion)
        datastoreTypeVersion = datastoreTypeVersionDecoded
        let sseConfigurationDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.SseConfiguration.self, forKey: .sseConfiguration)
        sseConfiguration = sseConfigurationDecoded
        let preloadDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.PreloadDataConfig.self, forKey: .preloadDataConfig)
        preloadDataConfig = preloadDataConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[HealthLakeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [HealthLakeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let identityProviderConfigurationDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.IdentityProviderConfiguration.self, forKey: .identityProviderConfiguration)
        identityProviderConfiguration = identityProviderConfigurationDecoded
    }
}

enum CreateFHIRDatastoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFHIRDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreArn = output.datastoreArn
            self.datastoreEndpoint = output.datastoreEndpoint
            self.datastoreId = output.datastoreId
            self.datastoreStatus = output.datastoreStatus
        } else {
            self.datastoreArn = nil
            self.datastoreEndpoint = nil
            self.datastoreId = nil
            self.datastoreStatus = nil
        }
    }
}

public struct CreateFHIRDatastoreOutputResponse: Swift.Equatable {
    /// The data store ARN is generated during the creation of the data store and can be found in the output from the initial data store creation call.
    /// This member is required.
    public var datastoreArn: Swift.String?
    /// The AWS endpoint for the created data store.
    /// This member is required.
    public var datastoreEndpoint: Swift.String?
    /// The AWS-generated data store id. This id is in the output from the initial data store creation call.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The status of the FHIR data store.
    /// This member is required.
    public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

    public init(
        datastoreArn: Swift.String? = nil,
        datastoreEndpoint: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
    )
    {
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

struct CreateFHIRDatastoreOutputResponseBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let datastoreArn: Swift.String?
    let datastoreStatus: HealthLakeClientTypes.DatastoreStatus?
    let datastoreEndpoint: Swift.String?
}

extension CreateFHIRDatastoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreStatus = "DatastoreStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
    }
}

extension HealthLakeClientTypes.DatastoreFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter = "CreatedAfter"
        case createdBefore = "CreatedBefore"
        case datastoreName = "DatastoreName"
        case datastoreStatus = "DatastoreStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .epochSeconds, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .epochSeconds, forKey: .createdBefore)
        }
        if let datastoreName = self.datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStatus = self.datastoreStatus {
            try encodeContainer.encode(datastoreStatus.rawValue, forKey: .datastoreStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
    }
}

extension HealthLakeClientTypes {
    /// The filters applied to data store query.
    public struct DatastoreFilter: Swift.Equatable {
        /// A filter that allows the user to set cutoff dates for records. All data stores created after the specified date will be included in the results.
        public var createdAfter: ClientRuntime.Date?
        /// A filter that allows the user to set cutoff dates for records. All data stores created before the specified date will be included in the results.
        public var createdBefore: ClientRuntime.Date?
        /// Allows the user to filter data store results by name.
        public var datastoreName: Swift.String?
        /// Allows the user to filter data store results by status.
        public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
        }
    }

}

extension HealthLakeClientTypes.DatastoreProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreName = "DatastoreName"
        case datastoreStatus = "DatastoreStatus"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case identityProviderConfiguration = "IdentityProviderConfiguration"
        case preloadDataConfig = "PreloadDataConfig"
        case sseConfiguration = "SseConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let datastoreArn = self.datastoreArn {
            try encodeContainer.encode(datastoreArn, forKey: .datastoreArn)
        }
        if let datastoreEndpoint = self.datastoreEndpoint {
            try encodeContainer.encode(datastoreEndpoint, forKey: .datastoreEndpoint)
        }
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let datastoreName = self.datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStatus = self.datastoreStatus {
            try encodeContainer.encode(datastoreStatus.rawValue, forKey: .datastoreStatus)
        }
        if let datastoreTypeVersion = self.datastoreTypeVersion {
            try encodeContainer.encode(datastoreTypeVersion.rawValue, forKey: .datastoreTypeVersion)
        }
        if let identityProviderConfiguration = self.identityProviderConfiguration {
            try encodeContainer.encode(identityProviderConfiguration, forKey: .identityProviderConfiguration)
        }
        if let preloadDataConfig = self.preloadDataConfig {
            try encodeContainer.encode(preloadDataConfig, forKey: .preloadDataConfig)
        }
        if let sseConfiguration = self.sseConfiguration {
            try encodeContainer.encode(sseConfiguration, forKey: .sseConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let datastoreTypeVersionDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.FHIRVersion.self, forKey: .datastoreTypeVersion)
        datastoreTypeVersion = datastoreTypeVersionDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
        let sseConfigurationDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.SseConfiguration.self, forKey: .sseConfiguration)
        sseConfiguration = sseConfigurationDecoded
        let preloadDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.PreloadDataConfig.self, forKey: .preloadDataConfig)
        preloadDataConfig = preloadDataConfigDecoded
        let identityProviderConfigurationDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.IdentityProviderConfiguration.self, forKey: .identityProviderConfiguration)
        identityProviderConfiguration = identityProviderConfigurationDecoded
    }
}

extension HealthLakeClientTypes {
    /// Displays the properties of the data store, including the ID, ARN, name, and the status of the data store.
    public struct DatastoreProperties: Swift.Equatable {
        /// The time that a data store was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name used in the creation of the data store.
        /// This member is required.
        public var datastoreArn: Swift.String?
        /// The AWS endpoint for the data store. Each data store will have it's own endpoint with data store ID in the endpoint URL.
        /// This member is required.
        public var datastoreEndpoint: Swift.String?
        /// The AWS-generated ID number for the data store.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The user-generated name for the data store.
        public var datastoreName: Swift.String?
        /// The status of the data store.
        /// This member is required.
        public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?
        /// The FHIR version. Only R4 version data is supported.
        /// This member is required.
        public var datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
        /// The identity provider that you selected when you created the data store.
        public var identityProviderConfiguration: HealthLakeClientTypes.IdentityProviderConfiguration?
        /// The preloaded data configuration for the data store. Only data preloaded from Synthea is supported.
        public var preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?
        /// The server-side encryption key configuration for a customer provided encryption key (CMK).
        public var sseConfiguration: HealthLakeClientTypes.SseConfiguration?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            datastoreArn: Swift.String? = nil,
            datastoreEndpoint: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil,
            datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion? = nil,
            identityProviderConfiguration: HealthLakeClientTypes.IdentityProviderConfiguration? = nil,
            preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig? = nil,
            sseConfiguration: HealthLakeClientTypes.SseConfiguration? = nil
        )
        {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreEndpoint = datastoreEndpoint
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.datastoreTypeVersion = datastoreTypeVersion
            self.identityProviderConfiguration = identityProviderConfiguration
            self.preloadDataConfig = preloadDataConfig
            self.sseConfiguration = sseConfiguration
        }
    }

}

extension HealthLakeClientTypes {
    public enum DatastoreStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [DatastoreStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatastoreStatus(rawValue: rawValue) ?? DatastoreStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteFHIRDatastoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
    }
}

extension DeleteFHIRDatastoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFHIRDatastoreInput: Swift.Equatable {
    /// The AWS-generated ID for the data store to be deleted.
    /// This member is required.
    public var datastoreId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

struct DeleteFHIRDatastoreInputBody: Swift.Equatable {
    let datastoreId: Swift.String?
}

extension DeleteFHIRDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

enum DeleteFHIRDatastoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFHIRDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreArn = output.datastoreArn
            self.datastoreEndpoint = output.datastoreEndpoint
            self.datastoreId = output.datastoreId
            self.datastoreStatus = output.datastoreStatus
        } else {
            self.datastoreArn = nil
            self.datastoreEndpoint = nil
            self.datastoreId = nil
            self.datastoreStatus = nil
        }
    }
}

public struct DeleteFHIRDatastoreOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that gives AWS HealthLake access permission.
    /// This member is required.
    public var datastoreArn: Swift.String?
    /// The AWS endpoint for the data store the user has requested to be deleted.
    /// This member is required.
    public var datastoreEndpoint: Swift.String?
    /// The AWS-generated ID for the data store to be deleted.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The status of the data store that the user has requested to be deleted.
    /// This member is required.
    public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

    public init(
        datastoreArn: Swift.String? = nil,
        datastoreEndpoint: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
    )
    {
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

struct DeleteFHIRDatastoreOutputResponseBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let datastoreArn: Swift.String?
    let datastoreStatus: HealthLakeClientTypes.DatastoreStatus?
    let datastoreEndpoint: Swift.String?
}

extension DeleteFHIRDatastoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreStatus = "DatastoreStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
    }
}

extension DescribeFHIRDatastoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
    }
}

extension DescribeFHIRDatastoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFHIRDatastoreInput: Swift.Equatable {
    /// The AWS-generated data store ID.
    /// This member is required.
    public var datastoreId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

struct DescribeFHIRDatastoreInputBody: Swift.Equatable {
    let datastoreId: Swift.String?
}

extension DescribeFHIRDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

enum DescribeFHIRDatastoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFHIRDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreProperties = output.datastoreProperties
        } else {
            self.datastoreProperties = nil
        }
    }
}

public struct DescribeFHIRDatastoreOutputResponse: Swift.Equatable {
    /// All properties associated with a data store, including the data store ID, data store ARN, data store name, data store status, when the data store was created, data store type version, and the data store's endpoint.
    /// This member is required.
    public var datastoreProperties: HealthLakeClientTypes.DatastoreProperties?

    public init(
        datastoreProperties: HealthLakeClientTypes.DatastoreProperties? = nil
    )
    {
        self.datastoreProperties = datastoreProperties
    }
}

struct DescribeFHIRDatastoreOutputResponseBody: Swift.Equatable {
    let datastoreProperties: HealthLakeClientTypes.DatastoreProperties?
}

extension DescribeFHIRDatastoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreProperties = "DatastoreProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastorePropertiesDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreProperties.self, forKey: .datastoreProperties)
        datastoreProperties = datastorePropertiesDecoded
    }
}

extension DescribeFHIRExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeFHIRExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFHIRExportJobInput: Swift.Equatable {
    /// The AWS generated ID for the data store from which files are being exported from for an export job.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The AWS generated ID for an export job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

struct DescribeFHIRExportJobInputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let jobId: Swift.String?
}

extension DescribeFHIRExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum DescribeFHIRExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFHIRExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFHIRExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportJobProperties = output.exportJobProperties
        } else {
            self.exportJobProperties = nil
        }
    }
}

public struct DescribeFHIRExportJobOutputResponse: Swift.Equatable {
    /// Displays the properties of the export job, including the ID, Arn, Name, and the status of the job.
    /// This member is required.
    public var exportJobProperties: HealthLakeClientTypes.ExportJobProperties?

    public init(
        exportJobProperties: HealthLakeClientTypes.ExportJobProperties? = nil
    )
    {
        self.exportJobProperties = exportJobProperties
    }
}

struct DescribeFHIRExportJobOutputResponseBody: Swift.Equatable {
    let exportJobProperties: HealthLakeClientTypes.ExportJobProperties?
}

extension DescribeFHIRExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportJobProperties = "ExportJobProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportJobPropertiesDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.ExportJobProperties.self, forKey: .exportJobProperties)
        exportJobProperties = exportJobPropertiesDecoded
    }
}

extension DescribeFHIRImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeFHIRImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFHIRImportJobInput: Swift.Equatable {
    /// The AWS-generated ID of the data store.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The AWS-generated job ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

struct DescribeFHIRImportJobInputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let jobId: Swift.String?
}

extension DescribeFHIRImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum DescribeFHIRImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFHIRImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFHIRImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.importJobProperties = output.importJobProperties
        } else {
            self.importJobProperties = nil
        }
    }
}

public struct DescribeFHIRImportJobOutputResponse: Swift.Equatable {
    /// The properties of the Import job request, including the ID, ARN, name, and the status of the job.
    /// This member is required.
    public var importJobProperties: HealthLakeClientTypes.ImportJobProperties?

    public init(
        importJobProperties: HealthLakeClientTypes.ImportJobProperties? = nil
    )
    {
        self.importJobProperties = importJobProperties
    }
}

struct DescribeFHIRImportJobOutputResponseBody: Swift.Equatable {
    let importJobProperties: HealthLakeClientTypes.ImportJobProperties?
}

extension DescribeFHIRImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importJobProperties = "ImportJobProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobPropertiesDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.ImportJobProperties.self, forKey: .importJobProperties)
        importJobProperties = importJobPropertiesDecoded
    }
}

extension HealthLakeClientTypes.ExportJobProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case endTime = "EndTime"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case message = "Message"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = self.submitTime {
            try encodeContainer.encodeTimestamp(submitTime, format: .epochSeconds, forKey: .submitTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes {
    /// The properties of a FHIR export job, including the ID, ARN, name, and the status of the job.
    public struct ExportJobProperties: Swift.Equatable {
        /// The Amazon Resource Name used during the initiation of the job.
        public var dataAccessRoleArn: Swift.String?
        /// The AWS generated ID for the data store from which files are being exported for an export job.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The time an export job completed.
        public var endTime: ClientRuntime.Date?
        /// The AWS generated ID for an export job.
        /// This member is required.
        public var jobId: Swift.String?
        /// The user generated name for an export job.
        public var jobName: Swift.String?
        /// The status of a FHIR export job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, or FAILED.
        /// This member is required.
        public var jobStatus: HealthLakeClientTypes.JobStatus?
        /// An explanation of any errors that may have occurred during the export job.
        public var message: Swift.String?
        /// The output data configuration that was supplied when the export job was created.
        /// This member is required.
        public var outputDataConfig: HealthLakeClientTypes.OutputDataConfig?
        /// The time an export job was initiated.
        /// This member is required.
        public var submitTime: ClientRuntime.Date?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: HealthLakeClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            outputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil,
            submitTime: ClientRuntime.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.outputDataConfig = outputDataConfig
            self.submitTime = submitTime
        }
    }

}

extension HealthLakeClientTypes {
    public enum FHIRVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case r4
        case sdkUnknown(Swift.String)

        public static var allCases: [FHIRVersion] {
            return [
                .r4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .r4: return "R4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FHIRVersion(rawValue: rawValue) ?? FHIRVersion.sdkUnknown(rawValue)
        }
    }
}

extension HealthLakeClientTypes.IdentityProviderConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationStrategy = "AuthorizationStrategy"
        case fineGrainedAuthorizationEnabled = "FineGrainedAuthorizationEnabled"
        case idpLambdaArn = "IdpLambdaArn"
        case metadata = "Metadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationStrategy = self.authorizationStrategy {
            try encodeContainer.encode(authorizationStrategy.rawValue, forKey: .authorizationStrategy)
        }
        if fineGrainedAuthorizationEnabled != false {
            try encodeContainer.encode(fineGrainedAuthorizationEnabled, forKey: .fineGrainedAuthorizationEnabled)
        }
        if let idpLambdaArn = self.idpLambdaArn {
            try encodeContainer.encode(idpLambdaArn, forKey: .idpLambdaArn)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationStrategyDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.AuthorizationStrategy.self, forKey: .authorizationStrategy)
        authorizationStrategy = authorizationStrategyDecoded
        let fineGrainedAuthorizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fineGrainedAuthorizationEnabled) ?? false
        fineGrainedAuthorizationEnabled = fineGrainedAuthorizationEnabledDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let idpLambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idpLambdaArn)
        idpLambdaArn = idpLambdaArnDecoded
    }
}

extension HealthLakeClientTypes {
    /// The identity provider configuration that you gave when the data store was created.
    public struct IdentityProviderConfiguration: Swift.Equatable {
        /// The authorization strategy that you selected when you created the data store.
        /// This member is required.
        public var authorizationStrategy: HealthLakeClientTypes.AuthorizationStrategy?
        /// If you enabled fine-grained authorization when you created the data store.
        public var fineGrainedAuthorizationEnabled: Swift.Bool
        /// The Amazon Resource Name (ARN) of the Lambda function that you want to use to decode the access token created by the authorization server.
        public var idpLambdaArn: Swift.String?
        /// The JSON metadata elements that you want to use in your identity provider configuration. Required elements are listed based on the launch specification of the SMART application. For more information on all possible elements, see [Metadata](https://build.fhir.org/ig/HL7/smart-app-launch/conformance.html#metadata) in SMART's App Launch specification. authorization_endpoint: The URL to the OAuth2 authorization endpoint. grant_types_supported: An array of grant types that are supported at the token endpoint. You must provide at least one grant type option. Valid options are authorization_code and client_credentials. token_endpoint: The URL to the OAuth2 token endpoint. capabilities: An array of strings of the SMART capabilities that the authorization server supports. code_challenge_methods_supported: An array of strings of supported PKCE code challenge methods. You must include the S256 method in the array of PKCE code challenge methods.
        public var metadata: Swift.String?

        public init(
            authorizationStrategy: HealthLakeClientTypes.AuthorizationStrategy? = nil,
            fineGrainedAuthorizationEnabled: Swift.Bool = false,
            idpLambdaArn: Swift.String? = nil,
            metadata: Swift.String? = nil
        )
        {
            self.authorizationStrategy = authorizationStrategy
            self.fineGrainedAuthorizationEnabled = fineGrainedAuthorizationEnabled
            self.idpLambdaArn = idpLambdaArn
            self.metadata = metadata
        }
    }

}

extension HealthLakeClientTypes.ImportJobProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobOutputDataConfig = "JobOutputDataConfig"
        case jobStatus = "JobStatus"
        case message = "Message"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutputDataConfig = self.jobOutputDataConfig {
            try encodeContainer.encode(jobOutputDataConfig, forKey: .jobOutputDataConfig)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let submitTime = self.submitTime {
            try encodeContainer.encodeTimestamp(submitTime, format: .epochSeconds, forKey: .submitTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let jobOutputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.OutputDataConfig.self, forKey: .jobOutputDataConfig)
        jobOutputDataConfig = jobOutputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes {
    /// Displays the properties of the import job, including the ID, Arn, Name, and the status of the data store.
    public struct ImportJobProperties: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that gives AWS HealthLake access to your input data.
        public var dataAccessRoleArn: Swift.String?
        /// The datastore id used when the Import job was created.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The time that the Import job was completed.
        public var endTime: ClientRuntime.Date?
        /// The input data configuration that was supplied when the Import job was created.
        /// This member is required.
        public var inputDataConfig: HealthLakeClientTypes.InputDataConfig?
        /// The AWS-generated id number for the Import job.
        /// This member is required.
        public var jobId: Swift.String?
        /// The user-generated name for an Import job.
        public var jobName: Swift.String?
        /// The output data configuration that was supplied when the export job was created.
        public var jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig?
        /// The job status for an Import job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED_WITH_ERRORS, COMPLETED, FAILED.
        /// This member is required.
        public var jobStatus: HealthLakeClientTypes.JobStatus?
        /// An explanation of any errors that may have occurred during the FHIR import job.
        public var message: Swift.String?
        /// The time that the Import job was submitted for processing.
        /// This member is required.
        public var submitTime: ClientRuntime.Date?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            inputDataConfig: HealthLakeClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil,
            jobStatus: HealthLakeClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            submitTime: ClientRuntime.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobOutputDataConfig = jobOutputDataConfig
            self.jobStatus = jobStatus
            self.message = message
            self.submitTime = submitTime
        }
    }

}

extension HealthLakeClientTypes.InputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3uri = "S3Uri"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3uri(s3uri):
                try container.encode(s3uri, forKey: .s3uri)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3uriDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .s3uri)
        if let s3uri = s3uriDecoded {
            self = .s3uri(s3uri)
            return
        }
        self = .sdkUnknown("")
    }
}

extension HealthLakeClientTypes {
    /// The input properties for an import job.
    public enum InputDataConfig: Swift.Equatable {
        /// The S3Uri is the user specified S3 location of the FHIR data to be imported into AWS HealthLake.
        case s3uri(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Unknown error occurs in the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelCompleted
        case cancelFailed
        case cancelInProgress
        case cancelSubmitted
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .cancelCompleted,
                .cancelFailed,
                .cancelInProgress,
                .cancelSubmitted,
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelCompleted: return "CANCEL_COMPLETED"
            case .cancelFailed: return "CANCEL_FAILED"
            case .cancelInProgress: return "CANCEL_IN_PROGRESS"
            case .cancelSubmitted: return "CANCEL_SUBMITTED"
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension HealthLakeClientTypes.KmsEncryptionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cmkType = "CmkType"
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cmkType = self.cmkType {
            try encodeContainer.encode(cmkType.rawValue, forKey: .cmkType)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cmkTypeDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.CmkType.self, forKey: .cmkType)
        cmkType = cmkTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension HealthLakeClientTypes {
    /// The customer-managed-key(CMK) used when creating a data store. If a customer owned key is not specified, an AWS owned key will be used for encryption.
    public struct KmsEncryptionConfig: Swift.Equatable {
        /// The type of customer-managed-key(CMK) used for encryption. The two types of supported CMKs are customer owned CMKs and AWS owned CMKs.
        /// This member is required.
        public var cmkType: HealthLakeClientTypes.CmkType?
        /// The KMS encryption key id/alias used to encrypt the data store contents at rest.
        public var kmsKeyId: Swift.String?

        public init(
            cmkType: HealthLakeClientTypes.CmkType? = nil,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.cmkType = cmkType
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension ListFHIRDatastoresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFHIRDatastoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFHIRDatastoresInput: Swift.Equatable {
    /// Lists all filters associated with a FHIR data store request.
    public var filter: HealthLakeClientTypes.DatastoreFilter?
    /// The maximum number of data stores returned in a single page of a ListFHIRDatastoresRequest call.
    public var maxResults: Swift.Int?
    /// Fetches the next page of data stores when results are paginated.
    public var nextToken: Swift.String?

    public init(
        filter: HealthLakeClientTypes.DatastoreFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFHIRDatastoresInputBody: Swift.Equatable {
    let filter: HealthLakeClientTypes.DatastoreFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListFHIRDatastoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

enum ListFHIRDatastoresOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFHIRDatastoresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFHIRDatastoresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastorePropertiesList = output.datastorePropertiesList
            self.nextToken = output.nextToken
        } else {
            self.datastorePropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFHIRDatastoresOutputResponse: Swift.Equatable {
    /// All properties associated with the listed data stores.
    /// This member is required.
    public var datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]?
    /// Pagination token that can be used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datastorePropertiesList = datastorePropertiesList
        self.nextToken = nextToken
    }
}

struct ListFHIRDatastoresOutputResponseBody: Swift.Equatable {
    let datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]?
    let nextToken: Swift.String?
}

extension ListFHIRDatastoresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastorePropertiesList = "DatastorePropertiesList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastorePropertiesListContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.DatastoreProperties?].self, forKey: .datastorePropertiesList)
        var datastorePropertiesListDecoded0:[HealthLakeClientTypes.DatastoreProperties]? = nil
        if let datastorePropertiesListContainer = datastorePropertiesListContainer {
            datastorePropertiesListDecoded0 = [HealthLakeClientTypes.DatastoreProperties]()
            for structure0 in datastorePropertiesListContainer {
                if let structure0 = structure0 {
                    datastorePropertiesListDecoded0?.append(structure0)
                }
            }
        }
        datastorePropertiesList = datastorePropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFHIRExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case submittedAfter = "SubmittedAfter"
        case submittedBefore = "SubmittedBefore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let submittedAfter = self.submittedAfter {
            try encodeContainer.encodeTimestamp(submittedAfter, format: .epochSeconds, forKey: .submittedAfter)
        }
        if let submittedBefore = self.submittedBefore {
            try encodeContainer.encodeTimestamp(submittedBefore, format: .epochSeconds, forKey: .submittedBefore)
        }
    }
}

extension ListFHIRExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFHIRExportJobsInput: Swift.Equatable {
    /// This parameter limits the response to the export job with the specified data store ID.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// This parameter limits the response to the export job with the specified job name.
    public var jobName: Swift.String?
    /// This parameter limits the response to the export jobs with the specified job status.
    public var jobStatus: HealthLakeClientTypes.JobStatus?
    /// This parameter limits the number of results returned for a ListFHIRExportJobs to a maximum quantity specified by the user.
    public var maxResults: Swift.Int?
    /// A pagination token used to identify the next page of results to return for a ListFHIRExportJobs query.
    public var nextToken: Swift.String?
    /// This parameter limits the response to FHIR export jobs submitted after a user specified date.
    public var submittedAfter: ClientRuntime.Date?
    /// This parameter limits the response to FHIR export jobs submitted before a user specified date.
    public var submittedBefore: ClientRuntime.Date?

    public init(
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        submittedAfter: ClientRuntime.Date? = nil,
        submittedBefore: ClientRuntime.Date? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.submittedAfter = submittedAfter
        self.submittedBefore = submittedBefore
    }
}

struct ListFHIRExportJobsInputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let jobName: Swift.String?
    let jobStatus: HealthLakeClientTypes.JobStatus?
    let submittedBefore: ClientRuntime.Date?
    let submittedAfter: ClientRuntime.Date?
}

extension ListFHIRExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case submittedAfter = "SubmittedAfter"
        case submittedBefore = "SubmittedBefore"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submittedBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedBefore)
        submittedBefore = submittedBeforeDecoded
        let submittedAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedAfter)
        submittedAfter = submittedAfterDecoded
    }
}

enum ListFHIRExportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFHIRExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFHIRExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportJobPropertiesList = output.exportJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.exportJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFHIRExportJobsOutputResponse: Swift.Equatable {
    /// The properties of listed FHIR export jobs, including the ID, ARN, name, and the status of the job.
    /// This member is required.
    public var exportJobPropertiesList: [HealthLakeClientTypes.ExportJobProperties]?
    /// A pagination token used to identify the next page of results to return for a ListFHIRExportJobs query.
    public var nextToken: Swift.String?

    public init(
        exportJobPropertiesList: [HealthLakeClientTypes.ExportJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportJobPropertiesList = exportJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListFHIRExportJobsOutputResponseBody: Swift.Equatable {
    let exportJobPropertiesList: [HealthLakeClientTypes.ExportJobProperties]?
    let nextToken: Swift.String?
}

extension ListFHIRExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportJobPropertiesList = "ExportJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportJobPropertiesListContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.ExportJobProperties?].self, forKey: .exportJobPropertiesList)
        var exportJobPropertiesListDecoded0:[HealthLakeClientTypes.ExportJobProperties]? = nil
        if let exportJobPropertiesListContainer = exportJobPropertiesListContainer {
            exportJobPropertiesListDecoded0 = [HealthLakeClientTypes.ExportJobProperties]()
            for structure0 in exportJobPropertiesListContainer {
                if let structure0 = structure0 {
                    exportJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        exportJobPropertiesList = exportJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFHIRImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case submittedAfter = "SubmittedAfter"
        case submittedBefore = "SubmittedBefore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let submittedAfter = self.submittedAfter {
            try encodeContainer.encodeTimestamp(submittedAfter, format: .epochSeconds, forKey: .submittedAfter)
        }
        if let submittedBefore = self.submittedBefore {
            try encodeContainer.encodeTimestamp(submittedBefore, format: .epochSeconds, forKey: .submittedBefore)
        }
    }
}

extension ListFHIRImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFHIRImportJobsInput: Swift.Equatable {
    /// This parameter limits the response to the import job with the specified data store ID.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// This parameter limits the response to the import job with the specified job name.
    public var jobName: Swift.String?
    /// This parameter limits the response to the import job with the specified job status.
    public var jobStatus: HealthLakeClientTypes.JobStatus?
    /// This parameter limits the number of results returned for a ListFHIRImportJobs to a maximum quantity specified by the user.
    public var maxResults: Swift.Int?
    /// A pagination token used to identify the next page of results to return for a ListFHIRImportJobs query.
    public var nextToken: Swift.String?
    /// This parameter limits the response to FHIR import jobs submitted after a user specified date.
    public var submittedAfter: ClientRuntime.Date?
    /// This parameter limits the response to FHIR import jobs submitted before a user specified date.
    public var submittedBefore: ClientRuntime.Date?

    public init(
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        submittedAfter: ClientRuntime.Date? = nil,
        submittedBefore: ClientRuntime.Date? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.submittedAfter = submittedAfter
        self.submittedBefore = submittedBefore
    }
}

struct ListFHIRImportJobsInputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let jobName: Swift.String?
    let jobStatus: HealthLakeClientTypes.JobStatus?
    let submittedBefore: ClientRuntime.Date?
    let submittedAfter: ClientRuntime.Date?
}

extension ListFHIRImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case submittedAfter = "SubmittedAfter"
        case submittedBefore = "SubmittedBefore"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submittedBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedBefore)
        submittedBefore = submittedBeforeDecoded
        let submittedAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedAfter)
        submittedAfter = submittedAfterDecoded
    }
}

enum ListFHIRImportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFHIRImportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFHIRImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.importJobPropertiesList = output.importJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.importJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFHIRImportJobsOutputResponse: Swift.Equatable {
    /// The properties of a listed FHIR import jobs, including the ID, ARN, name, and the status of the job.
    /// This member is required.
    public var importJobPropertiesList: [HealthLakeClientTypes.ImportJobProperties]?
    /// A pagination token used to identify the next page of results to return for a ListFHIRImportJobs query.
    public var nextToken: Swift.String?

    public init(
        importJobPropertiesList: [HealthLakeClientTypes.ImportJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importJobPropertiesList = importJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListFHIRImportJobsOutputResponseBody: Swift.Equatable {
    let importJobPropertiesList: [HealthLakeClientTypes.ImportJobProperties]?
    let nextToken: Swift.String?
}

extension ListFHIRImportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importJobPropertiesList = "ImportJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobPropertiesListContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.ImportJobProperties?].self, forKey: .importJobPropertiesList)
        var importJobPropertiesListDecoded0:[HealthLakeClientTypes.ImportJobProperties]? = nil
        if let importJobPropertiesListContainer = importJobPropertiesListContainer {
            importJobPropertiesListDecoded0 = [HealthLakeClientTypes.ImportJobProperties]()
            for structure0 in importJobPropertiesListContainer {
                if let structure0 = structure0 {
                    importJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        importJobPropertiesList = importJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name(ARN) of the data store for which tags are being added.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Returns a list of tags associated with a data store.
    public var tags: [HealthLakeClientTypes.Tag]?

    public init(
        tags: [HealthLakeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [HealthLakeClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[HealthLakeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [HealthLakeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension HealthLakeClientTypes.OutputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3configuration = "S3Configuration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3configuration(s3configuration):
                try container.encode(s3configuration, forKey: .s3configuration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3configurationDecoded = try values.decodeIfPresent(HealthLakeClientTypes.S3Configuration.self, forKey: .s3configuration)
        if let s3configuration = s3configurationDecoded {
            self = .s3configuration(s3configuration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension HealthLakeClientTypes {
    /// The output data configuration that was supplied when the export job was created.
    public enum OutputDataConfig: Swift.Equatable {
        /// The output data configuration that was supplied when the export job was created.
        case s3configuration(HealthLakeClientTypes.S3Configuration)
        case sdkUnknown(Swift.String)
    }

}

extension HealthLakeClientTypes.PreloadDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preloadDataType = "PreloadDataType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let preloadDataType = self.preloadDataType {
            try encodeContainer.encode(preloadDataType.rawValue, forKey: .preloadDataType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preloadDataTypeDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.PreloadDataType.self, forKey: .preloadDataType)
        preloadDataType = preloadDataTypeDecoded
    }
}

extension HealthLakeClientTypes {
    /// The input properties for the preloaded data store. Only data preloaded from Synthea is supported.
    public struct PreloadDataConfig: Swift.Equatable {
        /// The type of preloaded data. Only Synthea preloaded data is supported.
        /// This member is required.
        public var preloadDataType: HealthLakeClientTypes.PreloadDataType?

        public init(
            preloadDataType: HealthLakeClientTypes.PreloadDataType? = nil
        )
        {
            self.preloadDataType = preloadDataType
        }
    }

}

extension HealthLakeClientTypes {
    public enum PreloadDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case synthea
        case sdkUnknown(Swift.String)

        public static var allCases: [PreloadDataType] {
            return [
                .synthea,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .synthea: return "SYNTHEA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PreloadDataType(rawValue: rawValue) ?? PreloadDataType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested data store was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes.S3Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension HealthLakeClientTypes {
    /// The configuration of the S3 bucket for either an import or export job. This includes assigning permissions for access.
    public struct S3Configuration: Swift.Equatable {
        /// The KMS key ID used to access the S3 bucket.
        /// This member is required.
        public var kmsKeyId: Swift.String?
        /// The S3Uri is the user specified S3 location of the FHIR data to be imported into AWS HealthLake.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }
    }

}

extension HealthLakeClientTypes.SseConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsEncryptionConfig = "KmsEncryptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsEncryptionConfig = self.kmsEncryptionConfig {
            try encodeContainer.encode(kmsEncryptionConfig, forKey: .kmsEncryptionConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsEncryptionConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.KmsEncryptionConfig.self, forKey: .kmsEncryptionConfig)
        kmsEncryptionConfig = kmsEncryptionConfigDecoded
    }
}

extension HealthLakeClientTypes {
    /// The server-side encryption key configuration for a customer provided encryption key.
    public struct SseConfiguration: Swift.Equatable {
        /// The KMS encryption configuration used to provide details for data encryption.
        /// This member is required.
        public var kmsEncryptionConfig: HealthLakeClientTypes.KmsEncryptionConfig?

        public init(
            kmsEncryptionConfig: HealthLakeClientTypes.KmsEncryptionConfig? = nil
        )
        {
            self.kmsEncryptionConfig = kmsEncryptionConfig
        }
    }

}

extension StartFHIRExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartFHIRExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartFHIRExportJobInput: Swift.Equatable {
    /// An optional user provided token used for ensuring idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name used during the initiation of the job.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The AWS generated ID for the data store from which files are being exported for an export job.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The user generated name for an export job.
    public var jobName: Swift.String?
    /// The output data configuration that was supplied when the export job was created.
    /// This member is required.
    public var outputDataConfig: HealthLakeClientTypes.OutputDataConfig?

    public init(
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
    }
}

struct StartFHIRExportJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let outputDataConfig: HealthLakeClientTypes.OutputDataConfig?
    let datastoreId: Swift.String?
    let dataAccessRoleArn: Swift.String?
    let clientToken: Swift.String?
}

extension StartFHIRExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

enum StartFHIRExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartFHIRExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartFHIRExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreId = output.datastoreId
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.datastoreId = nil
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartFHIRExportJobOutputResponse: Swift.Equatable {
    /// The AWS generated ID for the data store from which files are being exported for an export job.
    public var datastoreId: Swift.String?
    /// The AWS generated ID for an export job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The status of a FHIR export job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, or FAILED.
    /// This member is required.
    public var jobStatus: HealthLakeClientTypes.JobStatus?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartFHIRExportJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
    let jobStatus: HealthLakeClientTypes.JobStatus?
    let datastoreId: Swift.String?
}

extension StartFHIRExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension StartFHIRImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case jobOutputDataConfig = "JobOutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutputDataConfig = self.jobOutputDataConfig {
            try encodeContainer.encode(jobOutputDataConfig, forKey: .jobOutputDataConfig)
        }
    }
}

extension StartFHIRImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartFHIRImportJobInput: Swift.Equatable {
    /// Optional user provided token used for ensuring idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) that gives AWS HealthLake access permission.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The AWS-generated data store ID.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The input properties of the FHIR Import job in the StartFHIRImport job request.
    /// This member is required.
    public var inputDataConfig: HealthLakeClientTypes.InputDataConfig?
    /// The name of the FHIR Import job in the StartFHIRImport job request.
    public var jobName: Swift.String?
    /// The output data configuration that was supplied when the export job was created.
    /// This member is required.
    public var jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig?

    public init(
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        inputDataConfig: HealthLakeClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.jobOutputDataConfig = jobOutputDataConfig
    }
}

struct StartFHIRImportJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let inputDataConfig: HealthLakeClientTypes.InputDataConfig?
    let jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig?
    let datastoreId: Swift.String?
    let dataAccessRoleArn: Swift.String?
    let clientToken: Swift.String?
}

extension StartFHIRImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case jobOutputDataConfig = "JobOutputDataConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let jobOutputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.OutputDataConfig.self, forKey: .jobOutputDataConfig)
        jobOutputDataConfig = jobOutputDataConfigDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

enum StartFHIRImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartFHIRImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartFHIRImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreId = output.datastoreId
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.datastoreId = nil
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartFHIRImportJobOutputResponse: Swift.Equatable {
    /// The AWS-generated data store ID.
    public var datastoreId: Swift.String?
    /// The AWS-generated job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The status of an import job.
    /// This member is required.
    public var jobStatus: HealthLakeClientTypes.JobStatus?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartFHIRImportJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
    let jobStatus: HealthLakeClientTypes.JobStatus?
    let datastoreId: Swift.String?
}

extension StartFHIRImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension HealthLakeClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension HealthLakeClientTypes {
    /// A tag is a label consisting of a user-defined key and value. The form for tags is {"Key", "Value"}
    public struct Tag: Swift.Equatable {
        /// The key portion of a tag. Tag keys are case sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// The value portion of a tag. Tag values are case sensitive.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name(ARN)that gives AWS HealthLake access to the data store which tags are being added to.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The user specified key and value pair tags being added to a data store.
    /// This member is required.
    public var tags: [HealthLakeClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [HealthLakeClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [HealthLakeClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[HealthLakeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [HealthLakeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user has exceeded their maximum number of allowed calls to the given API.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name(ARN) of the data store for which tags are being removed.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys for the tags to be removed from the HealthLake data store.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user input parameter was invalid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
