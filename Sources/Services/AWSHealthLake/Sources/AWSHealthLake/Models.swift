//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// Access is denied. Your account is not authorized to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension HealthLakeClientTypes {

    public enum AuthorizationStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsAuth
        case smartv1
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationStrategy] {
            return [
                .awsAuth,
                .smartv1
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsAuth: return "AWS_AUTH"
            case .smartv1: return "SMART_ON_FHIR_V1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthLakeClientTypes {

    public enum CmkType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aoCmk
        case cmCmk
        case sdkUnknown(Swift.String)

        public static var allCases: [CmkType] {
            return [
                .aoCmk,
                .cmCmk
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aoCmk: return "AWS_OWNED_KMS_KEY"
            case .cmCmk: return "CUSTOMER_MANAGED_KMS_KEY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The data store is in a transition state and the user requested action can not be performed.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Unknown error occurs in the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The user has exceeded their maximum number of allowed calls to the given API.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The user input parameter was invalid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension HealthLakeClientTypes {

    public enum FHIRVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case r4
        case sdkUnknown(Swift.String)

        public static var allCases: [FHIRVersion] {
            return [
                .r4
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .r4: return "R4"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthLakeClientTypes {

    /// The identity provider configuration that you gave when the data store was created.
    public struct IdentityProviderConfiguration: Swift.Sendable {
        /// The authorization strategy that you selected when you created the data store.
        /// This member is required.
        public var authorizationStrategy: HealthLakeClientTypes.AuthorizationStrategy?
        /// If you enabled fine-grained authorization when you created the data store.
        public var fineGrainedAuthorizationEnabled: Swift.Bool
        /// The Amazon Resource Name (ARN) of the Lambda function that you want to use to decode the access token created by the authorization server.
        public var idpLambdaArn: Swift.String?
        /// The JSON metadata elements that you want to use in your identity provider configuration. Required elements are listed based on the launch specification of the SMART application. For more information on all possible elements, see [Metadata](https://build.fhir.org/ig/HL7/smart-app-launch/conformance.html#metadata) in SMART's App Launch specification. authorization_endpoint: The URL to the OAuth2 authorization endpoint. grant_types_supported: An array of grant types that are supported at the token endpoint. You must provide at least one grant type option. Valid options are authorization_code and client_credentials. token_endpoint: The URL to the OAuth2 token endpoint. capabilities: An array of strings of the SMART capabilities that the authorization server supports. code_challenge_methods_supported: An array of strings of supported PKCE code challenge methods. You must include the S256 method in the array of PKCE code challenge methods.
        public var metadata: Swift.String?

        public init(
            authorizationStrategy: HealthLakeClientTypes.AuthorizationStrategy? = nil,
            fineGrainedAuthorizationEnabled: Swift.Bool = false,
            idpLambdaArn: Swift.String? = nil,
            metadata: Swift.String? = nil
        )
        {
            self.authorizationStrategy = authorizationStrategy
            self.fineGrainedAuthorizationEnabled = fineGrainedAuthorizationEnabled
            self.idpLambdaArn = idpLambdaArn
            self.metadata = metadata
        }
    }
}

extension HealthLakeClientTypes {

    public enum PreloadDataType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case synthea
        case sdkUnknown(Swift.String)

        public static var allCases: [PreloadDataType] {
            return [
                .synthea
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .synthea: return "SYNTHEA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthLakeClientTypes {

    /// The input properties for the preloaded data store. Only data preloaded from Synthea is supported.
    public struct PreloadDataConfig: Swift.Sendable {
        /// The type of preloaded data. Only Synthea preloaded data is supported.
        /// This member is required.
        public var preloadDataType: HealthLakeClientTypes.PreloadDataType?

        public init(
            preloadDataType: HealthLakeClientTypes.PreloadDataType? = nil
        )
        {
            self.preloadDataType = preloadDataType
        }
    }
}

extension HealthLakeClientTypes {

    /// The customer-managed-key(CMK) used when creating a data store. If a customer owned key is not specified, an AWS owned key will be used for encryption.
    public struct KmsEncryptionConfig: Swift.Sendable {
        /// The type of customer-managed-key(CMK) used for encryption. The two types of supported CMKs are customer owned CMKs and AWS owned CMKs.
        /// This member is required.
        public var cmkType: HealthLakeClientTypes.CmkType?
        /// The KMS encryption key id/alias used to encrypt the data store contents at rest.
        public var kmsKeyId: Swift.String?

        public init(
            cmkType: HealthLakeClientTypes.CmkType? = nil,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.cmkType = cmkType
            self.kmsKeyId = kmsKeyId
        }
    }
}

extension HealthLakeClientTypes {

    /// The server-side encryption key configuration for a customer provided encryption key.
    public struct SseConfiguration: Swift.Sendable {
        /// The KMS encryption configuration used to provide details for data encryption.
        /// This member is required.
        public var kmsEncryptionConfig: HealthLakeClientTypes.KmsEncryptionConfig?

        public init(
            kmsEncryptionConfig: HealthLakeClientTypes.KmsEncryptionConfig? = nil
        )
        {
            self.kmsEncryptionConfig = kmsEncryptionConfig
        }
    }
}

extension HealthLakeClientTypes {

    /// A tag is a label consisting of a user-defined key and value. The form for tags is {"Key", "Value"}
    public struct Tag: Swift.Sendable {
        /// The key portion of a tag. Tag keys are case sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// The value portion of a tag. Tag values are case sensitive.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateFHIRDatastoreInput: Swift.Sendable {
    /// Optional user provided token used for ensuring idempotency.
    public var clientToken: Swift.String?
    /// The user generated name for the data store.
    public var datastoreName: Swift.String?
    /// The FHIR version of the data store. The only supported version is R4.
    /// This member is required.
    public var datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
    /// The configuration of the identity provider that you want to use for your data store.
    public var identityProviderConfiguration: HealthLakeClientTypes.IdentityProviderConfiguration?
    /// Optional parameter to preload data upon creation of the data store. Currently, the only supported preloaded data is synthetic data generated from Synthea.
    public var preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?
    /// The server-side encryption key configuration for a customer provided encryption key specified for creating a data store.
    public var sseConfiguration: HealthLakeClientTypes.SseConfiguration?
    /// Resource tags that are applied to a data store when it is created.
    public var tags: [HealthLakeClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        datastoreName: Swift.String? = nil,
        datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion? = nil,
        identityProviderConfiguration: HealthLakeClientTypes.IdentityProviderConfiguration? = nil,
        preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig? = nil,
        sseConfiguration: HealthLakeClientTypes.SseConfiguration? = nil,
        tags: [HealthLakeClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.datastoreName = datastoreName
        self.datastoreTypeVersion = datastoreTypeVersion
        self.identityProviderConfiguration = identityProviderConfiguration
        self.preloadDataConfig = preloadDataConfig
        self.sseConfiguration = sseConfiguration
        self.tags = tags
    }
}

extension HealthLakeClientTypes {

    public enum DatastoreStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [DatastoreStatus] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleted,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFHIRDatastoreOutput: Swift.Sendable {
    /// The data store ARN is generated during the creation of the data store and can be found in the output from the initial data store creation call.
    /// This member is required.
    public var datastoreArn: Swift.String?
    /// The AWS endpoint for the created data store.
    /// This member is required.
    public var datastoreEndpoint: Swift.String?
    /// The AWS-generated data store id. This id is in the output from the initial data store creation call.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The status of the FHIR data store.
    /// This member is required.
    public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

    public init(
        datastoreArn: Swift.String? = nil,
        datastoreEndpoint: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
    )
    {
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

extension HealthLakeClientTypes {

    /// The filters applied to data store query.
    public struct DatastoreFilter: Swift.Sendable {
        /// A filter that allows the user to set cutoff dates for records. All data stores created after the specified date will be included in the results.
        public var createdAfter: Foundation.Date?
        /// A filter that allows the user to set cutoff dates for records. All data stores created before the specified date will be included in the results.
        public var createdBefore: Foundation.Date?
        /// Allows the user to filter data store results by name.
        public var datastoreName: Swift.String?
        /// Allows the user to filter data store results by status.
        public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

        public init(
            createdAfter: Foundation.Date? = nil,
            createdBefore: Foundation.Date? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
        }
    }
}

extension HealthLakeClientTypes {

    public enum ErrorCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nonRetryableError
        case retryableError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCategory] {
            return [
                .nonRetryableError,
                .retryableError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nonRetryableError: return "NON_RETRYABLE_ERROR"
            case .retryableError: return "RETRYABLE_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthLakeClientTypes {

    /// The error info of the create/delete data store operation.
    public struct ErrorCause: Swift.Sendable {
        /// The error category of the create/delete data store operation. Possible statuses are RETRYABLE_ERROR or NON_RETRYABLE_ERROR.
        public var errorCategory: HealthLakeClientTypes.ErrorCategory?
        /// The text of the error message.
        public var errorMessage: Swift.String?

        public init(
            errorCategory: HealthLakeClientTypes.ErrorCategory? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
        }
    }
}

extension HealthLakeClientTypes {

    /// Displays the properties of the data store, including the ID, ARN, name, and the status of the data store.
    public struct DatastoreProperties: Swift.Sendable {
        /// The time that a data store was created.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name used in the creation of the data store.
        /// This member is required.
        public var datastoreArn: Swift.String?
        /// The AWS endpoint for the data store. Each data store will have it's own endpoint with data store ID in the endpoint URL.
        /// This member is required.
        public var datastoreEndpoint: Swift.String?
        /// The AWS-generated ID number for the data store.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The user-generated name for the data store.
        public var datastoreName: Swift.String?
        /// The status of the data store.
        /// This member is required.
        public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?
        /// The FHIR version. Only R4 version data is supported.
        /// This member is required.
        public var datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
        /// The error cause for the current data store operation.
        public var errorCause: HealthLakeClientTypes.ErrorCause?
        /// The identity provider that you selected when you created the data store.
        public var identityProviderConfiguration: HealthLakeClientTypes.IdentityProviderConfiguration?
        /// The preloaded data configuration for the data store. Only data preloaded from Synthea is supported.
        public var preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?
        /// The server-side encryption key configuration for a customer provided encryption key (CMK).
        public var sseConfiguration: HealthLakeClientTypes.SseConfiguration?

        public init(
            createdAt: Foundation.Date? = nil,
            datastoreArn: Swift.String? = nil,
            datastoreEndpoint: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil,
            datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion? = nil,
            errorCause: HealthLakeClientTypes.ErrorCause? = nil,
            identityProviderConfiguration: HealthLakeClientTypes.IdentityProviderConfiguration? = nil,
            preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig? = nil,
            sseConfiguration: HealthLakeClientTypes.SseConfiguration? = nil
        )
        {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreEndpoint = datastoreEndpoint
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.datastoreTypeVersion = datastoreTypeVersion
            self.errorCause = errorCause
            self.identityProviderConfiguration = identityProviderConfiguration
            self.preloadDataConfig = preloadDataConfig
            self.sseConfiguration = sseConfiguration
        }
    }
}

/// The requested data store was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteFHIRDatastoreInput: Swift.Sendable {
    /// The AWS-generated ID for the data store to be deleted.
    /// This member is required.
    public var datastoreId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

public struct DeleteFHIRDatastoreOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that gives AWS HealthLake access permission.
    /// This member is required.
    public var datastoreArn: Swift.String?
    /// The AWS endpoint for the data store the user has requested to be deleted.
    /// This member is required.
    public var datastoreEndpoint: Swift.String?
    /// The AWS-generated ID for the data store to be deleted.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The status of the data store that the user has requested to be deleted.
    /// This member is required.
    public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

    public init(
        datastoreArn: Swift.String? = nil,
        datastoreEndpoint: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
    )
    {
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

public struct DescribeFHIRDatastoreInput: Swift.Sendable {
    /// The AWS-generated data store ID.
    /// This member is required.
    public var datastoreId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

public struct DescribeFHIRDatastoreOutput: Swift.Sendable {
    /// All properties associated with a data store, including the data store ID, data store ARN, data store name, data store status, when the data store was created, data store type version, and the data store's endpoint.
    /// This member is required.
    public var datastoreProperties: HealthLakeClientTypes.DatastoreProperties?

    public init(
        datastoreProperties: HealthLakeClientTypes.DatastoreProperties? = nil
    )
    {
        self.datastoreProperties = datastoreProperties
    }
}

public struct DescribeFHIRExportJobInput: Swift.Sendable {
    /// The AWS generated ID for the data store from which files are being exported from for an export job.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The AWS generated ID for an export job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

extension HealthLakeClientTypes {

    public enum JobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelCompleted
        case cancelFailed
        case cancelInProgress
        case cancelSubmitted
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .cancelCompleted,
                .cancelFailed,
                .cancelInProgress,
                .cancelSubmitted,
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .submitted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelCompleted: return "CANCEL_COMPLETED"
            case .cancelFailed: return "CANCEL_FAILED"
            case .cancelInProgress: return "CANCEL_IN_PROGRESS"
            case .cancelSubmitted: return "CANCEL_SUBMITTED"
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthLakeClientTypes {

    /// The configuration of the S3 bucket for either an import or export job. This includes assigning permissions for access.
    public struct S3Configuration: Swift.Sendable {
        /// The KMS key ID used to access the S3 bucket.
        /// This member is required.
        public var kmsKeyId: Swift.String?
        /// The S3Uri is the user specified S3 location of the FHIR data to be imported into AWS HealthLake.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }
    }
}

extension HealthLakeClientTypes {

    /// The output data configuration that was supplied when the export job was created.
    public enum OutputDataConfig: Swift.Sendable {
        /// The output data configuration that was supplied when the export job was created.
        case s3configuration(HealthLakeClientTypes.S3Configuration)
        case sdkUnknown(Swift.String)
    }
}

extension HealthLakeClientTypes {

    /// The properties of a FHIR export job, including the ID, ARN, name, and the status of the job.
    public struct ExportJobProperties: Swift.Sendable {
        /// The Amazon Resource Name used during the initiation of the job.
        public var dataAccessRoleArn: Swift.String?
        /// The AWS generated ID for the data store from which files are being exported for an export job.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The time an export job completed.
        public var endTime: Foundation.Date?
        /// The AWS generated ID for an export job.
        /// This member is required.
        public var jobId: Swift.String?
        /// The user generated name for an export job.
        public var jobName: Swift.String?
        /// The status of a FHIR export job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, or FAILED.
        /// This member is required.
        public var jobStatus: HealthLakeClientTypes.JobStatus?
        /// An explanation of any errors that may have occurred during the export job.
        public var message: Swift.String?
        /// The output data configuration that was supplied when the export job was created.
        /// This member is required.
        public var outputDataConfig: HealthLakeClientTypes.OutputDataConfig?
        /// The time an export job was initiated.
        /// This member is required.
        public var submitTime: Foundation.Date?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: HealthLakeClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            outputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil,
            submitTime: Foundation.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.outputDataConfig = outputDataConfig
            self.submitTime = submitTime
        }
    }
}

public struct DescribeFHIRExportJobOutput: Swift.Sendable {
    /// Displays the properties of the export job, including the ID, Arn, Name, and the status of the job.
    /// This member is required.
    public var exportJobProperties: HealthLakeClientTypes.ExportJobProperties?

    public init(
        exportJobProperties: HealthLakeClientTypes.ExportJobProperties? = nil
    )
    {
        self.exportJobProperties = exportJobProperties
    }
}

public struct DescribeFHIRImportJobInput: Swift.Sendable {
    /// The AWS-generated ID of the data store.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The AWS-generated job ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

extension HealthLakeClientTypes {

    /// The input properties for an import job.
    public enum InputDataConfig: Swift.Sendable {
        /// The S3Uri is the user specified S3 location of the FHIR data to be imported into AWS HealthLake.
        case s3uri(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension HealthLakeClientTypes {

    /// The progress report of an import job.
    public struct JobProgressReport: Swift.Sendable {
        /// The throughput (in MB/sec) of the import job.
        public var throughput: Swift.Double?
        /// The number of files that failed to be read from the input S3 bucket due to customer error.
        public var totalNumberOfFilesReadWithCustomerError: Swift.Int?
        /// The number of files imported so far.
        public var totalNumberOfImportedFiles: Swift.Int?
        /// The number of resources imported so far.
        public var totalNumberOfResourcesImported: Swift.Int?
        /// The number of resources scanned from the input S3 bucket.
        public var totalNumberOfResourcesScanned: Swift.Int?
        /// The number of resources that failed due to customer error.
        public var totalNumberOfResourcesWithCustomerError: Swift.Int?
        /// The number of files scanned from input S3 bucket.
        public var totalNumberOfScannedFiles: Swift.Int?
        /// The size (in MB) of the files scanned from the input S3 bucket.
        public var totalSizeOfScannedFilesInMB: Swift.Double?

        public init(
            throughput: Swift.Double? = nil,
            totalNumberOfFilesReadWithCustomerError: Swift.Int? = nil,
            totalNumberOfImportedFiles: Swift.Int? = nil,
            totalNumberOfResourcesImported: Swift.Int? = nil,
            totalNumberOfResourcesScanned: Swift.Int? = nil,
            totalNumberOfResourcesWithCustomerError: Swift.Int? = nil,
            totalNumberOfScannedFiles: Swift.Int? = nil,
            totalSizeOfScannedFilesInMB: Swift.Double? = nil
        )
        {
            self.throughput = throughput
            self.totalNumberOfFilesReadWithCustomerError = totalNumberOfFilesReadWithCustomerError
            self.totalNumberOfImportedFiles = totalNumberOfImportedFiles
            self.totalNumberOfResourcesImported = totalNumberOfResourcesImported
            self.totalNumberOfResourcesScanned = totalNumberOfResourcesScanned
            self.totalNumberOfResourcesWithCustomerError = totalNumberOfResourcesWithCustomerError
            self.totalNumberOfScannedFiles = totalNumberOfScannedFiles
            self.totalSizeOfScannedFilesInMB = totalSizeOfScannedFilesInMB
        }
    }
}

extension HealthLakeClientTypes {

    /// Displays the properties of the import job, including the ID, Arn, Name, the status of the job, and the progress report of the job.
    public struct ImportJobProperties: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that gives AWS HealthLake access to your input data.
        public var dataAccessRoleArn: Swift.String?
        /// The datastore id used when the Import job was created.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The time that the Import job was completed.
        public var endTime: Foundation.Date?
        /// The input data configuration that was supplied when the Import job was created.
        /// This member is required.
        public var inputDataConfig: HealthLakeClientTypes.InputDataConfig?
        /// The AWS-generated id number for the Import job.
        /// This member is required.
        public var jobId: Swift.String?
        /// The user-generated name for an Import job.
        public var jobName: Swift.String?
        /// The output data configuration that was supplied when the export job was created.
        public var jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig?
        /// Displays the progress of the import job, including total resources scanned, total resources ingested, and total size of data ingested.
        public var jobProgressReport: HealthLakeClientTypes.JobProgressReport?
        /// The job status for an Import job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED_WITH_ERRORS, COMPLETED, FAILED.
        /// This member is required.
        public var jobStatus: HealthLakeClientTypes.JobStatus?
        /// An explanation of any errors that may have occurred during the FHIR import job.
        public var message: Swift.String?
        /// The time that the Import job was submitted for processing.
        /// This member is required.
        public var submitTime: Foundation.Date?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            inputDataConfig: HealthLakeClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil,
            jobProgressReport: HealthLakeClientTypes.JobProgressReport? = nil,
            jobStatus: HealthLakeClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            submitTime: Foundation.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobOutputDataConfig = jobOutputDataConfig
            self.jobProgressReport = jobProgressReport
            self.jobStatus = jobStatus
            self.message = message
            self.submitTime = submitTime
        }
    }
}

public struct DescribeFHIRImportJobOutput: Swift.Sendable {
    /// The properties of the Import job request, including the ID, ARN, name, status of the job, and the progress report of the job.
    /// This member is required.
    public var importJobProperties: HealthLakeClientTypes.ImportJobProperties?

    public init(
        importJobProperties: HealthLakeClientTypes.ImportJobProperties? = nil
    )
    {
        self.importJobProperties = importJobProperties
    }
}

public struct ListFHIRDatastoresInput: Swift.Sendable {
    /// Lists all filters associated with a FHIR data store request.
    public var filter: HealthLakeClientTypes.DatastoreFilter?
    /// The maximum number of data stores returned in a single page of a ListFHIRDatastoresRequest call.
    public var maxResults: Swift.Int?
    /// Fetches the next page of data stores when results are paginated.
    public var nextToken: Swift.String?

    public init(
        filter: HealthLakeClientTypes.DatastoreFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFHIRDatastoresOutput: Swift.Sendable {
    /// All properties associated with the listed data stores.
    /// This member is required.
    public var datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]?
    /// Pagination token that can be used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datastorePropertiesList = datastorePropertiesList
        self.nextToken = nextToken
    }
}

public struct ListFHIRExportJobsInput: Swift.Sendable {
    /// This parameter limits the response to the export job with the specified data store ID.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// This parameter limits the response to the export job with the specified job name.
    public var jobName: Swift.String?
    /// This parameter limits the response to the export jobs with the specified job status.
    public var jobStatus: HealthLakeClientTypes.JobStatus?
    /// This parameter limits the number of results returned for a ListFHIRExportJobs to a maximum quantity specified by the user.
    public var maxResults: Swift.Int?
    /// A pagination token used to identify the next page of results to return for a ListFHIRExportJobs query.
    public var nextToken: Swift.String?
    /// This parameter limits the response to FHIR export jobs submitted after a user specified date.
    public var submittedAfter: Foundation.Date?
    /// This parameter limits the response to FHIR export jobs submitted before a user specified date.
    public var submittedBefore: Foundation.Date?

    public init(
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        submittedAfter: Foundation.Date? = nil,
        submittedBefore: Foundation.Date? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.submittedAfter = submittedAfter
        self.submittedBefore = submittedBefore
    }
}

public struct ListFHIRExportJobsOutput: Swift.Sendable {
    /// The properties of listed FHIR export jobs, including the ID, ARN, name, and the status of the job.
    /// This member is required.
    public var exportJobPropertiesList: [HealthLakeClientTypes.ExportJobProperties]?
    /// A pagination token used to identify the next page of results to return for a ListFHIRExportJobs query.
    public var nextToken: Swift.String?

    public init(
        exportJobPropertiesList: [HealthLakeClientTypes.ExportJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportJobPropertiesList = exportJobPropertiesList
        self.nextToken = nextToken
    }
}

public struct ListFHIRImportJobsInput: Swift.Sendable {
    /// This parameter limits the response to the import job with the specified data store ID.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// This parameter limits the response to the import job with the specified job name.
    public var jobName: Swift.String?
    /// This parameter limits the response to the import job with the specified job status.
    public var jobStatus: HealthLakeClientTypes.JobStatus?
    /// This parameter limits the number of results returned for a ListFHIRImportJobs to a maximum quantity specified by the user.
    public var maxResults: Swift.Int?
    /// A pagination token used to identify the next page of results to return for a ListFHIRImportJobs query.
    public var nextToken: Swift.String?
    /// This parameter limits the response to FHIR import jobs submitted after a user specified date.
    public var submittedAfter: Foundation.Date?
    /// This parameter limits the response to FHIR import jobs submitted before a user specified date.
    public var submittedBefore: Foundation.Date?

    public init(
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        submittedAfter: Foundation.Date? = nil,
        submittedBefore: Foundation.Date? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.submittedAfter = submittedAfter
        self.submittedBefore = submittedBefore
    }
}

public struct ListFHIRImportJobsOutput: Swift.Sendable {
    /// The properties of a listed FHIR import jobs, including the ID, ARN, name, the status of the job, and the progress report of the job.
    /// This member is required.
    public var importJobPropertiesList: [HealthLakeClientTypes.ImportJobProperties]?
    /// A pagination token used to identify the next page of results to return for a ListFHIRImportJobs query.
    public var nextToken: Swift.String?

    public init(
        importJobPropertiesList: [HealthLakeClientTypes.ImportJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importJobPropertiesList = importJobPropertiesList
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name(ARN) of the data store for which tags are being added.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Returns a list of tags associated with a data store.
    public var tags: [HealthLakeClientTypes.Tag]?

    public init(
        tags: [HealthLakeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct StartFHIRExportJobInput: Swift.Sendable {
    /// An optional user provided token used for ensuring idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name used during the initiation of the job.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The AWS generated ID for the data store from which files are being exported for an export job.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The user generated name for an export job.
    public var jobName: Swift.String?
    /// The output data configuration that was supplied when the export job was created.
    /// This member is required.
    public var outputDataConfig: HealthLakeClientTypes.OutputDataConfig?

    public init(
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
    }
}

public struct StartFHIRExportJobOutput: Swift.Sendable {
    /// The AWS generated ID for the data store from which files are being exported for an export job.
    public var datastoreId: Swift.String?
    /// The AWS generated ID for an export job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The status of a FHIR export job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, or FAILED.
    /// This member is required.
    public var jobStatus: HealthLakeClientTypes.JobStatus?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

public struct StartFHIRImportJobInput: Swift.Sendable {
    /// Optional user provided token used for ensuring idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) that gives AWS HealthLake access permission.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The AWS-generated data store ID.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The input properties of the FHIR Import job in the StartFHIRImport job request.
    /// This member is required.
    public var inputDataConfig: HealthLakeClientTypes.InputDataConfig?
    /// The name of the FHIR Import job in the StartFHIRImport job request.
    public var jobName: Swift.String?
    /// The output data configuration that was supplied when the export job was created.
    /// This member is required.
    public var jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig?

    public init(
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        inputDataConfig: HealthLakeClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.jobOutputDataConfig = jobOutputDataConfig
    }
}

public struct StartFHIRImportJobOutput: Swift.Sendable {
    /// The AWS-generated data store ID.
    public var datastoreId: Swift.String?
    /// The AWS-generated job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The status of an import job.
    /// This member is required.
    public var jobStatus: HealthLakeClientTypes.JobStatus?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name(ARN)that gives AWS HealthLake access to the data store which tags are being added to.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The user specified key and value pair tags being added to a data store.
    /// This member is required.
    public var tags: [HealthLakeClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [HealthLakeClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name(ARN) of the data store for which tags are being removed.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys for the tags to be removed from the HealthLake data store.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CreateFHIRDatastoreInput {

    static func urlPathProvider(_ value: CreateFHIRDatastoreInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteFHIRDatastoreInput {

    static func urlPathProvider(_ value: DeleteFHIRDatastoreInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFHIRDatastoreInput {

    static func urlPathProvider(_ value: DescribeFHIRDatastoreInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFHIRExportJobInput {

    static func urlPathProvider(_ value: DescribeFHIRExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFHIRImportJobInput {

    static func urlPathProvider(_ value: DescribeFHIRImportJobInput) -> Swift.String? {
        return "/"
    }
}

extension ListFHIRDatastoresInput {

    static func urlPathProvider(_ value: ListFHIRDatastoresInput) -> Swift.String? {
        return "/"
    }
}

extension ListFHIRExportJobsInput {

    static func urlPathProvider(_ value: ListFHIRExportJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListFHIRImportJobsInput {

    static func urlPathProvider(_ value: ListFHIRImportJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension StartFHIRExportJobInput {

    static func urlPathProvider(_ value: StartFHIRExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension StartFHIRImportJobInput {

    static func urlPathProvider(_ value: StartFHIRImportJobInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateFHIRDatastoreInput {

    static func write(value: CreateFHIRDatastoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DatastoreName"].write(value.datastoreName)
        try writer["DatastoreTypeVersion"].write(value.datastoreTypeVersion)
        try writer["IdentityProviderConfiguration"].write(value.identityProviderConfiguration, with: HealthLakeClientTypes.IdentityProviderConfiguration.write(value:to:))
        try writer["PreloadDataConfig"].write(value.preloadDataConfig, with: HealthLakeClientTypes.PreloadDataConfig.write(value:to:))
        try writer["SseConfiguration"].write(value.sseConfiguration, with: HealthLakeClientTypes.SseConfiguration.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: HealthLakeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteFHIRDatastoreInput {

    static func write(value: DeleteFHIRDatastoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatastoreId"].write(value.datastoreId)
    }
}

extension DescribeFHIRDatastoreInput {

    static func write(value: DescribeFHIRDatastoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatastoreId"].write(value.datastoreId)
    }
}

extension DescribeFHIRExportJobInput {

    static func write(value: DescribeFHIRExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatastoreId"].write(value.datastoreId)
        try writer["JobId"].write(value.jobId)
    }
}

extension DescribeFHIRImportJobInput {

    static func write(value: DescribeFHIRImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatastoreId"].write(value.datastoreId)
        try writer["JobId"].write(value.jobId)
    }
}

extension ListFHIRDatastoresInput {

    static func write(value: ListFHIRDatastoresInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: HealthLakeClientTypes.DatastoreFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListFHIRExportJobsInput {

    static func write(value: ListFHIRExportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatastoreId"].write(value.datastoreId)
        try writer["JobName"].write(value.jobName)
        try writer["JobStatus"].write(value.jobStatus)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SubmittedAfter"].writeTimestamp(value.submittedAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["SubmittedBefore"].writeTimestamp(value.submittedBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ListFHIRImportJobsInput {

    static func write(value: ListFHIRImportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatastoreId"].write(value.datastoreId)
        try writer["JobName"].write(value.jobName)
        try writer["JobStatus"].write(value.jobStatus)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SubmittedAfter"].writeTimestamp(value.submittedAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["SubmittedBefore"].writeTimestamp(value.submittedBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension StartFHIRExportJobInput {

    static func write(value: StartFHIRExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["DatastoreId"].write(value.datastoreId)
        try writer["JobName"].write(value.jobName)
        try writer["OutputDataConfig"].write(value.outputDataConfig, with: HealthLakeClientTypes.OutputDataConfig.write(value:to:))
    }
}

extension StartFHIRImportJobInput {

    static func write(value: StartFHIRImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["DatastoreId"].write(value.datastoreId)
        try writer["InputDataConfig"].write(value.inputDataConfig, with: HealthLakeClientTypes.InputDataConfig.write(value:to:))
        try writer["JobName"].write(value.jobName)
        try writer["JobOutputDataConfig"].write(value.jobOutputDataConfig, with: HealthLakeClientTypes.OutputDataConfig.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: HealthLakeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateFHIRDatastoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFHIRDatastoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFHIRDatastoreOutput()
        value.datastoreArn = try reader["DatastoreArn"].readIfPresent() ?? ""
        value.datastoreEndpoint = try reader["DatastoreEndpoint"].readIfPresent() ?? ""
        value.datastoreId = try reader["DatastoreId"].readIfPresent() ?? ""
        value.datastoreStatus = try reader["DatastoreStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteFHIRDatastoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFHIRDatastoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFHIRDatastoreOutput()
        value.datastoreArn = try reader["DatastoreArn"].readIfPresent() ?? ""
        value.datastoreEndpoint = try reader["DatastoreEndpoint"].readIfPresent() ?? ""
        value.datastoreId = try reader["DatastoreId"].readIfPresent() ?? ""
        value.datastoreStatus = try reader["DatastoreStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DescribeFHIRDatastoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFHIRDatastoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFHIRDatastoreOutput()
        value.datastoreProperties = try reader["DatastoreProperties"].readIfPresent(with: HealthLakeClientTypes.DatastoreProperties.read(from:))
        return value
    }
}

extension DescribeFHIRExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFHIRExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFHIRExportJobOutput()
        value.exportJobProperties = try reader["ExportJobProperties"].readIfPresent(with: HealthLakeClientTypes.ExportJobProperties.read(from:))
        return value
    }
}

extension DescribeFHIRImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFHIRImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFHIRImportJobOutput()
        value.importJobProperties = try reader["ImportJobProperties"].readIfPresent(with: HealthLakeClientTypes.ImportJobProperties.read(from:))
        return value
    }
}

extension ListFHIRDatastoresOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFHIRDatastoresOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFHIRDatastoresOutput()
        value.datastorePropertiesList = try reader["DatastorePropertiesList"].readListIfPresent(memberReadingClosure: HealthLakeClientTypes.DatastoreProperties.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFHIRExportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFHIRExportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFHIRExportJobsOutput()
        value.exportJobPropertiesList = try reader["ExportJobPropertiesList"].readListIfPresent(memberReadingClosure: HealthLakeClientTypes.ExportJobProperties.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFHIRImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFHIRImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFHIRImportJobsOutput()
        value.importJobPropertiesList = try reader["ImportJobPropertiesList"].readListIfPresent(memberReadingClosure: HealthLakeClientTypes.ImportJobProperties.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: HealthLakeClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartFHIRExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartFHIRExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartFHIRExportJobOutput()
        value.datastoreId = try reader["DatastoreId"].readIfPresent()
        value.jobId = try reader["JobId"].readIfPresent() ?? ""
        value.jobStatus = try reader["JobStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension StartFHIRImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartFHIRImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartFHIRImportJobOutput()
        value.datastoreId = try reader["DatastoreId"].readIfPresent()
        value.jobId = try reader["JobId"].readIfPresent() ?? ""
        value.jobStatus = try reader["JobStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum CreateFHIRDatastoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFHIRDatastoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFHIRDatastoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFHIRExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFHIRImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFHIRDatastoresOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFHIRExportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFHIRImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartFHIRExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartFHIRImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension HealthLakeClientTypes.DatastoreProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.DatastoreProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.DatastoreProperties()
        value.datastoreId = try reader["DatastoreId"].readIfPresent() ?? ""
        value.datastoreArn = try reader["DatastoreArn"].readIfPresent() ?? ""
        value.datastoreName = try reader["DatastoreName"].readIfPresent()
        value.datastoreStatus = try reader["DatastoreStatus"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.datastoreTypeVersion = try reader["DatastoreTypeVersion"].readIfPresent() ?? .sdkUnknown("")
        value.datastoreEndpoint = try reader["DatastoreEndpoint"].readIfPresent() ?? ""
        value.sseConfiguration = try reader["SseConfiguration"].readIfPresent(with: HealthLakeClientTypes.SseConfiguration.read(from:))
        value.preloadDataConfig = try reader["PreloadDataConfig"].readIfPresent(with: HealthLakeClientTypes.PreloadDataConfig.read(from:))
        value.identityProviderConfiguration = try reader["IdentityProviderConfiguration"].readIfPresent(with: HealthLakeClientTypes.IdentityProviderConfiguration.read(from:))
        value.errorCause = try reader["ErrorCause"].readIfPresent(with: HealthLakeClientTypes.ErrorCause.read(from:))
        return value
    }
}

extension HealthLakeClientTypes.ErrorCause {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.ErrorCause {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.ErrorCause()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.errorCategory = try reader["ErrorCategory"].readIfPresent()
        return value
    }
}

extension HealthLakeClientTypes.IdentityProviderConfiguration {

    static func write(value: HealthLakeClientTypes.IdentityProviderConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizationStrategy"].write(value.authorizationStrategy)
        try writer["FineGrainedAuthorizationEnabled"].write(value.fineGrainedAuthorizationEnabled)
        try writer["IdpLambdaArn"].write(value.idpLambdaArn)
        try writer["Metadata"].write(value.metadata)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.IdentityProviderConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.IdentityProviderConfiguration()
        value.authorizationStrategy = try reader["AuthorizationStrategy"].readIfPresent() ?? .sdkUnknown("")
        value.fineGrainedAuthorizationEnabled = try reader["FineGrainedAuthorizationEnabled"].readIfPresent() ?? false
        value.metadata = try reader["Metadata"].readIfPresent()
        value.idpLambdaArn = try reader["IdpLambdaArn"].readIfPresent()
        return value
    }
}

extension HealthLakeClientTypes.PreloadDataConfig {

    static func write(value: HealthLakeClientTypes.PreloadDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PreloadDataType"].write(value.preloadDataType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.PreloadDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.PreloadDataConfig()
        value.preloadDataType = try reader["PreloadDataType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension HealthLakeClientTypes.SseConfiguration {

    static func write(value: HealthLakeClientTypes.SseConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsEncryptionConfig"].write(value.kmsEncryptionConfig, with: HealthLakeClientTypes.KmsEncryptionConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.SseConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.SseConfiguration()
        value.kmsEncryptionConfig = try reader["KmsEncryptionConfig"].readIfPresent(with: HealthLakeClientTypes.KmsEncryptionConfig.read(from:))
        return value
    }
}

extension HealthLakeClientTypes.KmsEncryptionConfig {

    static func write(value: HealthLakeClientTypes.KmsEncryptionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CmkType"].write(value.cmkType)
        try writer["KmsKeyId"].write(value.kmsKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.KmsEncryptionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.KmsEncryptionConfig()
        value.cmkType = try reader["CmkType"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        return value
    }
}

extension HealthLakeClientTypes.ExportJobProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.ExportJobProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.ExportJobProperties()
        value.jobId = try reader["JobId"].readIfPresent() ?? ""
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobStatus = try reader["JobStatus"].readIfPresent() ?? .sdkUnknown("")
        value.submitTime = try reader["SubmitTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.datastoreId = try reader["DatastoreId"].readIfPresent() ?? ""
        value.outputDataConfig = try reader["OutputDataConfig"].readIfPresent(with: HealthLakeClientTypes.OutputDataConfig.read(from:))
        value.dataAccessRoleArn = try reader["DataAccessRoleArn"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension HealthLakeClientTypes.OutputDataConfig {

    static func write(value: HealthLakeClientTypes.OutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3configuration(s3configuration):
                try writer["S3Configuration"].write(s3configuration, with: HealthLakeClientTypes.S3Configuration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.OutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "S3Configuration":
                return .s3configuration(try reader["S3Configuration"].read(with: HealthLakeClientTypes.S3Configuration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension HealthLakeClientTypes.S3Configuration {

    static func write(value: HealthLakeClientTypes.S3Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["S3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.S3Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.S3Configuration()
        value.s3Uri = try reader["S3Uri"].readIfPresent() ?? ""
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent() ?? ""
        return value
    }
}

extension HealthLakeClientTypes.ImportJobProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.ImportJobProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.ImportJobProperties()
        value.jobId = try reader["JobId"].readIfPresent() ?? ""
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobStatus = try reader["JobStatus"].readIfPresent() ?? .sdkUnknown("")
        value.submitTime = try reader["SubmitTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.datastoreId = try reader["DatastoreId"].readIfPresent() ?? ""
        value.inputDataConfig = try reader["InputDataConfig"].readIfPresent(with: HealthLakeClientTypes.InputDataConfig.read(from:))
        value.jobOutputDataConfig = try reader["JobOutputDataConfig"].readIfPresent(with: HealthLakeClientTypes.OutputDataConfig.read(from:))
        value.jobProgressReport = try reader["JobProgressReport"].readIfPresent(with: HealthLakeClientTypes.JobProgressReport.read(from:))
        value.dataAccessRoleArn = try reader["DataAccessRoleArn"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension HealthLakeClientTypes.JobProgressReport {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.JobProgressReport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.JobProgressReport()
        value.totalNumberOfScannedFiles = try reader["TotalNumberOfScannedFiles"].readIfPresent()
        value.totalSizeOfScannedFilesInMB = try reader["TotalSizeOfScannedFilesInMB"].readIfPresent()
        value.totalNumberOfImportedFiles = try reader["TotalNumberOfImportedFiles"].readIfPresent()
        value.totalNumberOfResourcesScanned = try reader["TotalNumberOfResourcesScanned"].readIfPresent()
        value.totalNumberOfResourcesImported = try reader["TotalNumberOfResourcesImported"].readIfPresent()
        value.totalNumberOfResourcesWithCustomerError = try reader["TotalNumberOfResourcesWithCustomerError"].readIfPresent()
        value.totalNumberOfFilesReadWithCustomerError = try reader["TotalNumberOfFilesReadWithCustomerError"].readIfPresent()
        value.throughput = try reader["Throughput"].readIfPresent()
        return value
    }
}

extension HealthLakeClientTypes.InputDataConfig {

    static func write(value: HealthLakeClientTypes.InputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3uri(s3uri):
                try writer["S3Uri"].write(s3uri)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.InputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "S3Uri":
                return .s3uri(try reader["S3Uri"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension HealthLakeClientTypes.Tag {

    static func write(value: HealthLakeClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension HealthLakeClientTypes.DatastoreFilter {

    static func write(value: HealthLakeClientTypes.DatastoreFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatedAfter"].writeTimestamp(value.createdAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["CreatedBefore"].writeTimestamp(value.createdBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["DatastoreName"].write(value.datastoreName)
        try writer["DatastoreStatus"].write(value.datastoreStatus)
    }
}

public enum HealthLakeClientTypes {}
