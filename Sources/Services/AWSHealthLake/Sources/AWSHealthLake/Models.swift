//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// Access is denied. Your account is not authorized to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension HealthLakeClientTypes {

    public enum AuthorizationStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsAuth
        case smartv1
        case smartOnFhir
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationStrategy] {
            return [
                .awsAuth,
                .smartv1,
                .smartOnFhir
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsAuth: return "AWS_AUTH"
            case .smartv1: return "SMART_ON_FHIR_V1"
            case .smartOnFhir: return "SMART_ON_FHIR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthLakeClientTypes {

    public enum CmkType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aoCmk
        case cmCmk
        case sdkUnknown(Swift.String)

        public static var allCases: [CmkType] {
            return [
                .aoCmk,
                .cmCmk
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aoCmk: return "AWS_OWNED_KMS_KEY"
            case .cmCmk: return "CUSTOMER_MANAGED_KMS_KEY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The data store is in a transition state and the user requested action cannot be performed.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// An unknown internal error occurred in the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The user has exceeded their maximum number of allowed calls to the given API.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The user input parameter was invalid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension HealthLakeClientTypes {

    public enum FHIRVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case r4
        case sdkUnknown(Swift.String)

        public static var allCases: [FHIRVersion] {
            return [
                .r4
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .r4: return "R4"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthLakeClientTypes {

    /// The identity provider configuration selected when the data store was created.
    public struct IdentityProviderConfiguration: Swift.Sendable {
        /// The authorization strategy selected when the HealthLake data store is created. HealthLake provides support for both SMART on FHIR V1 and V2 as described below.
        ///
        /// * SMART_ON_FHIR_V1 – Support for only SMART on FHIR V1, which includes read (read/search) and write (create/update/delete) permissions.
        ///
        /// * SMART_ON_FHIR – Support for both SMART on FHIR V1 and V2, which includes create, read, update, delete, and search permissions.
        ///
        /// * AWS_AUTH – The default HealthLake authorization strategy; not affiliated with SMART on FHIR.
        /// This member is required.
        public var authorizationStrategy: HealthLakeClientTypes.AuthorizationStrategy?
        /// The parameter to enable SMART on FHIR fine-grained authorization for the data store.
        public var fineGrainedAuthorizationEnabled: Swift.Bool
        /// The Amazon Resource Name (ARN) of the Lambda function to use to decode the access token created by the authorization server.
        public var idpLambdaArn: Swift.String?
        /// The JSON metadata elements to use in your identity provider configuration. Required elements are listed based on the launch specification of the SMART application. For more information on all possible elements, see [Metadata](https://build.fhir.org/ig/HL7/smart-app-launch/conformance.html#metadata) in SMART's App Launch specification. authorization_endpoint: The URL to the OAuth2 authorization endpoint. grant_types_supported: An array of grant types that are supported at the token endpoint. You must provide at least one grant type option. Valid options are authorization_code and client_credentials. token_endpoint: The URL to the OAuth2 token endpoint. capabilities: An array of strings of the SMART capabilities that the authorization server supports. code_challenge_methods_supported: An array of strings of supported PKCE code challenge methods. You must include the S256 method in the array of PKCE code challenge methods.
        public var metadata: Swift.String?

        public init(
            authorizationStrategy: HealthLakeClientTypes.AuthorizationStrategy? = nil,
            fineGrainedAuthorizationEnabled: Swift.Bool = false,
            idpLambdaArn: Swift.String? = nil,
            metadata: Swift.String? = nil
        ) {
            self.authorizationStrategy = authorizationStrategy
            self.fineGrainedAuthorizationEnabled = fineGrainedAuthorizationEnabled
            self.idpLambdaArn = idpLambdaArn
            self.metadata = metadata
        }
    }
}

extension HealthLakeClientTypes {

    public enum PreloadDataType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case synthea
        case sdkUnknown(Swift.String)

        public static var allCases: [PreloadDataType] {
            return [
                .synthea
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .synthea: return "SYNTHEA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthLakeClientTypes {

    /// The input properties for the preloaded (Synthea) data store.
    public struct PreloadDataConfig: Swift.Sendable {
        /// The type of preloaded data. Only Synthea preloaded data is supported.
        /// This member is required.
        public var preloadDataType: HealthLakeClientTypes.PreloadDataType?

        public init(
            preloadDataType: HealthLakeClientTypes.PreloadDataType? = nil
        ) {
            self.preloadDataType = preloadDataType
        }
    }
}

extension HealthLakeClientTypes {

    /// The customer-managed-key (CMK) used when creating a data store. If a customer-owned key is not specified, an AWS-owned key is used for encryption.
    public struct KmsEncryptionConfig: Swift.Sendable {
        /// The type of customer-managed-key (CMK) used for encryption.
        /// This member is required.
        public var cmkType: HealthLakeClientTypes.CmkType?
        /// The Key Management Service (KMS) encryption key id/alias used to encrypt the data store contents at rest.
        public var kmsKeyId: Swift.String?

        public init(
            cmkType: HealthLakeClientTypes.CmkType? = nil,
            kmsKeyId: Swift.String? = nil
        ) {
            self.cmkType = cmkType
            self.kmsKeyId = kmsKeyId
        }
    }
}

extension HealthLakeClientTypes {

    /// The server-side encryption key configuration for a customer-provided encryption key.
    public struct SseConfiguration: Swift.Sendable {
        /// The Key Management Service (KMS) encryption configuration used to provide details for data encryption.
        /// This member is required.
        public var kmsEncryptionConfig: HealthLakeClientTypes.KmsEncryptionConfig?

        public init(
            kmsEncryptionConfig: HealthLakeClientTypes.KmsEncryptionConfig? = nil
        ) {
            self.kmsEncryptionConfig = kmsEncryptionConfig
        }
    }
}

extension HealthLakeClientTypes {

    /// A label consisting of a user-defined key and value. The form for tags is {"Key", "Value"}
    public struct Tag: Swift.Sendable {
        /// The key portion of a tag. Tag keys are case sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// The value portion of a tag. Tag values are case-sensitive.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateFHIRDatastoreInput: Swift.Sendable {
    /// An optional user-provided token to ensure API idempotency.
    public var clientToken: Swift.String?
    /// The data store name (user-generated).
    public var datastoreName: Swift.String?
    /// The FHIR release version supported by the data store. Current support is for version R4.
    /// This member is required.
    public var datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
    /// The identity provider configuration to use for the data store.
    public var identityProviderConfiguration: HealthLakeClientTypes.IdentityProviderConfiguration?
    /// An optional parameter to preload (import) open source Synthea FHIR data upon creation of the data store.
    public var preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?
    /// The server-side encryption key configuration for a customer-provided encryption key specified for creating a data store.
    public var sseConfiguration: HealthLakeClientTypes.SseConfiguration?
    /// The resource tags applied to a data store when it is created.
    public var tags: [HealthLakeClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        datastoreName: Swift.String? = nil,
        datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion? = nil,
        identityProviderConfiguration: HealthLakeClientTypes.IdentityProviderConfiguration? = nil,
        preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig? = nil,
        sseConfiguration: HealthLakeClientTypes.SseConfiguration? = nil,
        tags: [HealthLakeClientTypes.Tag]? = nil
    ) {
        self.clientToken = clientToken
        self.datastoreName = datastoreName
        self.datastoreTypeVersion = datastoreTypeVersion
        self.identityProviderConfiguration = identityProviderConfiguration
        self.preloadDataConfig = preloadDataConfig
        self.sseConfiguration = sseConfiguration
        self.tags = tags
    }
}

extension HealthLakeClientTypes {

    public enum DatastoreStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [DatastoreStatus] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleted,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFHIRDatastoreOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the data store.
    /// This member is required.
    public var datastoreArn: Swift.String?
    /// The AWS endpoint created for the data store.
    /// This member is required.
    public var datastoreEndpoint: Swift.String?
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The data store status.
    /// This member is required.
    public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

    public init(
        datastoreArn: Swift.String? = nil,
        datastoreEndpoint: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
    ) {
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

extension HealthLakeClientTypes {

    /// The filters applied to a data store query.
    public struct DatastoreFilter: Swift.Sendable {
        /// Filter to set cutoff dates for records. All data stores created after the specified date are included in the results.
        public var createdAfter: Foundation.Date?
        /// Filter to set cutoff dates for records. All data stores created before the specified date are included in the results.
        public var createdBefore: Foundation.Date?
        /// Filter data store results by name.
        public var datastoreName: Swift.String?
        /// Filter data store results by status.
        public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

        public init(
            createdAfter: Foundation.Date? = nil,
            createdBefore: Foundation.Date? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
        ) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
        }
    }
}

extension HealthLakeClientTypes {

    public enum ErrorCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nonRetryableError
        case retryableError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCategory] {
            return [
                .nonRetryableError,
                .retryableError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nonRetryableError: return "NON_RETRYABLE_ERROR"
            case .retryableError: return "RETRYABLE_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthLakeClientTypes {

    /// The error information for CreateFHIRDatastore and DeleteFHIRDatastore actions.
    public struct ErrorCause: Swift.Sendable {
        /// The error category for ErrorCause.
        public var errorCategory: HealthLakeClientTypes.ErrorCategory?
        /// The error message text for ErrorCause.
        public var errorMessage: Swift.String?

        public init(
            errorCategory: HealthLakeClientTypes.ErrorCategory? = nil,
            errorMessage: Swift.String? = nil
        ) {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
        }
    }
}

extension HealthLakeClientTypes {

    /// The data store properties.
    public struct DatastoreProperties: Swift.Sendable {
        /// The time the data store was created.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) used in the creation of the data store.
        /// This member is required.
        public var datastoreArn: Swift.String?
        /// The AWS endpoint for the data store.
        /// This member is required.
        public var datastoreEndpoint: Swift.String?
        /// The data store identifier.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The data store name.
        public var datastoreName: Swift.String?
        /// The data store status.
        /// This member is required.
        public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?
        /// The FHIR release version supported by the data store. Current support is for version R4.
        /// This member is required.
        public var datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
        /// The error cause for the current data store operation.
        public var errorCause: HealthLakeClientTypes.ErrorCause?
        /// The identity provider selected during data store creation.
        public var identityProviderConfiguration: HealthLakeClientTypes.IdentityProviderConfiguration?
        /// The preloaded Synthea data configuration for the data store.
        public var preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?
        /// The server-side encryption key configuration for a customer provided encryption key.
        public var sseConfiguration: HealthLakeClientTypes.SseConfiguration?

        public init(
            createdAt: Foundation.Date? = nil,
            datastoreArn: Swift.String? = nil,
            datastoreEndpoint: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil,
            datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion? = nil,
            errorCause: HealthLakeClientTypes.ErrorCause? = nil,
            identityProviderConfiguration: HealthLakeClientTypes.IdentityProviderConfiguration? = nil,
            preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig? = nil,
            sseConfiguration: HealthLakeClientTypes.SseConfiguration? = nil
        ) {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreEndpoint = datastoreEndpoint
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.datastoreTypeVersion = datastoreTypeVersion
            self.errorCause = errorCause
            self.identityProviderConfiguration = identityProviderConfiguration
            self.preloadDataConfig = preloadDataConfig
            self.sseConfiguration = sseConfiguration
        }
    }
}

/// The requested data store was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct DeleteFHIRDatastoreInput: Swift.Sendable {
    /// The AWS-generated identifier for the data store to be deleted.
    /// This member is required.
    public var datastoreId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil
    ) {
        self.datastoreId = datastoreId
    }
}

public struct DeleteFHIRDatastoreOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that grants access permission to AWS HealthLake.
    /// This member is required.
    public var datastoreArn: Swift.String?
    /// The AWS endpoint of the data store to be deleted.
    /// This member is required.
    public var datastoreEndpoint: Swift.String?
    /// The AWS-generated ID for the deleted data store.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The data store status.
    /// This member is required.
    public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

    public init(
        datastoreArn: Swift.String? = nil,
        datastoreEndpoint: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
    ) {
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

public struct DescribeFHIRDatastoreInput: Swift.Sendable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil
    ) {
        self.datastoreId = datastoreId
    }
}

public struct DescribeFHIRDatastoreOutput: Swift.Sendable {
    /// The data store properties.
    /// This member is required.
    public var datastoreProperties: HealthLakeClientTypes.DatastoreProperties?

    public init(
        datastoreProperties: HealthLakeClientTypes.DatastoreProperties? = nil
    ) {
        self.datastoreProperties = datastoreProperties
    }
}

public struct DescribeFHIRExportJobInput: Swift.Sendable {
    /// The data store identifier from which FHIR data is being exported from.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The export job identifier.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil
    ) {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

extension HealthLakeClientTypes {

    public enum JobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelCompleted
        case cancelFailed
        case cancelInProgress
        case cancelSubmitted
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case queued
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .cancelCompleted,
                .cancelFailed,
                .cancelInProgress,
                .cancelSubmitted,
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .queued,
                .submitted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelCompleted: return "CANCEL_COMPLETED"
            case .cancelFailed: return "CANCEL_FAILED"
            case .cancelInProgress: return "CANCEL_IN_PROGRESS"
            case .cancelSubmitted: return "CANCEL_SUBMITTED"
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthLakeClientTypes {

    /// The configuration of the S3 bucket for either an import or export job. This includes assigning access permissions.
    public struct S3Configuration: Swift.Sendable {
        /// The Key Management Service (KMS) key ID used to access the S3 bucket.
        /// This member is required.
        public var kmsKeyId: Swift.String?
        /// The S3Uri is the user-specified S3 location of the FHIR data to be imported into AWS HealthLake.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        ) {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }
    }
}

extension HealthLakeClientTypes {

    /// The output data configuration supplied when the export job was created.
    public enum OutputDataConfig: Swift.Sendable {
        /// The output data configuration supplied when the export job was created.
        case s3configuration(HealthLakeClientTypes.S3Configuration)
        case sdkUnknown(Swift.String)
    }
}

extension HealthLakeClientTypes {

    /// The properties of a FHIR export job.
    public struct ExportJobProperties: Swift.Sendable {
        /// The Amazon Resource Name (ARN) used during the initiation of the export job.
        public var dataAccessRoleArn: Swift.String?
        /// The data store identifier from which files are being exported.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The time the export job completed.
        public var endTime: Foundation.Date?
        /// The export job identifier.
        /// This member is required.
        public var jobId: Swift.String?
        /// The export job name.
        public var jobName: Swift.String?
        /// The export job status.
        /// This member is required.
        public var jobStatus: HealthLakeClientTypes.JobStatus?
        /// An explanation of any errors that might have occurred during the export job.
        public var message: Swift.String?
        /// The output data configuration supplied when the export job was created.
        /// This member is required.
        public var outputDataConfig: HealthLakeClientTypes.OutputDataConfig?
        /// The time the export job was initiated.
        /// This member is required.
        public var submitTime: Foundation.Date?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: HealthLakeClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            outputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil,
            submitTime: Foundation.Date? = nil
        ) {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.outputDataConfig = outputDataConfig
            self.submitTime = submitTime
        }
    }
}

public struct DescribeFHIRExportJobOutput: Swift.Sendable {
    /// The export job properties.
    /// This member is required.
    public var exportJobProperties: HealthLakeClientTypes.ExportJobProperties?

    public init(
        exportJobProperties: HealthLakeClientTypes.ExportJobProperties? = nil
    ) {
        self.exportJobProperties = exportJobProperties
    }
}

public struct DescribeFHIRImportJobInput: Swift.Sendable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The import job identifier.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil
    ) {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

extension HealthLakeClientTypes {

    /// The import job input properties.
    public enum InputDataConfig: Swift.Sendable {
        /// The S3Uri is the user-specified S3 location of the FHIR data to be imported into AWS HealthLake.
        case s3uri(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension HealthLakeClientTypes {

    /// The progress report for the import job.
    public struct JobProgressReport: Swift.Sendable {
        /// The transaction rate the import job is processed at.
        public var throughput: Swift.Double?
        /// The number of files that failed to be read from the S3 input bucket due to customer error.
        public var totalNumberOfFilesReadWithCustomerError: Swift.Int?
        /// The number of files imported.
        public var totalNumberOfImportedFiles: Swift.Int?
        /// The number of resources imported.
        public var totalNumberOfResourcesImported: Swift.Int?
        /// The number of resources scanned from the S3 input bucket.
        public var totalNumberOfResourcesScanned: Swift.Int?
        /// The number of resources that failed due to customer error.
        public var totalNumberOfResourcesWithCustomerError: Swift.Int?
        /// The number of files scanned from the S3 input bucket.
        public var totalNumberOfScannedFiles: Swift.Int?
        /// The size (in MB) of files scanned from the S3 input bucket.
        public var totalSizeOfScannedFilesInMB: Swift.Double?

        public init(
            throughput: Swift.Double? = nil,
            totalNumberOfFilesReadWithCustomerError: Swift.Int? = nil,
            totalNumberOfImportedFiles: Swift.Int? = nil,
            totalNumberOfResourcesImported: Swift.Int? = nil,
            totalNumberOfResourcesScanned: Swift.Int? = nil,
            totalNumberOfResourcesWithCustomerError: Swift.Int? = nil,
            totalNumberOfScannedFiles: Swift.Int? = nil,
            totalSizeOfScannedFilesInMB: Swift.Double? = nil
        ) {
            self.throughput = throughput
            self.totalNumberOfFilesReadWithCustomerError = totalNumberOfFilesReadWithCustomerError
            self.totalNumberOfImportedFiles = totalNumberOfImportedFiles
            self.totalNumberOfResourcesImported = totalNumberOfResourcesImported
            self.totalNumberOfResourcesScanned = totalNumberOfResourcesScanned
            self.totalNumberOfResourcesWithCustomerError = totalNumberOfResourcesWithCustomerError
            self.totalNumberOfScannedFiles = totalNumberOfScannedFiles
            self.totalSizeOfScannedFilesInMB = totalSizeOfScannedFilesInMB
        }
    }
}

extension HealthLakeClientTypes {

    public enum ValidationLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case minimal
        case strict
        case structureOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationLevel] {
            return [
                .minimal,
                .strict,
                .structureOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .minimal: return "minimal"
            case .strict: return "strict"
            case .structureOnly: return "structure-only"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthLakeClientTypes {

    /// The import job properties.
    public struct ImportJobProperties: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that grants AWS HealthLake access to the input data.
        public var dataAccessRoleArn: Swift.String?
        /// The data store identifier.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The time the import job was completed.
        public var endTime: Foundation.Date?
        /// The input data configuration supplied when the import job was created.
        /// This member is required.
        public var inputDataConfig: HealthLakeClientTypes.InputDataConfig?
        /// The import job identifier.
        /// This member is required.
        public var jobId: Swift.String?
        /// The import job name.
        public var jobName: Swift.String?
        /// The output data configuration supplied when the export job was created.
        public var jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig?
        /// Displays the progress of the import job, including total resources scanned, total resources imported, and total size of data imported.
        public var jobProgressReport: HealthLakeClientTypes.JobProgressReport?
        /// The import job status.
        /// This member is required.
        public var jobStatus: HealthLakeClientTypes.JobStatus?
        /// An explanation of any errors that might have occurred during the FHIR import job.
        public var message: Swift.String?
        /// The time the import job was submitted for processing.
        /// This member is required.
        public var submitTime: Foundation.Date?
        /// The validation level of the import job.
        public var validationLevel: HealthLakeClientTypes.ValidationLevel?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            inputDataConfig: HealthLakeClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil,
            jobProgressReport: HealthLakeClientTypes.JobProgressReport? = nil,
            jobStatus: HealthLakeClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            submitTime: Foundation.Date? = nil,
            validationLevel: HealthLakeClientTypes.ValidationLevel? = nil
        ) {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobOutputDataConfig = jobOutputDataConfig
            self.jobProgressReport = jobProgressReport
            self.jobStatus = jobStatus
            self.message = message
            self.submitTime = submitTime
            self.validationLevel = validationLevel
        }
    }
}

public struct DescribeFHIRImportJobOutput: Swift.Sendable {
    /// The import job properties.
    /// This member is required.
    public var importJobProperties: HealthLakeClientTypes.ImportJobProperties?

    public init(
        importJobProperties: HealthLakeClientTypes.ImportJobProperties? = nil
    ) {
        self.importJobProperties = importJobProperties
    }
}

public struct ListFHIRDatastoresInput: Swift.Sendable {
    /// List all filters associated with a FHIR data store request.
    public var filter: HealthLakeClientTypes.DatastoreFilter?
    /// The maximum number of data stores returned on a page.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of data stores when results are paginated.
    public var nextToken: Swift.String?

    public init(
        filter: HealthLakeClientTypes.DatastoreFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFHIRDatastoresOutput: Swift.Sendable {
    /// The properties associated with all listed data stores.
    /// This member is required.
    public var datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]?
    /// The pagination token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.datastorePropertiesList = datastorePropertiesList
        self.nextToken = nextToken
    }
}

public struct ListFHIRExportJobsInput: Swift.Sendable {
    /// Limits the response to the export job with the specified data store ID.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// Limits the response to the export job with the specified job name.
    public var jobName: Swift.String?
    /// Limits the response to export jobs with the specified job status.
    public var jobStatus: HealthLakeClientTypes.JobStatus?
    /// Limits the number of results returned for a ListFHIRExportJobs to a maximum quantity specified by the user.
    public var maxResults: Swift.Int?
    /// A pagination token used to identify the next page of results to return.
    public var nextToken: Swift.String?
    /// Limits the response to FHIR export jobs submitted after a user-specified date.
    public var submittedAfter: Foundation.Date?
    /// Limits the response to FHIR export jobs submitted before a user- specified date.
    public var submittedBefore: Foundation.Date?

    public init(
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        submittedAfter: Foundation.Date? = nil,
        submittedBefore: Foundation.Date? = nil
    ) {
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.submittedAfter = submittedAfter
        self.submittedBefore = submittedBefore
    }
}

public struct ListFHIRExportJobsOutput: Swift.Sendable {
    /// The properties of listed FHIR export jobs.
    /// This member is required.
    public var exportJobPropertiesList: [HealthLakeClientTypes.ExportJobProperties]?
    /// The pagination token used to identify the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        exportJobPropertiesList: [HealthLakeClientTypes.ExportJobProperties]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.exportJobPropertiesList = exportJobPropertiesList
        self.nextToken = nextToken
    }
}

public struct ListFHIRImportJobsInput: Swift.Sendable {
    /// Limits the response to the import job with the specified data store ID.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// Limits the response to the import job with the specified job name.
    public var jobName: Swift.String?
    /// Limits the response to the import job with the specified job status.
    public var jobStatus: HealthLakeClientTypes.JobStatus?
    /// Limits the number of results returned for ListFHIRImportJobs to a maximum quantity specified by the user.
    public var maxResults: Swift.Int?
    /// The pagination token used to identify the next page of results to return.
    public var nextToken: Swift.String?
    /// Limits the response to FHIR import jobs submitted after a user-specified date.
    public var submittedAfter: Foundation.Date?
    /// Limits the response to FHIR import jobs submitted before a user- specified date.
    public var submittedBefore: Foundation.Date?

    public init(
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        submittedAfter: Foundation.Date? = nil,
        submittedBefore: Foundation.Date? = nil
    ) {
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.submittedAfter = submittedAfter
        self.submittedBefore = submittedBefore
    }
}

public struct ListFHIRImportJobsOutput: Swift.Sendable {
    /// The properties for listed import jobs.
    /// This member is required.
    public var importJobPropertiesList: [HealthLakeClientTypes.ImportJobProperties]?
    /// The pagination token used to identify the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        importJobPropertiesList: [HealthLakeClientTypes.ImportJobProperties]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.importJobPropertiesList = importJobPropertiesList
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the data store to which tags are being added.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    ) {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Returns a list of tags associated with a data store.
    public var tags: [HealthLakeClientTypes.Tag]?

    public init(
        tags: [HealthLakeClientTypes.Tag]? = nil
    ) {
        self.tags = tags
    }
}

public struct StartFHIRExportJobInput: Swift.Sendable {
    /// An optional user provided token used for ensuring API idempotency.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) used during initiation of the export job.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The data store identifier from which files are being exported.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The export job name.
    public var jobName: Swift.String?
    /// The output data configuration supplied when the export job was started.
    /// This member is required.
    public var outputDataConfig: HealthLakeClientTypes.OutputDataConfig?

    public init(
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil
    ) {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
    }
}

public struct StartFHIRExportJobOutput: Swift.Sendable {
    /// The data store identifier from which files are being exported.
    public var datastoreId: Swift.String?
    /// The export job identifier.
    /// This member is required.
    public var jobId: Swift.String?
    /// The export job status.
    /// This member is required.
    public var jobStatus: HealthLakeClientTypes.JobStatus?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil
    ) {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

public struct StartFHIRImportJobInput: Swift.Sendable {
    /// The optional user-provided token used for ensuring API idempotency.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) that grants access permission to AWS HealthLake.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The input properties for the import job request.
    /// This member is required.
    public var inputDataConfig: HealthLakeClientTypes.InputDataConfig?
    /// The import job name.
    public var jobName: Swift.String?
    /// The output data configuration supplied when the export job was created.
    /// This member is required.
    public var jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig?
    /// The validation level of the import job.
    public var validationLevel: HealthLakeClientTypes.ValidationLevel?

    public init(
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        inputDataConfig: HealthLakeClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil,
        validationLevel: HealthLakeClientTypes.ValidationLevel? = nil
    ) {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.jobOutputDataConfig = jobOutputDataConfig
        self.validationLevel = validationLevel
    }
}

public struct StartFHIRImportJobOutput: Swift.Sendable {
    /// The data store identifier.
    public var datastoreId: Swift.String?
    /// The import job identifier.
    /// This member is required.
    public var jobId: Swift.String?
    /// The import job status.
    /// This member is required.
    public var jobStatus: HealthLakeClientTypes.JobStatus?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil
    ) {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that grants access to the data store tags are being added to.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The user-specified key and value pair tags being added to a data store.
    /// This member is required.
    public var tags: [HealthLakeClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [HealthLakeClientTypes.Tag]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the data store from which tags are being removed.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys for the tags to be removed from the data store.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CreateFHIRDatastoreInput {

    static func urlPathProvider(_ value: CreateFHIRDatastoreInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteFHIRDatastoreInput {

    static func urlPathProvider(_ value: DeleteFHIRDatastoreInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFHIRDatastoreInput {

    static func urlPathProvider(_ value: DescribeFHIRDatastoreInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFHIRExportJobInput {

    static func urlPathProvider(_ value: DescribeFHIRExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFHIRImportJobInput {

    static func urlPathProvider(_ value: DescribeFHIRImportJobInput) -> Swift.String? {
        return "/"
    }
}

extension ListFHIRDatastoresInput {

    static func urlPathProvider(_ value: ListFHIRDatastoresInput) -> Swift.String? {
        return "/"
    }
}

extension ListFHIRExportJobsInput {

    static func urlPathProvider(_ value: ListFHIRExportJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListFHIRImportJobsInput {

    static func urlPathProvider(_ value: ListFHIRImportJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension StartFHIRExportJobInput {

    static func urlPathProvider(_ value: StartFHIRExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension StartFHIRImportJobInput {

    static func urlPathProvider(_ value: StartFHIRImportJobInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateFHIRDatastoreInput {

    static func write(value: CreateFHIRDatastoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DatastoreName"].write(value.datastoreName)
        try writer["DatastoreTypeVersion"].write(value.datastoreTypeVersion)
        try writer["IdentityProviderConfiguration"].write(value.identityProviderConfiguration, with: HealthLakeClientTypes.IdentityProviderConfiguration.write(value:to:))
        try writer["PreloadDataConfig"].write(value.preloadDataConfig, with: HealthLakeClientTypes.PreloadDataConfig.write(value:to:))
        try writer["SseConfiguration"].write(value.sseConfiguration, with: HealthLakeClientTypes.SseConfiguration.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: HealthLakeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteFHIRDatastoreInput {

    static func write(value: DeleteFHIRDatastoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatastoreId"].write(value.datastoreId)
    }
}

extension DescribeFHIRDatastoreInput {

    static func write(value: DescribeFHIRDatastoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatastoreId"].write(value.datastoreId)
    }
}

extension DescribeFHIRExportJobInput {

    static func write(value: DescribeFHIRExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatastoreId"].write(value.datastoreId)
        try writer["JobId"].write(value.jobId)
    }
}

extension DescribeFHIRImportJobInput {

    static func write(value: DescribeFHIRImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatastoreId"].write(value.datastoreId)
        try writer["JobId"].write(value.jobId)
    }
}

extension ListFHIRDatastoresInput {

    static func write(value: ListFHIRDatastoresInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: HealthLakeClientTypes.DatastoreFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListFHIRExportJobsInput {

    static func write(value: ListFHIRExportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatastoreId"].write(value.datastoreId)
        try writer["JobName"].write(value.jobName)
        try writer["JobStatus"].write(value.jobStatus)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SubmittedAfter"].writeTimestamp(value.submittedAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["SubmittedBefore"].writeTimestamp(value.submittedBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ListFHIRImportJobsInput {

    static func write(value: ListFHIRImportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatastoreId"].write(value.datastoreId)
        try writer["JobName"].write(value.jobName)
        try writer["JobStatus"].write(value.jobStatus)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SubmittedAfter"].writeTimestamp(value.submittedAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["SubmittedBefore"].writeTimestamp(value.submittedBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension StartFHIRExportJobInput {

    static func write(value: StartFHIRExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["DatastoreId"].write(value.datastoreId)
        try writer["JobName"].write(value.jobName)
        try writer["OutputDataConfig"].write(value.outputDataConfig, with: HealthLakeClientTypes.OutputDataConfig.write(value:to:))
    }
}

extension StartFHIRImportJobInput {

    static func write(value: StartFHIRImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["DatastoreId"].write(value.datastoreId)
        try writer["InputDataConfig"].write(value.inputDataConfig, with: HealthLakeClientTypes.InputDataConfig.write(value:to:))
        try writer["JobName"].write(value.jobName)
        try writer["JobOutputDataConfig"].write(value.jobOutputDataConfig, with: HealthLakeClientTypes.OutputDataConfig.write(value:to:))
        try writer["ValidationLevel"].write(value.validationLevel)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: HealthLakeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateFHIRDatastoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFHIRDatastoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFHIRDatastoreOutput()
        value.datastoreArn = try reader["DatastoreArn"].readIfPresent() ?? ""
        value.datastoreEndpoint = try reader["DatastoreEndpoint"].readIfPresent() ?? ""
        value.datastoreId = try reader["DatastoreId"].readIfPresent() ?? ""
        value.datastoreStatus = try reader["DatastoreStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteFHIRDatastoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFHIRDatastoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFHIRDatastoreOutput()
        value.datastoreArn = try reader["DatastoreArn"].readIfPresent() ?? ""
        value.datastoreEndpoint = try reader["DatastoreEndpoint"].readIfPresent() ?? ""
        value.datastoreId = try reader["DatastoreId"].readIfPresent() ?? ""
        value.datastoreStatus = try reader["DatastoreStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DescribeFHIRDatastoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFHIRDatastoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFHIRDatastoreOutput()
        value.datastoreProperties = try reader["DatastoreProperties"].readIfPresent(with: HealthLakeClientTypes.DatastoreProperties.read(from:))
        return value
    }
}

extension DescribeFHIRExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFHIRExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFHIRExportJobOutput()
        value.exportJobProperties = try reader["ExportJobProperties"].readIfPresent(with: HealthLakeClientTypes.ExportJobProperties.read(from:))
        return value
    }
}

extension DescribeFHIRImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFHIRImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFHIRImportJobOutput()
        value.importJobProperties = try reader["ImportJobProperties"].readIfPresent(with: HealthLakeClientTypes.ImportJobProperties.read(from:))
        return value
    }
}

extension ListFHIRDatastoresOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFHIRDatastoresOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFHIRDatastoresOutput()
        value.datastorePropertiesList = try reader["DatastorePropertiesList"].readListIfPresent(memberReadingClosure: HealthLakeClientTypes.DatastoreProperties.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFHIRExportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFHIRExportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFHIRExportJobsOutput()
        value.exportJobPropertiesList = try reader["ExportJobPropertiesList"].readListIfPresent(memberReadingClosure: HealthLakeClientTypes.ExportJobProperties.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFHIRImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFHIRImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFHIRImportJobsOutput()
        value.importJobPropertiesList = try reader["ImportJobPropertiesList"].readListIfPresent(memberReadingClosure: HealthLakeClientTypes.ImportJobProperties.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: HealthLakeClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartFHIRExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartFHIRExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartFHIRExportJobOutput()
        value.datastoreId = try reader["DatastoreId"].readIfPresent()
        value.jobId = try reader["JobId"].readIfPresent() ?? ""
        value.jobStatus = try reader["JobStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension StartFHIRImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartFHIRImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartFHIRImportJobOutput()
        value.datastoreId = try reader["DatastoreId"].readIfPresent()
        value.jobId = try reader["JobId"].readIfPresent() ?? ""
        value.jobStatus = try reader["JobStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum CreateFHIRDatastoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFHIRDatastoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFHIRDatastoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFHIRExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFHIRImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFHIRDatastoresOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFHIRExportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFHIRImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartFHIRExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartFHIRImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension HealthLakeClientTypes.DatastoreFilter {

    static func write(value: HealthLakeClientTypes.DatastoreFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatedAfter"].writeTimestamp(value.createdAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["CreatedBefore"].writeTimestamp(value.createdBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["DatastoreName"].write(value.datastoreName)
        try writer["DatastoreStatus"].write(value.datastoreStatus)
    }
}

extension HealthLakeClientTypes.DatastoreProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.DatastoreProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.DatastoreProperties()
        value.datastoreId = try reader["DatastoreId"].readIfPresent() ?? ""
        value.datastoreArn = try reader["DatastoreArn"].readIfPresent() ?? ""
        value.datastoreName = try reader["DatastoreName"].readIfPresent()
        value.datastoreStatus = try reader["DatastoreStatus"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.datastoreTypeVersion = try reader["DatastoreTypeVersion"].readIfPresent() ?? .sdkUnknown("")
        value.datastoreEndpoint = try reader["DatastoreEndpoint"].readIfPresent() ?? ""
        value.sseConfiguration = try reader["SseConfiguration"].readIfPresent(with: HealthLakeClientTypes.SseConfiguration.read(from:))
        value.preloadDataConfig = try reader["PreloadDataConfig"].readIfPresent(with: HealthLakeClientTypes.PreloadDataConfig.read(from:))
        value.identityProviderConfiguration = try reader["IdentityProviderConfiguration"].readIfPresent(with: HealthLakeClientTypes.IdentityProviderConfiguration.read(from:))
        value.errorCause = try reader["ErrorCause"].readIfPresent(with: HealthLakeClientTypes.ErrorCause.read(from:))
        return value
    }
}

extension HealthLakeClientTypes.ErrorCause {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.ErrorCause {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.ErrorCause()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.errorCategory = try reader["ErrorCategory"].readIfPresent()
        return value
    }
}

extension HealthLakeClientTypes.ExportJobProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.ExportJobProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.ExportJobProperties()
        value.jobId = try reader["JobId"].readIfPresent() ?? ""
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobStatus = try reader["JobStatus"].readIfPresent() ?? .sdkUnknown("")
        value.submitTime = try reader["SubmitTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.datastoreId = try reader["DatastoreId"].readIfPresent() ?? ""
        value.outputDataConfig = try reader["OutputDataConfig"].readIfPresent(with: HealthLakeClientTypes.OutputDataConfig.read(from:))
        value.dataAccessRoleArn = try reader["DataAccessRoleArn"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension HealthLakeClientTypes.IdentityProviderConfiguration {

    static func write(value: HealthLakeClientTypes.IdentityProviderConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizationStrategy"].write(value.authorizationStrategy)
        try writer["FineGrainedAuthorizationEnabled"].write(value.fineGrainedAuthorizationEnabled)
        try writer["IdpLambdaArn"].write(value.idpLambdaArn)
        try writer["Metadata"].write(value.metadata)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.IdentityProviderConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.IdentityProviderConfiguration()
        value.authorizationStrategy = try reader["AuthorizationStrategy"].readIfPresent() ?? .sdkUnknown("")
        value.fineGrainedAuthorizationEnabled = try reader["FineGrainedAuthorizationEnabled"].readIfPresent() ?? false
        value.metadata = try reader["Metadata"].readIfPresent()
        value.idpLambdaArn = try reader["IdpLambdaArn"].readIfPresent()
        return value
    }
}

extension HealthLakeClientTypes.ImportJobProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.ImportJobProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.ImportJobProperties()
        value.jobId = try reader["JobId"].readIfPresent() ?? ""
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobStatus = try reader["JobStatus"].readIfPresent() ?? .sdkUnknown("")
        value.submitTime = try reader["SubmitTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.datastoreId = try reader["DatastoreId"].readIfPresent() ?? ""
        value.inputDataConfig = try reader["InputDataConfig"].readIfPresent(with: HealthLakeClientTypes.InputDataConfig.read(from:))
        value.jobOutputDataConfig = try reader["JobOutputDataConfig"].readIfPresent(with: HealthLakeClientTypes.OutputDataConfig.read(from:))
        value.jobProgressReport = try reader["JobProgressReport"].readIfPresent(with: HealthLakeClientTypes.JobProgressReport.read(from:))
        value.dataAccessRoleArn = try reader["DataAccessRoleArn"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.validationLevel = try reader["ValidationLevel"].readIfPresent()
        return value
    }
}

extension HealthLakeClientTypes.InputDataConfig {

    static func write(value: HealthLakeClientTypes.InputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3uri(s3uri):
                try writer["S3Uri"].write(s3uri)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.InputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "S3Uri":
                return .s3uri(try reader["S3Uri"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension HealthLakeClientTypes.JobProgressReport {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.JobProgressReport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.JobProgressReport()
        value.totalNumberOfScannedFiles = try reader["TotalNumberOfScannedFiles"].readIfPresent()
        value.totalSizeOfScannedFilesInMB = try reader["TotalSizeOfScannedFilesInMB"].readIfPresent()
        value.totalNumberOfImportedFiles = try reader["TotalNumberOfImportedFiles"].readIfPresent()
        value.totalNumberOfResourcesScanned = try reader["TotalNumberOfResourcesScanned"].readIfPresent()
        value.totalNumberOfResourcesImported = try reader["TotalNumberOfResourcesImported"].readIfPresent()
        value.totalNumberOfResourcesWithCustomerError = try reader["TotalNumberOfResourcesWithCustomerError"].readIfPresent()
        value.totalNumberOfFilesReadWithCustomerError = try reader["TotalNumberOfFilesReadWithCustomerError"].readIfPresent()
        value.throughput = try reader["Throughput"].readIfPresent()
        return value
    }
}

extension HealthLakeClientTypes.KmsEncryptionConfig {

    static func write(value: HealthLakeClientTypes.KmsEncryptionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CmkType"].write(value.cmkType)
        try writer["KmsKeyId"].write(value.kmsKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.KmsEncryptionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.KmsEncryptionConfig()
        value.cmkType = try reader["CmkType"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        return value
    }
}

extension HealthLakeClientTypes.OutputDataConfig {

    static func write(value: HealthLakeClientTypes.OutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3configuration(s3configuration):
                try writer["S3Configuration"].write(s3configuration, with: HealthLakeClientTypes.S3Configuration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.OutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "S3Configuration":
                return .s3configuration(try reader["S3Configuration"].read(with: HealthLakeClientTypes.S3Configuration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension HealthLakeClientTypes.PreloadDataConfig {

    static func write(value: HealthLakeClientTypes.PreloadDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PreloadDataType"].write(value.preloadDataType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.PreloadDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.PreloadDataConfig()
        value.preloadDataType = try reader["PreloadDataType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension HealthLakeClientTypes.S3Configuration {

    static func write(value: HealthLakeClientTypes.S3Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["S3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.S3Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.S3Configuration()
        value.s3Uri = try reader["S3Uri"].readIfPresent() ?? ""
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent() ?? ""
        return value
    }
}

extension HealthLakeClientTypes.SseConfiguration {

    static func write(value: HealthLakeClientTypes.SseConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsEncryptionConfig"].write(value.kmsEncryptionConfig, with: HealthLakeClientTypes.KmsEncryptionConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.SseConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.SseConfiguration()
        value.kmsEncryptionConfig = try reader["KmsEncryptionConfig"].readIfPresent(with: HealthLakeClientTypes.KmsEncryptionConfig.read(from:))
        return value
    }
}

extension HealthLakeClientTypes.Tag {

    static func write(value: HealthLakeClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> HealthLakeClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthLakeClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

public enum HealthLakeClientTypes {}
