// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EMRClient {
    /// Paginate over `[ListBootstrapActionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBootstrapActionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBootstrapActionsOutputResponse`
    public func listBootstrapActionsPaginated(input: ListBootstrapActionsInput) -> ClientRuntime.PaginatorSequence<ListBootstrapActionsInput, ListBootstrapActionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBootstrapActionsInput, ListBootstrapActionsOutputResponse>(input: input, inputKey: \ListBootstrapActionsInput.marker, outputKey: \ListBootstrapActionsOutputResponse.marker, paginationFunction: self.listBootstrapActions(input:))
    }
}

extension ListBootstrapActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBootstrapActionsInput {
        return ListBootstrapActionsInput(
            clusterId: self.clusterId,
            marker: token
        )}
}

extension PaginatorSequence where Input == ListBootstrapActionsInput, Output == ListBootstrapActionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listBootstrapActionsPaginated`
    /// to access the nested member `[EMRClientTypes.Command]`
    /// - Returns: `[EMRClientTypes.Command]`
    public func bootstrapActions() async throws -> [EMRClientTypes.Command] {
        return try await self.asyncCompactMap { item in item.bootstrapActions }
    }
}
extension EMRClient {
    /// Paginate over `[ListClustersOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListClustersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListClustersOutputResponse`
    public func listClustersPaginated(input: ListClustersInput) -> ClientRuntime.PaginatorSequence<ListClustersInput, ListClustersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListClustersInput, ListClustersOutputResponse>(input: input, inputKey: \ListClustersInput.marker, outputKey: \ListClustersOutputResponse.marker, paginationFunction: self.listClusters(input:))
    }
}

extension ListClustersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListClustersInput {
        return ListClustersInput(
            clusterStates: self.clusterStates,
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            marker: token
        )}
}

extension PaginatorSequence where Input == ListClustersInput, Output == ListClustersOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listClustersPaginated`
    /// to access the nested member `[EMRClientTypes.ClusterSummary]`
    /// - Returns: `[EMRClientTypes.ClusterSummary]`
    public func clusters() async throws -> [EMRClientTypes.ClusterSummary] {
        return try await self.asyncCompactMap { item in item.clusters }
    }
}
extension EMRClient {
    /// Paginate over `[ListInstanceFleetsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInstanceFleetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInstanceFleetsOutputResponse`
    public func listInstanceFleetsPaginated(input: ListInstanceFleetsInput) -> ClientRuntime.PaginatorSequence<ListInstanceFleetsInput, ListInstanceFleetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListInstanceFleetsInput, ListInstanceFleetsOutputResponse>(input: input, inputKey: \ListInstanceFleetsInput.marker, outputKey: \ListInstanceFleetsOutputResponse.marker, paginationFunction: self.listInstanceFleets(input:))
    }
}

extension ListInstanceFleetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstanceFleetsInput {
        return ListInstanceFleetsInput(
            clusterId: self.clusterId,
            marker: token
        )}
}

extension PaginatorSequence where Input == ListInstanceFleetsInput, Output == ListInstanceFleetsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listInstanceFleetsPaginated`
    /// to access the nested member `[EMRClientTypes.InstanceFleet]`
    /// - Returns: `[EMRClientTypes.InstanceFleet]`
    public func instanceFleets() async throws -> [EMRClientTypes.InstanceFleet] {
        return try await self.asyncCompactMap { item in item.instanceFleets }
    }
}
extension EMRClient {
    /// Paginate over `[ListInstanceGroupsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInstanceGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInstanceGroupsOutputResponse`
    public func listInstanceGroupsPaginated(input: ListInstanceGroupsInput) -> ClientRuntime.PaginatorSequence<ListInstanceGroupsInput, ListInstanceGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListInstanceGroupsInput, ListInstanceGroupsOutputResponse>(input: input, inputKey: \ListInstanceGroupsInput.marker, outputKey: \ListInstanceGroupsOutputResponse.marker, paginationFunction: self.listInstanceGroups(input:))
    }
}

extension ListInstanceGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstanceGroupsInput {
        return ListInstanceGroupsInput(
            clusterId: self.clusterId,
            marker: token
        )}
}

extension PaginatorSequence where Input == ListInstanceGroupsInput, Output == ListInstanceGroupsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listInstanceGroupsPaginated`
    /// to access the nested member `[EMRClientTypes.InstanceGroup]`
    /// - Returns: `[EMRClientTypes.InstanceGroup]`
    public func instanceGroups() async throws -> [EMRClientTypes.InstanceGroup] {
        return try await self.asyncCompactMap { item in item.instanceGroups }
    }
}
extension EMRClient {
    /// Paginate over `[ListInstancesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInstancesOutputResponse`
    public func listInstancesPaginated(input: ListInstancesInput) -> ClientRuntime.PaginatorSequence<ListInstancesInput, ListInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListInstancesInput, ListInstancesOutputResponse>(input: input, inputKey: \ListInstancesInput.marker, outputKey: \ListInstancesOutputResponse.marker, paginationFunction: self.listInstances(input:))
    }
}

extension ListInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstancesInput {
        return ListInstancesInput(
            clusterId: self.clusterId,
            instanceFleetId: self.instanceFleetId,
            instanceFleetType: self.instanceFleetType,
            instanceGroupId: self.instanceGroupId,
            instanceGroupTypes: self.instanceGroupTypes,
            instanceStates: self.instanceStates,
            marker: token
        )}
}

extension PaginatorSequence where Input == ListInstancesInput, Output == ListInstancesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listInstancesPaginated`
    /// to access the nested member `[EMRClientTypes.Instance]`
    /// - Returns: `[EMRClientTypes.Instance]`
    public func instances() async throws -> [EMRClientTypes.Instance] {
        return try await self.asyncCompactMap { item in item.instances }
    }
}
extension EMRClient {
    /// Paginate over `[ListNotebookExecutionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNotebookExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNotebookExecutionsOutputResponse`
    public func listNotebookExecutionsPaginated(input: ListNotebookExecutionsInput) -> ClientRuntime.PaginatorSequence<ListNotebookExecutionsInput, ListNotebookExecutionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListNotebookExecutionsInput, ListNotebookExecutionsOutputResponse>(input: input, inputKey: \ListNotebookExecutionsInput.marker, outputKey: \ListNotebookExecutionsOutputResponse.marker, paginationFunction: self.listNotebookExecutions(input:))
    }
}

extension ListNotebookExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNotebookExecutionsInput {
        return ListNotebookExecutionsInput(
            editorId: self.editorId,
            from: self.from,
            marker: token,
            status: self.status,
            to: self.to
        )}
}

extension PaginatorSequence where Input == ListNotebookExecutionsInput, Output == ListNotebookExecutionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listNotebookExecutionsPaginated`
    /// to access the nested member `[EMRClientTypes.NotebookExecutionSummary]`
    /// - Returns: `[EMRClientTypes.NotebookExecutionSummary]`
    public func notebookExecutions() async throws -> [EMRClientTypes.NotebookExecutionSummary] {
        return try await self.asyncCompactMap { item in item.notebookExecutions }
    }
}
extension EMRClient {
    /// Paginate over `[ListReleaseLabelsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListReleaseLabelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListReleaseLabelsOutputResponse`
    public func listReleaseLabelsPaginated(input: ListReleaseLabelsInput) -> ClientRuntime.PaginatorSequence<ListReleaseLabelsInput, ListReleaseLabelsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListReleaseLabelsInput, ListReleaseLabelsOutputResponse>(input: input, inputKey: \ListReleaseLabelsInput.nextToken, outputKey: \ListReleaseLabelsOutputResponse.nextToken, paginationFunction: self.listReleaseLabels(input:))
    }
}

extension ListReleaseLabelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReleaseLabelsInput {
        return ListReleaseLabelsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension EMRClient {
    /// Paginate over `[ListSecurityConfigurationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSecurityConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSecurityConfigurationsOutputResponse`
    public func listSecurityConfigurationsPaginated(input: ListSecurityConfigurationsInput) -> ClientRuntime.PaginatorSequence<ListSecurityConfigurationsInput, ListSecurityConfigurationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSecurityConfigurationsInput, ListSecurityConfigurationsOutputResponse>(input: input, inputKey: \ListSecurityConfigurationsInput.marker, outputKey: \ListSecurityConfigurationsOutputResponse.marker, paginationFunction: self.listSecurityConfigurations(input:))
    }
}

extension ListSecurityConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityConfigurationsInput {
        return ListSecurityConfigurationsInput(
            marker: token
        )}
}

extension PaginatorSequence where Input == ListSecurityConfigurationsInput, Output == ListSecurityConfigurationsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listSecurityConfigurationsPaginated`
    /// to access the nested member `[EMRClientTypes.SecurityConfigurationSummary]`
    /// - Returns: `[EMRClientTypes.SecurityConfigurationSummary]`
    public func securityConfigurations() async throws -> [EMRClientTypes.SecurityConfigurationSummary] {
        return try await self.asyncCompactMap { item in item.securityConfigurations }
    }
}
extension EMRClient {
    /// Paginate over `[ListStepsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListStepsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListStepsOutputResponse`
    public func listStepsPaginated(input: ListStepsInput) -> ClientRuntime.PaginatorSequence<ListStepsInput, ListStepsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListStepsInput, ListStepsOutputResponse>(input: input, inputKey: \ListStepsInput.marker, outputKey: \ListStepsOutputResponse.marker, paginationFunction: self.listSteps(input:))
    }
}

extension ListStepsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListStepsInput {
        return ListStepsInput(
            clusterId: self.clusterId,
            marker: token,
            stepIds: self.stepIds,
            stepStates: self.stepStates
        )}
}

extension PaginatorSequence where Input == ListStepsInput, Output == ListStepsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listStepsPaginated`
    /// to access the nested member `[EMRClientTypes.StepSummary]`
    /// - Returns: `[EMRClientTypes.StepSummary]`
    public func steps() async throws -> [EMRClientTypes.StepSummary] {
        return try await self.asyncCompactMap { item in item.steps }
    }
}
extension EMRClient {
    /// Paginate over `[ListStudiosOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListStudiosInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListStudiosOutputResponse`
    public func listStudiosPaginated(input: ListStudiosInput) -> ClientRuntime.PaginatorSequence<ListStudiosInput, ListStudiosOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListStudiosInput, ListStudiosOutputResponse>(input: input, inputKey: \ListStudiosInput.marker, outputKey: \ListStudiosOutputResponse.marker, paginationFunction: self.listStudios(input:))
    }
}

extension ListStudiosInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListStudiosInput {
        return ListStudiosInput(
            marker: token
        )}
}

extension PaginatorSequence where Input == ListStudiosInput, Output == ListStudiosOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listStudiosPaginated`
    /// to access the nested member `[EMRClientTypes.StudioSummary]`
    /// - Returns: `[EMRClientTypes.StudioSummary]`
    public func studios() async throws -> [EMRClientTypes.StudioSummary] {
        return try await self.asyncCompactMap { item in item.studios }
    }
}
extension EMRClient {
    /// Paginate over `[ListStudioSessionMappingsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListStudioSessionMappingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListStudioSessionMappingsOutputResponse`
    public func listStudioSessionMappingsPaginated(input: ListStudioSessionMappingsInput) -> ClientRuntime.PaginatorSequence<ListStudioSessionMappingsInput, ListStudioSessionMappingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListStudioSessionMappingsInput, ListStudioSessionMappingsOutputResponse>(input: input, inputKey: \ListStudioSessionMappingsInput.marker, outputKey: \ListStudioSessionMappingsOutputResponse.marker, paginationFunction: self.listStudioSessionMappings(input:))
    }
}

extension ListStudioSessionMappingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListStudioSessionMappingsInput {
        return ListStudioSessionMappingsInput(
            identityType: self.identityType,
            marker: token,
            studioId: self.studioId
        )}
}

extension PaginatorSequence where Input == ListStudioSessionMappingsInput, Output == ListStudioSessionMappingsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listStudioSessionMappingsPaginated`
    /// to access the nested member `[EMRClientTypes.SessionMappingSummary]`
    /// - Returns: `[EMRClientTypes.SessionMappingSummary]`
    public func sessionMappings() async throws -> [EMRClientTypes.SessionMappingSummary] {
        return try await self.asyncCompactMap { item in item.sessionMappings }
    }
}
