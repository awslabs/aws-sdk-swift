//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.optionalFormOf
@_spi(SmithyReadWrite) import func SmithyReadWrite.sparseFormOf
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// User does not have sufficient access to perform this action.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BackupSearchClientTypes {

    /// This filters by recovery points within the CreatedAfter and CreatedBefore timestamps.
    public struct BackupCreationTimeFilter: Swift.Sendable {
        /// This timestamp includes recovery points only created after the specified time.
        public var createdAfter: Foundation.Date?
        /// This timestamp includes recovery points only created before the specified time.
        public var createdBefore: Foundation.Date?

        public init(
            createdAfter: Foundation.Date? = nil,
            createdBefore: Foundation.Date? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
        }
    }
}

/// This exception occurs when a conflict with a previous successful operation is detected. This generally occurs when the previous operation did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Updating or deleting a resource can cause an inconsistent state.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Unexpected error during processing of request.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Retry the call after number of seconds.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The resource was not found for this request. Confirm the resource information, such as the ARN or type is correct and exists, then retry the request.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request references a resource which does not exist.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Hypothetical identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Hypothetical type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

public struct ListSearchJobBackupsInput: Swift.Sendable {
    /// The maximum number of resource list items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned backups included in a search job. For example, if a request is made to return MaxResults number of backups, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// The unique string that specifies the search job.
    /// This member is required.
    public var searchJobIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchJobIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchJobIdentifier = searchJobIdentifier
    }
}

extension BackupSearchClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ebs
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .ebs,
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ebs: return "EBS"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupSearchClientTypes {

    public enum SearchJobState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchJobState] {
            return [
                .completed,
                .failed,
                .running,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupSearchClientTypes {

    /// This contains the information about recovery points returned in results of a search job.
    public struct SearchJobBackupsResult: Swift.Sendable {
        /// This is the creation time of the backup (recovery point).
        public var backupCreationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) that uniquely identifies the backup resources.
        public var backupResourceArn: Swift.String?
        /// This is the creation time of the backup index.
        public var indexCreationTime: Foundation.Date?
        /// This is the resource type of the search.
        public var resourceType: BackupSearchClientTypes.ResourceType?
        /// The Amazon Resource Name (ARN) that uniquely identifies the source resources.
        public var sourceResourceArn: Swift.String?
        /// This is the status of the search job backup result.
        public var status: BackupSearchClientTypes.SearchJobState?
        /// This is the status message included with the results.
        public var statusMessage: Swift.String?

        public init(
            backupCreationTime: Foundation.Date? = nil,
            backupResourceArn: Swift.String? = nil,
            indexCreationTime: Foundation.Date? = nil,
            resourceType: BackupSearchClientTypes.ResourceType? = nil,
            sourceResourceArn: Swift.String? = nil,
            status: BackupSearchClientTypes.SearchJobState? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.backupCreationTime = backupCreationTime
            self.backupResourceArn = backupResourceArn
            self.indexCreationTime = indexCreationTime
            self.resourceType = resourceType
            self.sourceResourceArn = sourceResourceArn
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct ListSearchJobBackupsOutput: Swift.Sendable {
    /// The next item following a partial list of returned backups included in a search job. For example, if a request is made to return MaxResults number of backups, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// The recovery points returned the results of a search job
    /// This member is required.
    public var results: [BackupSearchClientTypes.SearchJobBackupsResult]?

    public init(
        nextToken: Swift.String? = nil,
        results: [BackupSearchClientTypes.SearchJobBackupsResult]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

public struct ListSearchJobResultsInput: Swift.Sendable {
    /// The maximum number of resource list items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned search job results. For example, if a request is made to return MaxResults number of search job results, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// The unique string that specifies the search job.
    /// This member is required.
    public var searchJobIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchJobIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchJobIdentifier = searchJobIdentifier
    }
}

extension BackupSearchClientTypes {

    /// These are the items returned in the results of a search of Amazon EBS backup metadata.
    public struct EBSResultItem: Swift.Sendable {
        /// These are one or more items in the results that match values for the Amazon Resource Name (ARN) of recovery points returned in a search of Amazon EBS backup metadata.
        public var backupResourceArn: Swift.String?
        /// The name of the backup vault.
        public var backupVaultName: Swift.String?
        /// These are one or more items in the results that match values for creation times returned in a search of Amazon EBS backup metadata.
        public var creationTime: Foundation.Date?
        /// These are one or more items in the results that match values for file paths returned in a search of Amazon EBS backup metadata.
        public var filePath: Swift.String?
        /// These are one or more items in the results that match values for file sizes returned in a search of Amazon EBS backup metadata.
        public var fileSize: Swift.Int?
        /// These are one or more items in the results that match values for file systems returned in a search of Amazon EBS backup metadata.
        public var fileSystemIdentifier: Swift.String?
        /// These are one or more items in the results that match values for Last Modified Time returned in a search of Amazon EBS backup metadata.
        public var lastModifiedTime: Foundation.Date?
        /// These are one or more items in the results that match values for the Amazon Resource Name (ARN) of source resources returned in a search of Amazon EBS backup metadata.
        public var sourceResourceArn: Swift.String?

        public init(
            backupResourceArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            filePath: Swift.String? = nil,
            fileSize: Swift.Int? = nil,
            fileSystemIdentifier: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            sourceResourceArn: Swift.String? = nil
        )
        {
            self.backupResourceArn = backupResourceArn
            self.backupVaultName = backupVaultName
            self.creationTime = creationTime
            self.filePath = filePath
            self.fileSize = fileSize
            self.fileSystemIdentifier = fileSystemIdentifier
            self.lastModifiedTime = lastModifiedTime
            self.sourceResourceArn = sourceResourceArn
        }
    }
}

extension BackupSearchClientTypes.EBSResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EBSResultItem(backupResourceArn: \(Swift.String(describing: backupResourceArn)), backupVaultName: \(Swift.String(describing: backupVaultName)), creationTime: \(Swift.String(describing: creationTime)), fileSize: \(Swift.String(describing: fileSize)), fileSystemIdentifier: \(Swift.String(describing: fileSystemIdentifier)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), sourceResourceArn: \(Swift.String(describing: sourceResourceArn)), filePath: \"CONTENT_REDACTED\")"}
}

extension BackupSearchClientTypes {

    /// These are the items returned in the results of a search of Amazon S3 backup metadata.
    public struct S3ResultItem: Swift.Sendable {
        /// These are items in the returned results that match recovery point Amazon Resource Names (ARN) input during a search of Amazon S3 backup metadata.
        public var backupResourceArn: Swift.String?
        /// The name of the backup vault.
        public var backupVaultName: Swift.String?
        /// These are one or more items in the returned results that match values for item creation time input during a search of Amazon S3 backup metadata.
        public var creationTime: Foundation.Date?
        /// These are one or more items in the returned results that match values for ETags input during a search of Amazon S3 backup metadata.
        public var eTag: Swift.String?
        /// This is one or more items returned in the results of a search of Amazon S3 backup metadata that match the values input for object key.
        public var objectKey: Swift.String?
        /// These are items in the returned results that match values for object size(s) input during a search of Amazon S3 backup metadata.
        public var objectSize: Swift.Int?
        /// These are items in the returned results that match source Amazon Resource Names (ARN) input during a search of Amazon S3 backup metadata.
        public var sourceResourceArn: Swift.String?
        /// These are one or more items in the returned results that match values for version IDs input during a search of Amazon S3 backup metadata.
        public var versionId: Swift.String?

        public init(
            backupResourceArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            eTag: Swift.String? = nil,
            objectKey: Swift.String? = nil,
            objectSize: Swift.Int? = nil,
            sourceResourceArn: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.backupResourceArn = backupResourceArn
            self.backupVaultName = backupVaultName
            self.creationTime = creationTime
            self.eTag = eTag
            self.objectKey = objectKey
            self.objectSize = objectSize
            self.sourceResourceArn = sourceResourceArn
            self.versionId = versionId
        }
    }
}

extension BackupSearchClientTypes.S3ResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3ResultItem(backupResourceArn: \(Swift.String(describing: backupResourceArn)), backupVaultName: \(Swift.String(describing: backupVaultName)), creationTime: \(Swift.String(describing: creationTime)), eTag: \(Swift.String(describing: eTag)), objectSize: \(Swift.String(describing: objectSize)), sourceResourceArn: \(Swift.String(describing: sourceResourceArn)), versionId: \(Swift.String(describing: versionId)), objectKey: \"CONTENT_REDACTED\")"}
}

extension BackupSearchClientTypes {

    /// This is an object representing the item returned in the results of a search for a specific resource type.
    public enum ResultItem: Swift.Sendable {
        /// These are items returned in the search results of an Amazon S3 search.
        case s3resultitem(BackupSearchClientTypes.S3ResultItem)
        /// These are items returned in the search results of an Amazon EBS search.
        case ebsresultitem(BackupSearchClientTypes.EBSResultItem)
        case sdkUnknown(Swift.String)
    }
}

public struct ListSearchJobResultsOutput: Swift.Sendable {
    /// The next item following a partial list of search job results. For example, if a request is made to return MaxResults number of backups, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// The results consist of either EBSResultItem or S3ResultItem.
    /// This member is required.
    public var results: [BackupSearchClientTypes.ResultItem]?

    public init(
        nextToken: Swift.String? = nil,
        results: [BackupSearchClientTypes.ResultItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the resource.>
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// List of tags returned by the operation.
    public var tags: [Swift.String: Swift.String?]?

    public init(
        tags: [Swift.String: Swift.String?]? = nil
    )
    {
        self.tags = tags
    }
}

extension BackupSearchClientTypes {

    /// This contains information results retrieved from a search job that may not have completed.
    public struct CurrentSearchProgress: Swift.Sendable {
        /// This number is the sum of all items that match the item filters in a search job in progress.
        public var itemsMatchedCount: Swift.Int?
        /// This number is the sum of all items that have been scanned so far during a search job.
        public var itemsScannedCount: Swift.Int?
        /// This number is the sum of all backups that have been scanned so far during a search job.
        public var recoveryPointsScannedCount: Swift.Int?

        public init(
            itemsMatchedCount: Swift.Int? = nil,
            itemsScannedCount: Swift.Int? = nil,
            recoveryPointsScannedCount: Swift.Int? = nil
        )
        {
            self.itemsMatchedCount = itemsMatchedCount
            self.itemsScannedCount = itemsScannedCount
            self.recoveryPointsScannedCount = recoveryPointsScannedCount
        }
    }
}

public struct GetSearchJobInput: Swift.Sendable {
    /// Required unique string that specifies the search job.
    /// This member is required.
    public var searchJobIdentifier: Swift.String?

    public init(
        searchJobIdentifier: Swift.String? = nil
    )
    {
        self.searchJobIdentifier = searchJobIdentifier
    }
}

extension BackupSearchClientTypes {

    public enum TimeConditionOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equalsTo
        case greaterThanEqualTo
        case lessThanEqualTo
        case notEqualsTo
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeConditionOperator] {
            return [
                .equalsTo,
                .greaterThanEqualTo,
                .lessThanEqualTo,
                .notEqualsTo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equalsTo: return "EQUALS_TO"
            case .greaterThanEqualTo: return "GREATER_THAN_EQUAL_TO"
            case .lessThanEqualTo: return "LESS_THAN_EQUAL_TO"
            case .notEqualsTo: return "NOT_EQUALS_TO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupSearchClientTypes {

    /// A time condition denotes a creation time, last modification time, or other time.
    public struct TimeCondition: Swift.Sendable {
        /// A string that defines what values will be returned. If this is included, avoid combinations of operators that will return all possible values. For example, including both EQUALS_TO and NOT_EQUALS_TO with a value of 4 will return all values.
        public var `operator`: BackupSearchClientTypes.TimeConditionOperator?
        /// This is the timestamp value of the time condition.
        /// This member is required.
        public var value: Foundation.Date?

        public init(
            `operator`: BackupSearchClientTypes.TimeConditionOperator? = .equalsTo,
            value: Foundation.Date? = nil
        )
        {
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension BackupSearchClientTypes {

    public enum StringConditionOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case beginsWith
        case contains
        case doesNotBeginWith
        case doesNotContain
        case doesNotEndWith
        case endsWith
        case equalsTo
        case notEqualsTo
        case sdkUnknown(Swift.String)

        public static var allCases: [StringConditionOperator] {
            return [
                .beginsWith,
                .contains,
                .doesNotBeginWith,
                .doesNotContain,
                .doesNotEndWith,
                .endsWith,
                .equalsTo,
                .notEqualsTo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case .contains: return "CONTAINS"
            case .doesNotBeginWith: return "DOES_NOT_BEGIN_WITH"
            case .doesNotContain: return "DOES_NOT_CONTAIN"
            case .doesNotEndWith: return "DOES_NOT_END_WITH"
            case .endsWith: return "ENDS_WITH"
            case .equalsTo: return "EQUALS_TO"
            case .notEqualsTo: return "NOT_EQUALS_TO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupSearchClientTypes {

    /// This contains the value of the string and can contain one or more operators.
    public struct StringCondition: Swift.Sendable {
        /// A string that defines what values will be returned. If this is included, avoid combinations of operators that will return all possible values. For example, including both EQUALS_TO and NOT_EQUALS_TO with a value of 4 will return all values.
        public var `operator`: BackupSearchClientTypes.StringConditionOperator?
        /// The value of the string.
        /// This member is required.
        public var value: Swift.String?

        public init(
            `operator`: BackupSearchClientTypes.StringConditionOperator? = .equalsTo,
            value: Swift.String? = nil
        )
        {
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension BackupSearchClientTypes {

    public enum LongConditionOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equalsTo
        case greaterThanEqualTo
        case lessThanEqualTo
        case notEqualsTo
        case sdkUnknown(Swift.String)

        public static var allCases: [LongConditionOperator] {
            return [
                .equalsTo,
                .greaterThanEqualTo,
                .lessThanEqualTo,
                .notEqualsTo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equalsTo: return "EQUALS_TO"
            case .greaterThanEqualTo: return "GREATER_THAN_EQUAL_TO"
            case .lessThanEqualTo: return "LESS_THAN_EQUAL_TO"
            case .notEqualsTo: return "NOT_EQUALS_TO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupSearchClientTypes {

    /// The long condition contains a Value and can optionally contain an Operator.
    public struct LongCondition: Swift.Sendable {
        /// A string that defines what values will be returned. If this is included, avoid combinations of operators that will return all possible values. For example, including both EQUALS_TO and NOT_EQUALS_TO with a value of 4 will return all values.
        public var `operator`: BackupSearchClientTypes.LongConditionOperator?
        /// The value of an item included in one of the search item filters.
        /// This member is required.
        public var value: Swift.Int?

        public init(
            `operator`: BackupSearchClientTypes.LongConditionOperator? = .equalsTo,
            value: Swift.Int? = nil
        )
        {
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension BackupSearchClientTypes {

    /// This contains arrays of objects, which may include CreationTimes time condition objects, FilePaths string objects, LastModificationTimes time condition objects,
    public struct EBSItemFilter: Swift.Sendable {
        /// You can include 1 to 10 values. If one is included, the results will return only items that match. If more than one is included, the results will return all items that match any of the included values.
        public var creationTimes: [BackupSearchClientTypes.TimeCondition]?
        /// You can include 1 to 10 values. If one file path is included, the results will return only items that match the file path. If more than one file path is included, the results will return all items that match any of the file paths.
        public var filePaths: [BackupSearchClientTypes.StringCondition]?
        /// You can include 1 to 10 values. If one is included, the results will return only items that match. If more than one is included, the results will return all items that match any of the included values.
        public var lastModificationTimes: [BackupSearchClientTypes.TimeCondition]?
        /// You can include 1 to 10 values. If one is included, the results will return only items that match. If more than one is included, the results will return all items that match any of the included values.
        public var sizes: [BackupSearchClientTypes.LongCondition]?

        public init(
            creationTimes: [BackupSearchClientTypes.TimeCondition]? = nil,
            filePaths: [BackupSearchClientTypes.StringCondition]? = nil,
            lastModificationTimes: [BackupSearchClientTypes.TimeCondition]? = nil,
            sizes: [BackupSearchClientTypes.LongCondition]? = nil
        )
        {
            self.creationTimes = creationTimes
            self.filePaths = filePaths
            self.lastModificationTimes = lastModificationTimes
            self.sizes = sizes
        }
    }
}

extension BackupSearchClientTypes {

    /// This contains arrays of objects, which may include ObjectKeys, Sizes, CreationTimes, VersionIds, and/or Etags.
    public struct S3ItemFilter: Swift.Sendable {
        /// You can include 1 to 10 values. If one value is included, the results will return only items that match the value. If more than one value is included, the results will return all items that match any of the values.
        public var creationTimes: [BackupSearchClientTypes.TimeCondition]?
        /// You can include 1 to 10 values. If one value is included, the results will return only items that match the value. If more than one value is included, the results will return all items that match any of the values.
        public var eTags: [BackupSearchClientTypes.StringCondition]?
        /// You can include 1 to 10 values. If one value is included, the results will return only items that match the value. If more than one value is included, the results will return all items that match any of the values.
        public var objectKeys: [BackupSearchClientTypes.StringCondition]?
        /// You can include 1 to 10 values. If one value is included, the results will return only items that match the value. If more than one value is included, the results will return all items that match any of the values.
        public var sizes: [BackupSearchClientTypes.LongCondition]?
        /// You can include 1 to 10 values. If one value is included, the results will return only items that match the value. If more than one value is included, the results will return all items that match any of the values.
        public var versionIds: [BackupSearchClientTypes.StringCondition]?

        public init(
            creationTimes: [BackupSearchClientTypes.TimeCondition]? = nil,
            eTags: [BackupSearchClientTypes.StringCondition]? = nil,
            objectKeys: [BackupSearchClientTypes.StringCondition]? = nil,
            sizes: [BackupSearchClientTypes.LongCondition]? = nil,
            versionIds: [BackupSearchClientTypes.StringCondition]? = nil
        )
        {
            self.creationTimes = creationTimes
            self.eTags = eTags
            self.objectKeys = objectKeys
            self.sizes = sizes
            self.versionIds = versionIds
        }
    }
}

extension BackupSearchClientTypes {

    /// Item Filters represent all input item properties specified when the search was created. Contains either EBSItemFilters or S3ItemFilters
    public struct ItemFilters: Swift.Sendable {
        /// This array can contain CreationTimes, FilePaths, LastModificationTimes, or Sizes objects.
        public var ebsItemFilters: [BackupSearchClientTypes.EBSItemFilter]?
        /// This array can contain CreationTimes, ETags, ObjectKeys, Sizes, or VersionIds objects.
        public var s3ItemFilters: [BackupSearchClientTypes.S3ItemFilter]?

        public init(
            ebsItemFilters: [BackupSearchClientTypes.EBSItemFilter]? = nil,
            s3ItemFilters: [BackupSearchClientTypes.S3ItemFilter]? = nil
        )
        {
            self.ebsItemFilters = ebsItemFilters
            self.s3ItemFilters = s3ItemFilters
        }
    }
}

extension BackupSearchClientTypes {

    /// The search scope is all backup properties input into a search.
    public struct SearchScope: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that uniquely identifies the backup resources.
        public var backupResourceArns: [Swift.String]?
        /// This is the time a backup resource was created.
        public var backupResourceCreationTime: BackupSearchClientTypes.BackupCreationTimeFilter?
        /// These are one or more tags on the backup (recovery point).
        public var backupResourceTags: [Swift.String: Swift.String?]?
        /// The resource types included in a search. Eligible resource types include S3 and EBS.
        /// This member is required.
        public var backupResourceTypes: [BackupSearchClientTypes.ResourceType]?
        /// The Amazon Resource Name (ARN) that uniquely identifies the source resources.
        public var sourceResourceArns: [Swift.String]?

        public init(
            backupResourceArns: [Swift.String]? = nil,
            backupResourceCreationTime: BackupSearchClientTypes.BackupCreationTimeFilter? = nil,
            backupResourceTags: [Swift.String: Swift.String?]? = nil,
            backupResourceTypes: [BackupSearchClientTypes.ResourceType]? = nil,
            sourceResourceArns: [Swift.String]? = nil
        )
        {
            self.backupResourceArns = backupResourceArns
            self.backupResourceCreationTime = backupResourceCreationTime
            self.backupResourceTags = backupResourceTags
            self.backupResourceTypes = backupResourceTypes
            self.sourceResourceArns = sourceResourceArns
        }
    }
}

extension BackupSearchClientTypes {

    /// The summary of the specified search job scope, including:
    ///
    /// * TotalBackupsToScanCount, the number of recovery points returned by the search.
    ///
    /// * TotalItemsToScanCount, the number of items returned by the search.
    public struct SearchScopeSummary: Swift.Sendable {
        /// This is the count of the total number of items that will be scanned in a search.
        public var totalItemsToScanCount: Swift.Int?
        /// This is the count of the total number of backups that will be scanned in a search.
        public var totalRecoveryPointsToScanCount: Swift.Int?

        public init(
            totalItemsToScanCount: Swift.Int? = nil,
            totalRecoveryPointsToScanCount: Swift.Int? = nil
        )
        {
            self.totalItemsToScanCount = totalItemsToScanCount
            self.totalRecoveryPointsToScanCount = totalRecoveryPointsToScanCount
        }
    }
}

public struct GetSearchJobOutput: Swift.Sendable {
    /// The date and time that a search job completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var completionTime: Foundation.Date?
    /// The date and time that a search job was created, in Unix format and Coordinated Universal Time (UTC). The value of CompletionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// Returns numbers representing BackupsScannedCount, ItemsScanned, and ItemsMatched.
    public var currentSearchProgress: BackupSearchClientTypes.CurrentSearchProgress?
    /// The encryption key for the specified search job. Example: arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    public var encryptionKeyArn: Swift.String?
    /// Item Filters represent all input item properties specified when the search was created.
    /// This member is required.
    public var itemFilters: BackupSearchClientTypes.ItemFilters?
    /// Returned name of the specified search job.
    public var name: Swift.String?
    /// The unique string that identifies the Amazon Resource Name (ARN) of the specified search job.
    /// This member is required.
    public var searchJobArn: Swift.String?
    /// The unique string that identifies the specified search job.
    /// This member is required.
    public var searchJobIdentifier: Swift.String?
    /// The search scope is all backup properties input into a search.
    /// This member is required.
    public var searchScope: BackupSearchClientTypes.SearchScope?
    /// Returned summary of the specified search job scope, including:
    ///
    /// * TotalBackupsToScanCount, the number of recovery points returned by the search.
    ///
    /// * TotalItemsToScanCount, the number of items returned by the search.
    public var searchScopeSummary: BackupSearchClientTypes.SearchScopeSummary?
    /// The current status of the specified search job. A search job may have one of the following statuses: RUNNING; COMPLETED; STOPPED; FAILED; TIMED_OUT; or EXPIRED .
    /// This member is required.
    public var status: BackupSearchClientTypes.SearchJobState?
    /// A status message will be returned for either a earch job with a status of ERRORED or a status of COMPLETED jobs with issues. For example, a message may say that a search contained recovery points unable to be scanned because of a permissions issue.
    public var statusMessage: Swift.String?

    public init(
        completionTime: Foundation.Date? = nil,
        creationTime: Foundation.Date? = nil,
        currentSearchProgress: BackupSearchClientTypes.CurrentSearchProgress? = nil,
        encryptionKeyArn: Swift.String? = nil,
        itemFilters: BackupSearchClientTypes.ItemFilters? = nil,
        name: Swift.String? = nil,
        searchJobArn: Swift.String? = nil,
        searchJobIdentifier: Swift.String? = nil,
        searchScope: BackupSearchClientTypes.SearchScope? = nil,
        searchScopeSummary: BackupSearchClientTypes.SearchScopeSummary? = nil,
        status: BackupSearchClientTypes.SearchJobState? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.currentSearchProgress = currentSearchProgress
        self.encryptionKeyArn = encryptionKeyArn
        self.itemFilters = itemFilters
        self.name = name
        self.searchJobArn = searchJobArn
        self.searchJobIdentifier = searchJobIdentifier
        self.searchScope = searchScope
        self.searchScopeSummary = searchScopeSummary
        self.status = status
        self.statusMessage = statusMessage
    }
}

public struct ListSearchJobsInput: Swift.Sendable {
    /// Include this parameter to filter list by search job status.
    public var byStatus: BackupSearchClientTypes.SearchJobState?
    /// The maximum number of resource list items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned search jobs. For example, if a request is made to return MaxResults number of backups, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        byStatus: BackupSearchClientTypes.SearchJobState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byStatus = byStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BackupSearchClientTypes {

    /// This is information pertaining to a search job.
    public struct SearchJobSummary: Swift.Sendable {
        /// This is the completion time of the search job.
        public var completionTime: Foundation.Date?
        /// This is the creation time of the search job.
        public var creationTime: Foundation.Date?
        /// This is the name of the search job.
        public var name: Swift.String?
        /// The unique string that identifies the Amazon Resource Name (ARN) of the specified search job.
        public var searchJobArn: Swift.String?
        /// The unique string that specifies the search job.
        public var searchJobIdentifier: Swift.String?
        /// Returned summary of the specified search job scope, including:
        ///
        /// * TotalBackupsToScanCount, the number of recovery points returned by the search.
        ///
        /// * TotalItemsToScanCount, the number of items returned by the search.
        public var searchScopeSummary: BackupSearchClientTypes.SearchScopeSummary?
        /// This is the status of the search job.
        public var status: BackupSearchClientTypes.SearchJobState?
        /// A status message will be returned for either a earch job with a status of ERRORED or a status of COMPLETED jobs with issues. For example, a message may say that a search contained recovery points unable to be scanned because of a permissions issue.
        public var statusMessage: Swift.String?

        public init(
            completionTime: Foundation.Date? = nil,
            creationTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            searchJobArn: Swift.String? = nil,
            searchJobIdentifier: Swift.String? = nil,
            searchScopeSummary: BackupSearchClientTypes.SearchScopeSummary? = nil,
            status: BackupSearchClientTypes.SearchJobState? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.name = name
            self.searchJobArn = searchJobArn
            self.searchJobIdentifier = searchJobIdentifier
            self.searchScopeSummary = searchScopeSummary
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct ListSearchJobsOutput: Swift.Sendable {
    /// The next item following a partial list of returned backups included in a search job. For example, if a request is made to return MaxResults number of backups, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// The search jobs among the list, with details of the returned search jobs.
    /// This member is required.
    public var searchJobs: [BackupSearchClientTypes.SearchJobSummary]?

    public init(
        nextToken: Swift.String? = nil,
        searchJobs: [BackupSearchClientTypes.SearchJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.searchJobs = searchJobs
    }
}

/// The request denied due to exceeding the quota limits permitted.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This request was not successful due to a service quota exceeding limits.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// This is the code specific to the quota type.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// This is the code unique to the originating service with the quota.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

public struct StartSearchJobInput: Swift.Sendable {
    /// Include this parameter to allow multiple identical calls for idempotency. A client token is valid for 8 hours after the first request that uses it is completed. After this time, any request with the same token is treated as a new request.
    public var clientToken: Swift.String?
    /// The encryption key for the specified search job.
    public var encryptionKeyArn: Swift.String?
    /// Item Filters represent all input item properties specified when the search was created. Contains either EBSItemFilters or S3ItemFilters
    public var itemFilters: BackupSearchClientTypes.ItemFilters?
    /// Include alphanumeric characters to create a name for this search job.
    public var name: Swift.String?
    /// This object can contain BackupResourceTypes, BackupResourceArns, BackupResourceCreationTime, BackupResourceTags, and SourceResourceArns to filter the recovery points returned by the search job.
    /// This member is required.
    public var searchScope: BackupSearchClientTypes.SearchScope?
    /// List of tags returned by the operation.
    public var tags: [Swift.String: Swift.String?]?

    public init(
        clientToken: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil,
        itemFilters: BackupSearchClientTypes.ItemFilters? = nil,
        name: Swift.String? = nil,
        searchScope: BackupSearchClientTypes.SearchScope? = nil,
        tags: [Swift.String: Swift.String?]? = nil
    )
    {
        self.clientToken = clientToken
        self.encryptionKeyArn = encryptionKeyArn
        self.itemFilters = itemFilters
        self.name = name
        self.searchScope = searchScope
        self.tags = tags
    }
}

public struct StartSearchJobOutput: Swift.Sendable {
    /// The date and time that a job was created, in Unix format and Coordinated Universal Time (UTC). The value of CompletionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationTime: Foundation.Date?
    /// The unique string that identifies the Amazon Resource Name (ARN) of the specified search job.
    public var searchJobArn: Swift.String?
    /// The unique string that specifies the search job.
    public var searchJobIdentifier: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        searchJobArn: Swift.String? = nil,
        searchJobIdentifier: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.searchJobArn = searchJobArn
        self.searchJobIdentifier = searchJobIdentifier
    }
}

public struct StopSearchJobInput: Swift.Sendable {
    /// The unique string that specifies the search job.
    /// This member is required.
    public var searchJobIdentifier: Swift.String?

    public init(
        searchJobIdentifier: Swift.String? = nil
    )
    {
        self.searchJobIdentifier = searchJobIdentifier
    }
}

public struct StopSearchJobOutput: Swift.Sendable {

    public init() { }
}

extension BackupSearchClientTypes {

    public enum ExportJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportJobStatus] {
            return [
                .completed,
                .failed,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupSearchClientTypes {

    /// This specification contains a required string of the destination bucket; optionally, you can include the destination prefix.
    public struct S3ExportSpecification: Swift.Sendable {
        /// This specifies the destination Amazon S3 bucket for the export job.
        /// This member is required.
        public var destinationBucket: Swift.String?
        /// This specifies the prefix for the destination Amazon S3 bucket for the export job.
        public var destinationPrefix: Swift.String?

        public init(
            destinationBucket: Swift.String? = nil,
            destinationPrefix: Swift.String? = nil
        )
        {
            self.destinationBucket = destinationBucket
            self.destinationPrefix = destinationPrefix
        }
    }
}

extension BackupSearchClientTypes {

    /// This contains the export specification object.
    public enum ExportSpecification: Swift.Sendable {
        /// This specifies the destination Amazon S3 bucket for the export job. And, if included, it also specifies the destination prefix.
        case s3exportspecification(BackupSearchClientTypes.S3ExportSpecification)
        case sdkUnknown(Swift.String)
    }
}

public struct GetSearchResultExportJobInput: Swift.Sendable {
    /// This is the unique string that identifies a specific export job. Required for this operation.
    /// This member is required.
    public var exportJobIdentifier: Swift.String?

    public init(
        exportJobIdentifier: Swift.String? = nil
    )
    {
        self.exportJobIdentifier = exportJobIdentifier
    }
}

public struct GetSearchResultExportJobOutput: Swift.Sendable {
    /// The date and time that an export job completed, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var completionTime: Foundation.Date?
    /// The date and time that an export job was created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationTime: Foundation.Date?
    /// The unique Amazon Resource Name (ARN) that uniquely identifies the export job.
    public var exportJobArn: Swift.String?
    /// This is the unique string that identifies the specified export job.
    /// This member is required.
    public var exportJobIdentifier: Swift.String?
    /// The export specification consists of the destination S3 bucket to which the search results were exported, along with the destination prefix.
    public var exportSpecification: BackupSearchClientTypes.ExportSpecification?
    /// The unique string that identifies the Amazon Resource Name (ARN) of the specified search job.
    public var searchJobArn: Swift.String?
    /// This is the current status of the export job.
    public var status: BackupSearchClientTypes.ExportJobStatus?
    /// A status message is a string that is returned for search job with a status of FAILED, along with steps to remedy and retry the operation.
    public var statusMessage: Swift.String?

    public init(
        completionTime: Foundation.Date? = nil,
        creationTime: Foundation.Date? = nil,
        exportJobArn: Swift.String? = nil,
        exportJobIdentifier: Swift.String? = nil,
        exportSpecification: BackupSearchClientTypes.ExportSpecification? = nil,
        searchJobArn: Swift.String? = nil,
        status: BackupSearchClientTypes.ExportJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.exportJobArn = exportJobArn
        self.exportJobIdentifier = exportJobIdentifier
        self.exportSpecification = exportSpecification
        self.searchJobArn = searchJobArn
        self.status = status
        self.statusMessage = statusMessage
    }
}

public struct ListSearchResultExportJobsInput: Swift.Sendable {
    /// The maximum number of resource list items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned backups included in a search job. For example, if a request is made to return MaxResults number of backups, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// The unique string that specifies the search job.
    public var searchJobIdentifier: Swift.String?
    /// The search jobs to be included in the export job can be filtered by including this parameter.
    public var status: BackupSearchClientTypes.ExportJobStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchJobIdentifier: Swift.String? = nil,
        status: BackupSearchClientTypes.ExportJobStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchJobIdentifier = searchJobIdentifier
        self.status = status
    }
}

extension BackupSearchClientTypes {

    /// This is the summary of an export job.
    public struct ExportJobSummary: Swift.Sendable {
        /// This is a timestamp of the time the export job compeleted.
        public var completionTime: Foundation.Date?
        /// This is a timestamp of the time the export job was created.
        public var creationTime: Foundation.Date?
        /// This is the unique ARN (Amazon Resource Name) that belongs to the new export job.
        public var exportJobArn: Swift.String?
        /// This is the unique string that identifies a specific export job.
        /// This member is required.
        public var exportJobIdentifier: Swift.String?
        /// The unique string that identifies the Amazon Resource Name (ARN) of the specified search job.
        public var searchJobArn: Swift.String?
        /// The status of the export job is one of the following: CREATED; RUNNING; FAILED; or COMPLETED.
        public var status: BackupSearchClientTypes.ExportJobStatus?
        /// A status message is a string that is returned for an export job. A status message is included for any status other than COMPLETED without issues.
        public var statusMessage: Swift.String?

        public init(
            completionTime: Foundation.Date? = nil,
            creationTime: Foundation.Date? = nil,
            exportJobArn: Swift.String? = nil,
            exportJobIdentifier: Swift.String? = nil,
            searchJobArn: Swift.String? = nil,
            status: BackupSearchClientTypes.ExportJobStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.exportJobArn = exportJobArn
            self.exportJobIdentifier = exportJobIdentifier
            self.searchJobArn = searchJobArn
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct ListSearchResultExportJobsOutput: Swift.Sendable {
    /// The operation returns the included export jobs.
    /// This member is required.
    public var exportJobs: [BackupSearchClientTypes.ExportJobSummary]?
    /// The next item following a partial list of returned backups included in a search job. For example, if a request is made to return MaxResults number of backups, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        exportJobs: [BackupSearchClientTypes.ExportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportJobs = exportJobs
        self.nextToken = nextToken
    }
}

public struct StartSearchResultExportJobInput: Swift.Sendable {
    /// Include this parameter to allow multiple identical calls for idempotency. A client token is valid for 8 hours after the first request that uses it is completed. After this time, any request with the same token is treated as a new request.
    public var clientToken: Swift.String?
    /// This specification contains a required string of the destination bucket; optionally, you can include the destination prefix.
    /// This member is required.
    public var exportSpecification: BackupSearchClientTypes.ExportSpecification?
    /// This parameter specifies the role ARN used to start the search results export jobs.
    public var roleArn: Swift.String?
    /// The unique string that specifies the search job.
    /// This member is required.
    public var searchJobIdentifier: Swift.String?
    /// Optional tags to include. A tag is a key-value pair you can use to manage, filter, and search for your resources. Allowed characters include UTF-8 letters, numbers, spaces, and the following characters: + - = . _ : /.
    public var tags: [Swift.String: Swift.String?]?

    public init(
        clientToken: Swift.String? = nil,
        exportSpecification: BackupSearchClientTypes.ExportSpecification? = nil,
        roleArn: Swift.String? = nil,
        searchJobIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String?]? = nil
    )
    {
        self.clientToken = clientToken
        self.exportSpecification = exportSpecification
        self.roleArn = roleArn
        self.searchJobIdentifier = searchJobIdentifier
        self.tags = tags
    }
}

public struct StartSearchResultExportJobOutput: Swift.Sendable {
    /// This is the unique ARN (Amazon Resource Name) that belongs to the new export job.
    public var exportJobArn: Swift.String?
    /// This is the unique identifier that specifies the new export job.
    /// This member is required.
    public var exportJobIdentifier: Swift.String?

    public init(
        exportJobArn: Swift.String? = nil,
        exportJobIdentifier: Swift.String? = nil
    )
    {
        self.exportJobArn = exportJobArn
        self.exportJobIdentifier = exportJobIdentifier
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the resource. This is the resource that will have the indicated tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Required tags to include. A tag is a key-value pair you can use to manage, filter, and search for your resources. Allowed characters include UTF-8 letters, numbers, spaces, and the following characters: + - = . _ : /.
    /// This member is required.
    public var tags: [Swift.String: Swift.String?]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String?]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request was unsuccessful due to request throttling.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// This is the code unique to the originating service with the quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Retry the call after number of seconds.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// This is the code unique to the originating service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the resource where you want to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// This required parameter contains the tag keys you want to remove from the source.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

/// The input fails to satisfy the constraints specified by a service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The input fails to satisfy the constraints specified by an Amazon service.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GetSearchJobInput {

    static func urlPathProvider(_ value: GetSearchJobInput) -> Swift.String? {
        guard let searchJobIdentifier = value.searchJobIdentifier else {
            return nil
        }
        return "/search-jobs/\(searchJobIdentifier.urlPercentEncoding())"
    }
}

extension GetSearchResultExportJobInput {

    static func urlPathProvider(_ value: GetSearchResultExportJobInput) -> Swift.String? {
        guard let exportJobIdentifier = value.exportJobIdentifier else {
            return nil
        }
        return "/export-search-jobs/\(exportJobIdentifier.urlPercentEncoding())"
    }
}

extension ListSearchJobBackupsInput {

    static func urlPathProvider(_ value: ListSearchJobBackupsInput) -> Swift.String? {
        guard let searchJobIdentifier = value.searchJobIdentifier else {
            return nil
        }
        return "/search-jobs/\(searchJobIdentifier.urlPercentEncoding())/backups"
    }
}

extension ListSearchJobBackupsInput {

    static func queryItemProvider(_ value: ListSearchJobBackupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSearchJobResultsInput {

    static func urlPathProvider(_ value: ListSearchJobResultsInput) -> Swift.String? {
        guard let searchJobIdentifier = value.searchJobIdentifier else {
            return nil
        }
        return "/search-jobs/\(searchJobIdentifier.urlPercentEncoding())/search-results"
    }
}

extension ListSearchJobResultsInput {

    static func queryItemProvider(_ value: ListSearchJobResultsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSearchJobsInput {

    static func urlPathProvider(_ value: ListSearchJobsInput) -> Swift.String? {
        return "/search-jobs"
    }
}

extension ListSearchJobsInput {

    static func queryItemProvider(_ value: ListSearchJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let byStatus = value.byStatus {
            let byStatusQueryItem = Smithy.URIQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(byStatus.rawValue).urlPercentEncoding())
            items.append(byStatusQueryItem)
        }
        return items
    }
}

extension ListSearchResultExportJobsInput {

    static func urlPathProvider(_ value: ListSearchResultExportJobsInput) -> Swift.String? {
        return "/export-search-jobs"
    }
}

extension ListSearchResultExportJobsInput {

    static func queryItemProvider(_ value: ListSearchResultExportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let searchJobIdentifier = value.searchJobIdentifier {
            let searchJobIdentifierQueryItem = Smithy.URIQueryItem(name: "SearchJobIdentifier".urlPercentEncoding(), value: Swift.String(searchJobIdentifier).urlPercentEncoding())
            items.append(searchJobIdentifierQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension StartSearchJobInput {

    static func urlPathProvider(_ value: StartSearchJobInput) -> Swift.String? {
        return "/search-jobs"
    }
}

extension StartSearchResultExportJobInput {

    static func urlPathProvider(_ value: StartSearchResultExportJobInput) -> Swift.String? {
        return "/export-search-jobs"
    }
}

extension StopSearchJobInput {

    static func urlPathProvider(_ value: StopSearchJobInput) -> Swift.String? {
        guard let searchJobIdentifier = value.searchJobIdentifier else {
            return nil
        }
        return "/search-jobs/\(searchJobIdentifier.urlPercentEncoding())/actions/cancel"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension StartSearchJobInput {

    static func write(value: StartSearchJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["EncryptionKeyArn"].write(value.encryptionKeyArn)
        try writer["ItemFilters"].write(value.itemFilters, with: BackupSearchClientTypes.ItemFilters.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["SearchScope"].write(value.searchScope, with: BackupSearchClientTypes.SearchScope.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.sparseFormOf(writingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StartSearchResultExportJobInput {

    static func write(value: StartSearchResultExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ExportSpecification"].write(value.exportSpecification, with: BackupSearchClientTypes.ExportSpecification.write(value:to:))
        try writer["RoleArn"].write(value.roleArn)
        try writer["SearchJobIdentifier"].write(value.searchJobIdentifier)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.sparseFormOf(writingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.sparseFormOf(writingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension GetSearchJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSearchJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSearchJobOutput()
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.currentSearchProgress = try reader["CurrentSearchProgress"].readIfPresent(with: BackupSearchClientTypes.CurrentSearchProgress.read(from:))
        value.encryptionKeyArn = try reader["EncryptionKeyArn"].readIfPresent()
        value.itemFilters = try reader["ItemFilters"].readIfPresent(with: BackupSearchClientTypes.ItemFilters.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.searchJobArn = try reader["SearchJobArn"].readIfPresent() ?? ""
        value.searchJobIdentifier = try reader["SearchJobIdentifier"].readIfPresent() ?? ""
        value.searchScope = try reader["SearchScope"].readIfPresent(with: BackupSearchClientTypes.SearchScope.read(from:))
        value.searchScopeSummary = try reader["SearchScopeSummary"].readIfPresent(with: BackupSearchClientTypes.SearchScopeSummary.read(from:))
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension GetSearchResultExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSearchResultExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSearchResultExportJobOutput()
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.exportJobArn = try reader["ExportJobArn"].readIfPresent()
        value.exportJobIdentifier = try reader["ExportJobIdentifier"].readIfPresent() ?? ""
        value.exportSpecification = try reader["ExportSpecification"].readIfPresent(with: BackupSearchClientTypes.ExportSpecification.read(from:))
        value.searchJobArn = try reader["SearchJobArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension ListSearchJobBackupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSearchJobBackupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSearchJobBackupsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.results = try reader["Results"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.SearchJobBackupsResult.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSearchJobResultsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSearchJobResultsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSearchJobResultsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.results = try reader["Results"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.ResultItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSearchJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSearchJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSearchJobsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.searchJobs = try reader["SearchJobs"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.SearchJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSearchResultExportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSearchResultExportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSearchResultExportJobsOutput()
        value.exportJobs = try reader["ExportJobs"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.ExportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: SmithyReadWrite.ReadingClosures.readString(from:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension StartSearchJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSearchJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSearchJobOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.searchJobArn = try reader["SearchJobArn"].readIfPresent()
        value.searchJobIdentifier = try reader["SearchJobIdentifier"].readIfPresent()
        return value
    }
}

extension StartSearchResultExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSearchResultExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSearchResultExportJobOutput()
        value.exportJobArn = try reader["ExportJobArn"].readIfPresent()
        value.exportJobIdentifier = try reader["ExportJobIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension StopSearchJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopSearchJobOutput {
        return StopSearchJobOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

func httpServiceError(baseError: AWSClientRuntime.RestJSONError) throws -> Swift.Error? {
    switch baseError.code {
        case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
        case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
        case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
        case "ValidationException": return try ValidationException.makeError(baseError: baseError)
        default: return nil
    }
}

enum GetSearchJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSearchResultExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSearchJobBackupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSearchJobResultsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSearchJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSearchResultExportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSearchJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSearchResultExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopSearchJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BackupSearchClientTypes.SearchScopeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.SearchScopeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.SearchScopeSummary()
        value.totalRecoveryPointsToScanCount = try reader["TotalRecoveryPointsToScanCount"].readIfPresent()
        value.totalItemsToScanCount = try reader["TotalItemsToScanCount"].readIfPresent()
        return value
    }
}

extension BackupSearchClientTypes.CurrentSearchProgress {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.CurrentSearchProgress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.CurrentSearchProgress()
        value.recoveryPointsScannedCount = try reader["RecoveryPointsScannedCount"].readIfPresent()
        value.itemsScannedCount = try reader["ItemsScannedCount"].readIfPresent()
        value.itemsMatchedCount = try reader["ItemsMatchedCount"].readIfPresent()
        return value
    }
}

extension BackupSearchClientTypes.SearchScope {

    static func write(value: BackupSearchClientTypes.SearchScope?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupResourceArns"].writeList(value.backupResourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BackupResourceCreationTime"].write(value.backupResourceCreationTime, with: BackupSearchClientTypes.BackupCreationTimeFilter.write(value:to:))
        try writer["BackupResourceTags"].writeMap(value.backupResourceTags, valueWritingClosure: SmithyReadWrite.sparseFormOf(writingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["BackupResourceTypes"].writeList(value.backupResourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BackupSearchClientTypes.ResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceResourceArns"].writeList(value.sourceResourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.SearchScope {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.SearchScope()
        value.backupResourceTypes = try reader["BackupResourceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BackupSearchClientTypes.ResourceType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.backupResourceCreationTime = try reader["BackupResourceCreationTime"].readIfPresent(with: BackupSearchClientTypes.BackupCreationTimeFilter.read(from:))
        value.sourceResourceArns = try reader["SourceResourceArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.backupResourceArns = try reader["BackupResourceArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.backupResourceTags = try reader["BackupResourceTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: SmithyReadWrite.ReadingClosures.readString(from:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BackupSearchClientTypes.BackupCreationTimeFilter {

    static func write(value: BackupSearchClientTypes.BackupCreationTimeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatedAfter"].writeTimestamp(value.createdAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["CreatedBefore"].writeTimestamp(value.createdBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.BackupCreationTimeFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.BackupCreationTimeFilter()
        value.createdAfter = try reader["CreatedAfter"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBefore = try reader["CreatedBefore"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BackupSearchClientTypes.ItemFilters {

    static func write(value: BackupSearchClientTypes.ItemFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EBSItemFilters"].writeList(value.ebsItemFilters, memberWritingClosure: BackupSearchClientTypes.EBSItemFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["S3ItemFilters"].writeList(value.s3ItemFilters, memberWritingClosure: BackupSearchClientTypes.S3ItemFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.ItemFilters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.ItemFilters()
        value.s3ItemFilters = try reader["S3ItemFilters"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.S3ItemFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ebsItemFilters = try reader["EBSItemFilters"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.EBSItemFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BackupSearchClientTypes.EBSItemFilter {

    static func write(value: BackupSearchClientTypes.EBSItemFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreationTimes"].writeList(value.creationTimes, memberWritingClosure: BackupSearchClientTypes.TimeCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilePaths"].writeList(value.filePaths, memberWritingClosure: BackupSearchClientTypes.StringCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LastModificationTimes"].writeList(value.lastModificationTimes, memberWritingClosure: BackupSearchClientTypes.TimeCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sizes"].writeList(value.sizes, memberWritingClosure: BackupSearchClientTypes.LongCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.EBSItemFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.EBSItemFilter()
        value.filePaths = try reader["FilePaths"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.StringCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sizes = try reader["Sizes"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.LongCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationTimes = try reader["CreationTimes"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.TimeCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModificationTimes = try reader["LastModificationTimes"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.TimeCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BackupSearchClientTypes.TimeCondition {

    static func write(value: BackupSearchClientTypes.TimeCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].writeTimestamp(value.value, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.TimeCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.TimeCondition()
        value.value = try reader["Value"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.`operator` = try reader["Operator"].readIfPresent() ?? .equalsTo
        return value
    }
}

extension BackupSearchClientTypes.LongCondition {

    static func write(value: BackupSearchClientTypes.LongCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.LongCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.LongCondition()
        value.value = try reader["Value"].readIfPresent() ?? 0
        value.`operator` = try reader["Operator"].readIfPresent() ?? .equalsTo
        return value
    }
}

extension BackupSearchClientTypes.StringCondition {

    static func write(value: BackupSearchClientTypes.StringCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.StringCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.StringCondition()
        value.value = try reader["Value"].readIfPresent() ?? ""
        value.`operator` = try reader["Operator"].readIfPresent() ?? .equalsTo
        return value
    }
}

extension BackupSearchClientTypes.S3ItemFilter {

    static func write(value: BackupSearchClientTypes.S3ItemFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreationTimes"].writeList(value.creationTimes, memberWritingClosure: BackupSearchClientTypes.TimeCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ETags"].writeList(value.eTags, memberWritingClosure: BackupSearchClientTypes.StringCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ObjectKeys"].writeList(value.objectKeys, memberWritingClosure: BackupSearchClientTypes.StringCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sizes"].writeList(value.sizes, memberWritingClosure: BackupSearchClientTypes.LongCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VersionIds"].writeList(value.versionIds, memberWritingClosure: BackupSearchClientTypes.StringCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.S3ItemFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.S3ItemFilter()
        value.objectKeys = try reader["ObjectKeys"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.StringCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sizes = try reader["Sizes"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.LongCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationTimes = try reader["CreationTimes"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.TimeCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.versionIds = try reader["VersionIds"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.StringCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.eTags = try reader["ETags"].readListIfPresent(memberReadingClosure: BackupSearchClientTypes.StringCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BackupSearchClientTypes.ExportSpecification {

    static func write(value: BackupSearchClientTypes.ExportSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3exportspecification(s3exportspecification):
                try writer["s3ExportSpecification"].write(s3exportspecification, with: BackupSearchClientTypes.S3ExportSpecification.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.ExportSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3ExportSpecification":
                return .s3exportspecification(try reader["s3ExportSpecification"].read(with: BackupSearchClientTypes.S3ExportSpecification.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BackupSearchClientTypes.S3ExportSpecification {

    static func write(value: BackupSearchClientTypes.S3ExportSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationBucket"].write(value.destinationBucket)
        try writer["DestinationPrefix"].write(value.destinationPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.S3ExportSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.S3ExportSpecification()
        value.destinationBucket = try reader["DestinationBucket"].readIfPresent() ?? ""
        value.destinationPrefix = try reader["DestinationPrefix"].readIfPresent()
        return value
    }
}

extension BackupSearchClientTypes.SearchJobBackupsResult {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.SearchJobBackupsResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.SearchJobBackupsResult()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.backupResourceArn = try reader["BackupResourceArn"].readIfPresent()
        value.sourceResourceArn = try reader["SourceResourceArn"].readIfPresent()
        value.indexCreationTime = try reader["IndexCreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.backupCreationTime = try reader["BackupCreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BackupSearchClientTypes.ResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.ResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "S3ResultItem":
                return .s3resultitem(try reader["S3ResultItem"].read(with: BackupSearchClientTypes.S3ResultItem.read(from:)))
            case "EBSResultItem":
                return .ebsresultitem(try reader["EBSResultItem"].read(with: BackupSearchClientTypes.EBSResultItem.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BackupSearchClientTypes.EBSResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.EBSResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.EBSResultItem()
        value.backupResourceArn = try reader["BackupResourceArn"].readIfPresent()
        value.sourceResourceArn = try reader["SourceResourceArn"].readIfPresent()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.fileSystemIdentifier = try reader["FileSystemIdentifier"].readIfPresent()
        value.filePath = try reader["FilePath"].readIfPresent()
        value.fileSize = try reader["FileSize"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BackupSearchClientTypes.S3ResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.S3ResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.S3ResultItem()
        value.backupResourceArn = try reader["BackupResourceArn"].readIfPresent()
        value.sourceResourceArn = try reader["SourceResourceArn"].readIfPresent()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.objectKey = try reader["ObjectKey"].readIfPresent()
        value.objectSize = try reader["ObjectSize"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.eTag = try reader["ETag"].readIfPresent()
        value.versionId = try reader["VersionId"].readIfPresent()
        return value
    }
}

extension BackupSearchClientTypes.SearchJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.SearchJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.SearchJobSummary()
        value.searchJobIdentifier = try reader["SearchJobIdentifier"].readIfPresent()
        value.searchJobArn = try reader["SearchJobArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.searchScopeSummary = try reader["SearchScopeSummary"].readIfPresent(with: BackupSearchClientTypes.SearchScopeSummary.read(from:))
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension BackupSearchClientTypes.ExportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupSearchClientTypes.ExportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupSearchClientTypes.ExportJobSummary()
        value.exportJobIdentifier = try reader["ExportJobIdentifier"].readIfPresent() ?? ""
        value.exportJobArn = try reader["ExportJobArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.searchJobArn = try reader["SearchJobArn"].readIfPresent()
        return value
    }
}

public enum BackupSearchClientTypes {}
